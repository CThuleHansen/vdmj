Index: README
===================================================================
--- README	(revision 466)
+++ README	(working copy)
@@ -14,4 +14,11 @@
 
 Maven installs VDMJ in the com.fujitsu group.
 
-For information on a particular release, see the RELEASE_NOTES file.
\ No newline at end of file
+
+
+For information on a particular VDMJ release, see the RELEASE_NOTES file.
+
+VDMJ includes the Apfloat library for arbitrary precision arithmetic.
+
+For information on licensing, see the LICENCE, LGPL and APFLOAT_README files in the
+documentation folder.
\ No newline at end of file
Index: pom.xml
===================================================================
--- pom.xml	(revision 466)
+++ pom.xml	(working copy)
@@ -4,7 +4,7 @@
 	<groupId>com.fujitsu</groupId>
 	<artifactId>vdmj</artifactId>
 	<name>VDMJ</name>
-	<version>3.0.1</version>
+	<version>3.0.1-P</version>
 
 	<properties>
 		<maven.build.timestamp.format>yyMMdd</maven.build.timestamp.format>
Index: documentation/APFLOAT_README
===================================================================
--- documentation/APFLOAT_README	(revision 0)
+++ documentation/APFLOAT_README	(revision 0)
@@ -0,0 +1,14 @@
+Apfloat
+Copyright ï¿½ 2015 Mikko Tommila
+
+This library is free software; you can redistribute it and/or modify it under the terms of the
+GNU Lesser General Public License as published by the Free Software Foundation; either version
+2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
+the GNU Lesser General Public License for more details.
+
+If you have any questions or need a different type of license, please contact the author.
+
+http://www.apfloat.org/apfloat_java/
Index: documentation/LGPL
===================================================================
--- documentation/LGPL	(revision 0)
+++ documentation/LGPL	(revision 0)
@@ -0,0 +1,165 @@
+                   GNU LESSER GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+
+  This version of the GNU Lesser General Public License incorporates
+the terms and conditions of version 3 of the GNU General Public
+License, supplemented by the additional permissions listed below.
+
+  0. Additional Definitions.
+
+  As used herein, "this License" refers to version 3 of the GNU Lesser
+General Public License, and the "GNU GPL" refers to version 3 of the GNU
+General Public License.
+
+  "The Library" refers to a covered work governed by this License,
+other than an Application or a Combined Work as defined below.
+
+  An "Application" is any work that makes use of an interface provided
+by the Library, but which is not otherwise based on the Library.
+Defining a subclass of a class defined by the Library is deemed a mode
+of using an interface provided by the Library.
+
+  A "Combined Work" is a work produced by combining or linking an
+Application with the Library.  The particular version of the Library
+with which the Combined Work was made is also called the "Linked
+Version".
+
+  The "Minimal Corresponding Source" for a Combined Work means the
+Corresponding Source for the Combined Work, excluding any source code
+for portions of the Combined Work that, considered in isolation, are
+based on the Application, and not on the Linked Version.
+
+  The "Corresponding Application Code" for a Combined Work means the
+object code and/or source code for the Application, including any data
+and utility programs needed for reproducing the Combined Work from the
+Application, but excluding the System Libraries of the Combined Work.
+
+  1. Exception to Section 3 of the GNU GPL.
+
+  You may convey a covered work under sections 3 and 4 of this License
+without being bound by section 3 of the GNU GPL.
+
+  2. Conveying Modified Versions.
+
+  If you modify a copy of the Library, and, in your modifications, a
+facility refers to a function or data to be supplied by an Application
+that uses the facility (other than as an argument passed when the
+facility is invoked), then you may convey a copy of the modified
+version:
+
+   a) under this License, provided that you make a good faith effort to
+   ensure that, in the event an Application does not supply the
+   function or data, the facility still operates, and performs
+   whatever part of its purpose remains meaningful, or
+
+   b) under the GNU GPL, with none of the additional permissions of
+   this License applicable to that copy.
+
+  3. Object Code Incorporating Material from Library Header Files.
+
+  The object code form of an Application may incorporate material from
+a header file that is part of the Library.  You may convey such object
+code under terms of your choice, provided that, if the incorporated
+material is not limited to numerical parameters, data structure
+layouts and accessors, or small macros, inline functions and templates
+(ten or fewer lines in length), you do both of the following:
+
+   a) Give prominent notice with each copy of the object code that the
+   Library is used in it and that the Library and its use are
+   covered by this License.
+
+   b) Accompany the object code with a copy of the GNU GPL and this license
+   document.
+
+  4. Combined Works.
+
+  You may convey a Combined Work under terms of your choice that,
+taken together, effectively do not restrict modification of the
+portions of the Library contained in the Combined Work and reverse
+engineering for debugging such modifications, if you also do each of
+the following:
+
+   a) Give prominent notice with each copy of the Combined Work that
+   the Library is used in it and that the Library and its use are
+   covered by this License.
+
+   b) Accompany the Combined Work with a copy of the GNU GPL and this license
+   document.
+
+   c) For a Combined Work that displays copyright notices during
+   execution, include the copyright notice for the Library among
+   these notices, as well as a reference directing the user to the
+   copies of the GNU GPL and this license document.
+
+   d) Do one of the following:
+
+       0) Convey the Minimal Corresponding Source under the terms of this
+       License, and the Corresponding Application Code in a form
+       suitable for, and under terms that permit, the user to
+       recombine or relink the Application with a modified version of
+       the Linked Version to produce a modified Combined Work, in the
+       manner specified by section 6 of the GNU GPL for conveying
+       Corresponding Source.
+
+       1) Use a suitable shared library mechanism for linking with the
+       Library.  A suitable mechanism is one that (a) uses at run time
+       a copy of the Library already present on the user's computer
+       system, and (b) will operate properly with a modified version
+       of the Library that is interface-compatible with the Linked
+       Version.
+
+   e) Provide Installation Information, but only if you would otherwise
+   be required to provide such information under section 6 of the
+   GNU GPL, and only to the extent that such information is
+   necessary to install and execute a modified version of the
+   Combined Work produced by recombining or relinking the
+   Application with a modified version of the Linked Version. (If
+   you use option 4d0, the Installation Information must accompany
+   the Minimal Corresponding Source and Corresponding Application
+   Code. If you use option 4d1, you must provide the Installation
+   Information in the manner specified by section 6 of the GNU GPL
+   for conveying Corresponding Source.)
+
+  5. Combined Libraries.
+
+  You may place library facilities that are a work based on the
+Library side by side in a single library together with other library
+facilities that are not Applications and are not covered by this
+License, and convey such a combined library under terms of your
+choice, if you do both of the following:
+
+   a) Accompany the combined library with a copy of the same work based
+   on the Library, uncombined with any other library facilities,
+   conveyed under the terms of this License.
+
+   b) Give prominent notice with the combined library that part of it
+   is a work based on the Library, and explaining where to find the
+   accompanying uncombined form of the same work.
+
+  6. Revised Versions of the GNU Lesser General Public License.
+
+  The Free Software Foundation may publish revised and/or new versions
+of the GNU Lesser General Public License from time to time. Such new
+versions will be similar in spirit to the present version, but may
+differ in detail to address new problems or concerns.
+
+  Each version is given a distinguishing version number. If the
+Library as you received it specifies that a certain numbered version
+of the GNU Lesser General Public License "or any later version"
+applies to it, you have the option of following the terms and
+conditions either of that published version or of any later version
+published by the Free Software Foundation. If the Library as you
+received it does not specify a version number of the GNU Lesser
+General Public License, you may choose any version of the GNU Lesser
+General Public License ever published by the Free Software Foundation.
+
+  If the Library as you received it specifies that a proxy can decide
+whether future versions of the GNU Lesser General Public License shall
+apply, that proxy's public statement of acceptance of any version is
+permanent authorization for you to choose that version for the
+Library.
Index: src/main/java/DEFAULT.java
===================================================================
--- src/main/java/DEFAULT.java	(revision 466)
+++ src/main/java/DEFAULT.java	(working copy)
@@ -131,7 +131,7 @@
 		return MATH.pi_f();
 	}
 
-	public static Value rand(Value arg) throws ValueException
+	public static Value rand(Value arg) throws Exception
 	{
 		return MATH.rand(arg);
 	}
Index: src/main/java/MATH.java
===================================================================
--- src/main/java/MATH.java	(revision 466)
+++ src/main/java/MATH.java	(working copy)
@@ -23,8 +23,13 @@
 
 // This must be in the default package to work with VDMJ's native delegation.
 
+import java.math.BigDecimal;
+import java.math.BigInteger;
 import java.util.Random;
 
+import org.apfloat.Apfloat;
+import org.apfloat.ApfloatMath;
+import org.overturetool.vdmj.Settings;
 import org.overturetool.vdmj.runtime.ValueException;
 import org.overturetool.vdmj.values.IntegerValue;
 import org.overturetool.vdmj.values.NaturalOneValue;
@@ -38,87 +43,110 @@
 
 	public static Value sin(Value arg) throws ValueException, Exception
 	{
-		return new RealValue(Math.sin(arg.realValue(null)));
+		Apfloat ap = new Apfloat(arg.realValue(null));
+		Apfloat apResult = ApfloatMath.sin(ap);
+		return new RealValue(new BigDecimal(apResult.toString(), Settings.precision));
 	}
 
 	public static Value cos(Value arg) throws ValueException, Exception
 	{
-		return new RealValue(Math.cos(arg.realValue(null)));
+		Apfloat ap = new Apfloat(arg.realValue(null));
+		Apfloat apResult = ApfloatMath.cos(ap);
+		return new RealValue(new BigDecimal(apResult.toString(), Settings.precision));
 	}
 
 	public static Value tan(Value arg) throws ValueException, Exception
 	{
-		return new RealValue(Math.tan(arg.realValue(null)));
+		Apfloat ap = new Apfloat(arg.realValue(null));
+		Apfloat apResult = ApfloatMath.tan(ap);
+		return new RealValue(new BigDecimal(apResult.toString(), Settings.precision));
 	}
 
 	public static Value cot(Value arg) throws ValueException, Exception
 	{
-		return new RealValue(1/Math.tan(arg.realValue(null)));
+		Apfloat ap = new Apfloat(arg.realValue(null));
+		Apfloat apResult = Apfloat.ONE.divide(ApfloatMath.tan(ap));
+		return new RealValue(new BigDecimal(apResult.toString(), Settings.precision));
 	}
 
 	public static Value asin(Value arg) throws ValueException, Exception
 	{
-		return new RealValue(Math.asin(arg.realValue(null)));
+		Apfloat ap = new Apfloat(arg.realValue(null));
+		Apfloat apResult = ApfloatMath.asin(ap);
+		return new RealValue(new BigDecimal(apResult.toString(), Settings.precision));
 	}
 
 	public static Value acos(Value arg) throws ValueException, Exception
 	{
-		return new RealValue(Math.acos(arg.realValue(null)));
+		Apfloat ap = new Apfloat(arg.realValue(null));
+		Apfloat apResult = ApfloatMath.acos(ap);
+		return new RealValue(new BigDecimal(apResult.toString(), Settings.precision));
 	}
 
 	public static Value atan(Value arg) throws ValueException, Exception
 	{
-		return new RealValue(Math.atan(arg.realValue(null)));
+		Apfloat ap = new Apfloat(arg.realValue(null));
+		Apfloat apResult = ApfloatMath.atan(ap);
+		return new RealValue(new BigDecimal(apResult.toString(), Settings.precision));
 	}
 
 	public static Value sqrt(Value arg) throws ValueException, Exception
 	{
-		return new RealValue(Math.sqrt(arg.realValue(null)));
+		Apfloat ap = new Apfloat(arg.realValue(null));
+		Apfloat apResult = ApfloatMath.sqrt(ap);
+		return new RealValue(new BigDecimal(apResult.toString(), Settings.precision));
 	}
 
 	public static Value pi_f() throws Exception
 	{
-		return new RealValue(Math.PI);
+		Apfloat apResult = ApfloatMath.pi(Settings.precision.getPrecision());
+		return new RealValue(new BigDecimal(apResult.toString(), Settings.precision));
 	}
 
-	public static Value rand(Value arg) throws ValueException
+	public static Value rand(Value arg) throws Exception
 	{
-		long lv = arg.intValue(null);
+		BigInteger lv = arg.intValue(null).abs();
 
 		if (seed == -1)
 		{
 			return new IntegerValue(lv);
 		}
-		else if (lv == 0)
+		else if (lv.equals(BigInteger.ZERO))
 		{
-			return new IntegerValue(0);
+			return new IntegerValue(BigInteger.ZERO);
 		}
 		else
 		{
-			return new IntegerValue(Math.abs(random.nextLong() % lv));
+			return new IntegerValue(new BigInteger(lv.bitLength(), random).mod(lv));
 		}
 	}
 
 	public static Value srand2(Value arg) throws ValueException
 	{
-		seed = arg.intValue(null);
+		seed = arg.intValue(null).longValue();
 		random.setSeed(seed);
 		return new IntegerValue(seed);
 	}
 
 	public static Value exp(Value arg) throws ValueException, Exception
 	{
-		return new RealValue(Math.exp(arg.realValue(null)));
+		Apfloat ap = new Apfloat(arg.realValue(null));
+		Apfloat apResult = ApfloatMath.exp(ap);
+		return new RealValue(new BigDecimal(apResult.toString(), Settings.precision));
 	}
 
 	public static Value ln(Value arg) throws ValueException, Exception
 	{
-		return new RealValue(Math.log(arg.realValue(null)));
+		Apfloat ap = new Apfloat(arg.realValue(null));
+		Apfloat apResult = ApfloatMath.log(ap);
+		return new RealValue(new BigDecimal(apResult.toString(), Settings.precision));
 	}
 
 	public static Value log(Value arg) throws ValueException, Exception
 	{
-		return new RealValue(Math.log10(arg.realValue(null)));
+		Apfloat ap = new Apfloat(arg.realValue(null));
+		Apfloat apResult = ApfloatMath.log(ap, new Apfloat(10));
+		return new RealValue(new BigDecimal(apResult.toString(), Settings.precision));
 	}
 
 	public static Value fac(Value arg) throws ValueException, Exception
@@ -126,8 +154,9 @@
 		return new NaturalOneValue(factorial(arg.natValue(null)));
 	}
 
-	private static long factorial(long n)
+	private static BigInteger factorial(BigInteger n)
 	{
-		return (n < 1) ? 1 : n * factorial(n-1);
+		return (n.compareTo(BigInteger.ONE) < 0) ?
+			BigInteger.ONE : n.multiply(factorial(n.subtract(BigInteger.ONE)));
 	}
 }
Index: src/main/java/org/apfloat/Apcomplex.java
===================================================================
--- src/main/java/org/apfloat/Apcomplex.java	(revision 0)
+++ src/main/java/org/apfloat/Apcomplex.java	(revision 0)
@@ -0,0 +1,827 @@
+package org.apfloat;
+
+import java.io.Serializable;
+import java.io.PushbackReader;
+import java.io.Writer;
+import java.io.IOException;
+import java.util.Formattable;
+import java.util.Formatter;
+import static java.util.FormattableFlags.*;
+
+/**
+ * Arbitrary precision complex number class. An apcomplex consists of
+ * a real and imaginary part of type {@link Apfloat}.<p>
+ *
+ * Note that although the Apcomplex class extends <code>Number</code>,
+ * the methods inherited from <code>Number</code> return the value of
+ * the real part of the complex number. Thus they are more meaningful
+ * for the {@link Apfloat} class and its subclasses.<p>
+ *
+ * @see Apfloat
+ * @see ApcomplexMath
+ *
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class Apcomplex
+    extends Number
+    implements Formattable, Serializable
+{
+    /**
+     * Constant for zero. It is safe to use <code>ZERO</code>
+     * in all addition, subtraction, multiplication, division and
+     * comparison operations regardless of the radix used.
+     */
+
+    public static final Apint ZERO = new Apint(0);
+
+    /**
+     * Constant for one. Note that this number is created using the
+     * initial default radix. It is safe to use <code>ONE</code>
+     * in all multiplication, division and equality comparison operations
+     * regardless of the radix used. However, in subtraction and addition
+     * it only works with numbers in the same radix.
+     */
+
+    public static final Apint ONE = new Apint(1);
+
+    /**
+     * Imaginary unit. That is, <code>Apcomplex(ZERO, ONE)</code>.
+     * It is safe to use <code>I</code> in all multiplication,
+     * division and equality comparison operations
+     * regardless of the radix used. In addition and subtraction
+     * it only works with numbers in the same radix.
+     */
+
+    public static final Apcomplex I = new Apcomplex(ZERO, ONE);
+
+    /**
+     * Infinite precision or scale. Can be used as the precision argument
+     * when constructing apfloats.
+     */
+
+    public static final long INFINITE = Long.MAX_VALUE;
+
+    /**
+     * Default precision. Can be used as an argument when constructing apfloats.
+     */
+
+    public static final long DEFAULT = 0x8000000000000000L;
+
+    /**
+     * Extra precision that is added in various apfloat internal
+     * operations to avoid round-off errors.
+     */
+
+    static final int EXTRA_PRECISION = 20;
+
+    /**
+     * Default constructor. To be used only by subclasses that
+     * overload all needed methods.
+     */
+
+    protected Apcomplex()
+    {
+    }
+
+    /**
+     * Construct a real apcomplex whose imaginary part is zero.
+     *
+     * @param real The real part of the number.
+     */
+
+    public Apcomplex(Apfloat real)
+    {
+        this(real, ZERO);
+    }
+
+    /**
+     * Construct an apcomplex with the specified real and imaginary part.
+     *
+     * @param real The real part of the number.
+     * @param imag The imaginary part of the number.
+     *
+     * @exception java.lang.IllegalArgumentException If the real part and imaginary part are not zero but have different radixes.
+     */
+
+    public Apcomplex(Apfloat real, Apfloat imag)
+        throws IllegalArgumentException
+    {
+        if (real.signum() != 0 && imag.signum() != 0 && real.radix() != imag.radix())
+        {
+            throw new IllegalArgumentException("Real part and imaginary part must have the same radix");
+        }
+
+        this.real = real;
+        this.imag = imag;
+    }
+
+    /**
+     * Constructs an apcomplex from a string.<p>
+     *
+     * The input must be of one of the formats<p>
+     *
+     * <code>realPart</code><br>
+     * <code>"(" [whitespace] realPart [whitespace] ")"</code><br>
+     * <code>"(" [whitespace] realPart [whitespace] "," [whitespace] imaginaryPart [whitespace] ")"</code><br>
+     *
+     * @param value The input string.
+     *
+     * @exception java.lang.NumberFormatException If the number is invalid.
+     */
+
+    public Apcomplex(String value)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        if (!value.startsWith("("))
+        {
+            this.real = new Apfloat(value);
+            this.imag = ZERO;
+            return;
+        }
+        if (!value.endsWith(")"))
+        {
+            throw new NumberFormatException("Missing end parenthesis");
+        }
+
+        int index = value.indexOf(',');
+        if (index < 0)
+        {
+            this.real = new Apfloat(value.substring(1, value.length() - 1).trim());
+            this.imag = ZERO;
+            return;
+        }
+
+        this.real = new Apfloat(value.substring(1, index).trim());
+        this.imag = new Apfloat(value.substring(index + 1, value.length() - 1).trim());
+    }
+
+    /**
+     * Reads an apcomplex from a reader. The constructor stops reading
+     * at the first character it doesn't understand. The reader must thus
+     * be a <code>PushbackReader</code> so that the invalid character can
+     * be returned back to the stream.<p>
+     *
+     * The input must be of one of the formats<p>
+     *
+     * <code>realPart</code><br>
+     * <code>"(" [whitespace] realPart [whitespace] ")"</code><br>
+     * <code>"(" [whitespace] realPart [whitespace] "," [whitespace] imaginaryPart [whitespace] ")"</code><br>
+     *
+     * @param in The input stream.
+     *
+     * @exception java.io.IOException In case of I/O error reading from the stream.
+     * @exception java.lang.NumberFormatException If the number is invalid.
+     */
+
+    public Apcomplex(PushbackReader in)
+        throws IOException, NumberFormatException, ApfloatRuntimeException
+    {
+        if (!ApfloatHelper.readMatch(in, '('))
+        {
+            this.real = new Apfloat(in);
+            this.imag = ZERO;
+            return;
+        }
+
+        ApfloatHelper.extractWhitespace(in);
+        this.real = new Apfloat(in);
+        ApfloatHelper.extractWhitespace(in);
+
+        if (ApfloatHelper.readMatch(in, ','))
+        {
+            ApfloatHelper.extractWhitespace(in);
+            this.imag = new Apfloat(in);
+        }
+        else
+        {
+            this.imag = ZERO;
+        }
+
+        ApfloatHelper.extractWhitespace(in);
+
+        if (!ApfloatHelper.readMatch(in, ')'))
+        {
+            throw new NumberFormatException("Missing end parenthesis");
+        }
+    }
+
+    /**
+     * Radix of this apcomplex.
+     *
+     * @return Radix of this apcomplex.
+     */
+
+    public int radix()
+    {
+        return (real().signum() == 0 ? (imag().signum() == 0 ? real().radix() : imag().radix()) : real().radix());
+    }
+
+    /**
+     * Returns the real part of this apcomplex.
+     *
+     * @return The real part of this apcomplex.
+     */
+
+    public Apfloat real()
+    {
+        return this.real;
+    }
+
+    /**
+     * Returns the imaginary part of this apcomplex.
+     *
+     * @return The imaginary part of this apcomplex.
+     */
+
+    public Apfloat imag()
+    {
+        return this.imag;
+    }
+
+    /**
+     * Returns the complex conjugate of this apcomplex.
+     *
+     * @return <code>x - <i>i</i> y</code>, where this apcomplex is <code>x + <i>i</i> y</code>.
+     */
+
+    public Apcomplex conj()
+        throws ApfloatRuntimeException
+    {
+        return new Apcomplex(real(), imag().negate());
+    }
+
+    /**
+     * Returns the precision of this apcomplex.
+     *
+     * @return The precision of this apcomplex in number of digits of the radix in which it's presented.
+     */
+
+    public long precision()
+        throws ApfloatRuntimeException
+    {
+        if (real().signum() == 0 || imag().signum() == 0)
+        {
+            return Math.min(real().precision(), imag().precision());
+        }
+        else
+        {
+            long[] precisions = ApfloatHelper.getMatchingPrecisions(real(), imag());
+
+            return Math.max(precisions[0], precisions[1]);
+        }
+    }
+
+    /**
+     * Returns an apcomplex with the same value as this apcomplex accurate to the
+     * specified precision.<p>
+     *
+     * If the requested precision less than this number's current precision, the
+     * functionality is quite obvious: the precision is simply truncated, and e.g.
+     * comparison and equality checking will work as expected. Some rounding errors
+     * in e.g. addition and subtraction may still occur, as "invisible" trailing
+     * digits can remain in the number.<p>
+     *
+     * If the requested precision more than this number's current precision, the
+     * functionality is quite undefined: the digits up to this number's current
+     * precision are guaranteed to be the same, but the "new" digits are undefined:
+     * they may be zero, or they may be digits that have been previously discarded
+     * with a call to precision() with a smaller number of digits, or they may be
+     * something else, or any combination of these.<p>
+     *
+     * These limitations allow various performance optimizations to be made.
+     *
+     * @param precision Precision of the new apcomplex.
+     *
+     * @return An apcomplex with the specified precision and same value as this apcomplex.
+     *
+     * @exception java.lang.IllegalArgumentException If <code>precision</code> is &lt;= 0.
+     *
+     * @since 1.2
+     */
+
+    public Apcomplex precision(long precision)
+        throws IllegalArgumentException, ApfloatRuntimeException
+    {
+        ApfloatHelper.checkPrecision(precision);
+
+        Apcomplex z = new Apcomplex(real().precision(precision), imag().precision(precision));
+
+        if (real().signum() == 0 || imag().signum() == 0)
+        {
+            return z;
+        }
+
+        long[] precisions = ApfloatHelper.getMatchingPrecisions(z.real(), z.imag());
+        long realPrecision = precisions[0],
+             imagPrecision = precisions[1];
+
+        return new Apcomplex(realPrecision > 0 ? z.real().precision(realPrecision) : Apfloat.ZERO,
+                             imagPrecision > 0 ? z.imag().precision(imagPrecision) : Apfloat.ZERO);
+    }
+
+    /**
+     * Returns the scale of this apcomplex. The scale is the maximum of the scale of the real part and imaginary part.<p>
+     *
+     * Zero has a scale of <code>-INFINITE</code>.
+     *
+     * @return The exponent of this apcomplex in number of digits of the radix in which it's presented.
+     *
+     * @see Apfloat#scale()
+     */
+
+    public long scale()
+        throws ApfloatRuntimeException
+    {
+        return Math.max(real().scale(), imag().scale());
+    }
+
+    /**
+     * Returns the size of this apcomplex. The size is the maximum of the size of the real part and imaginary part.<p>
+     *
+     * Zero has a size of <code>0</code>.
+     *
+     * @return The number of digits in this number, from the most significant digit to the least significant nonzero digit, in the radix in which it's presented.
+     *
+     * @see Apfloat#size()
+     *
+     * @since 1.6
+     */
+
+    public long size()
+        throws ApfloatRuntimeException
+    {
+        return Math.max(real().size(), imag().size());
+    }
+
+    /**
+     * Negative value.
+     *
+     * @return <code>-this</code>.
+     *
+     * @since 1.1
+     */
+
+    public Apcomplex negate()
+        throws ApfloatRuntimeException
+    {
+        return new Apcomplex(real().negate(), imag().negate());
+    }
+
+    /**
+     * Adds two apcomplex numbers.
+     *
+     * @param z The number to be added to this number.
+     *
+     * @return <code>this + z</code>.
+     */
+
+    public Apcomplex add(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return new Apcomplex(real().add(z.real()),
+                             imag().add(z.imag()));
+    }
+
+    /**
+     * Subtracts two apcomplex numbers.
+     *
+     * @param z The number to be subtracted from this number.
+     *
+     * @return <code>this - z</code>.
+     */
+
+    public Apcomplex subtract(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return new Apcomplex(real().subtract(z.real()),
+                             imag().subtract(z.imag()));
+    }
+
+    /**
+     * Multiplies two apcomplex numbers.
+     *
+     * @param z The number to be multiplied by this number.
+     *
+     * @return <code>this * z</code>.
+     */
+
+    public Apcomplex multiply(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return new Apcomplex(ApfloatMath.multiplySubtract(real(), z.real(), imag(), z.imag()),
+                             ApfloatMath.multiplyAdd(real(), z.imag(), imag(), z.real()));
+    }
+
+    /**
+     * Divides two apcomplex numbers.
+     *
+     * @param z The number by which this number is to be divided.
+     *
+     * @return <code>this / z</code>.
+     *
+     * @exception java.lang.ArithmeticException In case the divisor is zero.
+     */
+
+    public Apcomplex divide(Apcomplex z)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (z.real().signum() == 0 && z.imag().signum() == 0)
+        {
+            throw new ArithmeticException(real().signum() == 0 && imag().signum() == 0 ? "Zero divided by zero" : "Division by zero");
+        }
+
+        Apfloat tmpReal,
+                tmpImag;
+
+        // Multiply both numbers by i if z is pure imaginary
+        if (z.real().signum() == 0)
+        {
+            z = new Apcomplex(z.imag(), z.real().negate());
+            tmpReal = imag();
+            tmpImag = real().negate();
+        }
+        else
+        {
+            tmpReal = real();
+            tmpImag = imag();
+        }
+
+        if (tmpImag.signum() == 0)
+        {
+            if (tmpReal.signum() == 0)
+            {
+                // 0 / x = 0
+                return this;
+            }
+            else if (z.imag().signum() == 0)
+            {
+                // Real
+                return tmpReal.divide(z.real());
+            }
+        }
+        else if (z.imag().signum() == 0)
+        {
+            if (z.real().equals(ONE))
+            {
+                // x / 1 = x
+                return new Apcomplex(tmpReal.precision(Math.min(tmpReal.precision(), z.real().precision())),
+                                     tmpImag.precision(Math.min(tmpImag.precision(), z.real().precision())));
+            }
+            else if (z.real().isShort())
+            {
+                // If the divisor real and "short", it's faster to divide directly
+                return new Apcomplex(tmpReal.divide(z.real()),
+                                     tmpImag.divide(z.real()));
+            }
+
+            // If the divisor is real but not "short", it's faster to generate the inverse root (only once) and multiply by it
+            long precision = Math.min(precision(), z.real().precision());
+            Apfloat inverse = ApfloatMath.inverseRoot(z.real(), 1, precision);
+
+            return new Apcomplex(tmpReal.multiply(inverse),
+                                 tmpImag.multiply(inverse));
+        }
+
+        long precision = Math.min(precision(), z.precision());
+        Apcomplex zApprox = new Apcomplex(z.real().precision(Math.min(precision, z.real().precision())),
+                                          z.imag().precision(Math.min(precision, z.imag().precision())));
+
+        return multiply(z.conj()).divide(ApcomplexMath.norm(zApprox));
+    }
+
+    /**
+     * Returns the value of the this number as a <code>double</code>.
+     * Only takes the real part of this number.
+     *
+     * @see Apfloat#doubleValue()
+     *
+     * @return The numeric value represented by this object after conversion to type <code>double</code>.
+     */
+
+    public double doubleValue()
+    {
+        return real().doubleValue();
+    }
+
+    /**
+     * Returns the value of the this number as a <code>float</code>.
+     * Only takes the real part of this number.
+     *
+     * @see Apfloat#floatValue()
+     *
+     * @return The numeric value represented by this object after conversion to type <code>float</code>.
+     */
+
+    public float floatValue()
+    {
+        return real().floatValue();
+    }
+
+    /**
+     * Returns the value of the this number as a <code>byte</code>.
+     * Only takes the real part of this number.
+     *
+     * @see Apfloat#byteValue()
+     *
+     * @return The numeric value represented by this object after conversion to type <code>byte</code>.
+     */
+
+    public byte byteValue()
+    {
+        return real().byteValue();
+    }
+
+    /**
+     * Returns the value of the this number as a <code>short</code>.
+     * Only takes the real part of this number.
+     *
+     * @see Apfloat#shortValue()
+     *
+     * @return The numeric value represented by this object after conversion to type <code>short</code>.
+     */
+
+    public short shortValue()
+    {
+        return real().shortValue();
+    }
+
+    /**
+     * Returns the value of the this number as an <code>int</code>.
+     * Only takes the real part of this number.
+     *
+     * @see Apfloat#intValue()
+     *
+     * @return The numeric value represented by this object after conversion to type <code>int</code>.
+     */
+
+    public int intValue()
+    {
+        return real().intValue();
+    }
+
+    /**
+     * Returns the value of the this number as a <code>long</code>.
+     * Only takes the real part of this number.
+     *
+     * @see Apfloat#longValue()
+     *
+     * @return The numeric value represented by this object after conversion to type <code>long</code>.
+     */
+
+    public long longValue()
+    {
+        return real().longValue();
+    }
+
+    /**
+     * Computes number of equal digits.<p>
+     *
+     * Compares the digits of the numbers starting from the
+     * most significant digits. The exponent and sign are
+     * taken into consideration, so if either one doesn't match,
+     * the numbers are considered to have zero equal digits.<p>
+     *
+     * For example, the numbers (12345, 123) and (123456, 12) have
+     * zero matching digits, and the numbers (12345, 12) and
+     * (12355, 13) have three matching digits.
+     *
+     * @param z Number to compare with.
+     *
+     * @return Number of matching digits in the radix in which the numbers are presented.
+     */
+
+    public long equalDigits(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        if (real().signum() == 0 && imag().signum() == 0 &&
+            z.real().signum() == 0 && z.imag().signum() == 0)
+        {
+            // Both are zero
+            return Apfloat.INFINITE;
+        }
+
+        long minScale = Math.min(scale(), z.scale()),
+             maxScale = Math.max(scale(), z.scale());
+
+        if (maxScale - 1 > minScale)
+        {
+            // No match
+            return 0;
+        }
+        else
+        {
+            // Neither is zero, but the real part OR the imaginary part of each number may be zero
+            long realScale = Math.max(real().scale(), z.real().scale()),
+                 imagScale = Math.max(imag().scale(), z.imag().scale()),
+                 realScaleDiff = (maxScale - realScale < 0 ? Apfloat.INFINITE : maxScale - realScale),
+                 imagScaleDiff = (maxScale - imagScale < 0 ? Apfloat.INFINITE : maxScale - imagScale),
+                 realEquals = real().equalDigits(z.real()),
+                 imagEquals = imag().equalDigits(z.imag());
+
+            return Math.min(realEquals + realScaleDiff < 0 ? Apfloat.INFINITE : realEquals + realScaleDiff,
+                            imagEquals + imagScaleDiff < 0 ? Apfloat.INFINITE : imagEquals + imagScaleDiff);
+        }
+    }
+
+    /**
+     * Convert this apcomplex to the specified radix.
+     *
+     * @param radix The radix.
+     *
+     * @return This number in the specified radix.
+     *
+     * @exception java.lang.NumberFormatException If the radix is invalid.
+     *
+     * @since 1.2
+     */
+
+    public Apcomplex toRadix(int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        return new Apcomplex(real().toRadix(radix), imag().toRadix(radix));
+    }
+
+    /**
+     * Compares this object to the specified object.<p>
+     *
+     * Note: two apfloats are considered equal if they have an identical mantissa,
+     * but different precision.
+     *
+     * @param obj The object to compare with.
+     *
+     * @return <code>true</code> if the objects are equal; <code>false</code> otherwise.
+     */
+
+    public boolean equals(Object obj)
+    {
+        if (obj == this)
+        {
+            return true;
+        }
+        else if (obj instanceof Apcomplex)
+        {
+            Apcomplex that = (Apcomplex) obj;
+            return real().equals(that.real()) &&
+                   imag().equals(that.imag());
+        }
+        else
+        {
+            return false;
+        }
+    }
+
+    /**
+     * Returns a hash code for this apcomplex.
+     *
+     * @return The hash code value for this object.
+     */
+
+    public int hashCode()
+    {
+        return real().hashCode() * 3 +
+               imag().hashCode();
+    }
+
+    /**
+     * Returns a string representation of this apcomplex.
+     *
+     * @return A string representing this object.
+     */
+
+    public String toString()
+    {
+        return toString(false);
+    }
+
+    /**
+     * Returns a string representation of this apcomplex.
+     *
+     * @param pretty <code>true</code> to use a fixed-point notation, <code>false</code> to use an exponential notation.
+     *
+     * @return A string representing this object.
+     */
+
+    public String toString(boolean pretty)
+        throws ApfloatRuntimeException
+    {
+        if (imag().signum() == 0)
+        {
+            return real().toString(pretty);
+        }
+        else
+        {
+            return '(' + real().toString(pretty) + ", " +
+                         imag().toString(pretty) + ')';
+        }
+    }
+
+    /**
+     * Write a string representation of this apcomplex to a <code>Writer</code>.
+     *
+     * @param out The output <code>Writer</code>.
+     *
+     * @exception java.io.IOException In case of I/O error writing to the stream.
+     */
+
+    public void writeTo(Writer out)
+        throws IOException, ApfloatRuntimeException
+    {
+        writeTo(out, false);
+    }
+
+    /**
+     * Write a string representation of this apcomplex to a <code>Writer</code>.
+     *
+     * @param out The output <code>Writer</code>.
+     * @param pretty <code>true</code> to use a fixed-point notation, <code>false</code> to use an exponential notation.
+     *
+     * @exception java.io.IOException In case of I/O error writing to the stream.
+     */
+
+    public void writeTo(Writer out, boolean pretty)
+        throws IOException, ApfloatRuntimeException
+    {
+        if (imag().signum() == 0)
+        {
+            real().writeTo(out, pretty);
+        }
+        else
+        {
+            out.write('(');
+            real().writeTo(out, pretty);
+            out.write(", ");
+            imag().writeTo(out, pretty);
+            out.write(')');
+        }
+    }
+
+    /**
+     * Formats the object using the provided formatter.
+     *
+     * @param formatter The formatter.
+     * @param flags The flags to modify the output format.
+     * @param width The minimum number of characters to be written to the output, or <code>-1</code> for no minimum.
+     * @param precision The maximum number of characters to be written to the output, or <code>-1</code> for no maximum.
+     *
+     * @since 1.3
+     *
+     * @see Apfloat#formatTo(Formatter,int,int,int)
+     */
+
+    public void formatTo(Formatter formatter, int flags, int width, int precision)
+    {
+        if (imag().signum() == 0)
+        {
+            real().formatTo(formatter, flags, width, precision);
+        }
+        else
+        {
+            if (width == -1)
+            {
+                formatter.format("(");
+                real().formatTo(formatter, flags, width, precision);
+                formatter.format(", ");
+                imag().formatTo(formatter, flags, width, precision);
+                formatter.format(")");
+            }
+            else
+            {
+                try
+                {
+                    Writer out = FormattingHelper.wrapAppendableWriter(formatter.out());
+                    out = FormattingHelper.wrapPadWriter(out, (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY);
+                    formatter = new Formatter(out, formatter.locale());
+                    formatter.format("(");
+                    real().formatTo(formatter, flags, -1, precision);
+                    formatter.format(", ");
+                    imag().formatTo(formatter, flags, -1, precision);
+                    formatter.format(")");
+                    FormattingHelper.finishPad(out, width);
+                }
+                catch (IOException ioe)
+                {
+                    // Ignore as we can't propagate it; unfortunately we can't set it to the formattable either
+                }
+            }
+        }
+    }
+
+    static final Apint[] ONES;
+
+    static
+    {
+        ONES = new Apint[37];
+        for (int i =  2; i <= 36; i++)
+        {
+            ONES[i] = new Apint(1, i);
+        }
+        ONES[ONE.radix()] = ONE;
+    }
+
+    private static final long serialVersionUID = 3642932980384250551L;
+
+    private Apfloat real;
+    private Apfloat imag;
+}
Index: src/main/java/org/apfloat/ApcomplexMath.java
===================================================================
--- src/main/java/org/apfloat/ApcomplexMath.java	(revision 0)
+++ src/main/java/org/apfloat/ApcomplexMath.java	(revision 0)
@@ -0,0 +1,1564 @@
+package org.apfloat;
+
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.Queue;
+import java.util.PriorityQueue;
+
+import org.apfloat.spi.Util;
+
+/**
+ * Various mathematical functions for arbitrary precision complex numbers.
+ *
+ * @see ApfloatMath
+ *
+ * @version 1.8.1
+ * @author Mikko Tommila
+ */
+
+public class ApcomplexMath
+{
+    private ApcomplexMath()
+    {
+    }
+
+    /**
+     * Negative value.
+     *
+     * @deprecated Use {@link Apcomplex#negate()}.
+     *
+     * @param z The argument.
+     *
+     * @return <code>-z</code>.
+     */
+
+    @Deprecated
+    public static Apcomplex negate(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return z.negate();
+    }
+
+    /**
+     * Absolute value.
+     *
+     * @param z The argument.
+     *
+     * @return <code>sqrt(x<sup>2</sup> + y<sup>2</sup>)</code>, where <code>z = x + <i>i</i> y</code>.
+     */
+
+    public static Apfloat abs(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        if (z.real().signum() == 0)
+        {
+             return ApfloatMath.abs(z.imag());
+        }
+        else if (z.imag().signum() == 0)
+        {
+             return ApfloatMath.abs(z.real());
+        }
+        else
+        {
+             return ApfloatMath.sqrt(norm(z));
+        }
+    }
+
+    /**
+     * Norm. Square of the magnitude.
+     *
+     * @param z The argument.
+     *
+     * @return <code>x<sup>2</sup> + y<sup>2</sup></code>, where <code>z = x + <i>i</i> y</code>.
+     */
+
+    public static Apfloat norm(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return ApfloatMath.multiplyAdd(z.real(), z.real(), z.imag(), z.imag());
+    }
+
+    /**
+     * Angle of the complex vector in the complex plane.
+     *
+     * @param z The argument.
+     *
+     * @return <code>arctan(y / x)</code> from the appropriate branch, where <code>z = x + <i>i</i> y</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> is zero.
+     */
+
+    public static Apfloat arg(Apcomplex z)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return ApfloatMath.atan2(z.imag(), z.real());
+    }
+
+    /**
+     * Multiply by a power of the radix.
+     *
+     * @param z The argument.
+     * @param scale The scaling factor.
+     *
+     * @return <code>z * z.radix()<sup>scale</sup></code>.
+     */
+
+    public static Apcomplex scale(Apcomplex z, long scale)
+        throws ApfloatRuntimeException
+    {
+        return new Apcomplex(ApfloatMath.scale(z.real(), scale),
+                             ApfloatMath.scale(z.imag(), scale));
+    }
+
+    /**
+     * Integer power.
+     *
+     * @param z Base of the power operator.
+     * @param n Exponent of the power operator.
+     *
+     * @return <code>z</code> to the <code>n</code>:th power, that is <code>z<sup>n</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If both <code>z</code> and <code>n</code> are zero.
+     */
+
+    public static Apcomplex pow(Apcomplex z, long n)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (n == 0)
+        {
+            if (z.real().signum() == 0 && z.imag().signum() == 0)
+            {
+                throw new ArithmeticException("Zero to power zero");
+            }
+
+            return new Apcomplex(new Apfloat(1, Apfloat.INFINITE, z.radix()));
+        }
+        else if (n < 0)
+        {
+            z = Apcomplex.ONE.divide(z);
+            n = -n;
+        }
+
+        return powAbs(z, n);
+    }
+
+    // Absolute value of n used
+    private static Apcomplex powAbs(Apcomplex z, long n)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        long precision = z.precision();
+        z = ApfloatHelper.extendPrecision(z);   // Big exponents will accumulate round-off errors
+
+        // Algorithm improvements by Bernd Kellner
+        int b2pow = 0;
+
+        while ((n & 1) == 0)
+        {
+            b2pow++;
+            n >>>= 1;
+        }
+
+        Apcomplex r = z;
+
+        while ((n >>>= 1) > 0)
+        {
+            z = z.multiply(z);
+            if ((n & 1) != 0)
+            {
+                r = r.multiply(z);
+            }
+        }
+
+        while (b2pow-- > 0)
+        {
+            r = r.multiply(r);
+        }
+
+        return ApfloatHelper.setPrecision(r, precision);
+    }
+
+    /**
+     * Square root.
+     *
+     * @param z The argument.
+     *
+     * @return Square root of <code>z</code>.
+     */
+
+    public static Apcomplex sqrt(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return root(z, 2);
+    }
+
+    /**
+     * Cube root.
+     *
+     * @param z The argument.
+     *
+     * @return Cube root of <code>z</code>.
+     */
+
+    public static Apcomplex cbrt(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return root(z, 3);
+    }
+
+    /**
+     * Positive integer root. The branch that has the smallest angle
+     * and same sign of imaginary part as <code>z</code> is always chosen.
+     *
+     * @param z The argument.
+     * @param n Which root to take.
+     *
+     * @return <code>n</code>:th root of <code>z</code>, that is <code>z<sup>1/n</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>n</code> is zero.
+     */
+
+    public static Apcomplex root(Apcomplex z, long n)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return root(z, n, 0);
+    }
+
+    /**
+     * Positive integer root. The specified branch counting from the smallest angle
+     * and same sign of imaginary part as <code>z</code> is chosen.
+     *
+     * @param z The argument.
+     * @param n Which root to take.
+     * @param k Which branch to take.
+     *
+     * @return <code>n</code>:th root of <code>z</code>, that is <code>z<sup>1/n</sup>e<sup>i2&pi;sk/n</sup></code> where <code>s</code> is the signum of the imaginary part of <code>z</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>n</code> is zero.
+     *
+     * @since 1.5
+     */
+
+    public static Apcomplex root(Apcomplex z, long n, long k)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (n == 0)
+        {
+            throw new ArithmeticException("Zeroth root");
+        }
+        else if (z.real().signum() == 0 && z.imag().signum() == 0)
+        {
+            if (n < 0)
+            {
+                throw new ArithmeticException("Inverse root of zero");
+            }
+            return Apcomplex.ZERO;              // Avoid division by zero
+        }
+        else if (n == 1)
+        {
+            return z;
+        }
+        k %= n;
+        if (z.imag().signum() == 0 && z.real().signum() > 0 && k == 0)
+        {
+            return new Apcomplex(ApfloatMath.root(z.real(), n));
+        }
+        else if (n < 0)                         // Also correctly handles 0x8000000000000000L
+        {
+            return inverseRootAbs(z, -n, k);
+        }
+        else if (n == 2)
+        {
+            return z.multiply(inverseRootAbs(z, 2, k));
+        }
+        else if (n == 3)
+        {
+            // Choose the correct branch
+            if (z.real().signum() < 0)
+            {
+                k = (z.imag().signum() == 0 ? 1 - k : k - 1);
+                k %= n;
+            }
+            else
+            {
+                k = -k;
+            }
+            Apcomplex w = z.multiply(z);
+            return z.multiply(inverseRootAbs(w, 3, k));
+        }
+        else
+        {
+            return inverseRootAbs(inverseRootAbs(z, n, k), 1, 0);
+        }
+    }
+
+    /**
+     * Inverse positive integer root. The branch that has the smallest angle
+     * and different sign of imaginary part than <code>z</code> is always chosen.
+     *
+     * @param z The argument.
+     * @param n Which inverse root to take.
+     *
+     * @return Inverse <code>n</code>:th root of <code>z</code>, that is <code>z<sup>-1/n</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> or <code>n</code> is zero.
+     */
+
+    public static Apcomplex inverseRoot(Apcomplex z, long n)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return inverseRoot(z, n, 0);
+    }
+
+    /**
+     * Inverse positive integer root. The specified branch counting from the smallest angle
+     * and different sign of imaginary part than <code>z</code> is chosen.
+     *
+     * @param z The argument.
+     * @param n Which inverse root to take.
+     * @param k Which branch to take.
+     *
+     * @return Inverse <code>n</code>:th root of <code>z</code>, that is <code>z<sup>-1/n</sup>e<sup>-i2&pi;k/n</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> or <code>n</code> is zero.
+     */
+
+    public static Apcomplex inverseRoot(Apcomplex z, long n, long k)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (z.real().signum() == 0 && z.imag().signum() == 0)
+        {
+            throw new ArithmeticException("Inverse root of zero");
+        }
+        else if (n == 0)
+        {
+            throw new ArithmeticException("Inverse zeroth root");
+        }
+        k %= n;
+        if (z.imag().signum() == 0 && z.real().signum() > 0 && k == 0)
+        {
+            return new Apcomplex(ApfloatMath.inverseRoot(z.real(), n));
+        }
+        else if (n < 0)
+        {
+            return inverseRootAbs(inverseRootAbs(z, -n, k), 1, 0);      // Also correctly handles 0x8000000000000000L
+        }
+
+        return inverseRootAbs(z, n, k);
+    }
+
+    // Absolute value of n used
+    private static Apcomplex inverseRootAbs(Apcomplex z, long n, long k)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (z.equals(Apcomplex.ONE) && k == 0)
+        {
+            // Trivial case
+            return z;
+        }
+        else if (n == 2 && z.imag().signum() == 0 && z.real().signum() < 0)
+        {
+            // Avoid round-off errors and produce a pure imaginary result
+            Apfloat y = ApfloatMath.inverseRoot(z.real().negate(), n);
+            return new Apcomplex(Apfloat.ZERO, k == 0 ? y.negate() : y);
+        }
+
+        long targetPrecision = z.precision();
+
+        if (targetPrecision == Apfloat.INFINITE)
+        {
+            throw new InfiniteExpansionException("Cannot calculate inverse root to infinite precision");
+        }
+
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, z.radix()),
+                divisor = ApfloatMath.abs(new Apfloat(n, Apfloat.INFINITE, z.radix()));
+
+        double doubleReal,
+               doubleImag,
+               magnitude,
+               angle,
+               doubleN = Math.abs((double) n);
+
+        long realScale = z.real().scale(),
+             imagScale = z.imag().scale(),
+             scale = Math.max(realScale, imagScale),
+             scaleDiff = scale - Math.min(realScale, imagScale),
+             doublePrecision = ApfloatHelper.getDoublePrecision(z.radix()),
+             precision = doublePrecision,       // Accuracy of initial guess
+             scaleQuot = scale / n,             // If n is 0x8000000000000000 then this will be zero
+             scaleRem = scale - scaleQuot * n;
+        double scaleRemFactor = Math.pow((double) z.radix(), (double) -scaleRem / doubleN);
+
+        Apcomplex result;
+
+        // Calculate initial guess from z
+        if (z.imag().signum() == 0 ||
+            (scaleDiff > doublePrecision / 2 || scaleDiff < 0) && realScale > imagScale)        // Detect overflow
+        {
+            // z.real() is a lot bigger in magnitude than z.imag()
+            Apfloat tmpReal = z.real().precision(doublePrecision),
+                    tmpImag = z.imag().precision(doublePrecision);
+            Apcomplex tweak = new Apcomplex(Apfloat.ZERO,
+                                            tmpImag.divide(divisor.multiply(tmpReal)));
+
+            tmpReal = ApfloatMath.scale(tmpReal, -tmpReal.scale());     // Allow exponents in excess of doubles'
+
+            if ((magnitude = tmpReal.doubleValue()) >= 0.0)
+            {
+                doubleReal = Math.pow(magnitude, -1.0 / doubleN) * scaleRemFactor;
+                doubleImag = 0.0;
+            }
+            else
+            {
+                magnitude = Math.pow(-magnitude, -1.0 / doubleN) * scaleRemFactor;
+                angle = (tmpImag.signum() >= 0 ? -Math.PI : Math.PI) / doubleN;
+                doubleReal = magnitude * Math.cos(angle);
+                doubleImag = magnitude * Math.sin(angle);
+            }
+
+            tmpReal = ApfloatMath.scale(new Apfloat(doubleReal, doublePrecision, z.radix()), -scaleQuot);
+            tmpImag = ApfloatMath.scale(new Apfloat(doubleImag, doublePrecision, z.radix()), -scaleQuot);
+            result = new Apcomplex(tmpReal, tmpImag);
+            result = result.subtract(result.multiply(tweak));               // Must not be real
+        }
+        else if (z.real().signum() == 0 ||
+                 (scaleDiff > doublePrecision / 2 || scaleDiff < 0) && imagScale > realScale)        // Detect overflow
+        {
+            // z.imag() is a lot bigger in magnitude than z.real()
+            Apfloat tmpReal = z.real().precision(doublePrecision),
+                    tmpImag = z.imag().precision(doublePrecision);
+            Apcomplex tweak = new Apcomplex(Apfloat.ZERO,
+                                            tmpReal.divide(divisor.multiply(tmpImag)));
+
+            tmpImag = ApfloatMath.scale(tmpImag, -tmpImag.scale());     // Allow exponents in exess of doubles'
+
+            if ((magnitude = tmpImag.doubleValue()) >= 0.0)
+            {
+                magnitude = Math.pow(magnitude, -1.0 / doubleN) * scaleRemFactor;
+                angle = -Math.PI / (2.0 * doubleN);
+            }
+            else
+            {
+                magnitude = Math.pow(-magnitude, -1.0 / doubleN) * scaleRemFactor;
+                angle = Math.PI / (2.0 * doubleN);
+            }
+
+            doubleReal = magnitude * Math.cos(angle);
+            doubleImag = magnitude * Math.sin(angle);
+
+            tmpReal = ApfloatMath.scale(new Apfloat(doubleReal, doublePrecision, z.radix()), -scaleQuot);
+            tmpImag = ApfloatMath.scale(new Apfloat(doubleImag, doublePrecision, z.radix()), -scaleQuot);
+            result = new Apcomplex(tmpReal, tmpImag);
+            result = result.add(result.multiply(tweak));               // Must not be pure imaginary
+        }
+        else
+        {
+            // z.imag() and z.real() approximately the same in magnitude
+            Apfloat tmpReal = z.real().precision(doublePrecision),
+                    tmpImag = z.imag().precision(doublePrecision);
+
+            tmpReal = ApfloatMath.scale(tmpReal, -scale);       // Allow exponents in exess of doubles'
+            tmpImag = ApfloatMath.scale(tmpImag, -scale);       // Allow exponents in exess of doubles'
+
+            doubleReal = tmpReal.doubleValue();
+            doubleImag = tmpImag.doubleValue();
+
+            magnitude = Math.pow(doubleReal * doubleReal + doubleImag * doubleImag, -1.0 / (2.0 * doubleN)) * scaleRemFactor;
+            angle = -Math.atan2(doubleImag, doubleReal) / doubleN;
+
+            doubleReal = magnitude * Math.cos(angle);
+            doubleImag = magnitude * Math.sin(angle);
+
+            tmpReal = ApfloatMath.scale(new Apfloat(doubleReal, doublePrecision, z.radix()), -scaleQuot);
+            tmpImag = ApfloatMath.scale(new Apfloat(doubleImag, doublePrecision, z.radix()), -scaleQuot);
+            result = new Apcomplex(tmpReal, tmpImag);
+        }
+
+        // Alter the angle by the branch chosen
+        if (k != 0)
+        {
+            Apcomplex branch;
+            // Handle exact cases
+            k = (k < 0 ? k + n : k);
+            if (n % 4 == 0 && (n >>> 2) == k)
+            {
+                branch = new Apcomplex(Apfloat.ZERO, one);
+            }
+            else if (n % 4 == 0 && (n >>> 2) * 3 == k)
+            {
+                branch = new Apcomplex(Apfloat.ZERO, one.negate());
+            }
+            else if (n % 2 == 0 && (n >>> 1) == k)
+            {
+                branch = one.negate();
+            }
+            else
+            {
+                angle = 2.0 * Math.PI * (double) k / doubleN;
+                doubleReal = Math.cos(angle);
+                doubleImag = Math.sin(angle);
+                Apfloat tmpReal = new Apfloat(doubleReal, doublePrecision, z.radix());
+                Apfloat tmpImag = new Apfloat(doubleImag, doublePrecision, z.radix());
+                branch = new Apcomplex(tmpReal, tmpImag);
+            }
+            result = result.multiply(z.imag().signum() >= 0 ? branch.conj() : branch);
+        }
+
+        int iterations = 0;
+
+        // Compute total number of iterations
+        for (long maxPrec = precision; maxPrec < targetPrecision; maxPrec <<= 1)
+        {
+            iterations++;
+        }
+
+        int precisingIteration = iterations;
+
+        // Check where the precising iteration should be done
+        for (long minPrec = precision; precisingIteration > 0; precisingIteration--, minPrec <<= 1)
+        {
+            if ((minPrec - Apcomplex.EXTRA_PRECISION) << precisingIteration >= targetPrecision)
+            {
+                break;
+            }
+        }
+
+        z = ApfloatHelper.extendPrecision(z);
+
+        // Newton's iteration
+        while (iterations-- > 0)
+        {
+            precision *= 2;
+            result = ApfloatHelper.setPrecision(result, Math.min(precision, targetPrecision));
+
+            Apcomplex t = powAbs(result, n);
+            t = lastIterationExtendPrecision(iterations, precisingIteration, t);
+            t = one.subtract(z.multiply(t));
+            if (iterations < precisingIteration)
+            {
+                t = new Apcomplex(t.real().precision(precision / 2),
+                                  t.imag().precision(precision / 2));
+            }
+
+            result = lastIterationExtendPrecision(iterations, precisingIteration, result);
+            result = result.add(result.multiply(t).divide(divisor));
+
+            // Precising iteration
+            if (iterations == precisingIteration)
+            {
+                t = powAbs(result, n);
+                t = lastIterationExtendPrecision(iterations, -1, t);
+
+                result = lastIterationExtendPrecision(iterations, -1, result);
+                result = result.add(result.multiply(one.subtract(z.multiply(t))).divide(divisor));
+            }
+        }
+
+        return ApfloatHelper.setPrecision(result, targetPrecision);
+    }
+
+    /**
+     * All values of the positive integer root.<p>
+     *
+     * Returns all of the <code>n</code> values of the root, in the order
+     * of the angle, starting from the smallest angle and same sign of
+     * imaginary part as <code>z</code>.
+     *
+     * @param z The argument.
+     * @param n Which root to take.
+     *
+     * @return All values of the <code>n</code>:th root of <code>z</code>, that is <code>z<sup>1/n</sup></code>, in the order of the angle.
+     *
+     * @exception java.lang.ArithmeticException If <code>n</code> is zero.
+     *
+     * @since 1.5
+     */
+
+    public static Apcomplex[] allRoots(Apcomplex z, int n)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (n == 0)
+        {
+            throw new ArithmeticException("Zeroth root");
+        }
+        else if (n == 1)
+        {
+            return new Apcomplex[] { z };
+        }
+        else if (n == 0x80000000)
+        {
+            throw new ApfloatRuntimeException("Maximum array size exceeded");
+        }
+        else if (z.real().signum() == 0 && z.imag().signum() == 0)
+        {
+            if (n < 0)
+            {
+                throw new ArithmeticException("Inverse root of zero");
+            }
+            Apcomplex[] allRoots = new Apcomplex[n];
+            Arrays.fill(allRoots, Apcomplex.ZERO);
+            return allRoots;                                    // Avoid division by zero
+        }
+
+        boolean inverse = (n < 0);
+        n = Math.abs(n);
+
+        long precision = z.precision();
+        z = ApfloatHelper.extendPrecision(z);                   // Big roots will accumulate round-off errors
+
+        Apcomplex w = inverseRootAbs(new Apfloat(1, precision, z.radix()), n, 1);
+        w = (z.imag().signum() >= 0 ^ inverse ? w.conj() : w);  // Complex n:th root of unity
+
+        Apcomplex[] allRoots = new Apcomplex[n];
+        Apcomplex root = (inverse ? inverseRootAbs(z, n, 0) : root(z, n));
+        allRoots[0] = ApfloatHelper.setPrecision(root, precision);
+        for (int i = 1; i < n; i++)
+        {
+            root = root.multiply(w);
+            allRoots[i] = ApfloatHelper.setPrecision(root, precision);
+        }
+        return allRoots;
+    }
+
+    /**
+     * Arithmetic-geometric mean.
+     *
+     * @param a First argument.
+     * @param b Second argument.
+     *
+     * @return Arithmetic-geometric mean of <code>a</code> and <code>b</code>.
+     */
+
+    public static Apcomplex agm(Apcomplex a, Apcomplex b)
+        throws ApfloatRuntimeException
+    {
+        if (a.real().signum() == 0 && a.imag().signum() == 0 ||
+            b.real().signum() == 0 && b.imag().signum() == 0)         // Would not converge quadratically
+        {
+            return Apcomplex.ZERO;
+        }
+
+        long workingPrecision = Math.min(a.precision(), b.precision()),
+             targetPrecision = Math.max(a.precision(), b.precision());
+
+        if (workingPrecision == Apfloat.INFINITE)
+        {
+            throw new InfiniteExpansionException("Cannot calculate agm to infinite precision");
+        }
+
+        // Some minimum precision is required for the algorithm to work
+        workingPrecision = ApfloatHelper.extendPrecision(workingPrecision);
+        a = ApfloatHelper.ensurePrecision(a, workingPrecision);
+        b = ApfloatHelper.ensurePrecision(b, workingPrecision);
+
+        long precision = 0,
+             halfWorkingPrecision = (workingPrecision + 1) / 2;
+        final long CONVERGING = 1000;           // Arbitrarily chosen value...
+        Apfloat two = new Apfloat(2, Apfloat.INFINITE, a.radix());
+
+        // First check convergence
+        while (precision < CONVERGING && precision < halfWorkingPrecision)
+        {
+            Apcomplex t = a.add(b).divide(two);
+            b = sqrt(a.multiply(b));
+            a = t;
+
+            // Conserve precision in case of accumulating round-off errors
+            a = ApfloatHelper.ensurePrecision(a, workingPrecision);
+            b = ApfloatHelper.ensurePrecision(b, workingPrecision);
+
+            precision = a.equalDigits(b);
+        }
+
+        // Now we know quadratic convergence
+        while (precision <= halfWorkingPrecision)
+        {
+            Apcomplex t = a.add(b).divide(two);
+            b = sqrt(a.multiply(b));
+            a = t;
+
+            // Conserve precision in case of accumulating round-off errors
+            a = ApfloatHelper.ensurePrecision(a, workingPrecision);
+            b = ApfloatHelper.ensurePrecision(b, workingPrecision);
+
+            precision *= 2;
+        }
+
+        return ApfloatHelper.setPrecision(a.add(b).divide(two), targetPrecision);
+    }
+
+    /**
+     * Natural logarithm.<p>
+     *
+     * The logarithm is calculated using the arithmetic-geometric mean.
+     * See the Borweins' book for the formula.
+     *
+     * @param z The argument.
+     *
+     * @return Natural logarithm of <code>z</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> is zero.
+     */
+
+    public static Apcomplex log(Apcomplex z)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (z.real().signum() >= 0 && z.imag().signum() == 0)
+        {
+            return ApfloatMath.log(z.real());
+        }
+
+        // Calculate the log using 1 / radix <= |z| < 1 and the log addition formula
+        // because the agm converges badly for big z
+
+        long targetPrecision = z.precision();
+
+        if (targetPrecision == Apfloat.INFINITE)
+        {
+            throw new InfiniteExpansionException("Cannot calculate logarithm to infinite precision");
+        }
+
+        Apfloat imagBias;
+
+        // Scale z so that real part of z is always >= 0, that is its angle is -pi/2 <= angle(z) <= pi/2 to avoid possible instability near z.imag() = +-pi
+        if (z.real().signum() < 0)
+        {
+            Apfloat pi = ApfloatHelper.extendPrecision(ApfloatMath.pi(targetPrecision, z.radix()), z.radix() <= 3 ? 1 : 0);     // pi may have 1 digit more than pi/2
+
+            if (z.imag().signum() >= 0)
+            {
+                imagBias = pi;
+            }
+            else
+            {
+                imagBias = pi.negate();
+            }
+
+            z = z.negate();
+        }
+        else
+        {
+            // No bias
+            imagBias = Apfloat.ZERO;
+        }
+
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, z.radix()),
+                x = abs(z);
+
+        long originalScale = z.scale();
+
+        z = scale(z, -originalScale);   // Set z's scale to zero
+
+        Apfloat radixPower;
+        if (originalScale == 0)
+        {
+            radixPower = Apfloat.ZERO;
+        }
+        else
+        {
+            Apfloat logRadix = ApfloatHelper.extendPrecision(ApfloatMath.logRadix(targetPrecision, z.radix()));
+            radixPower = new Apfloat(originalScale, Apfloat.INFINITE, z.radix()).multiply(logRadix);
+        }
+
+        Apcomplex result = ApfloatHelper.extendPrecision(rawLog(z)).add(radixPower);
+
+        // If the absolute value of the argument is close to 1, the real part of the result is less accurate
+        // If the angle of the argument is close to zero, the imaginary part of the result is less accurate
+        long finalRealPrecision = Math.max(targetPrecision - one.equalDigits(x), 1),
+             finalImagPrecision = Math.max(targetPrecision - 1 + result.imag().scale(), 1);     // Scale of pi/2 is always 1
+
+        return new Apcomplex(result.real().precision(finalRealPrecision),
+                             result.imag().precision(finalImagPrecision).add(imagBias));
+    }
+
+    /**
+     * Logarithm in arbitrary base.<p>
+     *
+     * @param z The argument.
+     * @param w The base.
+     *
+     * @return Base-<code>w</code> logarithm of <code>z</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> or <code>w</code> is zero.
+     *
+     * @since 1.6
+     */
+
+    public static Apcomplex log(Apcomplex z, Apcomplex w)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (z.real().signum() >= 0 && z.imag().signum() == 0 &&
+            w.real().signum() >= 0 && w.imag().signum() == 0)
+        {
+            return ApfloatMath.log(z.real(), w.real());
+        }
+
+        long targetPrecision = Math.min(z.precision(), w.precision());
+
+        if (z.real().signum() >= 0 && z.imag().signum() == 0)
+        {
+            Apfloat x = z.real();
+
+            Apfloat one = new Apfloat(1, Apfloat.INFINITE, x.radix());
+            targetPrecision = Util.ifFinite(targetPrecision, targetPrecision + one.equalDigits(x)); // If the log() argument is close to 1, the result is less accurate
+            x = x.precision(Math.min(x.precision(), targetPrecision));
+
+            return ApfloatMath.log(x).divide(log(w));
+        }
+        else if (w.real().signum() >= 0 && w.imag().signum() == 0)
+        {
+            Apfloat y = w.real();
+
+            Apfloat one = new Apfloat(1, Apfloat.INFINITE, y.radix());
+            targetPrecision = Util.ifFinite(targetPrecision, targetPrecision + one.equalDigits(y)); // If the log() argument is close to 1, the result is less accurate
+            y = y.precision(Math.min(y.precision(), targetPrecision));
+
+            return log(z).divide(ApfloatMath.log(y));
+        }
+        else
+        {
+            return log(z).divide(log(w));
+        }
+    }
+
+    // Raw logarithm, regardless of z
+    // Doesn't work for really big z, but is faster if used alone for small numbers
+    private static Apcomplex rawLog(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        assert (z.real().signum() != 0 || z.imag().signum() != 0);      // Infinity
+
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, z.radix());
+
+        final int EXTRA_PRECISION = 25;
+
+        long targetPrecision = z.precision(),
+             workingPrecision = ApfloatHelper.extendPrecision(targetPrecision),
+             n = targetPrecision / 2 + EXTRA_PRECISION;                 // Very rough estimate
+
+        z = ApfloatHelper.extendPrecision(z, EXTRA_PRECISION);
+
+        Apfloat e = one.precision(workingPrecision);
+        e = ApfloatMath.scale(e, -n);
+        z = scale(z, -n);
+
+        Apfloat agme = ApfloatHelper.extendPrecision(ApfloatMath.agm(one, e));
+        Apcomplex agmez = ApfloatHelper.extendPrecision(agm(one, z));
+
+        Apfloat pi = ApfloatHelper.extendPrecision(ApfloatMath.pi(targetPrecision, z.radix()));
+        Apcomplex log = pi.multiply(agmez.subtract(agme)).divide(new Apfloat(2, Apfloat.INFINITE, z.radix()).multiply(agme).multiply(agmez));
+
+        return ApfloatHelper.setPrecision(log, targetPrecision);
+    }
+
+    /**
+     * Exponent function.
+     * Calculated using Newton's iteration for the inverse of logarithm.
+     *
+     * @param z The argument.
+     *
+     * @return <code>e<sup>z</sup></code>.
+     */
+
+    public static Apcomplex exp(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        if (z.imag().signum() == 0)
+        {
+            return ApfloatMath.exp(z.real());
+        }
+
+        int radix = z.radix();
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, radix);
+
+        long doublePrecision = ApfloatHelper.getDoublePrecision(radix);
+
+        // If the real part of the argument is close to 0, the result is more accurate
+        // The imaginary part must be scaled to the range of -pi ... pi, which may limit the precision
+        long targetPrecision = (z.imag().precision() >= z.imag().scale() ?
+                                Math.min(Util.ifFinite(z.real().precision(), z.real().precision() + Math.max(1 - z.real().scale(), 0)),
+                                         Util.ifFinite(z.imag().precision(), 1 + z.imag().precision() - z.imag().scale())) :
+                                0);
+
+        if (targetPrecision == Apfloat.INFINITE)
+        {
+            throw new InfiniteExpansionException("Cannot calculate exponent to infinite precision");
+        }
+        else if (z.real().compareTo(new Apfloat((double) Long.MAX_VALUE * Math.log((double) radix), doublePrecision, radix)) >= 0)
+        {
+            throw new OverflowException("Overflow");
+        }
+        else if (z.real().compareTo(new Apfloat((double) Long.MIN_VALUE * Math.log((double) radix), doublePrecision, radix)) <= 0)
+        {
+            // Underflow
+
+            return Apcomplex.ZERO;
+        }
+        else if (targetPrecision == 0)
+        {
+            throw new LossOfPrecisionException("Complete loss of accurate digits in imaginary part");
+        }
+
+        boolean negateResult = false;                           // If the final result is to be negated
+        Apfloat zImag;
+
+        if (z.imag().scale() > 0)
+        {
+            long piPrecision = Util.ifFinite(targetPrecision, targetPrecision + z.imag().scale());
+            Apfloat pi = ApfloatMath.pi(piPrecision, radix),    // This is precalculated for initial check only
+                    twoPi = pi.add(pi),
+                    halfPi = pi.divide(new Apfloat(2, targetPrecision, radix));
+
+            // Scale z so that -pi < z.imag() <= pi
+            zImag = ApfloatMath.fmod(z.imag(), twoPi);
+            if (zImag.compareTo(pi) > 0)
+            {
+                zImag = zImag.subtract(twoPi);
+            }
+            else if (zImag.compareTo(pi.negate()) <= 0)
+            {
+                zImag = zImag.add(twoPi);
+            }
+            // More, scale z so that -pi/2 < z.imag() <= pi/2 to avoid instability near z.imag() = +-pi
+            if (zImag.compareTo(halfPi) > 0)
+            {
+                // exp(z - i*pi) = exp(z)/exp(i*pi) = -exp(z)
+                zImag = zImag.subtract(pi);
+                negateResult = true;
+            }
+            else if (zImag.compareTo(halfPi.negate()) <= 0)
+            {
+                // exp(z + i*pi) = exp(z)*exp(i*pi) = -exp(z)
+                zImag = zImag.add(pi);
+                negateResult = true;
+            }
+        }
+        else
+        {
+            // No need to scale the imaginary part since it's small, -pi/2 < z.imag() <= pi/2
+            zImag = z.imag();
+        }
+        z = new Apcomplex(z.real(), zImag);
+
+        Apfloat resultReal;
+        Apcomplex resultImag;
+
+        // First handle the real part
+
+        if (z.real().signum() == 0)
+        {
+            resultReal = one;
+        }
+        else if (z.real().scale() < -doublePrecision / 2)
+        {
+            // Taylor series: exp(x) = 1 + x + x^2/2 + ...
+
+            long precision = Util.ifFinite(-z.real().scale(), -2 * z.real().scale());
+            resultReal = one.precision(precision).add(z.real());
+        }
+        else
+        {
+            // Approximate starting value for iteration
+
+            // An overflow or underflow should not occur
+            long scaledRealPrecision = Math.max(0, z.real().scale()) + doublePrecision;
+            Apfloat logRadix = ApfloatMath.log(new Apfloat((double) radix, scaledRealPrecision, radix)),
+                    scaledReal = z.real().precision(scaledRealPrecision).divide(logRadix),
+                    integerPart = scaledReal.truncate(),
+                    fractionalPart = scaledReal.frac();
+
+            resultReal = new Apfloat(Math.pow((double) radix, fractionalPart.doubleValue()), doublePrecision, radix);
+            resultReal = ApfloatMath.scale(resultReal, integerPart.longValue());
+
+            if (resultReal.signum() == 0) {
+                // Underflow
+                return Apcomplex.ZERO;
+            }
+        }
+
+        // Then handle the imaginary part
+
+        if (zImag.signum() == 0)
+        {
+            // Imaginary part may have been reduced to zero e.g. if it was exactly pi
+            resultImag = one;
+        }
+        else if (zImag.scale() < -doublePrecision / 2)
+        {
+            // Taylor series: exp(z) = 1 + z + z^2/2 + ...
+
+            long precision = Util.ifFinite(-zImag.scale(), -2 * zImag.scale());
+            resultImag = new Apcomplex(one.precision(precision), zImag.precision(-zImag.scale()));
+        }
+        else
+        {
+            // Approximate starting value for iteration
+
+            double doubleImag = zImag.doubleValue();
+            resultImag = new Apcomplex(new Apfloat(Math.cos(doubleImag), doublePrecision, radix),
+                                       new Apfloat(Math.sin(doubleImag), doublePrecision, radix));
+        }
+
+        // Starting value is (real part starting value) * (imag part starting value)
+        Apcomplex result = resultReal.multiply(resultImag);
+
+        long precision = result.precision();    // Accuracy of initial guess
+
+        int iterations = 0;
+
+        // Compute total number of iterations
+        for (long maxPrec = precision; maxPrec < targetPrecision; maxPrec <<= 1)
+        {
+            iterations++;
+        }
+
+        int precisingIteration = iterations;
+
+        // Check where the precising iteration should be done
+        for (long minPrec = precision; precisingIteration > 0; precisingIteration--, minPrec <<= 1)
+        {
+            if ((minPrec - Apcomplex.EXTRA_PRECISION) << precisingIteration >= targetPrecision)
+            {
+                break;
+            }
+        }
+
+        if (iterations > 0)
+        {
+            // Precalculate the needed values once to the required precision
+            ApfloatMath.logRadix(targetPrecision, radix);
+        }
+
+        z = ApfloatHelper.extendPrecision(z);
+
+        // Newton's iteration
+        while (iterations-- > 0)
+        {
+            precision *= 2;
+            result = ApfloatHelper.setPrecision(result, Math.min(precision, targetPrecision));
+
+            Apcomplex t = log(result);
+            t = lastIterationExtendPrecision(iterations, precisingIteration, t);
+            t = z.subtract(t);
+
+            if (iterations < precisingIteration)
+            {
+                t = new Apcomplex(t.real().precision(precision / 2),
+                                  t.imag().precision(precision / 2));
+            }
+
+            result = lastIterationExtendPrecision(iterations, precisingIteration, result);
+            result = result.add(result.multiply(t));
+
+            // Precising iteration
+            if (iterations == precisingIteration)
+            {
+                t = log(result);
+                t = lastIterationExtendPrecision(iterations, -1, t);
+
+                result = lastIterationExtendPrecision(iterations, -1, result);
+                result = result.add(result.multiply(z.subtract(t)));
+            }
+        }
+
+        return ApfloatHelper.setPrecision(negateResult ? result.negate() : result, targetPrecision);
+    }
+
+    /**
+     * Arbitrary power. Calculated using <code>log()</code> and <code>exp()</code>.<p>
+     *
+     * @param z The base.
+     * @param w The exponent.
+     *
+     * @return <code>z<sup>w</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If both <code>z</code> and <code>w</code> are zero.
+     */
+
+    public static Apcomplex pow(Apcomplex z, Apcomplex w)
+        throws ApfloatRuntimeException
+    {
+        long targetPrecision = Math.min(z.precision(), w.precision());
+
+        Apcomplex result = ApfloatHelper.checkPow(z, w, targetPrecision);
+        if (result != null)
+        {
+            return result;
+        }
+
+        if (z.real().signum() >= 0 && z.imag().signum() == 0)
+        {
+            Apfloat x = z.real();
+
+            // Limits precision for log() but may be sub-optimal; precision could be limited more
+            Apfloat one = new Apfloat(1, Apfloat.INFINITE, x.radix());
+            targetPrecision = Util.ifFinite(targetPrecision, targetPrecision + one.equalDigits(x)); // If the log() argument is close to 1, the result is less accurate
+            x = x.precision(Math.min(x.precision(), targetPrecision));
+
+            return exp(w.multiply(ApfloatMath.log(x)));
+        }
+        else
+        {
+            return exp(w.multiply(log(z)));
+        }
+    }
+
+    /**
+     * Inverse cosine. Calculated using <code>log()</code>.
+     *
+     * @param z The argument.
+     *
+     * @return Inverse cosine of <code>z</code>.
+     */
+
+    public static Apcomplex acos(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, z.radix());
+
+        if (z.imag().signum() == 0 && ApfloatMath.abs(z.real()).compareTo(one) <= 0)
+        {
+            return ApfloatMath.acos(z.real());
+        }
+
+        Apcomplex i = new Apcomplex(Apfloat.ZERO, one),
+                  w = i.multiply(log(z.add(sqrt(z.multiply(z).subtract(one)))));
+
+        if (z.real().signum() * z.imag().signum() >= 0)
+        {
+            return w.negate();
+        }
+        else
+        {
+            return w;
+        }
+    }
+
+    /**
+     * Inverse hyperbolic cosine. Calculated using <code>log()</code>.
+     *
+     * @param z The argument.
+     *
+     * @return Inverse hyperbolic cosine of <code>z</code>.
+     */
+
+    public static Apcomplex acosh(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, z.radix());
+
+        if (z.real().signum() >= 0)
+        {
+            return log(z.add(sqrt(z.multiply(z).subtract(one))));
+        }
+        else
+        {
+            return log(z.subtract(sqrt(z.multiply(z).subtract(one))));
+        }
+    }
+
+    /**
+     * Inverse sine. Calculated using <code>log()</code>.
+     *
+     * @param z The argument.
+     *
+     * @return Inverse sine of <code>z</code>.
+     */
+
+    public static Apcomplex asin(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, z.radix());
+
+        if (z.imag().signum() == 0 && ApfloatMath.abs(z.real()).compareTo(one) <= 0)
+        {
+            return ApfloatMath.asin(z.real());
+        }
+
+        Apcomplex i = new Apcomplex(Apfloat.ZERO, one);
+
+        if (z.imag().signum() >= 0)
+        {
+            return i.multiply(log(sqrt(one.subtract(z.multiply(z))).subtract(i.multiply(z))));
+        }
+        else
+        {
+            return i.multiply(log(i.multiply(z).add(sqrt(one.subtract(z.multiply(z)))))).negate();
+        }
+    }
+
+    /**
+     * Inverse hyperbolic sine. Calculated using <code>log()</code>.
+     *
+     * @param z The argument.
+     *
+     * @return Inverse hyperbolic sine of <code>z</code>.
+     */
+
+    public static Apcomplex asinh(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, z.radix());
+
+        if (z.real().signum() >= 0)
+        {
+            return log(sqrt(z.multiply(z).add(one)).add(z));
+        }
+        else
+        {
+            return log(sqrt(z.multiply(z).add(one)).subtract(z)).negate();
+        }
+    }
+
+    /**
+     * Inverse tangent. Calculated using <code>log()</code>.
+     *
+     * @param z The argument.
+     *
+     * @return Inverse tangent of <code>z</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z == <i>i</i></code>.
+     */
+
+    public static Apcomplex atan(Apcomplex z)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (z.imag().signum() == 0)
+        {
+            return ApfloatMath.atan(z.real());
+        }
+
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, z.radix()),
+                two = new Apfloat(2, Apfloat.INFINITE, z.radix());
+        Apcomplex i = new Apcomplex(Apfloat.ZERO, one);
+
+        return log(i.add(z).divide(i.subtract(z))).multiply(i).divide(two);
+    }
+
+    /**
+     * Inverse hyperbolic tangent. Calculated using <code>log()</code>.
+     *
+     * @param z The argument.
+     *
+     * @return Inverse hyperbolic tangent of <code>z</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> is 1 or -1.
+     */
+
+    public static Apcomplex atanh(Apcomplex z)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, z.radix()),
+                two = new Apfloat(2, Apfloat.INFINITE, z.radix());
+
+        return log(one.add(z).divide(one.subtract(z))).divide(two);
+    }
+
+    /**
+     * Cosine. Calculated using <code>exp()</code>.
+     *
+     * @param z The argument.
+     *
+     * @return Cosine of <code>z</code>.
+     */
+
+    public static Apcomplex cos(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        if (z.imag().signum() == 0)
+        {
+            return ApfloatMath.cos(z.real());
+        }
+
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, z.radix()),
+                two = new Apfloat(2, Apfloat.INFINITE, z.radix());
+        Apcomplex i = new Apcomplex(Apfloat.ZERO, one),
+                  w = exp(i.multiply(z));
+
+        return (w.add(one.divide(w))).divide(two);
+    }
+
+    /**
+     * Hyperbolic cosine. Calculated using <code>exp()</code>.
+     *
+     * @param z The argument.
+     *
+     * @return Hyperbolic cosine of <code>z</code>.
+     */
+
+    public static Apcomplex cosh(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        if (z.imag().signum() == 0)
+        {
+            return ApfloatMath.cosh(z.real());
+        }
+
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, z.radix()),
+                two = new Apfloat(2, Apfloat.INFINITE, z.radix());
+        Apcomplex w = exp(z);
+
+        return (w.add(one.divide(w))).divide(two);
+    }
+
+    /**
+     * Sine. Calculated using <code>exp()</code>.
+     *
+     * @param z The argument.
+     *
+     * @return Sine of <code>z</code>.
+     */
+
+    public static Apcomplex sin(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        if (z.imag().signum() == 0)
+        {
+            return ApfloatMath.sin(z.real());
+        }
+
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, z.radix()),
+                two = new Apfloat(2, Apfloat.INFINITE, z.radix());
+        Apcomplex i = new Apcomplex(Apfloat.ZERO, one),
+                  w = exp(i.multiply(z));
+
+        return one.divide(w).subtract(w).multiply(i).divide(two);
+    }
+
+    /**
+     * Hyperbolic sine. Calculated using <code>exp()</code>.
+     *
+     * @param z The argument.
+     *
+     * @return Hyperbolic sine of <code>z</code>.
+     */
+
+    public static Apcomplex sinh(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        if (z.imag().signum() == 0)
+        {
+            return ApfloatMath.sinh(z.real());
+        }
+
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, z.radix()),
+                two = new Apfloat(2, Apfloat.INFINITE, z.radix());
+        Apcomplex w = exp(z);
+
+        return (w.subtract(one.divide(w))).divide(two);
+    }
+
+    /**
+     * Tangent. Calculated using <code>exp()</code>.
+     *
+     * @param z The argument.
+     *
+     * @return Tangent of <code>z</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> is &pi;/2 + n &pi; where n is an integer.
+     */
+
+    public static Apcomplex tan(Apcomplex z)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (z.imag().signum() == 0)
+        {
+            return ApfloatMath.tan(z.real());
+        }
+
+        boolean negate = z.imag().signum() > 0;
+        z = (negate ? z.negate() : z);
+
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, z.radix()),
+                two = new Apfloat(2, Apfloat.INFINITE, z.radix());
+        Apcomplex i = new Apcomplex(Apfloat.ZERO, one),
+                  w = exp(two.multiply(i).multiply(z));
+
+        w = i.multiply(one.subtract(w)).divide(one.add(w));
+
+        return (negate ? w.negate() : w);
+    }
+
+    /**
+     * Hyperbolic tangent. Calculated using <code>exp()</code>.
+     *
+     * @param z The argument.
+     *
+     * @return Hyperbolic tangent of <code>z</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> is <i>i</i> (&pi;/2 + n &pi;) where n is an integer.
+     */
+
+    public static Apcomplex tanh(Apcomplex z)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (z.imag().signum() == 0)
+        {
+            return ApfloatMath.tanh(z.real());
+        }
+
+        boolean negate = z.real().signum() < 0;
+        z = (negate ? z.negate() : z);
+
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, z.radix()),
+                two = new Apfloat(2, Apfloat.INFINITE, z.radix());
+        Apcomplex w = exp(two.multiply(z));
+
+        w = w.subtract(one).divide(w.add(one));
+
+        return (negate ? w.negate() : w);
+    }
+
+    /**
+     * Lambert W function. The W function gives the solution to the equation
+     * <code>W e<sup>W</sup> = z</code>. Also known as the product logarithm.<p>
+     *
+     * This function gives the solution to the principal branch, W<sub>0</sub>.
+     *
+     * @param z The argument.
+     *
+     * @return <code>W<sub>0</sub>(z)</code>.
+     *
+     * @since 1.8.0
+     */
+
+    public static Apcomplex w(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return LambertWHelper.w(z);
+    }
+
+    /**
+     * Lambert W function for the specified branch.<p>
+     *
+     * @param z The argument.
+     * @param k The branch.
+     *
+     * @return <code>W<sub>k</sub>(z)</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> is zero and <code>k</code> is not zero.
+     *
+     * @see #w(Apcomplex)
+     *
+     * @since 1.8.0
+     */
+
+    public static Apcomplex w(Apcomplex z, long k)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return LambertWHelper.w(z, k);
+    }
+
+    /**
+     * Product of numbers.
+     * The precision used in the multiplications is only
+     * what is needed for the end result. This method may
+     * perform significantly better than simply multiplying
+     * the numbers sequentially.<p>
+     *
+     * If there are no arguments, the return value is <code>1</code>.
+     *
+     * @param z The argument(s).
+     *
+     * @return The product of the given numbers.
+     *
+     * @since 1.3
+     */
+
+    public static Apcomplex product(Apcomplex... z)
+        throws ApfloatRuntimeException
+    {
+        if (z.length == 0)
+        {
+            return Apcomplex.ONE;
+        }
+
+        // Determine working precision
+        long maxPrec = Apcomplex.INFINITE;
+        for (int i = 0; i < z.length; i++)
+        {
+            if (z[i].real().signum() == 0 && z[i].imag().signum() == 0)
+            {
+                return Apcomplex.ZERO;
+            }
+            maxPrec = Math.min(maxPrec, z[i].precision());
+        }
+
+        // Do not use z.clone() as the array might be of some subclass type, resulting in ArrayStoreException later
+        Apcomplex[] tmp = new Apcomplex[z.length];
+
+        // Add sqrt length digits for round-off errors
+        long extraPrec = (long) Math.sqrt((double) z.length),
+             destPrec = ApfloatHelper.extendPrecision(maxPrec, extraPrec);
+        for (int i = 0; i < z.length; i++)
+        {
+            tmp[i] = z[i].precision(destPrec);
+        }
+        z = tmp;
+
+        // Create a heap, ordered by size
+        Queue<Apcomplex> heap = new PriorityQueue<Apcomplex>(z.length, new Comparator<Apcomplex>()
+        {
+            public int compare(Apcomplex z, Apcomplex w)
+            {
+                long zSize = z.size(),
+                     wSize = w.size();
+                return (zSize < wSize ? -1 : (zSize > wSize ? 1 : 0));
+            }
+        });
+
+        // Perform the multiplications in parallel
+        ParallelHelper.ProductKernel<Apcomplex> kernel = new ParallelHelper.ProductKernel<Apcomplex>()
+        {
+            public void run(Queue<Apcomplex> heap)
+            {
+                Apcomplex a = heap.remove();
+                Apcomplex b = heap.remove();
+                Apcomplex c = a.multiply(b);
+                heap.add(c);
+            }
+        };
+        ParallelHelper.parallelProduct(z, heap, kernel);
+
+        return ApfloatHelper.setPrecision(heap.remove(), maxPrec);
+    }
+
+    /**
+     * Sum of numbers.
+     * The precision used in the additions is only
+     * what is needed for the end result. This method may
+     * perform significantly better than simply adding
+     * the numbers sequentially.<p>
+     *
+     * If there are no arguments, the return value is <code>0</code>.
+     *
+     * @param z The argument(s).
+     *
+     * @return The sum of the given numbers.
+     *
+     * @since 1.3
+     */
+
+    public static Apcomplex sum(Apcomplex... z)
+        throws ApfloatRuntimeException
+    {
+        if (z.length == 0)
+        {
+            return Apcomplex.ZERO;
+        }
+
+        Apfloat[] x = new Apfloat[z.length],
+                  y = new Apfloat[z.length];
+        for (int i = 0; i < z.length; i++)
+        {
+            x[i] = z[i].real();
+            y[i] = z[i].imag();
+        }
+        return new Apcomplex(ApfloatMath.sum(x), ApfloatMath.sum(y));
+    }
+
+    // Extend the precision on last iteration
+    private static Apcomplex lastIterationExtendPrecision(int iterations, int precisingIteration, Apcomplex z)
+    {
+        return (iterations == 0 && precisingIteration != 0 ? ApfloatHelper.extendPrecision(z) : z);
+    }
+}
Index: src/main/java/org/apfloat/Apfloat.java
===================================================================
--- src/main/java/org/apfloat/Apfloat.java	(revision 0)
+++ src/main/java/org/apfloat/Apfloat.java	(revision 0)
@@ -0,0 +1,1247 @@
+package org.apfloat;
+
+import java.math.BigInteger;
+import java.math.BigDecimal;
+import java.io.PushbackReader;
+import java.io.Writer;
+import java.io.IOException;
+import java.util.Formatter;
+import static java.util.FormattableFlags.*;
+
+import org.apfloat.spi.ApfloatImpl;
+
+/**
+ * Arbitrary precision floating-point number class.<p>
+ *
+ * Apfloat numbers are immutable.<p>
+ *
+ * A pitfall exists with the constructors {@link #Apfloat(float,long)}
+ * and {@link #Apfloat(double,long)}. Since <code>float</code>s and
+ * <code>double</code>s are always represented internally in radix 2, the
+ * conversion to any other radix usually causes round-off errors, and the
+ * resulting apfloat won't be accurate to the desired number of digits.<p>
+ *
+ * For example, <code>0.3</code> can't be presented exactly in base 2. When
+ * you construct an apfloat like <code>new Apfloat(0.3f, 1000)</code>, the
+ * resulting number won't be accurate to 1000 digits, but only to roughly 7
+ * digits (in radix 10). In fact, the resulting number will be something like
+ * <code>0.30000001192092896</code>...
+ *
+ * @see ApfloatMath
+ *
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class Apfloat
+    extends Apcomplex
+    implements Comparable<Apfloat>
+{
+    /**
+     * Default constructor. To be used only by subclasses that
+     * overload all needed methods.
+     */
+
+    protected Apfloat()
+    {
+    }
+
+    /**
+     * Constructs an apfloat that is backed by the specified
+     * <code>ApfloatImpl</code> object.
+     *
+     * @param impl The <code>ApfloatImpl</code> object backing this apfloat.
+     */
+
+    protected Apfloat(ApfloatImpl impl)
+    {
+        assert (impl.precision() > 0);
+        this.impl = impl;
+    }
+
+    /**
+     * Constructs an apfloat from the specified string.
+     * The default radix will be used.<p>
+     *
+     * The precision will be calculated from the number
+     * of digits specified in the string. For example:<p>
+     *
+     * <code>"0.1"</code> will have a precision of 1 digit.<br>
+     * <code>"1.0"</code> will have a precision of 2 digits.<br>
+     * <code>"100"</code> will have a precision of 3 digits.<br>
+     *
+     * @param value The string representing the number.
+     *
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     */
+
+    public Apfloat(String value)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(value, false));
+    }
+
+    /**
+     * Constructs an apfloat from the specified string and precision.
+     * The default radix will be used.
+     *
+     * @param value The string representing the number.
+     * @param precision The precision of the number.
+     *
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     * @exception java.lang.IllegalArgumentException In case the precision is invalid.
+     */
+
+    public Apfloat(String value, long precision)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(value, precision, false));
+    }
+
+    /**
+     * Constructs an apfloat from the specified string, precision and radix.<p>
+     *
+     * Note that it's impossible to construct apfloats with a specified exponent
+     * and with radix &gt;= 14, since the characters 'e' and 'E' will be treated as
+     * digits of the mantissa.<p>
+     *
+     * For example, in radix 10, "1e5" means the decimal number 100000. But in
+     * radix 16, "1e5" means the decimal number 485.
+     *
+     * @param value The string representing the number.
+     * @param precision The precision of the number.
+     * @param radix The radix of the number.
+     *
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     * @exception java.lang.IllegalArgumentException In case the precision is invalid.
+     */
+
+    public Apfloat(String value, long precision, int radix)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(value, precision, radix, false));
+    }
+
+    /**
+     * Constructs an apfloat from the specified <code>long</code>.
+     * The default radix will be used. The precision of the number
+     * will be {@link #INFINITE}.
+     *
+     * @param value The value of the number.
+     *
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     */
+
+    public Apfloat(long value)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(value));
+    }
+
+    /**
+     * Constructs an apfloat from the specified <code>long</code>
+     * and precision. The default radix will be used.
+     *
+     * @param value The value of the number.
+     * @param precision The precision of the number.
+     *
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     * @exception java.lang.IllegalArgumentException In case the precision is invalid.
+     */
+
+    public Apfloat(long value, long precision)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(value, precision));
+    }
+
+    /**
+     * Constructs an apfloat from the specified <code>long</code>,
+     * precision and radix.
+     *
+     * @param value The value of the number.
+     * @param precision The precision of the number.
+     * @param radix The radix of the number.
+     *
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     * @exception java.lang.IllegalArgumentException In case the precision is invalid.
+     */
+
+    public Apfloat(long value, long precision, int radix)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(value, precision, radix));
+    }
+
+    /**
+     * Constructs an apfloat from the specified <code>float</code>.
+     * The default radix will be used. The precision of the number
+     * will be the precision of a <code>float</code> in the default
+     * radix, for example in radix 10 the precision is 7 digits.
+     *
+     * @param value The value of the number.
+     *
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     */
+
+    public Apfloat(float value)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(value));
+    }
+
+    /**
+     * Constructs an apfloat from the specified <code>float</code>
+     * and precision. The default radix will be used.
+     *
+     * @param value The value of the number.
+     * @param precision The precision of the number.
+     *
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     * @exception java.lang.IllegalArgumentException In case the precision is invalid.
+     */
+
+    public Apfloat(float value, long precision)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(value, precision));
+    }
+
+    /**
+     * Constructs an apfloat from the specified <code>float</code>,
+     * precision and radix.
+     *
+     * @param value The value of the number.
+     * @param precision The precision of the number.
+     * @param radix The radix of the number.
+     *
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     * @exception java.lang.IllegalArgumentException In case the precision is invalid.
+     */
+
+    public Apfloat(float value, long precision, int radix)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(value, precision, radix));
+    }
+
+    /**
+     * Constructs an apfloat from the specified <code>double</code>.
+     * The default radix will be used. The precision of the number
+     * will be the precision of a <code>double</code> in the default
+     * radix, for example in radix 10 the precision is 16 digits.
+     *
+     * @param value The value of the number.
+     *
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     */
+
+    public Apfloat(double value)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(value));
+    }
+
+    /**
+     * Constructs an apfloat from the specified <code>double</code>
+     * and precision. The default radix will be used.
+     *
+     * @param value The value of the number.
+     * @param precision The precision of the number.
+     *
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     * @exception java.lang.IllegalArgumentException In case the precision is invalid.
+     */
+
+    public Apfloat(double value, long precision)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(value, precision));
+    }
+
+    /**
+     * Constructs an apfloat from the specified <code>double</code>,
+     * precision and radix.
+     *
+     * @param value The value of the number.
+     * @param precision The precision of the number.
+     * @param radix The radix of the number.
+     *
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     * @exception java.lang.IllegalArgumentException In case the precision is invalid.
+     */
+
+    public Apfloat(double value, long precision, int radix)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(value, precision, radix));
+    }
+
+    /**
+     * Reads an apfloat from a stream using default precision and radix.
+     * The stream needs to be a <code>PushbackReader</code>,
+     * as the first invalid character is pushed back to the stream.<p>
+     *
+     * Note that since only a pushback buffer of one character is used,
+     * the number read may still not be valid. For example, if the stream
+     * contains <code>"-#"</code> or <code>"1.5e#"</code> (here <code>'#'</code>
+     * is the first invalid character), the number is actually not valid, and
+     * only the character <code>'#'</code> would be put back to the stream.<p>
+     *
+     * The precision is determined similarly as in the {@link #Apfloat(String)}
+     * constructor that is as the number of digits read from the stream.
+     *
+     * @param in The stream to read from
+     *
+     * @exception java.io.IOException If an I/O error occurs accessing the stream.
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public Apfloat(PushbackReader in)
+        throws IOException, NumberFormatException, ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(in, false));
+    }
+
+    /**
+     * Reads an apfloat from a stream using the specified precision.
+     * The default radix is used.
+     *
+     * @param in The stream to read from
+     * @param precision The precision of the number.
+     *
+     * @exception java.io.IOException If an I/O error occurs accessing the stream.
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     * @exception java.lang.IllegalArgumentException In case the precision is invalid.
+     *
+     * @see #Apfloat(PushbackReader)
+     */
+
+    public Apfloat(PushbackReader in, long precision)
+        throws IOException, NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(in, precision, false));
+    }
+
+    /**
+     * Reads an apfloat from a stream using the specified precision
+     * and radix.
+     *
+     * @param in The stream to read from
+     * @param precision The precision of the number.
+     * @param radix The radix of the number.
+     *
+     * @exception java.io.IOException If an I/O error occurs accessing the stream.
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     * @exception java.lang.IllegalArgumentException In case the precision is invalid.
+     *
+     * @see #Apfloat(PushbackReader)
+     */
+
+    public Apfloat(PushbackReader in, long precision, int radix)
+        throws IOException, NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(in, precision, radix, false));
+    }
+
+    /**
+     * Constructs an apfloat from a <code>BigInteger</code>.
+     * Precision will be {@link #INFINITE} and the default radix
+     * is used.
+     *
+     * @param value The value of the number.
+     *
+     * @exception java.lang.NumberFormatException If the default radix is not valid.
+     */
+
+    public Apfloat(BigInteger value)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(value));
+    }
+
+    /**
+     * Constructs an apfloat from a <code>BigInteger</code> with
+     * the specified precision. The default radix is used.
+     *
+     * @param value The value of the number.
+     * @param precision The precision of the number.
+     *
+     * @exception java.lang.NumberFormatException If the default radix is not valid.
+     * @exception java.lang.IllegalArgumentException In case the precision is invalid.
+     */
+
+    public Apfloat(BigInteger value, long precision)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(value, precision));
+    }
+
+    /**
+     * Constructs an apfloat from a <code>BigInteger</code> with
+     * the specified precision and radix.
+     *
+     * @param value The value of the number.
+     * @param precision The precision of the number.
+     * @param radix The radix of the number.
+     *
+     * @exception java.lang.NumberFormatException If the radix is not valid.
+     * @exception java.lang.IllegalArgumentException In case the precision is invalid.
+     */
+
+    public Apfloat(BigInteger value, long precision, int radix)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(value, precision, radix));
+    }
+
+    /**
+     * Creates an apfloat from a <code>BigDecimal</code>. An apfloat created this
+     * way will always have radix 10 regardless of the current default radix.
+     *
+     * @param value The value to use.
+     */
+
+    public Apfloat(BigDecimal value)
+        throws ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(value));
+    }
+
+    /**
+     * Creates an apfloat from a <code>BigDecimal</code>. An apfloat created this
+     * way will always have radix 10 regardless of the current default radix.
+     *
+     * @param value The value to use.
+     * @param precision The precision to use, in decimal digits.
+     *
+     * @exception java.lang.IllegalArgumentException In case the precision is invalid.
+     */
+
+    public Apfloat(BigDecimal value, long precision)
+        throws IllegalArgumentException, ApfloatRuntimeException
+    {
+        this(ApfloatHelper.createApfloat(value, precision));
+    }
+
+    /**
+     * Radix of this apfloat.
+     *
+     * @return Radix of this apfloat.
+     */
+
+    public int radix()
+    {
+        return this.impl.radix();
+    }
+
+    /**
+     * Real part of this apfloat.
+     *
+     * @return <code>this</code>
+     */
+
+    public Apfloat real()
+    {
+        return this;
+    }
+
+    /**
+     * Imaginary part of this apfloat.
+     *
+     * @return {@link #ZERO}
+     */
+
+    public Apfloat imag()
+    {
+        return Apfloat.ZERO;
+    }
+
+    /**
+     * Returns the precision of this apfloat.
+     *
+     * @return The precision of this apfloat in number of digits of the radix in which it's presented.
+     */
+
+    public long precision()
+        throws ApfloatRuntimeException
+    {
+        return this.impl.precision();
+    }
+
+    /**
+     * Returns an apfloat with the same value as this apfloat accurate to the
+     * specified precision.<p>
+     *
+     * If the requested precision less than this number's current precision, the
+     * functionality is quite obvious: the precision is simply truncated, and e.g.
+     * comparison and equality checking will work as expected. Some rounding errors
+     * in e.g. addition and subtraction may still occur, as "invisible" trailing
+     * digits can remain in the number.<p>
+     *
+     * If the requested precision more than this number's current precision, the
+     * functionality is quite undefined: the digits up to this number's current
+     * precision are guaranteed to be the same, but the "new" digits are undefined:
+     * they may be zero, or they may be digits that have been previously discarded
+     * with a call to precision() with a smaller number of digits, or they may be
+     * something else, or any combination of these.<p>
+     *
+     * These limitations allow various performance optimizations to be made.
+     *
+     * @param precision Precision of the new apfloat.
+     *
+     * @return An apfloat with the specified precision and same value as this apfloat.
+     *
+     * @exception java.lang.IllegalArgumentException If <code>precision</code> is &lt;= 0.
+     */
+
+    public Apfloat precision(long precision)
+        throws IllegalArgumentException, ApfloatRuntimeException
+    {
+        ApfloatHelper.checkPrecision(precision);
+
+        return new Apfloat(getImpl(precision));
+    }
+
+    /**
+     * Returns the scale of this apfloat. The scale is defined here as<p>
+     *
+     * <code>apfloat = signum * mantissa * radix<sup>scale</sup></code><p>
+     *
+     * where 1/radix &lt;= mantissa &lt; 1. In other words,
+     * <code>scale&nbsp;=&nbsp;floor(log<sub>radix</sub>(apfloat))&nbsp;+&nbsp;1</code>.<p>
+     *
+     * For example, 1 has a scale of 1, and 100 has a scale of 3 (in radix 10).
+     * For integers, scale is equal to the number of digits in the apfloat.<p>
+     *
+     * Zero has a scale of <code>-INFINITE</code>.<p>
+     *
+     * Note that this definition of <code>scale</code> is different than in <code>java.math.BigDecimal</code>.
+     *
+     * @return The exponent of this apfloat in number of digits of the radix in which it's presented.
+     */
+
+    public long scale()
+        throws ApfloatRuntimeException
+    {
+        if (signum() == 0)
+        {
+            return -INFINITE;
+        }
+        else
+        {
+            return this.impl.scale();
+        }
+    }
+
+    /**
+     * Returns the size of this apfloat. The size is defined here as<p>
+     *
+     * <code>apfloat = signum * mantissa * radix<sup>scale</sup></code> and<p>
+     * <code>mantissa = n / radix<sup>size</sup></code><p>
+     *
+     * where 1/radix &lt;= mantissa &lt; 1 and n is the smallest possible integer.
+     * In other words, the size is the number of significant digits in the
+     * mantissa (excluding leading and trailing zeros but including all zeros
+     * between the first and last nonzero digit).
+     *
+     * For example, 1 has a size of 1, and 100 has also a size of 1 (in radix 10).
+     * 11 has a size of 2, and 10001000 has a size of 5.<p>
+     *
+     * Zero has a size of <code>0</code>.
+     *
+     * @return The number of digits in this number, from the most significant digit to the least significant nonzero digit, in the radix in which it's presented.
+     *
+     * @since 1.6
+     */
+
+    public long size()
+        throws ApfloatRuntimeException
+    {
+        if (signum() == 0)
+        {
+            return 0;
+        }
+        else
+        {
+            return this.impl.size();
+        }
+    }
+
+    /**
+     * Returns the signum function of this apfloat.
+     *
+     * @return -1, 0 or 1 as the value of this apfloat is negative, zero or positive, correspondingly.
+     */
+
+    public int signum()
+    {
+        return this.impl.signum();
+    }
+
+    /**
+     * Returns if this apfloat is "short". In practice an apfloat is "short" if its
+     * mantissa fits in one machine word. If the apfloat is "short", some algorithms
+     * can be performed faster.<p>
+     *
+     * For example, division by a "short" apfloat requires only a single pass through
+     * the data, but that algorithm can't be used for divisors that aren't "short",
+     * where calculating an inverse root is required instead.<p>
+     *
+     * The return value of this method is implementation dependent.
+     *
+     * @return <code>true</code> if the apfloat is "short", <code>false</code> if not.
+     */
+
+    public boolean isShort()
+        throws ApfloatRuntimeException
+    {
+        return this.impl.isShort();
+    }
+
+    /**
+     * Negative value.
+     *
+     * @return <code>-this</code>.
+     *
+     * @since 1.1
+     */
+
+    public Apfloat negate()
+        throws ApfloatRuntimeException
+    {
+        return new Apfloat(this.impl.negate());
+    }
+
+    /**
+     * Adds two apfloats.
+     *
+     * @param x The number to be added to this number.
+     *
+     * @return <code>this + x</code>.
+     */
+
+    public Apfloat add(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        if (x.signum() == 0)
+        {
+            // x + 0 = x
+            return this;
+        }
+        else if (signum() == 0)
+        {
+            // 0 + x = x
+            return x;
+        }
+
+        return addOrSubtract(x, false);
+    }
+
+    /**
+     * Subtracts two apfloats.
+     *
+     * @param x The number to be subtracted from this number.
+     *
+     * @return <code>this - x</code>.
+     */
+
+    public Apfloat subtract(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        if (x.signum() == 0)
+        {
+            // x - 0 = x
+            return this;
+        }
+        else if (signum() == 0)
+        {
+            ApfloatImpl impl = x.getImpl();
+            impl = impl.negate();
+
+            return new Apfloat(impl);
+        }
+
+        return addOrSubtract(x, true);
+    }
+
+    private Apfloat addOrSubtract(Apfloat x, boolean subtract)
+        throws ApfloatRuntimeException
+    {
+        long[] precisions = ApfloatHelper.getMatchingPrecisions(this, x);
+        ApfloatImpl impl;
+
+        if (precisions[0] == 0)
+        {
+            impl = x.getImpl(precisions[1]);
+            if (subtract)
+            {
+                impl = impl.negate();
+            }
+        }
+        else if (precisions[1] == 0)
+        {
+            impl = getImpl(precisions[0]);
+        }
+        else
+        {
+            impl = getImpl(precisions[0]);
+            ApfloatImpl xImpl = x.getImpl(precisions[1]);
+            impl = impl.addOrSubtract(xImpl, subtract);
+        }
+
+        return new Apfloat(impl);
+    }
+
+    /**
+     * Multiplies two apfloats.
+     *
+     * @param x The number to be multiplied by this number.
+     *
+     * @return <code>this * x</code>.
+     */
+
+    public Apfloat multiply(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        if (signum() == 0)
+        {
+            // 0 * x = 0
+            return this;
+        }
+        else if (x.signum() == 0)
+        {
+            // x * 0 = 0
+            return x;
+        }
+        else if (equals(ONE))
+        {
+            // 1 * x = x
+            return x.precision(Math.min(precision(), x.precision()));
+        }
+        else if (x.equals(ONE))
+        {
+            // x * 1 = x
+            return precision(Math.min(precision(), x.precision()));
+        }
+
+        long targetPrecision = Math.min(precision(),
+                                        x.precision());
+
+        ApfloatImpl thisImpl = getImpl(targetPrecision),
+                    xImpl = x.getImpl(targetPrecision),
+                    impl = thisImpl.multiply(xImpl);
+
+        return new Apfloat(impl);
+    }
+
+    /**
+     * Divides two apfloats.
+     *
+     * @param x The number by which this number is to be divided.
+     *
+     * @return <code>this / x</code>.
+     *
+     * @exception java.lang.ArithmeticException In case the divisor is zero.
+     */
+
+    public Apfloat divide(Apfloat x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (x.signum() == 0)
+        {
+            throw new ArithmeticException(signum() == 0 ? "Zero divided by zero" : "Division by zero");
+        }
+        else if (signum() == 0)
+        {
+            // 0 / x = 0
+            return this;
+        }
+        else if (x.equals(ONE))
+        {
+            // x / 1 = x
+            return precision(Math.min(precision(), x.precision()));
+        }
+
+        long targetPrecision = Math.min(precision(),
+                                        x.precision());
+
+        if (x.isShort())
+        {
+            ApfloatImpl thisImpl = getImpl(targetPrecision),
+                        xImpl = x.getImpl(targetPrecision),
+                        impl = thisImpl.divideShort(xImpl);
+
+            return new Apfloat(impl);
+        }
+        else
+        {
+            Apfloat inverse = ApfloatMath.inverseRoot(x, 1, targetPrecision);
+            return multiply(inverse);
+        }
+    }
+
+    /**
+     * Calculates the remainder when divided by an apfloat.
+     * The result has the same sign as this number.
+     * If <code>x</code> is zero, then zero is returned.
+     *
+     * @param x The number that is used as the divisor in the remainder calculation.
+     *
+     * @return <code>this % x</code>.
+     *
+     * @see ApfloatMath#fmod(Apfloat,Apfloat)
+     *
+     * @since 1.2
+     */
+
+    public Apfloat mod(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return ApfloatMath.fmod(this, x);
+    }
+
+    /**
+     * Floor function. Returns the largest (closest to positive infinity) value
+     * that is not greater than this apfloat and is equal to a mathematical integer.
+     *
+     * @return This apfloat rounded towards negative infinity.
+     */
+
+    public Apint floor()
+        throws ApfloatRuntimeException
+    {
+        if (signum() >= 0)
+        {
+            return new Apint(new Apfloat(this.impl.absFloor()));
+        }
+        else
+        {
+            return new Apint(new Apfloat(this.impl.absCeil()));
+        }
+    }
+
+    /**
+     * Ceiling function. Returns the smallest (closest to negative infinity) value
+     * that is not less than this apfloat and is equal to a mathematical integer.
+     *
+     * @return This apfloat rounded towards positive infinity.
+     */
+
+    public Apint ceil()
+        throws ApfloatRuntimeException
+    {
+        if (signum() >= 0)
+        {
+            return new Apint(new Apfloat(this.impl.absCeil()));
+        }
+        else
+        {
+            return new Apint(new Apfloat(this.impl.absFloor()));
+        }
+    }
+
+    /**
+     * Truncates fractional part.
+     *
+     * @return This apfloat rounded towards zero.
+     */
+
+    public Apint truncate()
+        throws ApfloatRuntimeException
+    {
+        return new Apint(new Apfloat(this.impl.absFloor()));
+    }
+
+    /**
+     * Returns the fractional part. The fractional part is always <code>0 &lt;= abs(frac()) &lt; 1</code>.
+     * The fractional part has the same sign as the number. For the fractional and integer parts, this always holds:<p>
+     *
+     * <code>x = x.truncate() + x.frac()</code>
+     *
+     * @return The fractional part of this apfloat.
+     *
+     * @since 1.7.0
+     */
+
+    public Apfloat frac()
+        throws ApfloatRuntimeException
+    {
+        return new Apfloat(this.impl.frac());
+    }
+
+    /**
+     * Returns the value of the this number as a <code>double</code>.
+     * If the number is too big to fit in a <code>double</code>,
+     * <code>Double.POSITIVE_INFINITY</code> or
+     * <code>Double.NEGATIVE_INFINITY</code> is returned.
+     *
+     * @return The numeric value represented by this object after conversion to type <code>double</code>.
+     */
+
+    public double doubleValue()
+    {
+        int targetPrecision = ApfloatHelper.getDoublePrecision(radix());
+        ApfloatImpl impl = getImpl(targetPrecision);
+
+        return impl.doubleValue();
+    }
+
+    /**
+     * Returns the value of the this number as a <code>float</code>.
+     * If the number is too big to fit in a <code>float</code>,
+     * <code>Float.POSITIVE_INFINITY</code> or
+     * <code>Float.NEGATIVE_INFINITY</code> is returned.
+     *
+     * @return The numeric value represented by this object after conversion to type <code>float</code>.
+     */
+
+    public float floatValue()
+    {
+        return (float) doubleValue();
+    }
+
+    /**
+     * Returns the value of the this number as a <code>byte</code>.
+     * If the number is too big to fit in a <code>byte</code>,
+     * <code>Byte.MIN_VALUE</code> or
+     * <code>Byte.MAX_VALUE</code> is returned.
+     *
+     * @return The numeric value represented by this object after conversion to type <code>byte</code>.
+     */
+
+    public byte byteValue()
+    {
+        long longValue = longValue();
+        return (byte) Math.min(Math.max(longValue, Byte.MIN_VALUE), Byte.MAX_VALUE);
+    }
+
+    /**
+     * Returns the value of the this number as a <code>short</code>.
+     * If the number is too big to fit in a <code>short</code>,
+     * <code>Short.MIN_VALUE</code> or
+     * <code>Short.MAX_VALUE</code> is returned.
+     *
+     * @return The numeric value represented by this object after conversion to type <code>short</code>.
+     */
+
+    public short shortValue()
+    {
+        long longValue = longValue();
+        return (short) Math.min(Math.max(longValue, Short.MIN_VALUE), Short.MAX_VALUE);
+    }
+
+    /**
+     * Returns the value of the this number as an <code>int</code>.
+     * If the number is too big to fit in an <code>int</code>,
+     * <code>Integer.MIN_VALUE</code> or
+     * <code>Integer.MAX_VALUE</code> is returned.
+     *
+     * @return The numeric value represented by this object after conversion to type <code>int</code>.
+     */
+
+    public int intValue()
+    {
+        long longValue = longValue();
+        return (int) Math.min(Math.max(longValue, Integer.MIN_VALUE), Integer.MAX_VALUE);
+    }
+
+    /**
+     * Returns the value of the this number as a <code>long</code>.
+     * If the number is too big to fit in a <code>long</code>,
+     * <code>Long.MIN_VALUE</code> or
+     * <code>Long.MAX_VALUE</code> is returned.
+     *
+     * @return The numeric value represented by this object after conversion to type <code>long</code>.
+     */
+
+    public long longValue()
+    {
+        int targetPrecision = ApfloatHelper.getLongPrecision(radix());
+        ApfloatImpl impl = getImpl(targetPrecision);
+
+        return impl.longValue();
+    }
+
+    /**
+     * Computes number of equal digits.<p>
+     *
+     * Compares the digits of the numbers starting from the
+     * most significant digits. The exponent and sign are
+     * taken into consideration, so if either one doesn't match,
+     * the numbers are considered to have zero equal digits.<p>
+     *
+     * For example, the numbers 12345 and 123456 have zero
+     * matching digits, and the numbers 12345 and 12355 have
+     * three matching digits.<p>
+     *
+     * The result of this method is roughly equal to
+     * <code>Math.min(scale(), x.scale()) - subtract(x).scale()</code>
+     * but it typically is a lot more efficient to execute.
+     *
+     * @param x Number to compare with.
+     *
+     * @return Number of matching digits in the radix in which the numbers are presented.
+     */
+
+    public long equalDigits(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        long targetPrecision = Math.min(precision(),
+                                        x.precision());
+        ApfloatImpl thisImpl = getImpl(targetPrecision),
+                    xImpl = x.getImpl(targetPrecision);
+
+        return thisImpl.equalDigits(xImpl);
+    }
+
+    /**
+     * Convert this apfloat to the specified radix.
+     *
+     * @param radix The radix.
+     *
+     * @exception java.lang.NumberFormatException If the radix is invalid.
+     *
+     * @since 1.2
+     */
+
+    public Apfloat toRadix(int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        return RadixConversionHelper.toRadix(this, radix);
+    }
+
+    /**
+     * Compare this apfloat to the specified apfloat.<p>
+     *
+     * Note: if two apfloats are compared where one number doesn't have enough
+     * precise digits, the mantissa is assumed to contain zeros. For example:
+     *
+     * <pre>
+     * Apfloat x = new Apfloat("0.12", 2);
+     * Apfloat y = new Apfloat("0.12345", 5);
+     * </pre>
+     *
+     * Now <code>x.compareTo(y) &lt; 0</code> because <code>x</code> is assumed to
+     * be <code>0.12000</code>.<p>
+     *
+     * However, <code>new Apfloat("0.12", 2)</code> and <code>new Apfloat("0.12", 5)</code>
+     * would be considered equal.
+     *
+     * @param x Apfloat to which this apfloat is to be compared.
+     *
+     * @return -1, 0 or 1 as this apfloat is numerically less than, equal to, or greater than <code>x</code>.
+     */
+
+    public int compareTo(Apfloat x)
+    {
+        if (x.preferCompare(this))
+        {
+            // Special handling of aprationals
+            return -x.compareTo(this);
+        }
+        else
+        {
+            // Compare with maximum available precision; would not be efficient with aprationals
+            return getImpl().compareTo(x.getImpl());
+        }
+    }
+
+    /**
+     * Tests if the comparison with <code>equals</code> and <code>compareTo</code> should be done in the opposite order.<p>
+     *
+     * Implementations should avoid infinite recursion.
+     *
+     * @param x The number to compare to.
+     *
+     * @return <code>true</code> if this object should invoke <code>x.equals(this)</code> and <code>-x.compareTo(this)</code> instead of comparing normally.
+     *
+     * @since 1.7.0
+     */
+
+    public boolean preferCompare(Apfloat x)
+    {
+        return false;
+    }
+
+    /**
+     * Compares this object to the specified object.<p>
+     *
+     * Note: if two apfloats are compared where one number doesn't have enough
+     * precise digits, the mantissa is assumed to contain zeros.
+     * See {@link #compareTo(Apfloat)}.
+     *
+     * @param obj The object to compare with.
+     *
+     * @return <code>true</code> if the objects are equal; <code>false</code> otherwise.
+     */
+
+    public boolean equals(Object obj)
+    {
+        if (obj == this)
+        {
+            return true;
+        }
+        else if (obj instanceof Apfloat)
+        {
+            Apfloat x = (Apfloat) obj;
+            if (x.preferCompare(this))
+            {
+                // Special handling of aprationals
+                return x.equals(this);
+            }
+            return getImpl().equals(x.getImpl());
+        }
+        else
+        {
+            return super.equals(obj);
+        }
+    }
+
+    /**
+     * Returns a hash code for this apfloat.
+     *
+     * @return The hash code value for this object.
+     */
+
+    public int hashCode()
+    {
+        return this.impl.hashCode();
+    }
+
+    /**
+     * Returns a string representation of this apfloat.
+     *
+     * @param pretty <code>true</code> to use a fixed-point notation, <code>false</code> to use an exponential notation.
+     *
+     * @return A string representing this object.
+     */
+
+    public String toString(boolean pretty)
+        throws ApfloatRuntimeException
+    {
+        return this.impl.toString(pretty);
+    }
+
+    /**
+     * Write a string representation of this apfloat to a <code>Writer</code>.
+     *
+     * @param out The output <code>Writer</code>.
+     * @param pretty <code>true</code> to use a fixed-point notation, <code>false</code> to use an exponential notation.
+     *
+     * @exception java.io.IOException In case of I/O error writing to the stream.
+     */
+
+    public void writeTo(Writer out, boolean pretty)
+        throws IOException, ApfloatRuntimeException
+    {
+        this.impl.writeTo(out, pretty);
+    }
+
+    /**
+     * Formats the object using the provided formatter.<p>
+     *
+     * The format specifiers affect the output as follows:
+     * <ul>
+     *   <li>By default, the exponential notation is used.</li>
+     *   <li>If the alternate format is specified (<code>'#'</code>), then the fixed-point notation is used.</li>
+     *   <li>Width is the minimum number of characters output. Any padding is done using spaces. Padding is on the left by default.</li>
+     *   <li>If the <code>'-'</code> flag is specified, then the padding will be on the right.</li>
+     *   <li>The precision is the number of significant digts output. If the precision of the number exceeds the number of characters output, the rounding mode for output is undefined.</li>
+     * </ul>
+     * <p>
+     *
+     * The decimal separator will be localized if the formatter specifies a locale.
+     * The digits will be localized also, but only if the radix is less than or equal to 10.
+     *
+     * @param formatter The formatter.
+     * @param flags The flags to modify the output format.
+     * @param width The minimum number of characters to be written to the output, or <code>-1</code> for no minimum.
+     * @param precision The maximum number of characters to be written to the output, or <code>-1</code> for no maximum.
+     *
+     * @since 1.3
+     */
+
+    public void formatTo(Formatter formatter, int flags, int width, int precision)
+    {
+        Apfloat x = (precision == -1 ? this : ApfloatHelper.limitPrecision(this, precision));
+        try
+        {
+            Writer out = FormattingHelper.wrapAppendableWriter(formatter.out());
+            out = FormattingHelper.wrapLocalizeWriter(out, formatter, radix(), (flags & UPPERCASE) == UPPERCASE);
+            if (width == -1)
+            {
+                x.writeTo(out, (flags & ALTERNATE) == ALTERNATE);
+            }
+            else
+            {
+                out = FormattingHelper.wrapPadWriter(out, (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY);
+                x.writeTo(out, (flags & ALTERNATE) == ALTERNATE);
+                FormattingHelper.finishPad(out, width);
+            }
+        }
+        catch (IOException ioe)
+        {
+            // Ignore as we can't propagate it; unfortunately we can't set it to the formattable either
+        }
+    }
+
+    /**
+     * Returns an <code>ApfloatImpl</code> representing the actual instance
+     * of this apfloat up to the requested precision.<p>
+     *
+     * For apfloats this is simply the underlying <code>ApfloatImpl</code>,
+     * but e.g. the {@link Aprational} class implements this so that
+     * it only returns an approximation of the rational number.
+     *
+     * @param precision Precision of the <code>ApfloatImpl</code> that is needed.
+     *
+     * @return An <code>ApfloatImpl</code> representing this object to the requested precision.
+     */
+
+    protected ApfloatImpl getImpl(long precision)
+        throws ApfloatRuntimeException
+    {
+        if (precision == precision())
+        {
+            return this.impl;
+        }
+        else
+        {
+            return this.impl.precision(precision);
+        }
+    }
+
+    // Round away from zero i.e. opposite direction of rounding than in truncate()
+    Apint roundAway()
+        throws ApfloatRuntimeException
+    {
+        return new Apint(new Apfloat(this.impl.absCeil()));
+    }
+
+    Apfloat scale(long scale)
+    {
+        return ApfloatMath.scale(this, scale);
+    }
+
+    Apfloat abs()
+    {
+        return ApfloatMath.abs(this);
+    }
+
+    int compareToHalf()
+    {
+        return RoundingHelper.compareToHalf(this);
+    }
+
+    private ApfloatImpl getImpl()
+        throws ApfloatRuntimeException
+    {
+        long precision = precision();
+        return getImpl(precision);
+    }
+
+    private static final long serialVersionUID = -36707433458144439L;
+
+    private ApfloatImpl impl;
+}
Index: src/main/java/org/apfloat/ApfloatConfigurationException.java
===================================================================
--- src/main/java/org/apfloat/ApfloatConfigurationException.java	(revision 0)
+++ src/main/java/org/apfloat/ApfloatConfigurationException.java	(revision 0)
@@ -0,0 +1,46 @@
+package org.apfloat;
+
+/**
+ * Exception indicating an error in the apfloat configuration.<p>
+ *
+ * @since 1.5
+ * @version 1.5
+ * @author Mikko Tommila
+ */
+
+public class ApfloatConfigurationException
+    extends ApfloatRuntimeException
+{
+    /**
+     * Constructs a new apfloat configuration exception with an empty detail message.
+     */
+
+    public ApfloatConfigurationException()
+    {
+    }
+
+    /**
+     * Constructs a new apfloat configuration exception with the specified detail message.
+     *
+     * @param message The detail message.
+     */
+
+    public ApfloatConfigurationException(String message)
+    {
+        super(message);
+    }
+
+    /**
+     * Constructs a new apfloat configuration exception with the specified detail message and cause.
+     *
+     * @param message The detail message.
+     * @param cause Originating cause of the exception.
+     */
+
+    public ApfloatConfigurationException(String message, Throwable cause)
+    {
+        super(message, cause);
+    }
+
+    private static final long serialVersionUID = -7022924635011038776L;
+}
Index: src/main/java/org/apfloat/ApfloatContext.java
===================================================================
--- src/main/java/org/apfloat/ApfloatContext.java	(revision 0)
+++ src/main/java/org/apfloat/ApfloatContext.java	(revision 0)
@@ -0,0 +1,1340 @@
+package org.apfloat;
+
+import java.lang.management.ManagementFactory;
+import java.lang.management.MemoryMXBean;
+import java.lang.management.MemoryUsage;
+import java.util.Enumeration;
+import java.util.Map;
+import java.util.Properties;
+import java.util.ResourceBundle;
+import java.util.MissingResourceException;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import org.apfloat.spi.BuilderFactory;
+import org.apfloat.spi.FilenameGenerator;
+import org.apfloat.spi.Util;
+
+/**
+ * This class encapsulates the information needed by the apfloat implementation
+ * to perform computations.<p>
+ *
+ * All environment related settings of an apfloat implementation are accessed
+ * through an <code>ApfloatContext</code>. Such settings include for example
+ * the implementation provider class, maximum memory size to be used, and
+ * the file names that are used for temporary files.<p>
+ *
+ * For performance reasons, access to an <code>ApfloatContext</code> is not
+ * synchronized. Presumably, this won't be a problem in most cases. But, if
+ * the code needs to concurrently modify and access an ApfloatContext, all
+ * access to it should be externally synchronized.<p>
+ *
+ * At simplest, there is just one <code>ApfloatContext</code>, the global
+ * apfloat context. All settings in your application are retrieved through
+ * it. The global context is created when the <code>ApfloatContext</code>
+ * class is loaded, and it's thus always available.<p>
+ *
+ * Values for the different settings in the global apfloat context are specified
+ * in the <code>apfloat.properties</code> file, found in the class path. Since
+ * they are loaded via a <code>ResourceBundle</code> named "apfloat", you can
+ * alternatively deploy a <code>ResourceBundle</code> class named "apfloat" in
+ * your class path to avoid having a .properties file, or to define properties
+ * dynamically at run time.<p>
+ *
+ * The different settings that can be specified in the <code>apfloat.properties</code>
+ * file are as follows:
+ *
+ * <ul>
+ *   <li><code>builderFactory</code>, name of the class set as in {@link #setBuilderFactory(BuilderFactory)}</li>
+ *   <li><code>defaultRadix</code>, set as in {@link #setDefaultRadix(int)}</li>
+ *   <li><code>maxMemoryBlockSize</code>, set as in {@link #setMaxMemoryBlockSize(long)}</li>
+ *   <li><code>cacheL1Size</code>, set as in {@link #setCacheL1Size(int)}</li>
+ *   <li><code>cacheL2Size</code>, set as in {@link #setCacheL2Size(int)}</li>
+ *   <li><code>cacheBurst</code>, set as in {@link #setCacheBurst(int)}</li>
+ *   <li><code>memoryThreshold</code>, set as in {@link #setMemoryThreshold(long)}</li>
+ *   <li><code>shredMemoryTreshold</code>, set as in {@link #setSharedMemoryTreshold(long)}</li>
+ *   <li><code>blockSize</code>, set as in {@link #setBlockSize(int)}</li>
+ *   <li><code>numberOfProcessors</code>, set as in {@link #setNumberOfProcessors(int)}</li>
+ *   <li><code>filePath</code>, set as in {@link #setProperty(String,String)} with property name {@link #FILE_PATH}</li>
+ *   <li><code>fileInitialValue</code>, set as in {@link #setProperty(String,String)} with property name {@link #FILE_INITIAL_VALUE}</li>
+ *   <li><code>fileSuffix</code>, set as in {@link #setProperty(String,String)} with property name {@link #FILE_SUFFIX}</li>
+ *   <li><code>cleanupAtExit</code>, set as in {@link #setCleanupAtExit(boolean)}</li>
+ * </ul>
+ * <p>
+ *
+ * An example <code>apfloat.properties</code> file could contain the following:
+ *
+ * <pre>
+ * builderFactory=org.apfloat.internal.IntBuilderFactory
+ * defaultRadix=10
+ * maxMemoryBlockSize=50331648
+ * cacheL1Size=8192
+ * cacheL2Size=262144
+ * cacheBurst=32
+ * memoryThreshold=65536
+ * sharedMemoryTreshold=65536
+ * blockSize=65536
+ * numberOfProcessors=1
+ * filePath=
+ * fileInitialValue=0
+ * fileSuffix=.ap
+ * cleanupAtExit=true
+ * </pre>
+ *
+ * The total memory size and the number of processors are detected automatically,
+ * as reported by the Java runtime, if they are not specified in the configuration
+ * bundle.<p>
+ *
+ * If you need to create a complex multithreaded application that performs
+ * apfloat calculations in parallel using multiple threads, you may need to
+ * change the ApfloatContext settings for the different working threads.<p>
+ *
+ * If thread-specific apfloat contexts are not specified, all threads will use
+ * the global context. To set a thread specific context, you would typically
+ * create a {@link #clone()} of the global (or other parent) context, and then
+ * set that context to the thread using {@link #setThreadContext(ApfloatContext,Thread)}.
+ * Note that if you do not create a clone of the context, the same context will still
+ * be used, since it's passed by reference.<p>
+ *
+ * Typically you may need to set the following properties for each thread:
+ * <ul>
+ *   <li>{@link #setNumberOfProcessors(int)}: Since the number of physical
+ *       processors available is fixed, you may want to limit the amount
+ *       of processors each thread can use. In many cases you will want each
+ *       thread to use exactly one processor, and create as many threads as
+ *       there are processors.</li>
+ *   <li>{@link #setMaxMemoryBlockSize(long)}: The physical memory is global
+ *       and its amount is fixed as well. Since all threads share the global
+ *       memory, you may want to limit the maximum amount of memory each thread
+ *       can use. If you do this, you will probably just split the amount of
+ *       memory between the threads, e.g. by dividing it equally. In this case
+ *       you should set each thread to have a separate shared memory lock with
+ *       {@link #setSharedMemoryLock(Object)}. In this solution all threads can
+ *       allocate their maximum allowed memory block at the same time, and still
+ *       the VM won't run out of memory.<br>
+ *       Another possibility is to set the whole global memory size as the maximum
+ *       available for each thread, and use the same shared memory lock for every
+ *       thread. This is actually the default behavior, if you don't call
+ *       {@link #setMaxMemoryBlockSize(long)} nor {@link #setSharedMemoryLock(Object)}.
+ *       This way all threads can access the maximum amount of physical memory
+ *       available. The drawback is that the threads will synchronize on the
+ *       same memory block, so only one thread can use it at a time. This can
+ *       have a major effect on performance, if threads are idle, waiting to acquire
+ *       the shared memory lock for most of the time. To work around this, some
+ *       mechanism can be set up for pooling the threads competing for the same
+ *       lock, and executing the task using parallel threads from the thread pool.
+ *       For example the default apfloat multiplication algorithm uses such a
+ *       mechanism. Note that synchronization against the shared memory lock
+ *       will be used for all data blocks larger than the shared memory
+ *       treshold (see {@link #getSharedMemoryTreshold()}).</li>
+ *   <li>{@link #setFilenameGenerator(FilenameGenerator)}: When you clone an
+ *       ApfloatContext, the filename generator is by default shared. For most
+ *       situations this is fine. If you for some reason want to separate
+ *       the files generated in each thread, you can just set a new
+ *       FilenameGenerator for each thread. In this case it's essential to
+ *       configure the FilenameGenerators not to generate conflicting file
+ *       names. You can do this easily by specifying a different directory or
+ *       file suffix for each filename generator, or by specifying a different
+ *       starting value for the file names (e.g. 1000000, 2000000, 3000000, ...).<br>
+ *       Setting the filename generator may also be relevant, if you use a
+ *       distributed computing platform where separate physical machines (or
+ *       at least separate VM processes) create temporary files in the same
+ *       shared disk storage. In this case it's also essential to configure the
+ *       different processes so that they do not generate conflicting file names.</li>
+ * </ul>
+ * <p>
+ *
+ * The other settings are generally global and do not typically need to
+ * be set differently for each thread.<p>
+ *
+ * Unfortunately, Java doesn't allow detecting automatically many of the
+ * settings, such as cache sizes. Also, for optimal performance, it would
+ * usually be desirable to set each thread's processor affinity (which
+ * physical processor runs which thread), which is also not possible.
+ * If these features are added to the Java platform in the future, they
+ * may be added to the <code>ApfloatContext</code> API as well.
+ *
+ * @version 1.8.2
+ * @author Mikko Tommila
+ */
+
+public class ApfloatContext
+    implements Cloneable
+{
+    /**
+     * Property name for specifying the apfloat builder factory class.
+     */
+
+    public static final String BUILDER_FACTORY = "builderFactory";
+
+    /**
+     * Property name for specifying the default radix.
+     */
+
+    public static final String DEFAULT_RADIX = "defaultRadix";
+
+    /**
+     * Property name for specifying the maximum memory block size.
+     */
+
+    public static final String MAX_MEMORY_BLOCK_SIZE = "maxMemoryBlockSize";
+
+    /**
+     * Property name for specifying the level 1 cache size.
+     */
+
+    public static final String CACHE_L1_SIZE = "cacheL1Size";
+
+    /**
+     * Property name for specifying the level 2 cache size.
+     */
+
+    public static final String CACHE_L2_SIZE = "cacheL2Size";
+
+    /**
+     * Property name for specifying the level 1 cache burst size.
+     */
+
+    public static final String CACHE_BURST = "cacheBurst";
+
+    /**
+     * Property name for specifying the apfloat memory threshold.
+     */
+
+    public static final String MEMORY_THRESHOLD = "memoryThreshold";
+
+    /**
+     * Property name for specifying the apfloat memory threshold.
+     *
+     * @deprecated Use {@link #MEMORY_THRESHOLD}.
+     */
+
+    @Deprecated
+    public static final String MEMORY_TRESHOLD = "memoryTreshold";
+
+    /**
+     * Property name for specifying the apfloat shared memory threshold.
+     */
+
+    public static final String SHARED_MEMORY_TRESHOLD = "sharedMemoryTreshold";
+
+    /**
+     * Property name for specifying the I/O block size.
+     */
+
+    public static final String BLOCK_SIZE = "blockSize";
+
+    /**
+     * Property name for specifying the number of processors available.
+     */
+
+    public static final String NUMBER_OF_PROCESSORS = "numberOfProcessors";
+
+    /**
+     * Property name for specifying the temporary file path.
+     */
+
+    public static final String FILE_PATH = "filePath";
+
+    /**
+     * Property name for specifying the temporary file initial value.
+     */
+
+    public static final String FILE_INITIAL_VALUE = "fileInitialValue";
+
+    /**
+     * Property name for specifying the temporary file suffix.
+     */
+
+    public static final String FILE_SUFFIX = "fileSuffix";
+
+    /**
+     * Property name for specifying if clean-up should be done at program exit.
+     */
+
+    public static final String CLEANUP_AT_EXIT = "cleanupAtExit";
+
+    // At system exit, run garbage collection and finalization to clean up temporary files
+    private static class CleanupThread
+        extends Thread
+    {
+        public CleanupThread()
+        {
+            super("apfloat shutdown clean-up thread");
+        }
+
+        public void run()
+        {
+            ApfloatMath.cleanUp();      // Clear references to static cached apfloats
+            System.gc();
+            System.gc();
+            System.runFinalization();
+            this.builderFactory.shutdown();
+        }
+
+        public void setBuilderFactory(BuilderFactory builderFactory)
+        {
+            this.builderFactory = builderFactory;
+        }
+
+        private BuilderFactory builderFactory;
+    }
+
+    /**
+     * Create a new ApfloatContext using the specified properties.
+     *
+     * @param properties The properties for the ApfloatContext.
+     *
+     * @exception org.apfloat.ApfloatConfigurationException If a property value can't be converted to the correct type.
+     */
+
+    public ApfloatContext(Properties properties)
+        throws ApfloatConfigurationException
+    {
+        this.properties = (Properties) ApfloatContext.defaultProperties.clone();
+        this.properties.putAll(properties);
+
+        setProperties(this.properties);
+    }
+
+    /**
+     * Get the ApfloatContext for the calling thread. If a thread-specific
+     * context has not been specified, the global context is returned.
+     *
+     * @return The ApfloatContext for the calling thread.
+     */
+
+    public static ApfloatContext getContext()
+    {
+        ApfloatContext ctx = getThreadContext();
+
+        if (ctx == null)
+        {
+            ctx = getGlobalContext();
+        }
+
+        return ctx;
+    }
+
+    /**
+     * Get the global ApfloatContext.
+     *
+     * @return The global ApfloatContext.
+     */
+
+    public static ApfloatContext getGlobalContext()
+    {
+        return ApfloatContext.globalContext;
+    }
+
+    /**
+     * Get the thread-specific ApfloatContext for the calling thread.
+     *
+     * @return The ApfloatContext for the calling thread, or <code>null</code> if one has not been specified.
+     */
+
+    public static ApfloatContext getThreadContext()
+    {
+        // Quick check to improve performance
+        if (ApfloatContext.threadContexts.isEmpty())
+        {
+            return null;
+        }
+        return getThreadContext(Thread.currentThread());
+    }
+
+    /**
+     * Get the thread-specific ApfloatContext for the specified thread.
+     *
+     * @param thread The thread whose ApfloatContext is to be returned.
+     *
+     * @return The ApfloatContext for the specified thread, or <code>null</code> if one has not been specified.
+     */
+
+    public static ApfloatContext getThreadContext(Thread thread)
+    {
+        return ApfloatContext.threadContexts.get(thread);
+    }
+
+    /**
+     * Set the thread-specific ApfloatContext for the calling thread.
+     *
+     * @param threadContext The ApfloatContext for the calling thread.
+     */
+
+    public static void setThreadContext(ApfloatContext threadContext)
+    {
+        setThreadContext(threadContext, Thread.currentThread());
+    }
+
+    /**
+     * Set the thread-specific ApfloatContext for the specified thread.
+     *
+     * @param threadContext The ApfloatContext for the specified thread.
+     * @param thread The thread whose ApfloatContext is to be set.
+     */
+
+    public static void setThreadContext(ApfloatContext threadContext, Thread thread)
+    {
+        ApfloatContext.threadContexts.put(thread, threadContext);
+    }
+
+    /**
+     * Removes the thread-specific context for the current thread.
+     */
+
+    public static void removeThreadContext()
+    {
+        removeThreadContext(Thread.currentThread());
+    }
+
+    /**
+     * Removes the thread-specific context for the specified thread.
+     *
+     * @param thread The thread whose ApfloatContext is to be removed.
+     */
+
+    public static void removeThreadContext(Thread thread)
+    {
+        ApfloatContext.threadContexts.remove(thread);
+    }
+
+    /**
+     * Removes all thread-specific ApfloatContexts.
+     */
+
+    public static void clearThreadContexts()
+    {
+        ApfloatContext.threadContexts.clear();
+    }
+
+    /**
+     * Get the BuilderFactory.
+     *
+     * @return The BuilderFactory for this ApfloatContext.
+     */
+
+    public BuilderFactory getBuilderFactory()
+    {
+        return this.builderFactory;
+    }
+
+    /**
+     * Set the BuilderFactory.
+     *
+     * @param builderFactory The BuilderFactory for this ApfloatContext.
+     */
+
+    public void setBuilderFactory(BuilderFactory builderFactory)
+    {
+        this.properties.setProperty(BUILDER_FACTORY, builderFactory.getClass().getName());
+        this.builderFactory = builderFactory;
+
+        if (this.cleanupThread != null)
+        {
+            this.cleanupThread.setBuilderFactory(builderFactory);
+        }
+
+    }
+
+    /**
+     * Get the FilenameGenerator.
+     *
+     * @return The FilenameGenerator for this ApfloatContext.
+     */
+
+    public FilenameGenerator getFilenameGenerator()
+    {
+        return this.filenameGenerator;
+    }
+
+    /**
+     * Set the FilenameGenerator.
+     *
+     * @param filenameGenerator The FilenameGenerator for this ApfloatContext.
+     */
+
+    public void setFilenameGenerator(FilenameGenerator filenameGenerator)
+    {
+        this.properties.setProperty(FILE_PATH, filenameGenerator.getPath());
+        this.properties.setProperty(FILE_INITIAL_VALUE, String.valueOf(filenameGenerator.getInitialValue()));
+        this.properties.setProperty(FILE_SUFFIX, filenameGenerator.getSuffix());
+        this.filenameGenerator = filenameGenerator;
+    }
+
+    /**
+     * Get the default radix.
+     *
+     * @return The default radix for this ApfloatContext.
+     */
+
+    public int getDefaultRadix()
+    {
+        return this.defaultRadix;
+    }
+
+    /**
+     * Set the default radix.
+     * The default value is 10.
+     *
+     * @param radix The default radix for this ApfloatContext.
+     */
+
+    public void setDefaultRadix(int radix)
+    {
+        radix = Math.min(Math.max(radix, Character.MIN_RADIX), Character.MAX_RADIX);
+        this.properties.setProperty(DEFAULT_RADIX, String.valueOf(radix));
+        this.defaultRadix = radix;
+    }
+
+    /**
+     * Get the maximum memory block size.
+     *
+     * @return The maximum memory block size.
+     *
+     * @see #setMaxMemoryBlockSize(long)
+     */
+
+    public long getMaxMemoryBlockSize()
+    {
+        return this.maxMemoryBlockSize;
+    }
+
+    /**
+     * Set the maximum allowed memory block size in bytes.
+     * Apfloat will allocate an array at most of this size
+     * for calculations using this context.
+     * The minimum value for this setting is 65536.<p>
+     *
+     * If you set the value of this parameter too low,
+     * performance will suffer greatly as data is unnecessarily
+     * paged to disk. If you set this value too high, your
+     * application can crash with an <code>OutOfMemoryError</code>.<p>
+     *
+     * The default value for this setting is 80% of the total memory
+     * available to the VM at application startup, as reported by
+     * <code>Runtime.totalMemory()</code>, rounded down to the nearest
+     * power of two or three times a power of two.
+     *
+     * @param maxMemoryBlockSize Maximum allocated memory block size in bytes.
+     */
+
+    public void setMaxMemoryBlockSize(long maxMemoryBlockSize)
+    {
+        // Note that setting the 64-bit long is not guaranteed to be atomic
+        // However on 32-bit JVMs the upper word is always zero, and on 64-bit JVMs the update is probably atomic
+        maxMemoryBlockSize = Util.round23down(Math.max(maxMemoryBlockSize, 65536));
+        this.properties.setProperty(MAX_MEMORY_BLOCK_SIZE, String.valueOf(maxMemoryBlockSize));
+        this.maxMemoryBlockSize = maxMemoryBlockSize;
+    }
+
+    /**
+     * Get the level 1 cache size.
+     *
+     * @return The level 1 cache size.
+     *
+     * @see #setCacheL1Size(int)
+     */
+
+    public int getCacheL1Size()
+    {
+        return this.cacheL1Size;
+    }
+
+    /**
+     * Set the L1 cache size in bytes. The minimum value for this setting is 512.<p>
+     *
+     * This setting has a minor performance impact on some memory
+     * intensive operations. Unless you really want to tweak the performance,
+     * it's better to not touch this setting.<p>
+     *
+     * The default value for this setting is 8kB.
+     *
+     * @param cacheL1Size The level 1 cache size in bytes.
+     */
+
+    public void setCacheL1Size(int cacheL1Size)
+    {
+        cacheL1Size = Util.round2down(Math.max(cacheL1Size, 512));
+        this.properties.setProperty(CACHE_L1_SIZE, String.valueOf(cacheL1Size));
+        this.cacheL1Size = cacheL1Size;
+    }
+
+    /**
+     * Get the level 2 cache size.
+     *
+     * @return The level 2 cache size.
+     *
+     * @see #setCacheL2Size(int)
+     */
+
+    public int getCacheL2Size()
+    {
+        return this.cacheL2Size;
+    }
+
+    /**
+     * Set the L2 cache size in bytes. The minimum value for this setting is 2048.
+     *
+     * This setting has a minor performance impact on some memory
+     * intensive operations. Unless you really want to tweak the performance,
+     * it's better to not touch this setting.<p>
+     *
+     * The default value for this setting is 256kB.
+     *
+     * @param cacheL2Size The level 2 cache size in bytes.
+     */
+
+    public void setCacheL2Size(int cacheL2Size)
+    {
+        cacheL2Size = Util.round2down(Math.max(cacheL2Size, 2048));
+        this.properties.setProperty(CACHE_L2_SIZE, String.valueOf(cacheL2Size));
+        this.cacheL2Size = cacheL2Size;
+    }
+
+    /**
+     * Get the level 1 cache burst size.
+     *
+     * @return The cache burst size.
+     *
+     * @see #setCacheBurst(int)
+     */
+
+    public int getCacheBurst()
+    {
+        return this.cacheBurst;
+    }
+
+    /**
+     * Set the L1 cache burst block size in bytes.
+     * This value is also known as "L1 cache line size".<p>
+     *
+     * Some common values are:
+     * <ul>
+     *   <li>16 for 486 processors</li>
+     *   <li>32 for Pentium MMX/II/III/Celeron series and Itanium processors</li>
+     *   <li>64 for Pentium 4 and Itanium 2 processors</li>
+     * </ul>
+     * The processor will move at least this amount of bytes
+     * whenever data is moved between the level 1 cache and
+     * other memory (lower level cache or main memory).
+     * Note that other cache levels than L1 may have a different
+     * line size. The minimum value for this setting is 8.<p>
+     *
+     * This setting has a minor performance impact on some memory
+     * intensive operations. Unless you really want to tweak the performance,
+     * it's usually better to not touch this setting. Though, if you have e.g.
+     * a Pentium 4 processor, you may want to increase the value
+     * of this setting to 64 from the default value of 32.
+     *
+     * @param cacheBurst The number of bytes in a L1 cache line.
+     */
+
+    public void setCacheBurst(int cacheBurst)
+    {
+        cacheBurst = Util.round2down(Math.max(cacheBurst, 8));
+        this.properties.setProperty(CACHE_BURST, String.valueOf(cacheBurst));
+        this.cacheBurst = cacheBurst;
+    }
+
+    /**
+     * Get the memory threshold.<p>
+     *
+     * If the value is larger than the maximum value that can be presented
+     * in an integer, then <code>Integer.MAX_VALUE</code> is returned.
+     *
+     * @return The memory threshold.
+     *
+     * @deprecated Use {@link #getMemoryThreshold()}.
+     */
+
+    @Deprecated
+    public int getMemoryTreshold()
+    {
+        return (int) Math.min(Integer.MAX_VALUE, getMemoryThreshold());
+    }
+
+    /**
+     * Set the maximum size of apfloats in bytes that are
+     * stored in memory within this context.
+     *
+     * @param memoryThreshold The number of bytes that apfloats that are stored in memory will at most have within this context.
+     *
+     * @deprecated Use {@link #setMemoryThreshold(long)}.
+     */
+
+    @Deprecated
+    public void setMemoryTreshold(int memoryThreshold)
+    {
+        setMemoryThreshold(memoryThreshold);
+    }
+
+    /**
+     * Get the memory threshold.
+     *
+     * @return The memory threshold.
+     */
+
+    public long getMemoryThreshold()
+    {
+        return this.memoryThreshold;
+    }
+
+    /**
+     * Set the maximum size of apfloats in bytes that are
+     * stored in memory within this context. The minimum value for this setting is 128.<p>
+     *
+     * If the memory threshold is too small, performance will suffer as
+     * small numbers are stored to disk, and the amount of disk I/O
+     * overhead becomes significant. On the other hand, if the memory
+     * treshold is too big, you can get an <code>OutOfMemoryError</code>.<p>
+     *
+     * The optimal value depends greatly on each application. Obviously,
+     * if you have plenty of heap space and don't create too many too big
+     * numbers you are not likely to have problems. The default value of
+     * this setting is 64kB, or the maximum heap size divided by 1024,
+     * whichever is larger.
+     *
+     * @param memoryThreshold The number of bytes that apfloats that are stored in memory will at most have within this context.
+     */
+
+    public void setMemoryThreshold(long memoryThreshold)
+    {
+        memoryThreshold = Math.max(memoryThreshold, 128);
+        this.properties.setProperty(MEMORY_TRESHOLD, String.valueOf(memoryThreshold));
+        this.properties.setProperty(MEMORY_THRESHOLD, String.valueOf(memoryThreshold));
+        this.memoryThreshold = memoryThreshold;
+    }
+
+    /**
+     * Get the shared memory treshold.
+     *
+     * @return The shared memory treshold.
+     *
+     * @see #setSharedMemoryTreshold(long)
+     */
+
+    public long getSharedMemoryTreshold()
+    {
+        return this.sharedMemoryTreshold;
+    }
+
+    /**
+     * Set the maximum size of apfloats in bytes that can be used
+     * without synchronizing against the shared memory lock.
+     * The minimum value for this setting is 128.<p>
+     *
+     * If only one thread is used then this setting has no effect.
+     * If multiple threads are used, and this setting is too small,
+     * performance will suffer as the synchronization blocking and
+     * other overhead becomes significant. On the other hand, if the
+     * numbers are being stored in memory, and the shared memory
+     * treshold is too big, you can get an <code>OutOfMemoryError</code>.<p>
+     *
+     * The optimal value depends on the application and the way parallelism
+     * is used. As a rule of thumb, this should be set to a value that is
+     * the maximum memory block size divided by the number of parallel threads.
+     * The default is somewhat more conservatively this number divided by 32.
+     *
+     * @param sharedMemoryTreshold The number of bytes that apfloats will at most have, without synchronizing against the shared memory lock, within this context.
+     */
+
+    public void setSharedMemoryTreshold(long sharedMemoryTreshold)
+    {
+        sharedMemoryTreshold = Math.max(sharedMemoryTreshold, 128);
+        this.properties.setProperty(SHARED_MEMORY_TRESHOLD, String.valueOf(sharedMemoryTreshold));
+        this.sharedMemoryTreshold = sharedMemoryTreshold;
+    }
+
+    /**
+     * Get the I/O block size.
+     *
+     * @return The I/O block size.
+     *
+     * @see #setBlockSize(int)
+     */
+
+    public int getBlockSize()
+    {
+        return this.blockSize;
+    }
+
+    /**
+     * Set the efficient I/O block size in bytes for
+     * this context. The minimum value for this setting is 128.<p>
+     *
+     * If the block size is too small, the overhead of each I/O call will
+     * definetely have an adverse effect on performance. Setting the block
+     * size very big will not affect performance significantly, but can
+     * increase intermediate memory consumption a lot, possibly resulting
+     * in running out of memory with an <code>OutOfMemoryError</code>. A
+     * recommended minimum value is at least a few kilobytes.<p>
+     *
+     * In many places, data in files is accessed in reverse order, fetching
+     * blocks of this size. Probably the optimal value of this setting is
+     * roughly half of the read-ahead buffer size of you hard disk.
+     * The default value is 64kB.
+     *
+     * @param blockSize The I/O block size in bytes to be used in calculations using this context.
+     */
+
+    public void setBlockSize(int blockSize)
+    {
+        blockSize = Util.round2down(Math.max(blockSize, 128));
+        this.properties.setProperty(BLOCK_SIZE, String.valueOf(blockSize));
+        this.blockSize = blockSize;
+    }
+
+    /**
+     * Get the number of processors that should be used for parallel calculations.
+     *
+     * @return The number of processors.
+     *
+     * @see #setNumberOfProcessors(int)
+     */
+
+    public int getNumberOfProcessors()
+    {
+        return this.numberOfProcessors;
+    }
+
+    /**
+     * Set the number of processors available to parallel calculations using
+     * this context. The minimum value for this setting is 1.
+     * The default is to use all processors (CPU cores) available.<p>
+     *
+     * Note that if you change the number of processors after the library has
+     * been initialized, the number of threads available to the ExecutorService
+     * is not changed. If you want to change that too, it can be done easily with
+     * <code>setExecutorService(ApfloatContext.getDefaultExecutorService())</code>.
+     *
+     * @param numberOfProcessors Number of processors available to parallel calculations using this context.
+     *
+     * @see #getDefaultExecutorService
+     *
+     * @see #setExecutorService(ExecutorService)
+     */
+
+    public void setNumberOfProcessors(int numberOfProcessors)
+    {
+        numberOfProcessors = Math.max(numberOfProcessors, 1);
+        this.properties.setProperty(NUMBER_OF_PROCESSORS, String.valueOf(numberOfProcessors));
+        this.numberOfProcessors = numberOfProcessors;
+    }
+
+    /**
+     * Get if clean-up should be performed at the time the program exits.
+     *
+     * @return <code>true</code> if clean-up will be done at JVM exit, or <code>false</code> if not.
+     *
+     * @see #setCleanupAtExit(boolean)
+     */
+
+    public boolean getCleanupAtExit()
+    {
+        return (this.cleanupThread != null);
+    }
+
+    /**
+     * Set if clean-up should be performed at the time the program exits.
+     * The clean-up runs garbage collection and finalization to remove any
+     * remaining temporary files that may have been created.
+     * The default behavior is <code>true</code>.<p>
+     *
+     * For example unsigned applets must have this property set to <code>false</code>,
+     * since they do not have access to setting shutdown hooks.<p>
+     *
+     * Note that if this setting is ever set to <code>true</code> in any
+     * <code>ApfloatContext</code> (and never set to <code>false</code>
+     * subsequently in that context), then clean-up will be performed.<p>
+     *
+     * Also note that having the shutdown hook set will prevent class garbage
+     * collection i.e. the apfloat classes can't be unloaded if the shutdown
+     * hook still references the ApfloatContext class. If class unloading is
+     * desired then the cleanupAtExit property should be set to false first.
+     *
+     * @param cleanupAtExit <code>true</code> if clean-up should be done at JVM exit, or <code>false</code> if not.
+     */
+
+    public void setCleanupAtExit(boolean cleanupAtExit)
+    {
+        this.properties.setProperty(CLEANUP_AT_EXIT, String.valueOf(cleanupAtExit));
+
+        if (cleanupAtExit && this.cleanupThread == null)
+        {
+            this.cleanupThread = new CleanupThread();
+            this.cleanupThread.setBuilderFactory(this.builderFactory);
+            Runtime.getRuntime().addShutdownHook(this.cleanupThread);
+        }
+        else if (!cleanupAtExit && this.cleanupThread != null)
+        {
+            Runtime.getRuntime().removeShutdownHook(this.cleanupThread);
+            this.cleanupThread = null;
+        }
+    }
+
+    /**
+     * Get the value of a property as string.
+     * The name of the property can be any of the constants defined above.
+     *
+     * @param propertyName The name of the property.
+     *
+     * @return The value of the property as a <code>String</code>.
+     */
+
+    public String getProperty(String propertyName)
+    {
+        return this.properties.getProperty(propertyName);
+    }
+
+    /**
+     * Get the value of a property as string, with the provided default
+     * value if the property is not set.
+     *
+     * @param propertyName The name of the property.
+     * @param defaultValue The default value to be returned, if the property is not set.
+     *
+     * @return The value of the property as a <code>String</code>.
+     *
+     * @since 1.7.0
+     */
+
+    public String getProperty(String propertyName, String defaultValue)
+    {
+        return this.properties.getProperty(propertyName, defaultValue);
+    }
+
+    /**
+     * Set the value of a property as string.
+     * The name of the property can be any of the constants defined above.
+     *
+     * @param propertyName The name of the property.
+     * @param propertyValue The value of the property as a <code>String</code>.
+     *
+     * @exception org.apfloat.ApfloatConfigurationException If the property value can't be converted to the correct type.
+     */
+
+    public void setProperty(String propertyName, String propertyValue)
+        throws ApfloatConfigurationException
+    {
+        try
+        {
+            if (propertyName.equals(BUILDER_FACTORY))
+            {
+                setBuilderFactory((BuilderFactory) Class.forName(propertyValue).newInstance());
+            }
+            else if (propertyName.equals(DEFAULT_RADIX))
+            {
+                setDefaultRadix(Integer.parseInt(propertyValue));
+            }
+            else if (propertyName.equals(MAX_MEMORY_BLOCK_SIZE))
+            {
+                setMaxMemoryBlockSize(Long.parseLong(propertyValue));
+            }
+            else if (propertyName.equals(CACHE_L1_SIZE))
+            {
+                setCacheL1Size(Integer.parseInt(propertyValue));
+            }
+            else if (propertyName.equals(CACHE_L2_SIZE))
+            {
+                setCacheL2Size(Integer.parseInt(propertyValue));
+            }
+            else if (propertyName.equals(CACHE_BURST))
+            {
+                setCacheBurst(Integer.parseInt(propertyValue));
+            }
+            else if (propertyName.equals(MEMORY_TRESHOLD) || propertyName.equals(MEMORY_THRESHOLD))
+            {
+                setMemoryThreshold(Long.parseLong(propertyValue));
+            }
+            else if (propertyName.equals(SHARED_MEMORY_TRESHOLD))
+            {
+                setSharedMemoryTreshold(Long.parseLong(propertyValue));
+            }
+            else if (propertyName.equals(BLOCK_SIZE))
+            {
+                setBlockSize(Integer.parseInt(propertyValue));
+            }
+            else if (propertyName.equals(NUMBER_OF_PROCESSORS))
+            {
+                setNumberOfProcessors(Integer.parseInt(propertyValue));
+            }
+            else if (propertyName.equals(FILE_PATH))
+            {
+                setFilenameGenerator(new FilenameGenerator(propertyValue,
+                                                           getProperty(FILE_INITIAL_VALUE),
+                                                           getProperty(FILE_SUFFIX)));
+            }
+            else if (propertyName.equals(FILE_INITIAL_VALUE))
+            {
+                setFilenameGenerator(new FilenameGenerator(getProperty(FILE_PATH),
+                                                           propertyValue,
+                                                           getProperty(FILE_SUFFIX)));
+            }
+            else if (propertyName.equals(FILE_SUFFIX))
+            {
+                setFilenameGenerator(new FilenameGenerator(getProperty(FILE_PATH),
+                                                           getProperty(FILE_INITIAL_VALUE),
+                                                           propertyValue));
+            }
+            else if (propertyName.equals(CLEANUP_AT_EXIT))
+            {
+                setCleanupAtExit(Boolean.parseBoolean(propertyValue));
+            }
+            else
+            {
+                this.properties.setProperty(propertyName, propertyValue);
+            }
+        }
+        catch (Exception e)
+        {
+            throw new ApfloatConfigurationException("Error setting property \"" + propertyName + "\" to value \"" + propertyValue + '\"', e);
+        }
+    }
+
+    /**
+     * Get the values of all properties as strings.
+     * The names of the properties are all of the constants defined above.
+     *
+     * @return The properties.
+     */
+
+    public Properties getProperties()
+    {
+        return (Properties) this.properties.clone();
+    }
+
+    /**
+     * Get the shared memory lock object.
+     * All internal functions that allocate a memory block larger than the
+     * shared memory treshold should synchronize the allocation and memory access
+     * on the object returned by this method.
+     *
+     * @return The object on which large memory block allocation and access should be synchronized.
+     */
+
+    public Object getSharedMemoryLock()
+    {
+        return this.sharedMemoryLock;
+    }
+
+    /**
+     * Set the shared memory lock object.
+     * All internal functions that allocate a memory block larger than the
+     * shared memory treshold should synchronize the allocation and memory access
+     * on the object passed to this method.<p>
+     *
+     * The object is not used for anything else than synchronization, so the
+     * class of the object should really be <code>java.lang.Object</code>. One
+     * would typically call this method e.g. as
+     * <code>ctx.setSharedMemoryLock(new Object())</code>.
+     *
+     * @param lock The object on which large memory block allocation and access should be synchronized.
+     */
+
+    public void setSharedMemoryLock(Object lock)
+    {
+        this.sharedMemoryLock = lock;
+    }
+
+    /**
+     * Get the ExecutorService.
+     * It can be used for executing operations in parallel.<p>
+     *
+     * By default the ExecutorService is a thread pool that is
+     * shared by all the ApfloatContexts. The threads in the pool
+     * are daemon threads so the thread pool requires no clean-up
+     * at shutdown time.
+     *
+     * @return The ExecutorService.
+     *
+     * @see #getDefaultExecutorService
+     *
+     * @since 1.1
+     */
+
+    public ExecutorService getExecutorService()
+    {
+        return this.executorService;
+    }
+
+    /**
+     * Set the ExecutorService.<p>
+     *
+     * If a custom ExecutorService is used, e.g. a thread pool, then the number
+     * of available threads in the pool should match the number of processors
+     * set to all ApfloatContexts with {@link #setNumberOfProcessors(int)}.<p>
+     *
+     * Note that if a custom ExecutorService that requires shutdown is used,
+     * it is the caller's responsibility to clean up the ExecutorService
+     * at shutdown.
+     *
+     * @param executorService The ExecutorService.
+     *
+     * @see #getDefaultExecutorService
+     *
+     * @since 1.1
+     */
+
+    public void setExecutorService(ExecutorService executorService)
+    {
+        this.executorService = executorService;
+    }
+
+    /**
+     * Get an arbitrary object as an attribute for this ApfloatContext.
+     *
+     * @param name Name of the attribute.
+     *
+     * @return Value of the attribute or <code>null</code> if the attribute doesn't exist.
+     */
+
+    public Object getAttribute(String name)
+    {
+        return this.attributes.get(name);
+    }
+
+    /**
+     * Set an arbitrary object as an attribute for this ApfloatContext.
+     *
+     * @param name Name of the attribute.
+     * @param value Value of the attribute.
+     *
+     * @return Previous value of the attribute or <code>null</code> if the attribute didn't exist.
+     */
+
+    public Object setAttribute(String name, Object value)
+    {
+        return this.attributes.put(name, value);
+    }
+
+    /**
+     * Remove an attribute from this ApfloatContext.
+     *
+     * @param name Name of the attribute.
+     *
+     * @return Value of the attribute or <code>null</code> if the attribute didn't exist.
+     */
+
+    public Object removeAttribute(String name)
+    {
+        return this.attributes.remove(name);
+    }
+
+    /**
+     * Get names of all attributes for this ApfloatContext.
+     *
+     * @return Names of all attributes as strings.
+     */
+
+    public Enumeration<String> getAttributeNames()
+    {
+        return this.attributes.keys();
+    }
+
+    /**
+     * Loads properties from a properties file or resource bundle.
+     * First the <code>ResourceBundle</code> by the name "apfloat" is
+     * located, then all properties found from that resource bundle
+     * are put to a <code>Properties</code> object.<p>
+     *
+     * The resource bundle is found basically using the following logic
+     * (note that this is standard Java <code>ResourceBundle</code>
+     * functionality), in this order whichever is found first:
+     *
+     * <ol>
+     *   <li>From the class named <code>apfloat</code> (that should be a subclass of <code>ResourceBundle</code>), in the current class path</li>
+     *   <li>From the file "apfloat.properties" in the current class path</li>
+     * </ol>
+     *
+     * @return Properties found in the "apfloat" resource bundle, or an empty <code>Properties</code> object, if the resource bundle is not found.
+     */
+
+    public static Properties loadProperties()
+        throws ApfloatRuntimeException
+    {
+        Properties properties = new Properties();
+
+        try
+        {
+            ResourceBundle resourceBundle = ResourceBundle.getBundle("apfloat");
+
+            Enumeration<String> keys = resourceBundle.getKeys();
+            while (keys.hasMoreElements())
+            {
+                String key = keys.nextElement();
+                properties.setProperty(key, resourceBundle.getString(key));
+            }
+        }
+        catch (MissingResourceException mre)
+        {
+            // Ignore - properties file or class is not found or can't be read
+        }
+
+        return properties;
+    }
+
+    /**
+     * Returns a new instance of a default ExecutorService.<p>
+     *
+     * The default executor service is a thread-limited pool
+     * where the number of threads is one less than the number
+     * of processors set with {@link #setNumberOfProcessors(int)}.
+     *
+     * @return A new instance of a default ExecutorService.
+     *
+     * @since 1.3
+     */
+
+    public static ExecutorService getDefaultExecutorService()
+    {
+        // Executor service with all daemon threads, to avoid clean-up
+        ThreadFactory threadFactory = new ThreadFactory()
+        {
+            public Thread newThread(Runnable runnable)
+            {
+                Thread thread = this.defaultThreadFactory.newThread(runnable);
+                thread.setDaemon(true);
+
+                return thread;
+            }
+
+            private ThreadFactory defaultThreadFactory = Executors.defaultThreadFactory();
+        };
+
+        int numberOfThreads = Math.max(1, getContext().getNumberOfProcessors() - 1);
+        ThreadPoolExecutor executorService = new ThreadPoolExecutor(numberOfThreads, numberOfThreads, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), threadFactory);
+        executorService.allowCoreThreadTimeOut(true);
+
+        return executorService;
+    }
+
+    /**
+     * Set the values of all properties as strings.
+     * The names of the properties can be all of the constants defined above.
+     *
+     * @param properties The properties.
+     *
+     * @exception org.apfloat.ApfloatConfigurationException If a property value can't be converted to the correct type.
+     */
+
+    public void setProperties(Properties properties)
+        throws ApfloatConfigurationException
+    {
+        Enumeration<?> keys = properties.propertyNames();
+        while (keys.hasMoreElements())
+        {
+            String key = (String) keys.nextElement();
+            setProperty(key, properties.getProperty(key));
+        }
+    }
+
+    /**
+     * Creates a copy of this object.<p>
+     *
+     * The clone has the same BuilderFactory and FilenameGenerator members
+     * and the same shared memory lock and ExecutorService as the original
+     * ApfloatContext.<p>
+     *
+     * A shallow copy of the property set and the attribute set is created.
+     * Thus setting a property or attribute on the clone will not set it
+     * in the original object. Since the actual attributes (values) are shared,
+     * if an attribute is mutable and is modified in the clone, the modified
+     * value will appear in the original also.<p>
+     *
+     * @return A mostly shallow copy of this object.
+     */
+
+    public Object clone()
+    {
+        try
+        {
+            ApfloatContext ctx = (ApfloatContext) super.clone();    // Copy all attributes by reference
+            ctx.properties = (Properties) ctx.properties.clone();   // Create shallow copies
+            ctx.attributes = new ConcurrentHashMap<String, Object>(ctx.attributes);
+
+            return ctx;
+        }
+        catch (CloneNotSupportedException cnse)
+        {
+            // Should not occur
+            throw new InternalError();
+        }
+    }
+
+    private static ApfloatContext globalContext;
+    private static Map<Thread, ApfloatContext> threadContexts = new ConcurrentWeakHashMap<Thread, ApfloatContext>(); // Use a weak hash map to automatically remove completed threads; concurrent to avoid blocking threads
+    private static Properties defaultProperties;
+    private static ExecutorService defaultExecutorService;
+
+    private volatile BuilderFactory builderFactory;
+    private volatile FilenameGenerator filenameGenerator;
+    private volatile int defaultRadix;
+    private volatile long maxMemoryBlockSize;
+    private volatile int cacheL1Size;
+    private volatile int cacheL2Size;
+    private volatile int cacheBurst;
+    private volatile long memoryThreshold;
+    private volatile long sharedMemoryTreshold;
+    private volatile int blockSize;
+    private volatile int numberOfProcessors;
+    private volatile CleanupThread cleanupThread;
+    private volatile Properties properties;
+    private volatile Object sharedMemoryLock = new Object();
+    private volatile ExecutorService executorService = ApfloatContext.defaultExecutorService;
+    private volatile ConcurrentHashMap<String, Object> attributes = new ConcurrentHashMap<String, Object>();
+
+    static
+    {
+        ApfloatContext.defaultProperties = new Properties();
+
+        // Try to use up to 80% of total memory and all processors
+        long totalMemory;
+        try
+        {
+            MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
+            MemoryUsage memoryUsage = memoryBean.getHeapMemoryUsage();
+            totalMemory = Math.max(memoryUsage.getCommitted(), memoryUsage.getMax());
+        }
+        catch (NoClassDefFoundError ncdfe)
+        {
+            // The ManagementFactory class might be unavailable
+            totalMemory = Runtime.getRuntime().maxMemory();
+        }
+
+        long maxMemoryBlockSize = Util.round23down(totalMemory / 5 * 4);
+        int numberOfProcessors = Runtime.getRuntime().availableProcessors();
+        long memoryThreshold = Math.max(maxMemoryBlockSize >> 10, 65536);
+        int blockSize = Util.round2down((int) Math.min(memoryThreshold, Integer.MAX_VALUE));
+
+        // Guess if we are using a 32-bit or 64-bit platform
+        String elementType = (totalMemory >= 4L << 30 ? "Long" : "Int");
+
+        ApfloatContext.defaultProperties.setProperty(BUILDER_FACTORY, "org.apfloat.internal." + elementType + "BuilderFactory");
+        ApfloatContext.defaultProperties.setProperty(DEFAULT_RADIX, "10");
+        ApfloatContext.defaultProperties.setProperty(MAX_MEMORY_BLOCK_SIZE, String.valueOf(maxMemoryBlockSize));
+        ApfloatContext.defaultProperties.setProperty(CACHE_L1_SIZE, "8192");
+        ApfloatContext.defaultProperties.setProperty(CACHE_L2_SIZE, "262144");
+        ApfloatContext.defaultProperties.setProperty(CACHE_BURST, "32");
+        ApfloatContext.defaultProperties.setProperty(MEMORY_THRESHOLD, String.valueOf(memoryThreshold));
+        ApfloatContext.defaultProperties.setProperty(SHARED_MEMORY_TRESHOLD, String.valueOf(maxMemoryBlockSize / numberOfProcessors / 32));
+        ApfloatContext.defaultProperties.setProperty(BLOCK_SIZE, String.valueOf(blockSize));
+        ApfloatContext.defaultProperties.setProperty(NUMBER_OF_PROCESSORS, String.valueOf(numberOfProcessors));
+        ApfloatContext.defaultProperties.setProperty(FILE_PATH, "");
+        ApfloatContext.defaultProperties.setProperty(FILE_INITIAL_VALUE, "0");
+        ApfloatContext.defaultProperties.setProperty(FILE_SUFFIX, ".ap");
+        ApfloatContext.defaultProperties.setProperty(CLEANUP_AT_EXIT, "true");
+
+        // Set combination of default properties and properties specified in the resource bundle
+        ApfloatContext.globalContext = new ApfloatContext(loadProperties());
+
+        // ExecutorService depends on the properties so set it last
+        ApfloatContext.defaultExecutorService = getDefaultExecutorService();
+        ApfloatContext.globalContext.setExecutorService(ApfloatContext.defaultExecutorService);
+    }
+}
Index: src/main/java/org/apfloat/ApfloatHelper.java
===================================================================
--- src/main/java/org/apfloat/ApfloatHelper.java	(revision 0)
+++ src/main/java/org/apfloat/ApfloatHelper.java	(revision 0)
@@ -0,0 +1,714 @@
+package org.apfloat;
+
+import java.math.BigInteger;
+import java.math.BigDecimal;
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.PushbackReader;
+import java.io.Writer;
+import java.io.IOException;
+
+import org.apfloat.spi.ApfloatBuilder;
+import org.apfloat.spi.ApfloatImpl;
+import org.apfloat.spi.Util;
+import static org.apfloat.spi.RadixConstants.*;
+
+/**
+ * Various utility methods related to apfloats.
+ *
+ * @version 1.6.2
+ * @author Mikko Tommila
+ */
+
+class ApfloatHelper
+{
+    private ApfloatHelper()
+    {
+    }
+
+    public static ApfloatImpl createApfloat(String value, boolean isInteger)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        long precision = (isInteger ? Apfloat.INFINITE : Apfloat.DEFAULT);
+        int radix = getDefaultRadix();
+        return implCreateApfloat(value, precision, radix, isInteger);
+    }
+
+    public static ApfloatImpl createApfloat(String value, long precision, boolean isInteger)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        int radix = getDefaultRadix();
+        return createApfloat(value, precision, radix, isInteger);
+    }
+
+    public static ApfloatImpl createApfloat(String value, long precision, int radix, boolean isInteger)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        if (precision != Apfloat.DEFAULT)
+        {
+            checkPrecision(precision);
+        }
+        return implCreateApfloat(value, precision, radix, isInteger);
+    }
+
+    private static ApfloatImpl implCreateApfloat(String value, long precision, int radix, boolean isInteger)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        ApfloatBuilder factory = getApfloatBuilder();
+        return factory.createApfloat(value, precision, radix, isInteger);
+    }
+
+    public static ApfloatImpl createApfloat(long value)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        int radix = getDefaultRadix();
+        return implCreateApfloat(value, Apfloat.INFINITE, radix);
+    }
+
+    public static ApfloatImpl createApfloat(long value, long precision)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        int radix = getDefaultRadix();
+        return createApfloat(value, precision, radix);
+    }
+
+    public static ApfloatImpl createApfloat(long value, long precision, int radix)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        precision = (precision == Apfloat.DEFAULT ? Apfloat.INFINITE : precision);
+        checkPrecision(precision);
+        return implCreateApfloat(value, precision, radix);
+    }
+
+    private static ApfloatImpl implCreateApfloat(long value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        ApfloatBuilder factory = getApfloatBuilder();
+        return factory.createApfloat(value, precision, radix);
+    }
+
+    public static ApfloatImpl createApfloat(float value)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        int radix = getDefaultRadix();
+        int precision = getFloatPrecision(radix);
+        return implCreateApfloat(value, precision, radix);
+    }
+
+    public static ApfloatImpl createApfloat(float value, long precision)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        int radix = getDefaultRadix();
+        return createApfloat(value, precision, radix);
+    }
+
+    public static ApfloatImpl createApfloat(float value, long precision, int radix)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        precision = (precision == Apfloat.DEFAULT ? getFloatPrecision(radix) : precision);
+        checkPrecision(precision);
+        return implCreateApfloat(value, precision, radix);
+    }
+
+    public static ApfloatImpl createApfloat(double value)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        int radix = getDefaultRadix();
+        int precision = getDoublePrecision(radix);
+        return implCreateApfloat(value, precision, radix);
+    }
+
+    public static ApfloatImpl createApfloat(double value, long precision)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        int radix = getDefaultRadix();
+        return createApfloat(value, precision, radix);
+    }
+
+    public static ApfloatImpl createApfloat(double value, long precision, int radix)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        precision = (precision == Apfloat.DEFAULT ? getDoublePrecision(radix) : precision);
+        checkPrecision(precision);
+        return implCreateApfloat(value, precision, radix);
+    }
+
+    private static ApfloatImpl implCreateApfloat(double value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        ApfloatBuilder factory = getApfloatBuilder();
+        return factory.createApfloat(value, precision, radix);
+    }
+
+    public static ApfloatImpl createApfloat(PushbackReader in, boolean isInteger)
+        throws IOException, NumberFormatException, ApfloatRuntimeException
+    {
+        int radix = getDefaultRadix();
+        return implCreateApfloat(in, Apfloat.DEFAULT, radix, isInteger);
+    }
+
+    public static ApfloatImpl createApfloat(PushbackReader in, long precision, boolean isInteger)
+        throws IOException, NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        int radix = getDefaultRadix();
+        return createApfloat(in, precision, radix, isInteger);
+    }
+
+    public static ApfloatImpl createApfloat(PushbackReader in, long precision, int radix, boolean isInteger)
+        throws IOException, NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        if (precision != Apfloat.DEFAULT)
+        {
+            checkPrecision(precision);
+        }
+        return implCreateApfloat(in, precision, radix, isInteger);
+    }
+
+    private static ApfloatImpl implCreateApfloat(PushbackReader in, long precision, int radix, boolean isInteger)
+        throws IOException, NumberFormatException, ApfloatRuntimeException
+    {
+        ApfloatBuilder factory = getApfloatBuilder();
+        return factory.createApfloat(in, precision, radix, isInteger);
+    }
+
+    public static ApfloatImpl createApfloat(BigInteger value)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        int radix = getDefaultRadix();
+        return createApfloat(value, Apfloat.INFINITE, radix);
+    }
+
+    public static ApfloatImpl createApfloat(BigInteger value, long precision)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        int radix = getDefaultRadix();
+        return createApfloat(value, precision, radix);
+    }
+
+    public static ApfloatImpl createApfloat(BigInteger value, long precision, int radix)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        if (precision != Apfloat.DEFAULT)
+        {
+            checkPrecision(precision);
+        }
+        checkRadix(radix);
+        Apfloat a;
+        try
+        {
+            a = new Apfloat(createApfloat(toPushbackReader(value), Apfloat.INFINITE, 16, true));
+        }
+        catch (IOException ioe)
+        {
+            throw new ApfloatRuntimeException("Should not occur", ioe);
+        }
+        precision = (precision == Apfloat.DEFAULT ? Apfloat.INFINITE : precision);
+        return a.toRadix(radix).getImpl(precision);
+    }
+
+    public static ApfloatImpl createApfloat(BigDecimal value)
+        throws ApfloatRuntimeException
+    {
+        return implCreateApfloat(value.toString(), Apfloat.DEFAULT, 10, false);
+    }
+
+    public static ApfloatImpl createApfloat(BigDecimal value, long precision)
+        throws IllegalArgumentException, ApfloatRuntimeException
+    {
+        return createApfloat(value.toString(), precision, 10, false);
+    }
+
+    /**
+     * Extracts matching character from stream.
+     * A non-matching character is pushed back to the stream.
+     *
+     * @param in The input.
+     * @param c The character to expect from the stream.
+     *
+     * @return <code>true</code> if the specified character was extracted from the stream, <code>false</code> otherwise.
+     *
+     * @exception java.io.IOException In case of read error in the stream.
+     */
+
+    public static boolean readMatch(PushbackReader in, int c)
+        throws IOException
+    {
+        int i = in.read();
+
+        if (i != c)
+        {
+            if (i != -1)
+            {
+                in.unread(i);
+            }
+            return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * Extracts whitespace from stream.
+     *
+     * @param in The input.
+     *
+     * @exception java.io.IOException In case of read error in the stream.
+     */
+
+    public static void extractWhitespace(PushbackReader in)
+        throws IOException
+    {
+        int c;
+
+        while (Character.isWhitespace((char) (c = in.read())))
+        {
+            // Extracts any whitespace
+        }
+        if (c != -1)
+        {
+            in.unread(c);
+        }
+    }
+
+    /**
+     * Get working precisions for the arguments of e.g. an add, subtract or compare operation.<p>
+     *
+     * Note that the returned precision can be zero to indicate that the number is insignificant
+     * in the calculation. This is the case if either operand is zero, or if one number lies
+     * completely outside the significant range of the other number. Consider e.g. the case<p>
+     *
+     * x.scale() = 100<br>
+     * x.precision() = 50<br>
+     * y.scale() = 10<br>
+     * y.precision() = 5<p>
+     *
+     * In e.g. the sum of x and y, the operand y would now be insignificant.
+     *
+     * @param x First argument.
+     * @param y Second argument.
+     *
+     * @return Array of two longs containing the working precisions for <code>x</code> and <code>y</code>, correspondingly.
+     */
+
+    public static long[] getMatchingPrecisions(Apfloat x, Apfloat y)
+        throws ApfloatRuntimeException
+    {
+        if (x.signum() == 0 || y.signum() == 0)
+        {
+            return new long[] { 0, 0 };
+        }
+
+        long xPrec  = x.precision(),
+             yPrec  = y.precision(),
+             xScale = x.scale(),
+             yScale = y.scale(),
+             maxScale = Math.max(xScale, yScale),
+             xScaleDiff = (maxScale - xScale < 0 ? Apfloat.INFINITE : maxScale - xScale),
+             yScaleDiff = (maxScale - yScale < 0 ? Apfloat.INFINITE : maxScale - yScale),
+             maxPrec = Math.min(Util.ifFinite(xPrec, xPrec + xScaleDiff),
+                                Util.ifFinite(yPrec, yPrec + yScaleDiff)),
+             destXPrec = (maxPrec - xScaleDiff <= 0 ? 0 : Util.ifFinite(maxPrec, maxPrec - xScaleDiff)),
+             destYPrec = (maxPrec - yScaleDiff <= 0 ? 0 : Util.ifFinite(maxPrec, maxPrec - yScaleDiff));
+
+        return new long[] { destXPrec, destYPrec };
+    }
+
+    /**
+     * Get working precisions for the arguments of an multiply-add operation
+     * a * b + c * d. Works as well for a multiply-subtract operation, of course.<p>
+     *
+     * The returned array contains three longs:<p>
+     *
+     * [0] Working precisions for <code>a</code> and <code>b</code><br>
+     * [1] Working precisions for <code>c</code> and <code>d</code><br>
+     * [2] Maximum precision of the final result <code>a * b + c * d</code><p>
+     *
+     * Note that the precisions can be zero. See {@link #getMatchingPrecisions(Apfloat,Apfloat)}
+     * for details.
+     *
+     * @param a First argument.
+     * @param b Second argument.
+     * @param c Third argument.
+     * @param d Fourth argument.
+     *
+     * @return Array of three longs containing the precisions.
+     */
+
+    public static long[] getMatchingPrecisions(Apfloat a, Apfloat b, Apfloat c, Apfloat d)
+        throws ApfloatRuntimeException
+    {
+        long abPrec  = (a.signum() == 0 || b.signum() == 0 ? 0 : Math.min(a.precision(), b.precision())),
+             cdPrec  = (c.signum() == 0 || d.signum() == 0 ? 0 : Math.min(c.precision(), d.precision()));
+
+        if (abPrec == 0 || cdPrec == 0)
+        {
+            return new long[] { abPrec, cdPrec, Math.max(abPrec, cdPrec) };
+        }
+
+        long abScale = a.scale() + b.scale(),
+             cdScale = c.scale() + d.scale(),
+             maxScale = Math.max(abScale, cdScale),
+             abScaleDiff = (maxScale - abScale < 0 ? Apfloat.INFINITE : maxScale - abScale),
+             cdScaleDiff = (maxScale - cdScale < 0 ? Apfloat.INFINITE : maxScale - cdScale),
+             maxPrec = Math.min(Util.ifFinite(abPrec, abPrec + abScaleDiff),
+                                Util.ifFinite(cdPrec, cdPrec + cdScaleDiff)),
+             destAbPrec = (maxPrec - abScaleDiff <= 0 ? 0 : Util.ifFinite(maxPrec, maxPrec - abScaleDiff + 1)), // Add 1 since the scale may be 1 less
+             destCdPrec = (maxPrec - cdScaleDiff <= 0 ? 0 : Util.ifFinite(maxPrec, maxPrec - cdScaleDiff + 1));
+
+        return new long[] { destAbPrec, destCdPrec, maxPrec };
+    }
+
+    public static void checkPrecision(long precision)
+        throws IllegalArgumentException
+    {
+        if (precision <= 0)
+        {
+            throw new IllegalArgumentException("Precision " + precision + " is not positive");
+        }
+    }
+
+    public static void checkRadix(int radix)
+        throws NumberFormatException
+    {
+        if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)
+        {
+            throw new NumberFormatException("Invalid radix " + radix + "; radix must be between " + Character.MIN_RADIX + " and " + Character.MAX_RADIX);
+        }
+    }
+
+    private static void checkPowPrecision(long targetPrecision)
+        throws InfiniteExpansionException
+
+    {
+        if (targetPrecision == Apfloat.INFINITE)
+        {
+            throw new InfiniteExpansionException("Cannot calculate power to infinite precision");
+        }
+    }
+
+    private static Apcomplex checkPowBasic(Apcomplex z, Apcomplex w, long targetPrecision)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (w.real().signum() == 0 && w.imag().signum() == 0)
+        {
+            if (z.real().signum() == 0 && z.imag().signum() == 0)
+            {
+                throw new ArithmeticException("Zero to power zero");
+            }
+
+            return new Apcomplex(new Apfloat(1, Apfloat.INFINITE, z.radix()));
+        }
+        else if (z.real().signum() == 0 && z.imag().signum() == 0 || z.equals(Apcomplex.ONE) || w.equals(Apcomplex.ONE))
+        {
+            return z.precision(targetPrecision);
+        }
+
+        return null;
+    }
+
+    public static Apcomplex checkPow(Apcomplex z, Apcomplex w, long targetPrecision)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        Apcomplex result = checkPowBasic(z, w, targetPrecision);
+        if (result != null)
+        {
+            return result;
+        }
+
+        checkPowPrecision(targetPrecision);
+
+        return null;
+    }
+
+    public static Apfloat checkPow(Apfloat x, Apfloat y, long targetPrecision)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        Apcomplex result = checkPowBasic(x, y, targetPrecision);
+        if (result != null)
+        {
+            return result.real();
+        }
+        else if (x.signum() < 0)
+        {
+            throw new ArithmeticException("Power of negative number; result would be complex");
+        }
+
+        checkPowPrecision(targetPrecision);
+
+        return null;
+    }
+
+    public static int getFloatPrecision(int radix)
+    {
+        assert (radix > 0);
+        return FLOAT_PRECISION[radix];
+    }
+
+    public static int getDoublePrecision(int radix)
+    {
+        assert (radix > 0);
+        return DOUBLE_PRECISION[radix];
+    }
+
+    public static int getLongPrecision(int radix)
+    {
+        assert (radix > 0);
+        return LONG_PRECISION[radix];
+    }
+
+    // Returns x with precision at most as specified
+    public static Apfloat limitPrecision(Apfloat x, long precision)
+        throws ApfloatRuntimeException
+    {
+        return x.precision(Math.min(x.precision(), precision));
+    }
+
+    // Returns x with precision at least as specified
+    public static Apfloat ensurePrecision(Apfloat x, long precision)
+        throws ApfloatRuntimeException
+    {
+        return x.precision(Math.max(x.precision(), precision));
+    }
+
+    // Returns given precision extended by specified amount
+    public static long extendPrecision(long precision, long extraPrecision)
+    {
+        return Util.ifFinite(precision, precision + extraPrecision);
+    }
+
+    // Returns given precision extended by Apfloat.EXTRA_PRECISION
+    public static long extendPrecision(long precision)
+    {
+        return extendPrecision(precision, Apfloat.EXTRA_PRECISION);
+    }
+
+    // Returns x with precision extended by Apfloat.EXTRA_PRECISION
+    public static Apfloat extendPrecision(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return x.precision(extendPrecision(x.precision()));
+    }
+
+    // Returns x with precision extended by specified amount
+    public static Apfloat extendPrecision(Apfloat x, long extraPrecision)
+        throws ApfloatRuntimeException
+    {
+        return x.precision(extendPrecision(x.precision(), extraPrecision));
+    }
+
+    // Returns z with precision as specified
+    public static Apcomplex setPrecision(Apcomplex z, long precision)
+        throws ApfloatRuntimeException
+    {
+        if (z.real().signum() == 0)
+        {
+            return new Apcomplex(z.real(),
+                                 z.imag().precision(precision));
+        }
+        else if (z.imag().signum() == 0)
+        {
+            return new Apcomplex(z.real().precision(precision),
+                                 z.imag());
+        }
+
+        long precisionChange = precision - z.precision(),
+             realPrecision = z.real().precision(),
+             imagPrecision = z.imag().precision(),
+             newRealPrecision = Util.ifFinite(realPrecision, realPrecision + precisionChange),
+             newImagPrecision = Util.ifFinite(imagPrecision, imagPrecision + precisionChange);
+
+        if (precisionChange < 0)
+        {
+            if (realPrecision + precisionChange <= 0)
+            {
+                return new Apcomplex(Apfloat.ZERO,
+                                     z.imag().precision(precision));
+            }
+            else if (imagPrecision + precisionChange <= 0)
+            {
+                return new Apcomplex(z.real().precision(precision),
+                                     Apfloat.ZERO);
+            }
+        }
+
+        return new Apcomplex(z.real().precision(newRealPrecision),
+                             z.imag().precision(newImagPrecision));
+    }
+
+    // Returns z with precision at most as specified
+    public static Apcomplex limitPrecision(Apcomplex z, long precision)
+        throws ApfloatRuntimeException
+    {
+        return new Apcomplex(z.real().precision(Math.min(z.real().precision(), precision)),
+                             z.imag().precision(Math.min(z.imag().precision(), precision)));
+    }
+
+    // Returns z with precision at least as specified
+    public static Apcomplex ensurePrecision(Apcomplex z, long precision)
+        throws ApfloatRuntimeException
+    {
+        return new Apcomplex(z.real().precision(Math.max(z.real().precision(), precision)),
+                             z.imag().precision(Math.max(z.imag().precision(), precision)));
+    }
+
+    // Returns z with precision extended by Apfloat.EXTRA_PRECISION
+    public static Apcomplex extendPrecision(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return new Apcomplex(z.real().precision(extendPrecision(z.real().precision())),
+                             z.imag().precision(extendPrecision(z.imag().precision())));
+    }
+
+    // Returns z with precision extended by specified precision
+    public static Apcomplex extendPrecision(Apcomplex z, long extraPrecision)
+        throws ApfloatRuntimeException
+    {
+        return new Apcomplex(z.real().precision(extendPrecision(z.real().precision(), extraPrecision)),
+                             z.imag().precision(extendPrecision(z.imag().precision(), extraPrecision)));
+    }
+
+    public static long size(Aprational x)
+        throws ApfloatRuntimeException
+    {
+        return Math.max(x.numerator().size(), x.denominator().size());
+    }
+
+    public static BigInteger toBigInteger(Apint x)
+    {
+        assert (x.signum() != 0);
+
+        // The naive approach to convert to String and then to BigInteger is highly
+        // inefficient as the BigInteger String constructor has O(n^2) complexity.
+        // Therefore we first convert to radix-16 and then to a byte array.
+        Apint a = ApintMath.abs(x.toRadix(16));
+        long scale = a.scale();
+        long byteCount = (scale + 1) >> 1;
+
+        if (byteCount > Integer.MAX_VALUE)
+        {
+            throw new IllegalArgumentException("Maximum array size exceeded");
+        }
+
+        final byte[] bytes = new byte[(int) byteCount];
+        final boolean startHi = ((scale & 1) == 0);
+
+        try
+        {
+            a.writeTo(new Writer()
+            {
+                public void write(int c)
+                {
+                    c = Character.digit(c, 16);
+                    if (this.hi)
+                    {
+                        this.b = (c << 4);
+                    }
+                    else
+                    {
+                        this.b += (c & 0x0F);
+                        bytes[this.bytePosition] = (byte) this.b;
+                        this.bytePosition++;
+                    }
+                    this.hi = !this.hi;
+                }
+
+                public void write(char cbuf[], int off, int len)
+                {
+                    for (int i = 0; i < len; i++)
+                    {
+                        write(cbuf[off + i]);
+                    }
+                }
+
+                public void close()
+                {
+                }
+
+                public void flush()
+                {
+                }
+
+                private int b;
+                private int bytePosition;
+                private boolean hi = startHi;
+            });
+        }
+        catch (IOException ioe)
+        {
+            throw new ApfloatRuntimeException("Should not occur", ioe);
+        }
+
+        BigInteger b = new BigInteger(x.signum(), bytes);
+        return b;
+    }
+
+    // Get a reader for the radix-16 presentation of the BigInteger.
+    // The BigInteger.toString() method has O(n^2) complexity,
+    // therefore we convert to a byte array instead.
+    public static PushbackReader toPushbackReader(BigInteger x)
+        throws IOException
+    {
+        byte[] bytes = x.abs().toByteArray();
+        final int startB = (x.signum() < 0 ? '-' : -1);     // Start the stream with minus sign in case of negative number
+        InputStream in = new ByteArrayInputStream(bytes)
+        {
+            public int read()
+            {
+                int c;
+                if (this.b == -1)
+                {
+                    this.b = super.read();
+                    if (this.b == -1)
+                    {
+                        c = -1;
+                    }
+                    else
+                    {
+                        c = Character.forDigit(this.b >> 4, 16);
+                        this.b = Character.forDigit(this.b & 0x0F, 16);
+                    }
+                }
+                else
+                {
+                    c = this.b;
+                    this.b = -1;
+                }
+                return c;
+            }
+
+            public int read(byte[] b, int off, int len)
+            {
+                int i = 0;
+                for (; i < len; i++)
+                {
+                    int c = read();
+                    if (c == -1)
+                    {
+                        i = (i == 0 ? -1 : i);  // In case of EOF; there was nothing to read in the stream
+                        break;
+                    }
+                    b[i + off] = (byte) c;
+                }
+                return i;
+            }
+
+            private int b = startB;
+        };
+
+        return new PushbackReader(new InputStreamReader(in, "ISO-8859-1"));
+    }
+
+    private static int getDefaultRadix()
+        throws NumberFormatException
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        return ctx.getDefaultRadix();
+    }
+
+    private static ApfloatBuilder getApfloatBuilder()
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        return ctx.getBuilderFactory().getApfloatBuilder();
+    }
+}
Index: src/main/java/org/apfloat/ApfloatMath.java
===================================================================
--- src/main/java/org/apfloat/ApfloatMath.java	(revision 0)
+++ src/main/java/org/apfloat/ApfloatMath.java	(revision 0)
@@ -0,0 +1,2115 @@
+package org.apfloat;
+
+import java.math.RoundingMode;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.Hashtable;
+import java.util.Queue;
+import java.util.PriorityQueue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.apfloat.spi.Util;
+
+/**
+ * Various mathematical functions for arbitrary precision floating-point numbers.<p>
+ *
+ * Due to different types of round-off errors that can occur in the implementation,
+ * no guarantees about e.g. monotonicity are given for any of the methods.
+ *
+ * @see ApintMath
+ *
+ * @version 1.8.2
+ * @author Mikko Tommila
+ */
+
+public class ApfloatMath
+{
+    private ApfloatMath()
+    {
+    }
+
+    /**
+     * Integer power.
+     *
+     * @param x Base of the power operator.
+     * @param n Exponent of the power operator.
+     *
+     * @return <code>x</code> to the <code>n</code>:th power, that is <code>x<sup>n</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If both <code>x</code> and <code>n</code> are zero.
+     */
+
+    public static Apfloat pow(Apfloat x, long n)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (n == 0)
+        {
+            if (x.signum() == 0)
+            {
+                throw new ArithmeticException("Zero to power zero");
+            }
+
+            return new Apfloat(1, Apfloat.INFINITE, x.radix());
+        }
+        else if (n < 0)
+        {
+            x = inverseRoot(x, 1);
+            n = -n;
+        }
+
+        long precision = x.precision();
+        x = ApfloatHelper.extendPrecision(x);   // Big exponents will accumulate round-off errors
+
+        // Algorithm improvements by Bernd Kellner
+        int b2pow = 0;
+
+        while ((n & 1) == 0)
+        {
+            b2pow++;
+            n >>>= 1;
+        }
+
+        Apfloat r = x;
+
+        while ((n >>>= 1) > 0)
+        {
+            x = x.multiply(x);
+            if ((n & 1) != 0)
+            {
+                r = r.multiply(x);
+            }
+        }
+
+        while (b2pow-- > 0)
+        {
+            r = r.multiply(r);
+        }
+
+        return r.precision(precision);
+    }
+
+    /**
+     * Square root.
+     *
+     * @param x The argument.
+     *
+     * @return Square root of <code>x</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>x</code> is negative.
+     */
+
+    public static Apfloat sqrt(Apfloat x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return root(x, 2);
+    }
+
+    /**
+     * Cube root.
+     *
+     * @param x The argument.
+     *
+     * @return Cube root of <code>x</code>.
+     */
+
+    public static Apfloat cbrt(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return root(x, 3);
+    }
+
+    /**
+     * Positive integer root.
+     *
+     * @param x The argument.
+     * @param n Which root to take.
+     *
+     * @return <code>n</code>:th root of <code>x</code>, that is <code>x<sup>1/n</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>n</code> is zero, or <code>x</code> is negative and <code>n</code> is even.
+     */
+
+    public static Apfloat root(Apfloat x, long n)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (n == 0)
+        {
+            throw new ArithmeticException("Zeroth root");
+        }
+        else if (x.signum() == 0)
+        {
+            return Apfloat.ZERO;                // Avoid division by zero
+        }
+        else if (n == 1)
+        {
+            return x;
+        }
+        else if (n == 0x8000000000000000L)
+        {
+            return sqrt(inverseRoot(x, n / -2));
+        }
+        else if (n < 0)
+        {
+            return inverseRoot(x, -n);
+        }
+        else if (n == 2)
+        {
+            return x.multiply(inverseRoot(x, 2));
+        }
+        else if (n == 3)
+        {
+            Apfloat y = x.multiply(x);
+            return x.multiply(inverseRoot(y, 3));
+        }
+        else
+        {
+            Apfloat y = inverseRoot(x, n);
+            return inverseRoot(y, 1);
+        }
+    }
+
+    /**
+     * Inverse positive integer root.
+     *
+     * @param x The argument.
+     * @param n Which inverse root to take.
+     *
+     * @return Inverse <code>n</code>:th root of <code>x</code>, that is <code>x<sup>-1/n</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>x</code> or <code>n</code> is zero, or <code>x</code> is negative and <code>n</code> is even.
+     */
+
+    public static Apfloat inverseRoot(Apfloat x, long n)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return inverseRoot(x, n, x.precision());
+    }
+
+    /**
+     * Inverse positive integer root.
+     *
+     * @param x The argument.
+     * @param n Which inverse root to take.
+     * @param targetPrecision Precision of the desired result.
+     *
+     * @return Inverse <code>n</code>:th root of <code>x</code>, that is <code>x<sup>-1/n</sup></code>.
+     *
+     * @exception java.lang.IllegalArgumentException If <code>targetPrecision &lt;= 0</code>.
+     * @exception java.lang.ArithmeticException If <code>x</code> or <code>n</code> is zero, or <code>x</code> is negative and <code>n</code> is even.
+     */
+
+    public static Apfloat inverseRoot(Apfloat x, long n, long targetPrecision)
+        throws IllegalArgumentException, ArithmeticException, ApfloatRuntimeException
+    {
+        return inverseRoot(x, n, targetPrecision, null);
+    }
+
+    /**
+     * Inverse positive integer root.
+     *
+     * @param x The argument.
+     * @param n Which inverse root to take.
+     * @param targetPrecision Precision of the desired result.
+     * @param initialGuess Initial guess for the result value, or <code>null</code> if none is available.
+     *
+     * @return Inverse <code>n</code>:th root of <code>x</code>, that is <code>x<sup>-1/n</sup></code>.
+     *
+     * @exception java.lang.IllegalArgumentException If <code>targetPrecision &lt;= 0</code>.
+     * @exception java.lang.ArithmeticException If <code>x</code> or <code>n</code> is zero, or <code>x</code> is negative and <code>n</code> is even.
+     */
+
+    public static Apfloat inverseRoot(Apfloat x, long n, long targetPrecision, Apfloat initialGuess)
+        throws IllegalArgumentException, ArithmeticException, ApfloatRuntimeException
+    {
+        return inverseRoot(x, n, targetPrecision, initialGuess, initialGuess == null ? 0 : initialGuess.precision());
+    }
+
+    /**
+     * Inverse positive integer root.<p>
+     *
+     * This method is the basis for most of apfloat's non-elementary operations.
+     * It is used e.g. in {@link Apfloat#divide(Apfloat)}, {@link #sqrt(Apfloat)}
+     * and {@link #root(Apfloat,long)}.
+     *
+     * @param x The argument.
+     * @param n Which inverse root to take.
+     * @param targetPrecision Precision of the desired result.
+     * @param initialGuess Initial guess for the result value, or <code>null</code> if none is available.
+     * @param initialPrecision Precision of the initial guess, if available.
+     *
+     * @return Inverse <code>n</code>:th root of <code>x</code>, that is <code>x<sup>-1/n</sup></code>.
+     *
+     * @exception java.lang.IllegalArgumentException If <code>targetPrecision &lt;= 0</code> or <code>initialPrecision &lt;= 0</code>.
+     * @exception java.lang.ArithmeticException If <code>x</code> or <code>n</code> is zero, or <code>x</code> is negative and <code>n</code> is even.
+     */
+
+    public static Apfloat inverseRoot(Apfloat x, long n, long targetPrecision, Apfloat initialGuess, long initialPrecision)
+        throws IllegalArgumentException, ArithmeticException, ApfloatRuntimeException
+    {
+        if (x.signum() == 0)
+        {
+            throw new ArithmeticException("Inverse root of zero");
+        }
+        else if (n == 0)
+        {
+            throw new ArithmeticException("Inverse zeroth root");
+        }
+        else if ((n & 1) == 0 && x.signum() < 0)
+        {
+            throw new ArithmeticException("Even root of negative number; result would be complex");
+        }
+        else if (targetPrecision <= 0)
+        {
+            throw new IllegalArgumentException("Target precision " + targetPrecision + " is not positive");
+        }
+        else if (x.equals(Apfloat.ONE))
+        {
+            // Trivial case
+            return x.precision(targetPrecision);
+        }
+        else if (targetPrecision == Apfloat.INFINITE)
+        {
+            throw new InfiniteExpansionException("Cannot calculate inverse root to infinite precision");
+        }
+        else if (n == 0x8000000000000000L)
+        {
+            Apfloat y = inverseRoot(x, n / -2);
+            return inverseRoot(y, 2);
+        }
+        else if (n < 0)
+        {
+            Apfloat y = inverseRoot(x, -n);
+            return inverseRoot(y, 1);
+        }
+
+        long precision,
+             doublePrecision = ApfloatHelper.getDoublePrecision(x.radix());
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, x.radix()),
+                divisor = new Apfloat(n, Apfloat.INFINITE, x.radix()),
+                result;
+
+        if (initialGuess == null || initialPrecision < doublePrecision)
+        {
+            // Calculate initial guess from x
+            long scaleQuot = x.scale() / n,
+                 scaleRem = x.scale() - scaleQuot * n;
+
+            result = x.precision(doublePrecision);
+            result = scale(result, -result.scale());    // Allow scales in exess of doubles'
+
+            precision = doublePrecision;
+
+            result = new Apfloat((double) result.signum() * Math.pow(Math.abs(result.doubleValue()), -1.0 / (double) n) * Math.pow((double) x.radix(), (double) -scaleRem / (double) n), precision, x.radix());
+            result = scale(result, -scaleQuot);
+        }
+        else
+        {
+            // Take initial guess as given
+            result = initialGuess;
+            precision = initialPrecision;
+        }
+
+        int iterations = 0;
+
+        // Compute total number of iterations
+        for (long maxPrec = precision; maxPrec < targetPrecision; maxPrec <<= 1)
+        {
+            iterations++;
+        }
+
+        int precisingIteration = iterations;
+
+        // Check where the precising iteration should be done
+        for (long minPrec = precision; precisingIteration > 0; precisingIteration--, minPrec <<= 1)
+        {
+            if ((minPrec - Apfloat.EXTRA_PRECISION) << precisingIteration >= targetPrecision)
+            {
+                break;
+            }
+        }
+
+        x = ApfloatHelper.extendPrecision(x);
+
+        // Newton's iteration
+        while (iterations-- > 0)
+        {
+            precision *= 2;
+            result = result.precision(Math.min(precision, targetPrecision));
+
+            Apfloat t = pow(result, n);
+            t = lastIterationExtendPrecision(iterations, precisingIteration, t);
+            t = one.subtract(x.multiply(t));
+            if (iterations < precisingIteration)
+            {
+                t = t.precision(precision / 2);
+            }
+
+            result = lastIterationExtendPrecision(iterations, precisingIteration, result);
+            result = result.add(result.multiply(t).divide(divisor));
+
+            // Precising iteration
+            if (iterations == precisingIteration)
+            {
+                t = pow(result, n);
+                t = lastIterationExtendPrecision(iterations, -1, t);
+
+                result = lastIterationExtendPrecision(iterations, -1, result);
+                result = result.add(result.multiply(one.subtract(x.multiply(t))).divide(divisor));
+            }
+        }
+
+        return result.precision(targetPrecision);
+    }
+
+    /**
+     * Floor function. Returns the largest (closest to positive infinity) value
+     * that is not greater than the argument and is equal to a mathematical integer.
+     *
+     * @param x The argument.
+     *
+     * @return <code>x</code> rounded towards negative infinity.
+     */
+
+    public static Apint floor(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return x.floor();
+    }
+
+    /**
+     * Ceiling function. Returns the smallest (closest to negative infinity) value
+     * that is not less than the argument and is equal to a mathematical integer.
+     *
+     * @param x The argument.
+     *
+     * @return <code>x</code> rounded towards positive infinity.
+     */
+
+    public static Apint ceil(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return x.ceil();
+    }
+
+    /**
+     * Truncates fractional part.
+     *
+     * @param x The argument.
+     *
+     * @return <code>x</code> rounded towards zero.
+     */
+
+    public static Apint truncate(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return x.truncate();
+    }
+
+    /**
+     * Extracts fractional part.
+     *
+     * @param x The argument.
+     *
+     * @return The fractional part of <code>x</code>.
+     *
+     * @since 1.7.0
+     */
+
+    public static Apfloat frac(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return x.frac();
+    }
+
+    /**
+     * Rounds the given number to the specified precision with the specified rounding mode.
+     *
+     * @param x The number to round.
+     * @param precision The precision to round to.
+     * @param roundingMode The rounding mode to use.
+     *
+     * @return The rounded number.
+     *
+     * @exception java.lang.IllegalArgumentException If <code>precision</code> is less than zero or zero.
+     * @exception java.lang.ArithmeticException If rounding is necessary (result is not exact) and rounding mode is {@link RoundingMode#UNNECESSARY}.
+     *
+     * @since 1.7.0
+     */
+
+    public static Apfloat round(Apfloat x, long precision, RoundingMode roundingMode)
+        throws IllegalArgumentException, ArithmeticException, ApfloatRuntimeException
+    {
+        return RoundingHelper.round(x, precision, roundingMode);
+    }
+
+    /**
+     * Returns an apfloat whose value is <code>-x</code>.
+     *
+     * @deprecated Use {@link Apfloat#negate()}.
+     *
+     * @param x The argument.
+     *
+     * @return <code>-x</code>.
+     */
+
+    @Deprecated
+    public static Apfloat negate(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return x.negate();
+    }
+
+    /**
+     * Absolute value.
+     *
+     * @param x The argument.
+     *
+     * @return Absolute value of <code>x</code>.
+     */
+
+    public static Apfloat abs(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        if (x.signum() >= 0)
+        {
+            return x;
+        }
+        else
+        {
+            return x.negate();
+        }
+    }
+
+    /**
+     * Copy sign from one argument to another.
+     *
+     * @param x The value whose sign is to be adjusted.
+     * @param y The value whose sign is to be used.
+     *
+     * @return <code>x</code> with its sign changed to match the sign of <code>y</code>.
+     *
+     * @since 1.1
+     */
+
+    public static Apfloat copySign(Apfloat x, Apfloat y)
+        throws ApfloatRuntimeException
+    {
+        if (y.signum() == 0)
+        {
+            return y;
+        }
+        else if (x.signum() != y.signum())
+        {
+            return x.negate();
+        }
+        else
+        {
+            return x;
+        }
+    }
+
+    /**
+     * Multiply by a power of the radix.
+     *
+     * @param x The argument.
+     * @param scale The scaling factor.
+     *
+     * @return <code>x * x.radix()<sup>scale</sup></code>.
+     */
+
+    public static Apfloat scale(Apfloat x, long scale)
+        throws ApfloatRuntimeException
+    {
+        if (scale == 0 || x.signum() == 0)
+        {
+            return x;
+        }
+
+        Apfloat radix = new Apfloat(x.radix(), Apfloat.INFINITE, x.radix()),
+                result;
+
+        if ((Math.abs(scale) & 0xC000000000000000L) != 0)
+        {
+            // The exponent might overflow in the string or in intermediate calculations
+            Apfloat scaler1 = pow(radix, Math.abs(scale) >>> 1),
+                    scaler2 = ((scale & 1) == 0 ? scaler1 : scaler1.multiply(radix));
+            result = (scale >= 0 ? x.multiply(scaler1).multiply(scaler2) : x.divide(scaler1).divide(scaler2));
+        }
+        else if (x.radix() <= 14)
+        {
+            Apfloat scaler = new Apfloat("1e" + scale, Apfloat.INFINITE, x.radix());
+            result = x.multiply(scaler);
+        }
+        else
+        {
+            // "e" would be interpreted as a digit
+            Apfloat scaler = pow(radix, Math.abs(scale));
+            result = (scale >= 0 ? x.multiply(scaler) : x.divide(scaler));
+        }
+
+        return result;
+    }
+
+    /**
+     * Split to integer and fractional parts.
+     * The integer part is simply <code>i = floor(x)</code>.
+     * For the fractional part <code>f</code> the following is always true:<p>
+     *
+     * <code>0 &lt;= f &lt; 1</code>
+     *
+     * @param x The argument.
+     *
+     * @return An array of two apfloats, <code>[i, f]</code>, the first being the integer part and the last being the fractional part.
+     */
+
+    public static Apfloat[] modf(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        Apfloat[] result = new Apfloat[2];
+
+        result[0] = x.floor();
+        result[1] = (x.signum() >= 0 ? x.frac() : x.subtract(result[0]));
+
+        return result;
+    }
+
+    /**
+     * Returns x modulo y.<p>
+     *
+     * This function calculates the remainder <code>f</code> of <code>x / y</code>
+     * such that <code>x = i * y + f</code>, where <code>i</code> is an integer,
+     * <code>f</code> has the same sign as <code>x</code>,
+     * and the absolute value of <code>f</code> is less than the absolute value of <code>y</code>.<p>
+     *
+     * If <code>y</code> is zero, then zero is returned.
+     *
+     * @param x The dividend.
+     * @param y The divisor.
+     *
+     * @return The remainder when x is divided by y.
+     */
+
+    public static Apfloat fmod(Apfloat x, Apfloat y)
+        throws ApfloatRuntimeException
+    {
+        if (y.signum() == 0)
+        {
+            return y;                           // By definition
+        }
+        else if (x.signum() == 0)
+        {
+            // 0 % x = 0
+            return x;
+        }
+
+        long precision;
+        Apfloat t, a, b, tx, ty;
+
+        a = abs(x);
+        b = abs(y);
+
+        if (a.compareTo(b) < 0)
+        {
+            return x;                           // abs(x) < abs(y)
+        }
+        else if (x.precision() <= x.scale() - y.scale())                        // We now know that x.scale() >= y.scale()
+        {
+            return Apfloat.ZERO;                // Degenerate case; not enough precision to make any sense
+        }
+        else
+        {
+            precision = x.scale() - y.scale() + Apfloat.EXTRA_PRECISION;        // Some extra precision to avoid round-off errors
+        }
+
+        tx = x.precision(precision);
+        ty = y.precision(precision);
+
+        t = tx.divide(ty).truncate();           // Approximate division
+
+        precision = Math.min(Util.ifFinite(y.precision(), y.precision() + x.scale() - y.scale()), x.precision());
+
+        tx = x.precision(precision);
+        ty = y.precision(precision);
+
+        a = abs(tx).subtract(abs(t.multiply(ty)));
+        b = abs(ty);
+
+        if (a.compareTo(b) >= 0)                // Fix division round-off error
+        {
+            a = a.subtract(b);
+        }
+        else if (a.signum() < 0)                // Fix division round-off error
+        {
+            a = a.add(b);
+        }
+
+        t = copySign(a, x);
+
+        return t;
+    }
+
+    /**
+     * Fused multiply-add. Calculates <code>a * b + c * d</code>
+     * so that the precision used in the multiplications is only
+     * what is needed for the end result. Performance can this way
+     * be better than by calculating <code>a.multiply(b).add(c.multiply(d))</code>.
+     *
+     * @param a First argument.
+     * @param b Second argument.
+     * @param c Third argument.
+     * @param d Fourth argument.
+     *
+     * @return <code>a * b + c * d</code>.
+     */
+
+    public static Apfloat multiplyAdd(Apfloat a, Apfloat b, Apfloat c, Apfloat d)
+        throws ApfloatRuntimeException
+    {
+        return multiplyAddOrSubtract(a, b, c, d, false);
+    }
+
+    /**
+     * Fused multiply-subtract. Calculates <code>a * b - c * d</code>
+     * so that the precision used in the multiplications is only
+     * what is needed for the end result. Performance can this way
+     * be better than by calculating <code>a.multiply(b).subtract(c.multiply(d))</code>.
+     *
+     * @param a First argument.
+     * @param b Second argument.
+     * @param c Third argument.
+     * @param d Fourth argument.
+     *
+     * @return <code>a * b - c * d</code>.
+     */
+
+    public static Apfloat multiplySubtract(Apfloat a, Apfloat b, Apfloat c, Apfloat d)
+        throws ApfloatRuntimeException
+    {
+        return multiplyAddOrSubtract(a, b, c, d, true);
+    }
+
+    private static Apfloat multiplyAddOrSubtract(Apfloat a, Apfloat b, Apfloat c, Apfloat d, boolean subtract)
+        throws ApfloatRuntimeException
+    {
+        long[] precisions;
+        Apfloat ab, cd;
+
+        precisions = ApfloatHelper.getMatchingPrecisions(a, b, c, d);
+        if (precisions[0] == 0)
+        {
+            ab = Apfloat.ZERO;
+        }
+        else
+        {
+            a = a.precision(precisions[0]);
+            b = b.precision(precisions[0]);
+            ab = a.multiply(b);
+        }
+        if (precisions[1] == 0)
+        {
+            cd = Apfloat.ZERO;
+        }
+        else
+        {
+            c = c.precision(precisions[1]);
+            d = d.precision(precisions[1]);
+            cd = c.multiply(d);
+        }
+
+        Apfloat result = (subtract ? ab.subtract(cd) : ab.add(cd));
+
+        return (result.signum() == 0 ? result : result.precision(precisions[2]));
+    }
+
+    /**
+     * Arithmetic-geometric mean.
+     *
+     * @param a First argument.
+     * @param b Second argument.
+     *
+     * @return Arithmetic-geometric mean of a and b.
+     */
+
+    public static Apfloat agm(Apfloat a, Apfloat b)
+        throws ApfloatRuntimeException
+    {
+        if (a.signum() == 0 || b.signum() == 0)         // Would not converge quadratically
+        {
+            return Apfloat.ZERO;
+        }
+
+        long workingPrecision = Math.min(a.precision(), b.precision()),
+             targetPrecision = Math.max(a.precision(), b.precision());
+
+        if (workingPrecision == Apfloat.INFINITE)
+        {
+            throw new InfiniteExpansionException("Cannot calculate agm to infinite precision");
+        }
+
+        // Some extra precision is required for the algorithm to work accurately
+        workingPrecision = ApfloatHelper.extendPrecision(workingPrecision);
+        a = ApfloatHelper.ensurePrecision(a, workingPrecision);
+        b = ApfloatHelper.ensurePrecision(b, workingPrecision);
+
+        long precision = 0,
+             halfWorkingPrecision = (workingPrecision + 1) / 2;
+        final long CONVERGING = 1000;           // Arbitrarily chosen value...
+        Apfloat two = new Apfloat(2, Apfloat.INFINITE, a.radix());
+
+        // First check convergence
+        while (precision < CONVERGING && precision < halfWorkingPrecision)
+        {
+            Apfloat t = a.add(b).divide(two);
+            b = sqrt(a.multiply(b));
+            a = t;
+
+            // Conserve precision in case of accumulating round-off errors
+            a = ApfloatHelper.ensurePrecision(a, workingPrecision);
+            b = ApfloatHelper.ensurePrecision(b, workingPrecision);
+
+            precision = a.equalDigits(b);
+        }
+
+        // Now we know quadratic convergence
+        while (precision <= halfWorkingPrecision)
+        {
+            Apfloat t = a.add(b).divide(two);
+            b = sqrt(a.multiply(b));
+            a = t;
+
+            // Conserve precision in case of accumulating round-off errors
+            a = ApfloatHelper.ensurePrecision(a, workingPrecision);
+            b = ApfloatHelper.ensurePrecision(b, workingPrecision);
+
+            precision *= 2;
+        }
+
+        return a.add(b).divide(two).precision(targetPrecision);
+    }
+
+    /**
+     * Calculates &pi;. Uses default radix.
+     *
+     * @param precision Number of digits of &pi; to calculate.
+     *
+     * @return &pi; accurate to <code>precision</code> digits, in the default radix.
+     *
+     * @exception java.lang.NumberFormatException If the default radix is not valid.
+     * @exception java.lang.IllegalArgumentException In case the precision is invalid.
+     */
+
+    public static Apfloat pi(long precision)
+        throws IllegalArgumentException, NumberFormatException, ApfloatRuntimeException
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        int radix = ctx.getDefaultRadix();
+
+        return pi(precision, radix);
+    }
+
+    /**
+     * Calculates &pi;.
+     *
+     * @param precision Number of digits of &pi; to calculate.
+     * @param radix The radix in which the number should be presented.
+     *
+     * @return &pi; accurate to <code>precision</code> digits, in base <code>radix</code>.
+     *
+     * @exception java.lang.NumberFormatException If the radix is not valid.
+     * @exception java.lang.IllegalArgumentException In case the precision is invalid.
+     */
+
+    public static Apfloat pi(long precision, int radix)
+        throws IllegalArgumentException, NumberFormatException, ApfloatRuntimeException
+    {
+        if (precision <= 0)
+        {
+            throw new IllegalArgumentException("Precision " + precision + " is not positive");
+        }
+        else if (precision == Apfloat.INFINITE)
+        {
+            throw new InfiniteExpansionException("Cannot calculate pi to infinite precision");
+        }
+
+        // Get synchronization lock - getting the lock is also synchronized
+        Integer radixKey = getRadixPiKey(new Integer(radix));   // Use new Integer since we synchronize on it; Integer.valueOf() could be shared instance
+
+        Apfloat pi;
+
+        // Synchronize getting pre-calculated pi by radix key
+        // - two threads won't try to calculate it at the same time
+        // - doesn't block getting it for other radixes
+        synchronized (radixKey)
+        {
+            pi = ApfloatMath.radixPi.get(radixKey);
+
+            if (pi == null || pi.precision() < precision)
+            {
+                pi = calculatePi(precision, radixKey);
+            }
+            else
+            {
+                pi = pi.precision(precision);
+            }
+        }
+
+        return pi;
+    }
+
+    // Get shared radix key for synchronizing getting and calculating the pi related constants
+    private static Integer getRadixPiKey(Integer radix)
+    {
+        Integer radixKey = ApfloatMath.radixPiKeys.putIfAbsent(radix, radix);
+        if (radixKey == null)
+        {
+            radixKey = radix;
+        }
+
+        return radixKey;
+    }
+
+    /**
+     * Simple JavaBean to hold one apfloat. This class can
+     * also be thought of as a pointer to an apfloat.
+     */
+
+    private static class ApfloatHolder
+    {
+        public ApfloatHolder()
+        {
+            this(null);
+        }
+
+        public ApfloatHolder(Apfloat apfloat)
+        {
+            this.apfloat = apfloat;
+        }
+
+        public Apfloat getApfloat()
+        {
+            return this.apfloat;
+        }
+
+        public void setApfloat(Apfloat apfloat)
+        {
+            this.apfloat = apfloat;
+        }
+
+        private Apfloat apfloat;
+    }
+
+    private static class PiCalculator
+    {
+        public PiCalculator(int radix)
+            throws ApfloatRuntimeException
+        {
+            this.A = new Apfloat(13591409, Apfloat.INFINITE, radix);
+            this.B = new Apfloat(545140134, Apfloat.INFINITE, radix);
+            this.J = new Apfloat(10939058860032000L, Apfloat.INFINITE, radix);
+            this.ONE = new Apfloat(1, Apfloat.INFINITE, radix);
+            this.TWO = new Apfloat(2, Apfloat.INFINITE, radix);
+            this.FIVE = new Apfloat(5, Apfloat.INFINITE, radix);
+            this.SIX = new Apfloat(6, Apfloat.INFINITE, radix);
+            this.radix = radix;
+        }
+
+        private Apfloat a(long n)
+            throws ApfloatRuntimeException
+        {
+            Apfloat s = new Apfloat(n, Apfloat.INFINITE, this.radix),
+                    v = this.A.add(this.B.multiply(s));
+
+            v = ((n & 1) == 0 ? v : v.negate());
+
+            return v;
+        }
+
+        private Apfloat p(long n)
+            throws ApfloatRuntimeException
+        {
+            Apfloat v;
+
+            if (n == 0)
+            {
+                v = this.ONE;
+            }
+            else
+            {
+                Apfloat f = new Apfloat(n, Apfloat.INFINITE, this.radix),
+                        sixf = this.SIX.multiply(f);
+
+                v = sixf.subtract(this.ONE).multiply(this.TWO.multiply(f).subtract(this.ONE)).multiply(sixf.subtract(this.FIVE));
+            }
+
+            return v;
+        }
+
+        private Apfloat q(long n)
+            throws ApfloatRuntimeException
+        {
+            Apfloat v;
+
+            if (n == 0)
+            {
+                v = this.ONE;
+            }
+            else
+            {
+                Apfloat f = new Apfloat(n, Apfloat.INFINITE, this.radix);
+
+                v = this.J.multiply(f).multiply(f).multiply(f);
+            }
+
+            return v;
+        }
+
+        public void r(long n1, long n2, ApfloatHolder T, ApfloatHolder Q, ApfloatHolder P)
+            throws ApfloatRuntimeException
+        {
+            assert (n1 != n2);
+            long length = n2 - n1;
+
+            if (length == 1)
+            {
+                Apfloat p0 = p(n1);
+
+                T.setApfloat(a(n1).multiply(p0));
+                Q.setApfloat(q(n1));
+                P.setApfloat(p0);
+            }
+            else
+            {
+                long nMiddle = (n1 + n2) / 2;
+                ApfloatHolder LT = new ApfloatHolder(),
+                              LQ = new ApfloatHolder(),
+                              LP = new ApfloatHolder();
+
+                r(n1, nMiddle, LT, LQ, LP);
+                r(nMiddle, n2, T, Q, P);
+
+                T.setApfloat(Q.getApfloat().multiply(LT.getApfloat()).add(LP.getApfloat().multiply(T.getApfloat())));
+                Q.setApfloat(LQ.getApfloat().multiply(Q.getApfloat()));
+                P.setApfloat(LP.getApfloat().multiply(P.getApfloat()));
+            }
+        }
+
+        private final Apfloat A;
+        private final Apfloat B;
+        private final Apfloat J;
+        private final Apfloat ONE;
+        private final Apfloat TWO;
+        private final Apfloat FIVE;
+        private final Apfloat SIX;
+        private int radix;
+    }
+
+    // Perform actual calculation of pi for radix, and store the result to pre-calulation maps.
+    // Uses the Chudnovskys' binary splitting algorithm.
+    // Uses previously calculated terms (if such exist) to improve the precision of the calculation.
+    private static Apfloat calculatePi(long precision, Integer radixKey)
+        throws ApfloatRuntimeException
+    {
+        int radix = radixKey;
+        PiCalculator piCalculator = ApfloatMath.radixPiCalculator.get(radixKey);
+        if (piCalculator == null)
+        {
+            piCalculator = new PiCalculator(radix);
+            ApfloatMath.radixPiCalculator.put(radixKey, piCalculator);
+        }
+
+        Apfloat LT,
+                LQ,
+                LP,
+                inverseRoot;
+
+        ApfloatHolder RT = new ApfloatHolder(),
+                      RQ = new ApfloatHolder(),
+                      RP = new ApfloatHolder();
+
+        // Perform the calculation of T, Q and P to infinite precision
+        // to make possible to use them later for further calculations
+
+        long neededTerms = (long) ((double) precision * Math.log((double) radix) / 32.65445004177),
+             workingPrecision = ApfloatHelper.extendPrecision(precision);   // To avoid cumulative round-off errors
+
+        Long terms = ApfloatMath.radixPiTerms.get(radixKey);
+        LT = ApfloatMath.radixPiT.get(radixKey);
+        LQ = ApfloatMath.radixPiQ.get(radixKey);
+        LP = ApfloatMath.radixPiP.get(radixKey);
+        inverseRoot = ApfloatMath.radixPiInverseRoot.get(radixKey);
+
+        if (terms != null && LT != null && LQ != null && LP != null && inverseRoot != null)
+        {
+            // Some terms have been calculated already previously and cached
+            long currentTerms = terms;
+
+            // Check if there actually are more needed terms or if the needed
+            // extra precision is just a few digits achievable with current terms
+            if (currentTerms != neededTerms + 1)
+            {
+                piCalculator.r(currentTerms, neededTerms + 1, RT, RQ, RP);
+
+                LT = RQ.getApfloat().multiply(LT).add(LP.multiply(RT.getApfloat()));
+                LQ = LQ.multiply(RQ.getApfloat());
+                LP = LP.multiply(RP.getApfloat());
+            }
+
+            // Improve the inverse root value from the current precision
+            inverseRoot = inverseRoot(new Apfloat(1823176476672000L, workingPrecision, radix), 2, workingPrecision, inverseRoot);
+        }
+        else
+        {
+            piCalculator.r(0, neededTerms + 1, RT, RQ, RP);
+
+            LT = RT.getApfloat();
+            LQ = RQ.getApfloat();
+            LP = RP.getApfloat();
+
+            inverseRoot = inverseRoot(new Apfloat(1823176476672000L, workingPrecision, radix), 2);
+        }
+
+        Apfloat pi = inverseRoot(inverseRoot.multiply(LT), 1).multiply(LQ);
+
+        // Limit precisions to actual after extended working precisions
+        inverseRoot = inverseRoot.precision(precision);
+        pi = pi.precision(precision);
+
+        // Put the updated values to the caches
+        ApfloatMath.radixPiT.put(radixKey, LT);
+        ApfloatMath.radixPiQ.put(radixKey, LQ);
+        ApfloatMath.radixPiP.put(radixKey, LP);
+        ApfloatMath.radixPiInverseRoot.put(radixKey, inverseRoot);
+        ApfloatMath.radixPiTerms.put(radixKey, neededTerms + 1);
+        ApfloatMath.radixPi.put(radixKey, pi);
+
+        return pi;
+    }
+
+    /**
+     * Natural logarithm.<p>
+     *
+     * The logarithm is calculated using the arithmetic-geometric mean.
+     * See the Borweins' book for the formula.
+     *
+     * @param x The argument.
+     *
+     * @return Natural logarithm of <code>x</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>x &lt;= 0</code>.
+     */
+
+    public static Apfloat log(Apfloat x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return log(x, true);
+    }
+
+    /**
+     * Logarithm in arbitrary base.<p>
+     *
+     * The logarithm is calculated using the arithmetic-geometric mean.
+     * See the Borweins' book for the formula.
+     *
+     * @param x The argument.
+     * @param b The base.
+     *
+     * @return Base-<code>b</code> logarithm of <code>x</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>x &lt;= 0</code> or <code>b &lt;= 0</code>.
+     *
+     * @since 1.6
+     */
+
+    public static Apfloat log(Apfloat x, Apfloat b)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        long targetPrecision = Math.min(x.precision(), b.precision());
+
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, x.radix());
+        long xPrecision = Util.ifFinite(targetPrecision, targetPrecision + one.equalDigits(x)); // If the log() argument is close to 1, the result is less accurate
+        x = x.precision(Math.min(x.precision(), xPrecision));
+
+        long bPrecision = Util.ifFinite(targetPrecision, targetPrecision + one.equalDigits(b));
+        b = b.precision(Math.min(b.precision(), bPrecision));
+
+        return log(x, false).divide(log(b, false));
+    }
+
+    private static Apfloat log(Apfloat x, boolean multiplyByPi)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (x.signum() <= 0)
+        {
+            throw new ArithmeticException("Logarithm of " + (x.signum() == 0 ? "zero" : "negative number; result would be complex"));
+        }
+        else if (x.equals(Apfloat.ONE))
+        {
+            return Apfloat.ZERO;
+        }
+
+        // Calculate the log using 1 / radix <= x < 1 and the log addition formula
+        // because the agm converges badly for big x.
+
+        long targetPrecision = x.precision();
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, x.radix());
+        long finalPrecision = Util.ifFinite(targetPrecision, targetPrecision - one.equalDigits(x));     // If the argument is close to 1, the result is less accurate
+
+        long originalScale = x.scale();
+
+        x = scale(x, -originalScale);   // Set x's scale to zero
+
+        Apfloat radixPower;
+        if (originalScale == 0)
+        {
+            radixPower = Apfloat.ZERO;
+        }
+        else
+        {
+            Apfloat logRadix = ApfloatHelper.extendPrecision(logRadix(targetPrecision, x.radix(), multiplyByPi));
+            radixPower = new Apfloat(originalScale, Apfloat.INFINITE, x.radix()).multiply(logRadix);
+        }
+
+        return ApfloatHelper.extendPrecision(rawLog(x, multiplyByPi)).add(radixPower).precision(finalPrecision);
+    }
+
+    // Raw logarithm, regardless of x
+    // Doesn't work for big x, but is faster if used alone for small numbers
+    private static Apfloat rawLog(Apfloat x, boolean multiplyByPi)
+        throws ApfloatRuntimeException
+    {
+        assert (x.signum() > 0);                                        // Must be real logarithm
+
+        long targetPrecision = x.precision();
+
+        if (targetPrecision == Apfloat.INFINITE)
+        {
+            throw new InfiniteExpansionException("Cannot calculate logarithm to infinite precision");
+        }
+
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, x.radix());
+
+        final int EXTRA_PRECISION = 25;
+
+        long workingPrecision = ApfloatHelper.extendPrecision(targetPrecision),
+             n = targetPrecision / 2 + EXTRA_PRECISION;                 // Very rough estimate
+
+        x = ApfloatHelper.extendPrecision(x, EXTRA_PRECISION);
+
+        Apfloat e = one.precision(workingPrecision);
+        e = scale(e, -n);
+        x = scale(x, -n);
+
+        Apfloat agme = ApfloatHelper.extendPrecision(agm(one, e)),
+                agmex = ApfloatHelper.extendPrecision(agm(one, x));
+
+        Apfloat log = agmex.subtract(agme).precision(workingPrecision);
+        if (multiplyByPi)
+        {
+            Apfloat pi = ApfloatHelper.extendPrecision(pi(targetPrecision, x.radix()));
+            log = pi.multiply(log);
+        }
+        log = log.divide(new Apfloat(2, Apfloat.INFINITE, x.radix()).multiply(agme).multiply(agmex));
+
+        return log.precision(targetPrecision);
+    }
+
+    // Get shared radix key for synchronizing getting and calculating the logarithm related constants
+    private static Integer getRadixLogKey(Integer radix)
+    {
+        Integer radixKey = ApfloatMath.radixLogKeys.putIfAbsent(radix, radix);
+        if (radixKey == null)
+        {
+            radixKey = radix;
+        }
+
+        return radixKey;
+    }
+
+    /**
+     * Gets or calculates logarithm of a radix to required precision.
+     * The calculated value is stored in a cache for later usage.
+     *
+     * @param precision The needed precision.
+     * @param radix The radix.
+     *
+     * @return Natural logarithm of <code>radix</code> to the specified precision.
+     *
+     * @exception java.lang.NumberFormatException If the radix is invalid.
+     */
+
+    public static Apfloat logRadix(long precision, int radix)
+        throws ApfloatRuntimeException
+    {
+        return logRadix(precision, radix, true);
+    }
+
+    private static Apfloat logRadix(long precision, int radix, boolean multiplyByPi)
+        throws ApfloatRuntimeException
+    {
+        // Get synchronization lock - getting the lock is also synchronized
+        Integer radixKey = getRadixLogKey(new Integer(radix));      // Use new Integer since we synchronize on it; Integer.valueOf() could be shared instance
+
+        Apfloat logRadix;
+
+        // Synchronize getting pre-calculated log by radix key
+        // - two threads won't try to calculate it at the same time
+        // - doesn't block getting it for other radixes
+        synchronized (radixKey)
+        {
+            Map<Integer, Apfloat> cache = (multiplyByPi ? ApfloatMath.radixLogPi : ApfloatMath.radixLog);     // Which cache to use, the one multiplied by pi or not
+            logRadix = cache.get(radixKey);
+
+            if (logRadix == null || logRadix.precision() < precision)
+            {
+                if (multiplyByPi)
+                {
+                    // We want the multiplied-by-pi version so get first the not-multiplied-by-pi version
+                    logRadix = ApfloatHelper.extendPrecision(logRadix(precision, radix, false));
+                    Apfloat pi = ApfloatHelper.extendPrecision(pi(precision, radix));
+                    logRadix = logRadix.multiply(pi).precision(precision);
+                }
+                else
+                {
+                    Apfloat f = new Apfloat("0.1", precision, radix);
+
+                    logRadix = rawLog(f, multiplyByPi).negate();
+                }
+
+                cache.put(radixKey, logRadix);
+            }
+            else
+            {
+                logRadix = logRadix.precision(precision);
+            }
+        }
+
+        return logRadix;
+    }
+
+    /**
+     * Exponent function.
+     * Calculated using Newton's iteration for the inverse of logarithm.
+     *
+     * @param x The argument.
+     *
+     * @return <code>e<sup>x</sup></code>.
+     */
+
+    public static Apfloat exp(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        int radix = x.radix();
+
+        if (x.signum() == 0)
+        {
+            return new Apfloat(1, Apfloat.INFINITE, radix);
+        }
+
+        long targetPrecision = x.precision(),
+             precision,
+             doublePrecision = ApfloatHelper.getDoublePrecision(radix);
+
+        // If the argument is close to 0, the result is more accurate
+        targetPrecision = Util.ifFinite(targetPrecision, targetPrecision + Math.max(1 - x.scale(), 0));
+
+        if (targetPrecision == Apfloat.INFINITE)
+        {
+            throw new InfiniteExpansionException("Cannot calculate exponent to infinite precision");
+        }
+        else if (x.compareTo(new Apfloat((double) Long.MAX_VALUE * Math.log((double) radix), doublePrecision, radix)) >= 0)
+        {
+            throw new OverflowException("Overflow");
+        }
+        else if (x.compareTo(new Apfloat((double) Long.MIN_VALUE * Math.log((double) radix), doublePrecision, radix)) <= 0)
+        {
+            // Underflow
+
+            return Apfloat.ZERO;
+        }
+        else if (x.scale() <= Long.MIN_VALUE / 2 + Apfloat.EXTRA_PRECISION)
+        {
+            // Taylor series: exp(x) = 1 + x + x^2/2 + ...
+
+            return new Apfloat(1, Apfloat.INFINITE, radix).add(x).precision(Apfloat.INFINITE);
+        }
+
+        Apfloat result;
+
+        if (x.scale() < -doublePrecision / 2)
+        {
+            // Taylor series: exp(x) = 1 + x + x^2/2 + ...
+
+            precision = -2 * x.scale();
+            result = new Apfloat(1, precision, radix).add(x);
+        }
+        else
+        {
+            // Approximate starting value for iteration
+
+            // An overflow or underflow should not occur
+            long scaledXPrecision = Math.max(0, x.scale()) + doublePrecision;
+            Apfloat logRadix = log(new Apfloat((double) radix, scaledXPrecision, radix)),
+                    scaledX = x.precision(scaledXPrecision).divide(logRadix),
+                    integerPart = scaledX.truncate(),
+                    fractionalPart = scaledX.frac();
+
+            result = new Apfloat(Math.pow((double) radix, fractionalPart.doubleValue()), doublePrecision, radix);
+            result = scale(result, integerPart.longValue());
+
+            if (result.signum() == 0) {
+                // Underflow
+                return Apfloat.ZERO;
+            }
+
+            precision = doublePrecision;
+        }
+
+        int iterations = 0;
+
+        // Compute total number of iterations
+        for (long maxPrec = precision; maxPrec < targetPrecision; maxPrec <<= 1)
+        {
+            iterations++;
+        }
+
+        int precisingIteration = iterations;
+
+        // Check where the precising iteration should be done
+        for (long minPrec = precision; precisingIteration > 0; precisingIteration--, minPrec <<= 1)
+        {
+            if ((minPrec - Apfloat.EXTRA_PRECISION) << precisingIteration >= targetPrecision)
+            {
+                break;
+            }
+        }
+
+        if (iterations > 0)
+        {
+            // Precalculate the needed values once to the required precision
+            logRadix(targetPrecision, radix);
+        }
+
+        x = ApfloatHelper.extendPrecision(x);
+
+        // Newton's iteration
+        while (iterations-- > 0)
+        {
+            precision *= 2;
+            result = result.precision(Math.min(precision, targetPrecision));
+
+            Apfloat t = log(result);
+            t = lastIterationExtendPrecision(iterations, precisingIteration, t);
+            t = x.subtract(t);
+
+            if (iterations < precisingIteration)
+            {
+                t = t.precision(precision / 2);
+            }
+
+            result = lastIterationExtendPrecision(iterations, precisingIteration, result);
+            result = result.add(result.multiply(t));
+
+            // Precising iteration
+            if (iterations == precisingIteration)
+            {
+                t = log(result);
+                t = lastIterationExtendPrecision(iterations, -1, t);
+
+                result = lastIterationExtendPrecision(iterations, -1, result);
+                result = result.add(result.multiply(x.subtract(t)));
+            }
+        }
+
+        return result.precision(targetPrecision);
+    }
+
+    /**
+     * Arbitrary power. Calculated using <code>log()</code> and <code>exp()</code>.<p>
+     *
+     * This method doesn't calculate the result properly if <code>x</code> is negative
+     * and <code>y</code> is an integer. For that you should use {@link #pow(Apfloat,long)}.
+     *
+     * @param x The base.
+     * @param y The exponent.
+     *
+     * @return <code>x<sup>y</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If both <code>x</code> and <code>y</code> are zero, or <code>x</code> is negative.
+     */
+
+    public static Apfloat pow(Apfloat x, Apfloat y)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        long targetPrecision = Math.min(x.precision(), y.precision());
+
+        Apfloat result = ApfloatHelper.checkPow(x, y, targetPrecision);
+        if (result != null)
+        {
+            return result;
+        }
+
+        // Try to precalculate the needed values just once to the required precision,
+        // this may not work too efficiently if x is close to 1 or y is close to zero
+        logRadix(targetPrecision, x.radix());
+
+        // Limits precision for log() but may be sub-optimal; precision could be limited more
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, x.radix());
+        targetPrecision = Util.ifFinite(targetPrecision, targetPrecision + one.equalDigits(x)); // If the log() argument is close to 1, the result is less accurate
+        x = x.precision(Math.min(x.precision(), targetPrecision));
+
+        result = log(x);
+        long intermediatePrecision = Math.min(y.precision(), result.precision());
+        result = ApfloatHelper.extendPrecision(result);
+        result = ApfloatHelper.extendPrecision(y).multiply(result);
+        result = exp(result.precision(intermediatePrecision));
+
+        return result;
+    }
+
+    /**
+     * Inverse hyperbolic cosine. Calculated using <code>log()</code>.
+     *
+     * @param x The argument.
+     *
+     * @return Inverse hyperbolic cosine of <code>x</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>x &lt; 1</code>.
+     */
+
+    public static Apfloat acosh(Apfloat x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, x.radix());
+
+        return log(x.add(sqrt(x.multiply(x).subtract(one))));
+    }
+
+    /**
+     * Inverse hyperbolic sine. Calculated using <code>log()</code>.
+     *
+     * @param x The argument.
+     *
+     * @return Inverse hyperbolic sine of <code>x</code>.
+     */
+
+    public static Apfloat asinh(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, x.radix());
+
+        if (x.signum() >= 0)
+        {
+            return log(sqrt(x.multiply(x).add(one)).add(x));
+        }
+        else
+        {
+            return log(sqrt(x.multiply(x).add(one)).subtract(x)).negate();
+        }
+    }
+
+    /**
+     * Inverse hyperbolic tangent. Calculated using <code>log()</code>.
+     *
+     * @param x The argument.
+     *
+     * @return Inverse hyperbolic tangent of <code>x</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>abs(x) &gt;= 1</code>.
+     */
+
+    public static Apfloat atanh(Apfloat x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, x.radix()),
+                two = new Apfloat(2, Apfloat.INFINITE, x.radix());
+
+        return log(one.add(x).divide(one.subtract(x))).divide(two);
+    }
+
+    /**
+     * Hyperbolic cosine. Calculated using <code>exp()</code>.
+     *
+     * @param x The argument.
+     *
+     * @return Hyperbolic cosine of <code>x</code>.
+     */
+
+    public static Apfloat cosh(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        Apfloat y = exp(x),
+                one = new Apfloat(1, Apfloat.INFINITE, x.radix()),
+                two = new Apfloat(2, Apfloat.INFINITE, x.radix());
+
+        return y.add(one.divide(y)).divide(two);
+    }
+
+    /**
+     * Hyperbolic sine. Calculated using <code>exp()</code>.
+     *
+     * @param x The argument.
+     *
+     * @return Hyperbolic sine of <code>x</code>.
+     */
+
+    public static Apfloat sinh(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        Apfloat y = exp(x),
+                one = new Apfloat(1, Apfloat.INFINITE, x.radix()),
+                two = new Apfloat(2, Apfloat.INFINITE, x.radix());
+
+        return y.subtract(one.divide(y)).divide(two);
+    }
+
+    /**
+     * Hyperbolic tangent. Calculated using <code>exp()</code>.
+     *
+     * @param x The argument.
+     *
+     * @return Hyperbolic tangent of <code>x</code>.
+     */
+
+    public static Apfloat tanh(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, x.radix()),
+                two = new Apfloat(2, Apfloat.INFINITE, x.radix()),
+                y = exp(two.multiply(abs(x)));
+
+        y = y.subtract(one).divide(y.add(one));
+        return (x.signum() < 0 ? y.negate() : y);
+    }
+
+    /**
+     * Inverse cosine. Calculated using complex functions.
+     *
+     * @param x The argument.
+     *
+     * @return Inverse cosine of <code>x</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>abs(x) &gt; 1</code>.
+     */
+
+    public static Apfloat acos(Apfloat x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, x.radix());
+        Apcomplex i = new Apcomplex(Apfloat.ZERO, one);
+
+        return ApcomplexMath.log(x.add(i.multiply(sqrt(one.subtract(x.multiply(x)))))).imag();
+    }
+
+    /**
+     * Inverse sine. Calculated using complex functions.
+     *
+     * @param x The argument.
+     *
+     * @return Inverse sine of <code>x</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>abs(x) &gt; 1</code>.
+     */
+
+    public static Apfloat asin(Apfloat x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, x.radix());
+        Apcomplex i = new Apcomplex(Apfloat.ZERO, one);
+
+        return ApcomplexMath.log(sqrt(one.subtract(x.multiply(x))).subtract(i.multiply(x))).imag().negate();
+    }
+
+    /**
+     * Inverse tangent. Calculated using complex functions.
+     *
+     * @param x The argument.
+     *
+     * @return Inverse tangent of <code>x</code>.
+     */
+
+    public static Apfloat atan(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        Apfloat one = new Apfloat(1, Apfloat.INFINITE, x.radix()),
+                two = new Apfloat(2, Apfloat.INFINITE, x.radix());
+        Apcomplex i = new Apcomplex(Apfloat.ZERO, one);
+
+        return ApcomplexMath.log(i.subtract(x).divide(i.add(x))).imag().divide(two);
+    }
+
+    /**
+     * Converts cartesian coordinates to polar coordinates. Calculated using complex functions.<p>
+     *
+     * Computes the phase angle by computing an arc tangent of <code>x/y</code> in the range of -&pi; &lt; angle &lt;= &pi;.
+     *
+     * @param x The argument.
+     * @param y The argument.
+     *
+     * @return The angle of the point <code>(y, x)</code> in the plane.
+     *
+     * @exception java.lang.ArithmeticException If <code>x</code> and <code>y</code> are both zero.
+     */
+
+    public static Apfloat atan2(Apfloat x, Apfloat y)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (y.signum() == 0)
+        {
+            if (x.signum() == 0)
+            {
+                throw new ArithmeticException("Angle of (0, 0)");
+            }
+
+            Apfloat pi = pi(x.precision(), x.radix()),
+                    two = new Apfloat(2, Apfloat.INFINITE, x.radix());
+
+            return new Apfloat(x.signum(), Apfloat.INFINITE, x.radix()).multiply(pi).divide(two);
+        }
+        else if (x.signum() == 0)
+        {
+            if (y.signum() > 0)
+            {
+                return Apfloat.ZERO;
+            }
+
+            return pi(y.precision(), y.radix());
+        }
+        else if (Math.min(x.precision(), y.precision()) == Apfloat.INFINITE)
+        {
+            throw new InfiniteExpansionException("Cannot calculate atan2 to infinite precision");
+        }
+        else
+        {
+            long maxScale = Math.max(x.scale(), y.scale());
+
+            x = scale(x, -maxScale);    // Now neither x nor y is zero
+            y = scale(y, -maxScale);
+
+            return ApcomplexMath.log(new Apcomplex(y, x)).imag();
+        }
+    }
+
+    /**
+     * Cosine. Calculated using complex functions.
+     *
+     * @param x The argument (in radians).
+     *
+     * @return Cosine of <code>x</code>.
+     */
+
+    public static Apfloat cos(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return ApcomplexMath.exp(new Apcomplex(Apfloat.ZERO, x)).real();
+    }
+
+    /**
+     * Sine. Calculated using complex functions.
+     *
+     * @param x The argument (in radians).
+     *
+     * @return Sine of <code>x</code>.
+     */
+
+    public static Apfloat sin(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return ApcomplexMath.exp(new Apcomplex(Apfloat.ZERO, x)).imag();
+    }
+
+    /**
+     * Tangent. Calculated using complex functions.
+     *
+     * @param x The argument (in radians).
+     *
+     * @return Tangent of <code>x</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>x</code> is &pi;/2 + n &pi; where n is an integer.
+     */
+
+    public static Apfloat tan(Apfloat x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        Apcomplex w = ApcomplexMath.exp(new Apcomplex(Apfloat.ZERO, x));
+
+        return w.imag().divide(w.real());
+    }
+
+    /**
+     * Lambert W function. The W function gives the solution to the equation
+     * <code>W e<sup>W</sup> = x</code>. Also known as the product logarithm.<p>
+     *
+     * This function only gives the solution to the principal branch, W<sub>0</sub>.
+     * For the real-valued W<sub>-1</sub> branch, use {@link ApcomplexMath#w(Apcomplex,long)}.
+     *
+     * @param x The argument.
+     *
+     * @return <code>W<sub>0</sub>(x)</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>x</code> is less than -1/e.
+     *
+     * @since 1.8.0
+     */
+
+    public static Apfloat w(Apfloat x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return LambertWHelper.w(x);
+    }
+
+    /**
+     * Converts an angle measured in radians to degrees.<p>
+     *
+     * @param x The angle, in radians.
+     *
+     * @return The angle in degrees.
+     *
+     * @since 1.8.0
+     */
+
+    public static Apfloat toDegrees(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return x.multiply(new Apfloat(180, Apfloat.INFINITE, x.radix())).divide(pi(x.precision(), x.radix()));
+    }
+
+    /**
+     * Converts an angle measured in degrees to radians.<p>
+     *
+     * @param x The angle, in degrees.
+     *
+     * @return The angle in radians.
+     *
+     * @since 1.8.0
+     */
+
+    public static Apfloat toRadians(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return x.divide(new Apfloat(180, Apfloat.INFINITE, x.radix())).multiply(pi(x.precision(), x.radix()));
+    }
+
+    /**
+     * Product of numbers.
+     * The precision used in the multiplications is only
+     * what is needed for the end result. This method may
+     * perform significantly better than simply multiplying
+     * the numbers sequentially.<p>
+     *
+     * If there are no arguments, the return value is <code>1</code>.
+     *
+     * @param x The argument(s).
+     *
+     * @return The product of the given numbers.
+     *
+     * @since 1.3
+     */
+
+    public static Apfloat product(Apfloat... x)
+        throws ApfloatRuntimeException
+    {
+        if (x.length == 0)
+        {
+            return Apfloat.ONE;
+        }
+
+        // Determine working precision
+        long maxPrec = Apfloat.INFINITE;
+        for (int i = 0; i < x.length; i++)
+        {
+            if (x[i].signum() == 0)
+            {
+                return Apfloat.ZERO;
+            }
+            maxPrec = Math.min(maxPrec, x[i].precision());
+        }
+
+        // Do not use x.clone() as the array might be of some subclass type, resulting in ArrayStoreException later
+        Apfloat[] tmp = new Apfloat[x.length];
+
+        // Add sqrt length digits for round-off errors
+        long extraPrec = (long) Math.sqrt((double) x.length),
+             destPrec = ApfloatHelper.extendPrecision(maxPrec, extraPrec);
+        for (int i = 0; i < x.length; i++)
+        {
+            tmp[i] = x[i].precision(destPrec);
+        }
+        x = tmp;
+
+        // Create a heap, ordered by size
+        final Queue<Apfloat> heap = new PriorityQueue<Apfloat>(x.length, new Comparator<Apfloat>()
+        {
+            public int compare(Apfloat x, Apfloat y)
+            {
+                long xSize = x.size(),
+                     ySize = y.size();
+                return (xSize < ySize ? -1 : (xSize > ySize ? 1 : 0));
+            }
+        });
+
+        // Perform the multiplications in parallel
+        ParallelHelper.ProductKernel<Apfloat> kernel = new ParallelHelper.ProductKernel<Apfloat>()
+        {
+            public void run(Queue<Apfloat> heap)
+            {
+                Apfloat a = heap.remove();
+                Apfloat b = heap.remove();
+                Apfloat c = a.multiply(b);
+                heap.add(c);
+            }
+        };
+        ParallelHelper.parallelProduct(x, heap, kernel);
+
+        return heap.remove().precision(maxPrec);
+    }
+
+    /**
+     * Sum of numbers.
+     * The precision used in the additions is only
+     * what is needed for the end result. This method may
+     * perform significantly better than simply adding
+     * the numbers sequentially.<p>
+     *
+     * If there are no arguments, the return value is <code>0</code>.
+     *
+     * @param x The argument(s).
+     *
+     * @return The sum of the given numbers.
+     *
+     * @since 1.3
+     */
+
+    public static Apfloat sum(Apfloat... x)
+        throws ApfloatRuntimeException
+    {
+        if (x.length == 0)
+        {
+            return Apfloat.ZERO;
+        }
+
+        // Determine working precision
+        long maxScale = -Apfloat.INFINITE,
+             maxPrec = Apfloat.INFINITE;
+        for (int i = 0; i < x.length; i++)
+        {
+            long oldScale = maxScale,
+                 oldPrec = maxPrec,
+                 newScale = x[i].scale(),
+                 newPrec = x[i].precision();
+            maxScale = Math.max(oldScale, newScale);
+            long oldScaleDiff = (maxScale - oldScale < 0 ? Apfloat.INFINITE : maxScale - oldScale),
+                 newScaleDiff = (maxScale - newScale < 0 ? Apfloat.INFINITE : maxScale - newScale);
+            maxPrec = Math.min(Util.ifFinite(oldPrec, oldPrec + oldScaleDiff),
+                               Util.ifFinite(newPrec, newPrec + newScaleDiff));
+        }
+
+        // Do not use x.clone() as the array might be of some subclass type, resulting in ArrayStoreException later
+        Apfloat[] tmp = new Apfloat[x.length];
+
+        for (int i = 0; i < x.length; i++)
+        {
+            long scale = x[i].scale(),
+                 scaleDiff = (maxScale - scale < 0 ? Apfloat.INFINITE : maxScale - scale),
+                 destPrec = (maxPrec - scaleDiff <= 0 ? 0 : Util.ifFinite(maxPrec, maxPrec - scaleDiff));
+            if (destPrec > 0)
+            {
+                tmp[i] = x[i].precision(destPrec);
+            }
+            else
+            {
+                tmp[i] = Apfloat.ZERO;
+            }
+        }
+        x = tmp;
+
+        // Sort by scale (might be mostly equal to size)
+        Comparator<Apfloat> comparator = new Comparator<Apfloat>()
+        {
+            public int compare(Apfloat x, Apfloat y)
+            {
+                long xScale = x.scale(),
+                     yScale = y.scale();
+                return (xScale < yScale ? -1 : (xScale > yScale ? 1 : 0));
+            }
+        };
+        Arrays.sort(x, comparator);
+
+        // The list of numbers to be added
+        List<Apfloat> list;
+
+        // If there are lots of numbers then use a fully parallel algorithm, for small sums the overhead is not worth it
+        // Also note that memory (or worse - disk) bandwidth is likely a bottleneck, preventing efficient parallelization
+        if (x.length >= 1000)
+        {
+            // Only add in parallel numbers, which are (probably) below the memory threshold in size
+            ApfloatContext ctx = ApfloatContext.getContext();
+            long maxSize = (long) (ctx.getMemoryThreshold() * 5.0 / Math.log((double) ctx.getDefaultRadix()));
+
+            // Create a queue of small numbers where the parallel algorithm can add and remove elements
+            final Queue<Apfloat> queue = new ConcurrentLinkedQueue<Apfloat>();
+
+            // The large numbers go to the list where they will be added using a single thread algorithm
+            list = new ArrayList<Apfloat>();
+
+            // Put all the numbers to either the parallel queue or single thread list
+            for (Apfloat a : x)
+            {
+                (a.size() <= maxSize ? queue : list).add(a);
+            }
+
+            Runnable runnable = new Runnable()
+            {
+                public void run()
+                {
+                    // Add numbers as long as there are any left in the queue
+                    Apfloat s = Apfloat.ZERO,
+                            a;
+                    while ((a = queue.poll()) != null)
+                    {
+                        s = s.add(a);
+                    }
+                    // Finally, put the sub-sum back in the queue
+                    queue.add(s);
+                }
+            };
+
+            // Run the runnable in multiple threads
+            ParallelHelper.runParallel(runnable);
+
+            // Put the remaining sub-sums to the list to be added once more
+            list.addAll(queue);
+
+            // Sort again the list as it has been now mixed up
+            Collections.sort(list, comparator);
+        }
+        else
+        {
+            // Single thread case - just add all the numbers
+            list = Arrays.asList(x);
+        }
+
+        // Add the remaining elements in the queue (all, for the single-thread case, and sub-sums for the parallel case)
+        Apfloat s = Apfloat.ZERO;
+        for (Apfloat a : list)
+        {
+            s = s.add(a);
+        }
+
+        return s;
+    }
+
+    // Extend the precision on last iteration
+    private static Apfloat lastIterationExtendPrecision(int iterations, int precisingIteration, Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return (iterations == 0 && precisingIteration != 0 ? ApfloatHelper.extendPrecision(x) : x);
+    }
+
+    static Apfloat factorial(long n, long precision)
+        throws ArithmeticException, NumberFormatException, ApfloatRuntimeException
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        int radix = ctx.getDefaultRadix();
+
+        return factorial(n, precision, radix);
+    }
+
+    static Apfloat factorial(long n, long precision, int radix)
+        throws ArithmeticException, NumberFormatException, ApfloatRuntimeException
+    {
+        if (n < 0)
+        {
+            throw new ArithmeticException("Factorial of negative number");
+        }
+        else if (n < 2)
+        {
+            return new Apfloat(1, precision, radix);
+        }
+
+        long targetPrecision = precision;
+        precision = ApfloatHelper.extendPrecision(precision);
+
+        // Thanks to Peter Luschny for the improved algorithm.
+        // The idea is to split the factorial to two parts:
+        // a product of odd numbers, and a power of two.
+        // This saves some operations, as squaring is more
+        // efficient than multiplication, in the power of two.
+        // For any n, factorial(n) = oddProduct(n) * factorial(m) * 2^m,
+        // where m = n >>> 1, which gives the following algorithm.
+        Apfloat oddProduct = new Apfloat(1, precision, radix),
+                factorialProduct = oddProduct;
+        long exponentOfTwo = 0;
+
+        for (int i = 62 - Long.numberOfLeadingZeros(n); i >= 0; i--)
+        {
+            long m = n >>> i,
+                 k = m >>> 1;
+            exponentOfTwo += k;
+            oddProduct = oddProduct.multiply(oddProduct(k + 1, m, precision, radix));
+            factorialProduct = factorialProduct.multiply(oddProduct);
+        }
+
+        return factorialProduct.multiply(pow(new Apfloat(2, precision, radix), exponentOfTwo)).precision(targetPrecision);
+    }
+
+    private static Apfloat oddProduct(long n, long m, long precision, int radix)
+        throws ApfloatRuntimeException
+    {
+        n = n | 1;       // Round n up to the next odd number
+        m = (m - 1) | 1; // Round m down to the next odd number
+
+        if (n > m)
+        {
+            return new Apfloat(1, precision, radix);
+        }
+        else if (n == m)
+        {
+            return new Apfloat(n, precision, radix);
+        }
+        else
+        {
+            long k = (n + m) >>> 1;
+            return oddProduct(n, k, precision, radix).multiply(oddProduct(k + 1, m, precision, radix));
+        }
+    }
+
+    // Clean up static maps at shutdown, to allow garbage collecting temporary files
+    static void cleanUp()
+    {
+        ApfloatMath.radixPi = SHUTDOWN_MAP;
+        ApfloatMath.radixPiT = SHUTDOWN_MAP;
+        ApfloatMath.radixPiQ = SHUTDOWN_MAP;
+        ApfloatMath.radixPiP = SHUTDOWN_MAP;
+        ApfloatMath.radixPiInverseRoot = SHUTDOWN_MAP;
+        ApfloatMath.radixLog = SHUTDOWN_MAP;
+        ApfloatMath.radixLogPi = SHUTDOWN_MAP;
+    }
+
+    // Map that always throws ApfloatRuntimeException, to be used after clean-up has been initiated
+    private static final Map<Integer, Apfloat> SHUTDOWN_MAP = new ShutdownMap<Integer, Apfloat>();
+
+    // Synchronization keys for pi calculation
+    private static ConcurrentMap<Integer, Integer> radixPiKeys = new ConcurrentHashMap<Integer, Integer>();
+
+    // Shared cached values related to pi for different radixes
+    private static Map<Integer, Apfloat> radixPi = new ConcurrentSoftHashMap<Integer, Apfloat>();
+    private static Map<Integer, PiCalculator> radixPiCalculator = new Hashtable<Integer, PiCalculator>();
+    private static Map<Integer, Apfloat> radixPiT = new ConcurrentSoftHashMap<Integer, Apfloat>();
+    private static Map<Integer, Apfloat> radixPiQ = new ConcurrentSoftHashMap<Integer, Apfloat>();
+    private static Map<Integer, Apfloat> radixPiP = new ConcurrentSoftHashMap<Integer, Apfloat>();
+    private static Map<Integer, Apfloat> radixPiInverseRoot = new ConcurrentSoftHashMap<Integer, Apfloat>();
+    private static Map<Integer, Long> radixPiTerms = new Hashtable<Integer, Long>();
+
+    // Synchronization keys for logarithm calculation
+    private static ConcurrentMap<Integer, Integer> radixLogKeys = new ConcurrentHashMap<Integer, Integer>();
+
+    // Shared cached values related to logarithm for different radixes
+    private static Map<Integer, Apfloat> radixLog = new ConcurrentHashMap<Integer, Apfloat>();
+    private static Map<Integer, Apfloat> radixLogPi = new ConcurrentHashMap<Integer, Apfloat>();
+}
Index: src/main/java/org/apfloat/ApfloatRuntimeException.java
===================================================================
--- src/main/java/org/apfloat/ApfloatRuntimeException.java	(revision 0)
+++ src/main/java/org/apfloat/ApfloatRuntimeException.java	(revision 0)
@@ -0,0 +1,59 @@
+package org.apfloat;
+
+/**
+ * Exception indicating some unexpected error situation.
+ * This exception can be thrown in different situations, for example:
+ *
+ * <ul>
+ *   <li>The result of an operation would have infinite size. For example,
+ *       <code>new Apfloat(2).divide(new Apfloat(3))</code>, in radix 10.</li>
+ *   <li>Overflow. If the exponent is too large to fit in a <code>long</code>,
+ *       the situation can't be handled. Also, there is no "infinity" apfloat
+ *       value that could be returned as the result.</li>
+ *   <li>Total loss of precision. For example, <code>ApfloatMath.sin(new Apfloat(1e100))</code>.
+ *       If the magnitude (100) is far greater than the precision (1) then
+ *       the value of the <code>sin()</code> function can't be determined
+ *       to any accuracy.</li>
+ *   <li>Some other internal limitation.</li>
+ * </ul>
+ *
+ * @version 1.1
+ * @author Mikko Tommila
+ */
+
+public class ApfloatRuntimeException
+    extends RuntimeException
+{
+    /**
+     * Constructs a new apfloat runtime exception with an empty detail message.
+     */
+
+    public ApfloatRuntimeException()
+    {
+    }
+
+    /**
+     * Constructs a new apfloat runtime exception with the specified detail message.
+     *
+     * @param message The detail message.
+     */
+
+    public ApfloatRuntimeException(String message)
+    {
+        super(message);
+    }
+
+    /**
+     * Constructs a new apfloat runtime exception with the specified detail message and cause.
+     *
+     * @param message The detail message.
+     * @param cause Originating cause of the exception.
+     */
+
+    public ApfloatRuntimeException(String message, Throwable cause)
+    {
+        super(message, cause);
+    }
+
+    private static final long serialVersionUID = -7022924635011038776L;
+}
Index: src/main/java/org/apfloat/Apint.java
===================================================================
--- src/main/java/org/apfloat/Apint.java	(revision 0)
+++ src/main/java/org/apfloat/Apint.java	(revision 0)
@@ -0,0 +1,652 @@
+package org.apfloat;
+
+import java.math.BigInteger;
+import java.io.PushbackReader;
+import java.io.Writer;
+import java.io.IOException;
+import java.util.Formatter;
+import static java.util.FormattableFlags.*;
+import java.util.FormatFlagsConversionMismatchException ;
+import java.util.IllegalFormatPrecisionException;
+
+import org.apfloat.spi.ApfloatImpl;
+
+/**
+ * Arbitrary precision integer class.<p>
+ *
+ * In addition to the constructors, it is possible to create an apint
+ * from an apfloat or aprational via the methods that round these
+ * numbers to an integer value: {@link Apfloat#floor() }, {@link Apfloat#ceil() },
+ * and {@link Apfloat#truncate() }.
+ *
+ * @see ApintMath
+ *
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class Apint
+    extends Aprational
+{
+    /**
+     * Default constructor. To be used only by subclasses that
+     * overload all needed methods.
+     */
+
+    protected Apint()
+    {
+    }
+
+    // Package private constructor that skips validating that the provided value actually is an integer
+    Apint(Apfloat value)
+    {
+        this.value = value;
+    }
+
+    /**
+     * Constructs an apfloat from the specified string.
+     * The default radix will be used.<p>
+     *
+     * @param value The string representing the number.
+     *
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     */
+
+    public Apint(String value)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        this.value = new Apfloat(ApfloatHelper.createApfloat(value, true));
+    }
+
+    /**
+     * Constructs an apfloat from the specified string and radix.
+     *
+     * @param value The string representing the number.
+     * @param radix The radix of the number.
+     *
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     */
+
+    public Apint(String value, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        this.value = new Apfloat(ApfloatHelper.createApfloat(value, INFINITE, radix, true));
+    }
+
+    /**
+     * Constructs an apfloat from the specified <code>long</code>.
+     * The default radix will be used.
+     *
+     * @param value The value of the number.
+     *
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     */
+
+    public Apint(long value)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        this.value = new Apfloat(ApfloatHelper.createApfloat(value));
+    }
+
+    /**
+     * Constructs an apfloat from the specified <code>long</code>
+     * and radix.
+     *
+     * @param value The value of the number.
+     * @param radix The radix of the number.
+     *
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     */
+
+    public Apint(long value, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        this.value = new Apfloat(ApfloatHelper.createApfloat(value, INFINITE, radix));
+    }
+
+    /**
+     * Reads an apint from a stream using the default radix.
+     *
+     * @param in The stream to read from
+     *
+     * @exception java.io.IOException If an I/O error occurs accessing the stream.
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public Apint(PushbackReader in)
+        throws IOException, NumberFormatException, ApfloatRuntimeException
+    {
+        this.value = new Apfloat(ApfloatHelper.createApfloat(in, INFINITE, true));
+    }
+
+    /**
+     * Reads an apint from a stream using the specified radix.
+     *
+     * @param in The stream to read from
+     * @param radix The radix of the number.
+     *
+     * @exception java.io.IOException If an I/O error occurs accessing the stream.
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public Apint(PushbackReader in, int radix)
+        throws IOException, NumberFormatException, ApfloatRuntimeException
+    {
+        this.value = new Apfloat(ApfloatHelper.createApfloat(in, INFINITE, radix, true));
+    }
+
+    /**
+     * Constructs an apint from a <code>BigInteger</code>. The default radix is used.
+     *
+     * @param value The value of the number.
+     *
+     * @exception java.lang.NumberFormatException If the default radix is not valid.
+     */
+
+    public Apint(BigInteger value)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        this.value = new Apfloat(value);
+    }
+
+    /**
+     * Constructs an apint from a <code>BigInteger</code> using the specified radix.
+     *
+     * @param value The value of the number.
+     * @param radix The radix of the number.
+     *
+     * @exception java.lang.NumberFormatException If the radix is not valid.
+     */
+
+    public Apint(BigInteger value, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        this.value = new Apfloat(value, INFINITE, radix);
+    }
+
+    /**
+     * Numerator of this aprational.
+     *
+     * @return <code>this</code>.
+     */
+
+    public Apint numerator()
+    {
+        return this;
+    }
+
+    /**
+     * Denominator of this aprational.
+     *
+     * @return {@link #ONE}.
+     */
+
+    public Apint denominator()
+    {
+        return ONES[radix()];
+    }
+
+    /**
+     * Radix of this apint.
+     *
+     * @return Radix of this apint.
+     */
+
+    public int radix()
+    {
+        return this.value.radix();
+    }
+
+    /**
+     * Returns the scale of this apint. Scale is equal to the number of digits in an apint.<p>
+     *
+     * Zero has a scale of <code>-INFINITE</code>.
+     *
+     * @return Number of digits in this apint in the radix in which it's presented.
+     *
+     * @see Apfloat#scale()
+     */
+
+    public long scale()
+        throws ApfloatRuntimeException
+    {
+        return this.value.scale();
+    }
+
+    /**
+     * Returns the size of this apint. Size is equal to the number of significant
+     * digits in the number, excluding any trailing zeros.<p>
+     *
+     * Zero has a size of <code>0</code>.
+     *
+     * @return Number of significant digits in this number, excluding trailing zeros, in the radix in which it's presented.
+     *
+     * @see Apfloat#size()
+     *
+     * @since 1.6
+     */
+
+    public long size()
+        throws ApfloatRuntimeException
+    {
+        return this.value.size();
+    }
+
+    /**
+     * Returns the signum function of this apint.
+     *
+     * @return -1, 0 or 1 as the value of this apint is negative, zero or positive.
+     */
+
+    public int signum()
+    {
+        return this.value.signum();
+    }
+
+    /**
+     * Returns if this apint is "short".
+     *
+     * @return <code>true</code> if the apint is "short", <code>false</code> if not.
+     *
+     * @see Apfloat#isShort()
+     */
+
+    public boolean isShort()
+        throws ApfloatRuntimeException
+    {
+        return this.value.isShort();
+    }
+
+    /**
+     * Negative value.
+     *
+     * @return <code>-this</code>.
+     *
+     * @since 1.1
+     */
+
+    public Apint negate()
+        throws ApfloatRuntimeException
+    {
+        return new Apint(this.value.negate());
+    }
+
+    /**
+     * Adds two apints.
+     *
+     * @param x The number to be added to this number.
+     *
+     * @return <code>this + x</code>.
+     */
+
+    public Apint add(Apint x)
+        throws ApfloatRuntimeException
+    {
+        return new Apint(this.value.add(x.value));
+    }
+
+    /**
+     * Subtracts two apints.
+     *
+     * @param x The number to be subtracted from this number.
+     *
+     * @return <code>this - x</code>.
+     */
+
+    public Apint subtract(Apint x)
+        throws ApfloatRuntimeException
+    {
+        return new Apint(this.value.subtract(x.value));
+    }
+
+    /**
+     * Multiplies two apints.
+     *
+     * @param x The number to be multiplied by this number.
+     *
+     * @return <code>this * x</code>.
+     */
+
+    public Apint multiply(Apint x)
+        throws ApfloatRuntimeException
+    {
+        return new Apint(this.value.multiply(x.value));
+    }
+
+    /**
+     * Divides two apints.
+     *
+     * @param x The number by which this number is to be divided.
+     *
+     * @return <code>this / x</code>.
+     *
+     * @exception java.lang.ArithmeticException In case the divisor is zero.
+     */
+
+    public Apint divide(Apint x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (x.signum() == 0)
+        {
+            throw new ArithmeticException(signum() == 0 ? "Zero divided by zero" : "Division by zero");
+        }
+        else if (signum() == 0)
+        {
+            // 0 / x = 0
+            return this;
+        }
+        else if (x.equals(ONE))
+        {
+            // x / 1 = x
+            return this;
+        }
+
+        long precision;
+        Apfloat a, b, tx, ty;
+        Apint t;
+
+        a = ApfloatMath.abs(this.value);
+        b = ApfloatMath.abs(x.value);
+
+        if (a.compareTo(b) < 0)
+        {
+            return ZERO;                        // abs(this) < abs(x)
+        }
+        else
+        {
+            precision = scale() - x.scale() + EXTRA_PRECISION;          // Some extra precision
+        }
+
+        tx = this.value.precision(precision);
+        ty = x.value.precision(precision);
+
+        t = tx.divide(ty).truncate();           // Approximate division
+
+        a = a.subtract(ApfloatMath.abs(t.multiply(x.value)));
+
+        if (a.compareTo(b) >= 0)                // Fix division round-off error
+        {
+            t = t.add(new Apint(signum() * x.signum(), x.radix()));
+        }
+        else if (a.signum() < 0)                // Fix division round-off error
+        {
+            t = t.subtract(new Apint(signum() * x.signum(), x.radix()));
+        }
+
+        return t;
+    }
+
+    /**
+     * Calculates the remainder when divided by an apint.
+     * The result has the same sign as this number.
+     * If <code>x</code> is zero, then zero is returned.
+     *
+     * @param x The number that is used as the divisor in the remainder calculation.
+     *
+     * @return <code>this % x</code>.
+     *
+     * @see ApfloatMath#fmod(Apfloat,Apfloat)
+     */
+
+    public Apint mod(Apint x)
+        throws ApfloatRuntimeException
+    {
+        return new Apint(this.value.mod(x.value));
+    }
+
+    /**
+     * Floor function. Returns the largest (closest to positive infinity) value
+     * that is not greater than this apfloat and is equal to a mathematical integer.
+     *
+     * @return This apint.
+     */
+
+    public Apint floor()
+    {
+        return this;
+    }
+
+    /**
+     * Ceiling function. Returns the smallest (closest to negative infinity) value
+     * that is not less than this apfloat and is equal to a mathematical integer.
+     *
+     * @return This apint.
+     */
+
+    public Apint ceil()
+    {
+        return this;
+    }
+
+    /**
+     * Truncates fractional part.
+     *
+     * @return This apint.
+     */
+
+    public Apint truncate()
+    {
+        return this;
+    }
+
+    /**
+     * Returns the fractional part.
+     *
+     * @return Always zero.
+     *
+     * @since 1.7.0
+     */
+
+    public Apint frac()
+        throws ApfloatRuntimeException
+    {
+        return ZERO;
+    }
+
+    /**
+     * Converts this apint to Java's <code>BigInteger</code>.
+     * This method can be greatly faster than converting to String
+     * and then to BigInteger.
+     *
+     * @return This apint converted to a <code>BigInteger</code>.
+     *
+     * @exception java.lang.IllegalArgumentException If this number is too big to fit in a <code>BigInteger</code>.
+     *
+     * @since 1.6
+     */
+
+    public BigInteger toBigInteger()
+        throws IllegalArgumentException
+    {
+        if (signum() == 0)
+        {
+            return BigInteger.ZERO;
+        }
+
+        return ApfloatHelper.toBigInteger(this);
+    }
+
+    /**
+     * Convert this apint to the specified radix.
+     *
+     * @param radix The radix.
+     *
+     * @exception java.lang.NumberFormatException If the radix is invalid.
+     *
+     * @since 1.2
+     */
+
+    public Apint toRadix(int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        return new Apint(this.value.toRadix(radix));
+    }
+
+    /**
+     * Compare this apint to the specified apint.<p>
+     *
+     * @param x Apint to which this apint is to be compared.
+     *
+     * @return -1, 0 or 1 as this apint is numerically less than, equal to, or greater than <code>x</code>.
+     */
+
+    public int compareTo(Apint x)
+    {
+        return this.value.compareTo(x.value);
+    }
+
+    /**
+     * Compare this apint to the specified aprational.<p>
+     *
+     * @param x Aprational to which this apint is to be compared.
+     *
+     * @return -1, 0 or 1 as this apint is numerically less than, equal to, or greater than <code>x</code>.
+     */
+
+    public int compareTo(Aprational x)
+    {
+        if (x instanceof Apint)
+        {
+            return compareTo((Apint) x);
+        }
+        else
+        {
+            return super.compareTo(x);
+        }
+    }
+
+    /**
+     * Compare this apint to the specified apfloat.<p>
+     *
+     * @param x Apfloat to which this apint is to be compared.
+     *
+     * @return -1, 0 or 1 as this apint is numerically less than, equal to, or greater than <code>x</code>.
+     */
+
+    public int compareTo(Apfloat x)
+    {
+        if (x instanceof Aprational)
+        {
+            return compareTo((Aprational) x);
+        }
+        else
+        {
+            return this.value.compareTo(x);
+        }
+    }
+
+    /**
+     * Compares this object to the specified object.<p>
+     *
+     * Note: if two apfloats are compared where one number doesn't have enough
+     * precise digits, the mantissa is assumed to contain zeros.
+     * See {@link Apfloat#compareTo(Apfloat)}.
+     *
+     * @param obj The object to compare with.
+     *
+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.
+     */
+
+    public boolean equals(Object obj)
+    {
+        if (obj == this)
+        {
+            return true;
+        }
+        else if (obj instanceof Apint)
+        {
+            Apint that = (Apint) obj;
+            return this.value.equals(that.value);
+        }
+        else if (obj instanceof Apfloat && !(obj instanceof Aprational))
+        {
+            Apfloat that = (Apfloat) obj;
+            return this.value.equals(that);
+        }
+        else
+        {
+            return super.equals(obj);
+        }
+    }
+
+    /**
+     * Returns a hash code for this apint.
+     *
+     * @return The hash code value for this object.
+     */
+
+    public int hashCode()
+    {
+        return this.value.hashCode();
+    }
+
+    /**
+     * Returns a string representation of this aprational.
+     *
+     * @param pretty <code>true</code> to use a fixed-point notation, <code>false</code> to use an exponential notation.
+     *
+     * @return A string representing this object.
+     */
+
+    public String toString(boolean pretty)
+        throws ApfloatRuntimeException
+    {
+        return this.value.toString(pretty);
+    }
+
+    /**
+     * Write a string representation of this aprational to a <code>Writer</code>.
+     *
+     * @param out The output <code>Writer</code>.
+     * @param pretty <code>true</code> to use a fixed-point notation, <code>false</code> to use an exponential notation.
+     *
+     * @exception java.io.IOException In case of I/O error writing to the stream.
+     */
+
+    public void writeTo(Writer out, boolean pretty)
+        throws IOException, ApfloatRuntimeException
+    {
+        this.value.writeTo(out, pretty);
+    }
+
+    public void formatTo(Formatter formatter, int flags, int width, int precision)
+    {
+        if ((flags & ALTERNATE) == ALTERNATE)
+        {
+            throw new FormatFlagsConversionMismatchException("#", 's');
+        }
+        if (precision != -1)
+        {
+            throw new IllegalFormatPrecisionException(precision);
+        }
+        this.value.formatTo(formatter, flags | ALTERNATE, width, precision);
+    }
+
+    /**
+     * Returns an <code>ApfloatImpl</code> representing this apint up to the requested precision.
+     *
+     * @param precision Precision of the <code>ApfloatImpl</code> that is needed.
+     *
+     * @return An <code>ApfloatImpl</code> representing this object to the requested precision.
+     */
+
+    protected ApfloatImpl getImpl(long precision)
+        throws ApfloatRuntimeException
+    {
+        return this.value.getImpl(precision);
+    }
+
+    Apint roundAway()
+    {
+        return this;
+    }
+
+    Apint abs()
+    {
+        return ApintMath.abs(this);
+    }
+
+    private static final long serialVersionUID = 5409721945040465491L;
+
+    private Apfloat value;
+}
Index: src/main/java/org/apfloat/ApintMath.java
===================================================================
--- src/main/java/org/apfloat/ApintMath.java	(revision 0)
+++ src/main/java/org/apfloat/ApintMath.java	(revision 0)
@@ -0,0 +1,659 @@
+package org.apfloat;
+
+/**
+ * Various mathematical functions for arbitrary precision integers.
+ *
+ * @version 1.6
+ * @author Mikko Tommila
+ */
+
+public class ApintMath
+{
+    private ApintMath()
+    {
+    }
+
+    /**
+     * Integer power.
+     *
+     * @param x Base of the power operator.
+     * @param n Exponent of the power operator.
+     *
+     * @return <code>x</code> to the <code>n</code>:th power, that is <code>x<sup>n</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If both <code>x</code> and <code>n</code> are zero.
+     */
+
+    public static Apint pow(Apint x, long n)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (n == 0)
+        {
+            if (x.signum() == 0)
+            {
+                throw new ArithmeticException("Zero to power zero");
+            }
+
+            return new Apint(1, x.radix());
+        }
+        else if (n < 0)
+        {
+            return Apint.ZERO;
+        }
+
+        // Algorithm improvements by Bernd Kellner
+        int b2pow = 0;
+
+        while ((n & 1) == 0)
+        {
+            b2pow++;
+            n >>= 1;
+        }
+
+        Apint r = x;
+
+        while ((n >>= 1) > 0)
+        {
+            x = x.multiply(x);
+            if ((n & 1) != 0)
+            {
+                r = r.multiply(x);
+            }
+        }
+
+        while (b2pow-- > 0)
+        {
+            r = r.multiply(r);
+        }
+
+        return r;
+    }
+
+    /**
+     * Square root and remainder.
+     *
+     * @param x The argument.
+     *
+     * @return An array of two apints: <code>[q, r]</code>, where <code>q<sup>2</sup> + r = x</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>x</code> is negative.
+     */
+
+    public static Apint[] sqrt(Apint x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return root(x, 2);
+    }
+
+    /**
+     * Cube root and remainder.
+     *
+     * @param x The argument.
+     *
+     * @return An array of two apints: <code>[q, r]</code>, where <code>q<sup>3</sup> + r = x</code>.
+     */
+
+    public static Apint[] cbrt(Apint x)
+        throws ApfloatRuntimeException
+    {
+        return root(x, 3);
+    }
+
+    /**
+     * Positive integer root and remainder.<p>
+     *
+     * Returns the <code>n</code>:th root of <code>x</code>,
+     * that is <code>x<sup>1/n</sup></code>, rounded towards zero.
+     *
+     * @param x The argument.
+     * @param n Which root to take.
+     *
+     * @return An array of two apints: <code>[q, r]</code>, where <code>q<sup>n</sup> + r = x</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>n</code> and <code>x</code> are zero, or <code>x</code> is negative and <code>n</code> is even.
+     */
+
+    public static Apint[] root(Apint x, long n)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (n == 0)
+        {
+            if (x.signum() == 0)
+            {
+                throw new ArithmeticException("Zeroth root of zero");
+            }
+
+            Apint one = new Apint(1, x.radix());
+            return new Apint[] { one, x.subtract(one) };
+        }
+        else if (x.signum() == 0)
+        {
+            return new Apint[] { x, x };                        // Avoid division by zero
+        }
+        else if (x.equals(Apint.ONE) || n == 1)
+        {
+            return new Apint[] { x, Apint.ZERO };
+        }
+        else if (n < 0)
+        {
+            return new Apint[] { Apint.ZERO, x };               // 1 / x where x > 1
+        }
+
+        long precision = x.scale() / n + Apint.EXTRA_PRECISION;
+        Apfloat approxX = x.precision(precision);
+        Apfloat approxRoot;
+
+        approxRoot = ApfloatMath.root(approxX, n);
+
+        Apint root = approxRoot.truncate(),                             // May be one too big or one too small
+              pow = pow(root, n);
+
+        if (abs(pow).compareTo(abs(x)) > 0)
+        {
+            // Approximate root was one too big
+
+            pow = (x.signum() >= 0 ? powXMinus1(pow, root, n) : powXPlus1(pow, root, n));
+            root = root.subtract(new Apint(x.signum(), x.radix()));
+        }
+        else
+        {
+            // Approximate root was correct or one too small
+
+            Apint powPlus1 = (x.signum() >= 0 ? powXPlus1(pow, root, n) : powXMinus1(pow, root, n));
+
+            if (abs(powPlus1).compareTo(abs(x)) <= 0)
+            {
+                // Approximate root was one too small
+
+                pow = powPlus1;
+                root = root.add(new Apint(x.signum(), x.radix()));
+            }
+        }
+
+        Apint remainder = x.subtract(pow);
+
+        assert (remainder.signum() * x.signum() >= 0);
+
+        return new Apint[] { root, remainder };
+    }
+
+    private static Apint powXMinus1(Apint pow, Apint x, long n)
+        throws ApfloatRuntimeException
+    {
+        Apint one = new Apint(1, x.radix());
+
+        if (n == 2)
+        {
+            // (x - 1)^2 = x^2 - 2*x + 1
+            pow = pow.subtract(x).subtract(x).add(one);
+        }
+        else if (n == 3)
+        {
+            // (x - 1)^3 = x^3 - 3*x^2 + 3*x - 1 = x^3 - 3*x*(x - 1) - 1
+            pow = pow.subtract(new Apint(3, x.radix()).multiply(x).multiply(x.subtract(one))).subtract(one);
+        }
+        else
+        {
+            pow = pow(x.subtract(one), n);
+        }
+
+        return pow;
+    }
+
+    private static Apint powXPlus1(Apint pow, Apint x, long n)
+        throws ApfloatRuntimeException
+    {
+        Apint one = new Apint(1, x.radix());
+
+        if (n == 2)
+        {
+            // (x + 1)^2 = x^2 + 2*x + 1
+            pow = pow.add(x).add(x).add(one);
+        }
+        else if (n == 3)
+        {
+            // (x + 1)^3 = x^3 + 3*x^2 + 3*x + 1 = x^3 + 3*x*(x + 1) + 1
+            pow = pow.add(new Apint(3, x.radix()).multiply(x).multiply(x.add(one))).add(one);
+        }
+        else
+        {
+            pow = pow(x.add(one), n);
+        }
+
+        return pow;
+    }
+
+    /**
+     * Returns an apint whose value is <code>-x</code>.
+     *
+     * @deprecated Use {@link Apint#negate()}.
+     *
+     * @param x The argument.
+     *
+     * @return <code>-x</code>.
+     */
+
+    @Deprecated
+    public static Apint negate(Apint x)
+        throws ApfloatRuntimeException
+    {
+        return x.negate();
+    }
+
+    /**
+     * Absolute value.
+     *
+     * @param x The argument.
+     *
+     * @return Absolute value of <code>x</code>.
+     */
+
+    public static Apint abs(Apint x)
+        throws ApfloatRuntimeException
+    {
+        if (x.signum() >= 0)
+        {
+            return x;
+        }
+        else
+        {
+            return x.negate();
+        }
+    }
+
+    /**
+     * Copy sign from one argument to another.
+     *
+     * @param x The value whose sign is to be adjusted.
+     * @param y The value whose sign is to be used.
+     *
+     * @return <code>x</code> with its sign changed to match the sign of <code>y</code>.
+     *
+     * @since 1.1
+     */
+
+    public static Apint copySign(Apint x, Apint y)
+        throws ApfloatRuntimeException
+    {
+        if (y.signum() == 0)
+        {
+            return y;
+        }
+        else if (x.signum() != y.signum())
+        {
+            return x.negate();
+        }
+        else
+        {
+            return x;
+        }
+    }
+
+    /**
+     * Multiply by a power of the radix.
+     * Any rounding will occur towards zero.
+     *
+     * @param x The argument.
+     * @param scale The scaling factor.
+     *
+     * @return <code>x * x.radix()<sup>scale</sup></code>.
+     */
+
+    public static Apint scale(Apint x, long scale)
+        throws ApfloatRuntimeException
+    {
+        return ApfloatMath.scale(x, scale).truncate();
+    }
+
+    /**
+     * Quotient and remainder.
+     *
+     * @param x The dividend.
+     * @param y The divisor.
+     *
+     * @return An array of two apints: <code>[quotient, remainder]</code>, that is <code>[x / y, x % y]</code>.
+     *
+     * @exception java.lang.ArithmeticException In case the divisor is zero.
+     */
+
+    public static Apint[] div(Apint x, Apint y)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (y.signum() == 0)
+        {
+            throw new ArithmeticException("Division by zero");
+        }
+        else if (x.signum() == 0)
+        {
+            // 0 / x = 0
+            return new Apint[] { x, x };
+        }
+        else if (y.equals(Apint.ONE))
+        {
+            // x / 1 = x
+            return new Apint[] { x, Apint.ZERO };
+        }
+
+        long precision;
+        Apfloat tx, ty;
+        Apint a, b, q, r;
+
+        a = abs(x);
+        b = abs(y);
+
+        if (a.compareTo(b) < 0)
+        {
+            return new Apint[] { Apint.ZERO, x };  // abs(x) < abs(y)
+        }
+        else
+        {
+            precision = x.scale() - y.scale() + Apint.EXTRA_PRECISION;        // Some extra precision to avoid round-off errors
+        }
+
+        tx = x.precision(precision);
+        ty = y.precision(precision);
+
+        q = tx.divide(ty).truncate();           // Approximate division
+
+        a = a.subtract(abs(q.multiply(y)));
+
+        if (a.compareTo(b) >= 0)                // Fix division round-off error
+        {
+            q = q.add(new Apint(x.signum() * y.signum(), x.radix()));
+            a = a.subtract(b);
+        }
+        else if (a.signum() < 0)                // Fix division round-off error
+        {
+            q = q.subtract(new Apint(x.signum() * y.signum(), x.radix()));
+            a = a.add(b);
+        }
+
+        r = copySign(a, x);
+
+        return new Apint[] { q, r };
+    }
+
+    /**
+     * Greatest common divisor.
+     * This method returns a positive number even if one of <code>a</code>
+     * and <code>b</code> is negative.
+     *
+     * @param a First argument.
+     * @param b Second argument.
+     *
+     * @return Greatest common divisor of <code>a</code> and <code>b</code>.
+     */
+
+    public static Apint gcd(Apint a, Apint b)
+        throws ApfloatRuntimeException
+    {
+        return GCDHelper.gcd(a, b);
+    }
+
+    /**
+     * Least common multiple.
+     * This method returns a positive number even if one of <code>a</code>
+     * and <code>b</code> is negative.
+     *
+     * @param a First argument.
+     * @param b Second argument.
+     *
+     * @return Least common multiple of <code>a</code> and <code>b</code>.
+     */
+
+    public static Apint lcm(Apint a, Apint b)
+        throws ApfloatRuntimeException
+    {
+        if (a.signum() == 0 && b.signum() == 0)
+        {
+            return Apint.ZERO;
+        }
+        else
+        {
+            return abs(a.multiply(b)).divide(gcd(a, b));
+        }
+    }
+
+    /**
+     * Modular multiplication. Returns <code>a * b % m</code>
+     *
+     * @param a First argument.
+     * @param b Second argument.
+     * @param m Modulus.
+     *
+     * @return <code>a * b mod m</code>
+     */
+
+    public static Apint modMultiply(Apint a, Apint b, Apint m)
+        throws ApfloatRuntimeException
+    {
+        return a.multiply(b).mod(m);
+    }
+
+    private static Apint modMultiply(Apint x1, Apint x2, Apint y, Apfloat inverseY)
+        throws ApfloatRuntimeException
+    {
+        Apint x = x1.multiply(x2);
+
+        if (x.signum() == 0)
+        {
+            // 0 % x = 0
+            return x;
+        }
+
+        long precision = x.scale() - y.scale() + Apfloat.EXTRA_PRECISION;       // Some extra precision to avoid round-off errors
+        Apint a, b, t;
+
+        a = abs(x);
+        b = abs(y);
+
+        if (a.compareTo(b) < 0)
+        {
+            return x;                           // abs(x) < abs(y)
+        }
+
+        t = x.multiply(inverseY.precision(precision)).truncate();               // Approximate division
+
+        a = a.subtract(abs(t.multiply(y)));
+
+        if (a.compareTo(b) >= 0)                // Fix division round-off error
+        {
+            a = a.subtract(b);
+        }
+        else if (a.signum() < 0)                // Fix division round-off error
+        {
+            a = a.add(b);
+        }
+
+        t = copySign(a, x);
+
+        return t;
+    }
+
+    /**
+     * Modular power.
+     *
+     * @param a Base.
+     * @param b Exponent.
+     * @param m Modulus.
+     *
+     * @return <code>a<sup>b</sup> mod m</code>
+     *
+     * @exception java.lang.ArithmeticException If the exponent is negative but the GCD of <code>a</code> and <code>m</code> is not 1 and the modular inverse does not exist.
+     */
+
+    public static Apint modPow(Apint a, Apint b, Apint m)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (b.signum() == 0)
+        {
+            if (a.signum() == 0)
+            {
+                throw new ArithmeticException("Zero to power zero");
+            }
+
+            return new Apint(1, a.radix());
+        }
+        else if (m.signum() == 0)
+        {
+            return m;                           // By definition
+        }
+
+        m = abs(m);
+
+        Apfloat inverseModulus = ApfloatMath.inverseRoot(m, 1, m.scale() + Apfloat.EXTRA_PRECISION);
+        a = a.mod(m);
+
+        if (b.signum() < 0)
+        {
+            // Calculate modular inverse first
+            a = modInverse(a, m);
+            b = b.negate();
+        }
+
+        Apint two = new Apint(2, b.radix());    // Sub-optimal; the divisor could be some power of two
+        Apint[] qr;
+
+        while ((qr = div(b, two))[1].signum() == 0)
+        {
+            a = modMultiply(a, a, m, inverseModulus);
+            b = qr[0];
+        }
+
+        Apint r = a;
+        qr = div(b, two);
+
+        while ((b = qr[0]).signum() > 0)
+        {
+            a = modMultiply(a, a, m, inverseModulus);
+            qr = div(b, two);
+            if (qr[1].signum() != 0)
+            {
+                r = modMultiply(r, a, m, inverseModulus);
+            }
+        }
+
+        return r;
+    }
+
+    private static Apint modInverse(Apint a, Apint m)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        // Extended Euclidean algorithm
+        Apint one = new Apint(1, m.radix()),
+              x = Apint.ZERO,
+              y = one,
+              oldX = one,
+              oldY = Apint.ZERO,
+              oldA = a,
+              b = m;
+
+        while (b.signum() != 0)
+        {
+            Apint q = a.divide(b);
+
+            Apint tmp = b;
+            b = a.mod(b);
+            a = tmp;
+
+            tmp = x;
+            x = oldX.subtract(q.multiply(x));
+            oldX = tmp;
+
+            tmp = y;
+            y = oldY.subtract(q.multiply(y));
+            oldY = tmp;
+        }
+
+        if (!abs(a).equals(one))
+        {
+            // GCD is not 1
+            throw new ArithmeticException("Modular inverse does not exist");
+        }
+
+        if (oldX.signum() != oldA.signum())
+        {
+            // Adjust by one modulus if sign is wrong
+            oldX = oldX.add(copySign(m, oldA));
+        }
+
+        return oldX;
+    }
+
+    /**
+     * Factorial function. Uses the default radix.
+     *
+     * @param n The number whose factorial is to be calculated. Should be non-negative.
+     *
+     * @return <code>n!</code>
+     *
+     * @exception java.lang.ArithmeticException If <code>n</code> is negative.
+     * @exception java.lang.NumberFormatException If the default radix is not valid.
+     *
+     * @since 1.1
+     */
+
+    public static Apint factorial(long n)
+        throws ArithmeticException, NumberFormatException, ApfloatRuntimeException
+    {
+        return new Apint(ApfloatMath.factorial(n, Apfloat.INFINITE));
+    }
+
+    /**
+     * Factorial function. Returns a number in the specified radix.
+     *
+     * @param n The number whose factorial is to be calculated. Should be non-negative.
+     * @param radix The radix to use.
+     *
+     * @return <code>n!</code>
+     *
+     * @exception java.lang.ArithmeticException If <code>n</code> is negative.
+     * @exception java.lang.NumberFormatException If the radix is not valid.
+     *
+     * @since 1.1
+     */
+
+    public static Apint factorial(long n, int radix)
+        throws ArithmeticException, NumberFormatException, ApfloatRuntimeException
+    {
+        return new Apint(ApfloatMath.factorial(n, Apfloat.INFINITE, radix));
+    }
+
+    /**
+     * Product of numbers.
+     * This method may perform significantly better
+     * than simply multiplying the numbers sequentially.<p>
+     *
+     * If there are no arguments, the return value is <code>1</code>.
+     *
+     * @param x The argument(s).
+     *
+     * @return The product of the given numbers.
+     *
+     * @since 1.3
+     */
+
+    public static Apint product(Apint... x)
+        throws ApfloatRuntimeException
+    {
+        return new Apint(ApfloatMath.product(x));
+    }
+
+    /**
+     * Sum of numbers.<p>
+     *
+     * If there are no arguments, the return value is <code>0</code>.
+     *
+     * @param x The argument(s).
+     *
+     * @return The sum of the given numbers.
+     *
+     * @since 1.3
+     */
+
+    public static Apint sum(Apint... x)
+        throws ApfloatRuntimeException
+    {
+        return new Apint(ApfloatMath.sum(x));
+    }
+}
Index: src/main/java/org/apfloat/Aprational.java
===================================================================
--- src/main/java/org/apfloat/Aprational.java	(revision 0)
+++ src/main/java/org/apfloat/Aprational.java	(revision 0)
@@ -0,0 +1,953 @@
+package org.apfloat;
+
+import java.math.BigInteger;
+import java.io.PushbackReader;
+import java.io.Writer;
+import java.io.IOException;
+import java.lang.ref.SoftReference;
+import java.util.Formatter;
+import static java.util.FormattableFlags.*;
+
+import org.apfloat.spi.ApfloatImpl;
+import static org.apfloat.spi.RadixConstants.*;
+
+/**
+ * Arbitrary precision rational number class. An aprational consists of
+ * a numerator and a denominator of type {@link Apint}.<p>
+ *
+ * @see Apint
+ * @see AprationalMath
+ *
+ * @version 1.8.2
+ * @author Mikko Tommila
+ */
+
+public class Aprational
+    extends Apfloat
+{
+    /**
+     * Default constructor. To be used only by subclasses that
+     * overload all needed methods.
+     */
+
+    protected Aprational()
+    {
+    }
+
+    /**
+     * Construct an integer aprational whose denominator is one.
+     *
+     * @param value The numerator of the number.
+     */
+
+    public Aprational(Apint value)
+        throws ApfloatRuntimeException
+    {
+        this(value, ONES[value.radix()]);
+    }
+
+    /**
+     * Construct an aprational with the specified numerator and denominator.
+     *
+     * @param numerator The numerator.
+     * @param denominator The denominator.
+     *
+     * @exception java.lang.IllegalArgumentException In case the denominator is zero, or if the denominator is not one or the numerator is not zero, and the radix of the numerator and denominator are different.
+     */
+
+    public Aprational(Apint numerator, Apint denominator)
+        throws IllegalArgumentException, ApfloatRuntimeException
+    {
+        this.numerator = numerator;
+        this.denominator = denominator;
+
+        checkDenominator();
+
+        reduce();
+    }
+
+    /**
+     * Constructs an aprational from a string. The default radix is used.<p>
+     *
+     * The input must be of one of the formats<p>
+     *
+     * <code>integer</code><br>
+     * <code>numerator [whitespace] "/" [whitespace] denominator</code><br>
+     *
+     * @param value The input string.
+     *
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     * @exception java.lang.IllegalArgumentException In case the denominator is zero.
+     */
+
+    public Aprational(String value)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        this(value, ApfloatContext.getContext().getDefaultRadix());
+    }
+
+    /**
+     * Constructs an aprational from a string with the specified radix.<p>
+     *
+     * The input must be of one of the formats<p>
+     *
+     * <code>integer</code><br>
+     * <code>numerator [whitespace] "/" [whitespace] denominator</code><br>
+     *
+     * @param value The input string.
+     * @param radix The radix to be used.
+     *
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     * @exception java.lang.IllegalArgumentException In case the denominator is zero.
+     */
+
+    public Aprational(String value, int radix)
+        throws NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        int index = value.indexOf('/');
+        if (index < 0)
+        {
+            this.numerator = new Apint(value, radix);
+            this.denominator = ONES[radix];
+            return;
+        }
+
+        this.numerator = new Apint(value.substring(0, index).trim(), radix);
+        this.denominator = new Apint(value.substring(index + 1).trim(), radix);
+
+        checkDenominator();
+
+        reduce();
+    }
+
+    /**
+     * Reads an aprational from a reader. The default radix is used. The constructor
+     * stops reading at the first character it doesn't understand. The reader must
+     * thus be a <code>PushbackReader</code> so that the invalid character can be
+     * returned back to the stream.<p>
+     *
+     * The input must be of one of the formats<p>
+     *
+     * <code>integer [whitespace]</code><br>
+     * <code>numerator [whitespace] "/" [whitespace] denominator</code><br>
+     *
+     * @param in The input stream.
+     *
+     * @exception java.io.IOException In case of I/O error reading the stream.
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     * @exception java.lang.IllegalArgumentException In case the denominator is zero.
+     */
+
+    public Aprational(PushbackReader in)
+        throws IOException, NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        this(in, ApfloatContext.getContext().getDefaultRadix());
+    }
+
+    /**
+     * Reads an aprational from a reader. The specified radix is used.
+     *
+     * @param in The input stream.
+     * @param radix The radix to be used.
+     *
+     * @exception java.io.IOException In case of I/O error reading the stream.
+     * @exception java.lang.NumberFormatException In case the number is invalid.
+     * @exception java.lang.IllegalArgumentException In case the denominator is zero.
+     *
+     * @see #Aprational(PushbackReader)
+     */
+
+    public Aprational(PushbackReader in, int radix)
+        throws IOException, NumberFormatException, IllegalArgumentException, ApfloatRuntimeException
+    {
+        this.numerator = new Apint(in, radix);
+
+        ApfloatHelper.extractWhitespace(in);
+
+        if (!ApfloatHelper.readMatch(in, '/'))
+        {
+            this.denominator = ONES[radix];
+            return;
+        }
+
+        ApfloatHelper.extractWhitespace(in);
+        this.denominator = new Apint(in, radix);
+
+        checkDenominator();
+
+        reduce();
+    }
+
+    /**
+     * Constructs an aprational from a <code>BigInteger</code>.
+     * The default radix is used.
+     *
+     * @param value The numerator of the number.
+     */
+
+    public Aprational(BigInteger value)
+        throws ApfloatRuntimeException
+    {
+        this.numerator = new Apint(value);
+        this.denominator = ONE;
+    }
+
+    /**
+     * Constructs an aprational from a <code>BigInteger</code> using the specified radix.
+     *
+     * @param value The numerator of the number.
+     * @param radix The radix of the number.
+     */
+
+    public Aprational(BigInteger value, int radix)
+        throws ApfloatRuntimeException
+    {
+        this.numerator = new Apint(value, radix);
+        this.denominator = ONES[radix];
+    }
+
+    /**
+     * Numerator of this aprational.
+     *
+     * @return <code>n</code> where <code>this = n / m</code>.
+     */
+
+    public Apint numerator()
+    {
+        return this.numerator;
+    }
+
+    /**
+     * Denominator of this aprational.
+     *
+     * @return <code>m</code> where <code>this = n / m</code>.
+     */
+
+    public Apint denominator()
+    {
+        return this.denominator;
+    }
+
+    /**
+     * Radix of this aprational.
+     *
+     * @return Radix of this aprational.
+     */
+
+    public int radix()
+    {
+        return (numerator() == ONE ? denominator().radix() : numerator().radix());
+    }
+
+    /**
+     * Returns the precision of this aprational.
+     *
+     * @return <code>INFINITE</code>
+     */
+
+    public long precision()
+        throws ApfloatRuntimeException
+    {
+        return INFINITE;
+    }
+
+    /**
+     * Returns the scale of this aprational. Scale is equal to the number of digits in the aprational's truncated value.<p>
+     *
+     * Zero has a scale of <code>-INFINITE</code>.
+     *
+     * @return Number of digits in the truncated value of this aprational in the radix in which it's presented.
+     *
+     * @see Apfloat#scale()
+     */
+
+    public long scale()
+        throws ApfloatRuntimeException
+    {
+        if (signum() == 0)
+        {
+            return -INFINITE;
+        }
+
+        if (this.scale == UNDEFINED)
+        {
+            long scale = numerator().scale() - denominator().scale();
+
+            if (scale > 0)
+            {
+                scale = truncate().scale();
+            }
+            else
+            {
+                scale = AprationalMath.scale(this, 1 - scale).truncate().scale() + scale - 1;
+            }
+
+            // Writes and reads of volatile long values are always atomic so multiple threads can read and write this at the same time
+            this.scale = scale;
+        }
+
+        return this.scale;
+    }
+
+    /**
+     * Returns the size of this aprational. Size is equal to the number of significant
+     * digits in the aprational's floating-point expansion. If the expansion is infinite
+     * then this method returns <code>INFINITE</code>.<p>
+     *
+     * Zero has a size of <code>0</code>.
+     *
+     * @return Number of significant digits in the floating-point expansion of this aprational in the radix in which it's presented.
+     *
+     * @see Apfloat#size()
+     *
+     * @since 1.6
+     */
+
+    public long size()
+        throws ApfloatRuntimeException
+    {
+        if (signum() == 0)
+        {
+            return 0;
+        }
+        if (denominator().equals(ONE))
+        {
+            return numerator().size();
+        }
+
+        if (this.size == 0)
+        {
+            long size;
+
+            // Check that the factorization of the divisor consists entirely of factors of the base
+            // E.g. if base is 10=2*5 then the divisor should be 2^n*5^m
+            Apint dividend = denominator();
+            for (int i = 0; i < RADIX_FACTORS[radix()].length; i++)
+            {
+                Apint factor = new Apint(RADIX_FACTORS[radix()][i], radix());
+                Apint[] quotientAndRemainder;
+
+                // Keep dividing by factor as long as dividend % factor == 0
+                // that is remove factors of the base from the divisor
+                while ((quotientAndRemainder = ApintMath.div(dividend, factor))[1].signum() == 0)
+                {
+                    dividend = quotientAndRemainder[0];
+                }
+            }
+
+            // Check if the divisor was factored all the way to one by just dividing by factors of the base
+            if (!dividend.equals(ONE))
+            {
+                // No - infinite floating-point expansion
+                size = INFINITE;
+            }
+            else
+            {
+                // Yes - calculate the number of digits
+                // Scale the number so that all significant digits will fit in the integer part
+                // The factor 5 is a rough estimate; e.g. if the denominator is 2^n then in base 34 we get close to that value
+                size = ApintMath.scale(numerator(), denominator().scale() * 5).divide(denominator()).size();
+            }
+
+            // Writes and reads of volatile long values are always atomic so multiple threads can read and write this at the same time
+            this.size = size;
+        }
+
+        return this.size;
+    }
+
+    /**
+     * Returns the signum function of this aprational.
+     *
+     * @return -1, 0 or 1 as the value of this aprational is negative, zero or positive.
+     */
+
+    public int signum()
+    {
+        return numerator().signum();
+    }
+
+    /**
+     * Returns if this aprational is "short".
+     *
+     * @return <code>true</code> if the aprational is "short", <code>false</code> if not.
+     *
+     * @see Apfloat#isShort()
+     */
+
+    public boolean isShort()
+        throws ApfloatRuntimeException
+    {
+        return numerator().isShort() && denominator().equals(ONE);
+    }
+
+    /**
+     * Negative value.
+     *
+     * @return <code>-this</code>.
+     *
+     * @since 1.1
+     */
+
+    public Aprational negate()
+        throws ApfloatRuntimeException
+    {
+        return new Aprational(numerator().negate(), denominator());
+    }
+
+    /**
+     * Adds two aprational numbers.
+     *
+     * @param x The number to be added to this number.
+     *
+     * @return <code>this + x</code>.
+     */
+
+    public Aprational add(Aprational x)
+        throws ApfloatRuntimeException
+    {
+        return new Aprational(numerator().multiply(x.denominator()).add(denominator().multiply(x.numerator())),
+                              denominator().multiply(x.denominator())).reduce();
+    }
+
+    /**
+     * Subtracts two aprational numbers.
+     *
+     * @param x The number to be subtracted from this number.
+     *
+     * @return <code>this - x</code>.
+     */
+
+    public Aprational subtract(Aprational x)
+        throws ApfloatRuntimeException
+    {
+        return new Aprational(numerator().multiply(x.denominator()).subtract(denominator().multiply(x.numerator())),
+                              denominator().multiply(x.denominator())).reduce();
+    }
+
+    /**
+     * Multiplies two aprational numbers.
+     *
+     * @param x The number to be multiplied by this number.
+     *
+     * @return <code>this * x</code>.
+     */
+
+    public Aprational multiply(Aprational x)
+        throws ApfloatRuntimeException
+    {
+        Aprational result = new Aprational(numerator().multiply(x.numerator()),
+                                           denominator().multiply(x.denominator()));
+
+        if (this == x)
+        {
+            // When squaring we know that no reduction is needed
+            return result;
+        }
+        else
+        {
+            return result.reduce();
+        }
+    }
+
+    /**
+     * Divides two aprational numbers.
+     *
+     * @param x The number by which this number is to be divided.
+     *
+     * @return <code>this / x</code>.
+     *
+     * @exception java.lang.ArithmeticException In case the divisor is zero.
+     */
+
+    public Aprational divide(Aprational x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (x.signum() == 0)
+        {
+            throw new ArithmeticException(signum() == 0 ? "Zero divided by zero" : "Division by zero");
+        }
+        else if (signum() == 0)
+        {
+            // 0 / x = 0
+            return this;
+        }
+        // Comparison against one would be inefficient at this point
+
+        return new Aprational(numerator().multiply(x.denominator()),
+                              denominator().multiply(x.numerator())).reduce();
+    }
+
+    /**
+     * Calculates the remainder when divided by an aprational.
+     * The result has the same sign as this number.
+     * If <code>x</code> is zero, then zero is returned.
+     *
+     * @param x The number that is used as the divisor in the remainder calculation.
+     *
+     * @return <code>this % x</code>.
+     *
+     * @since 1.2
+     */
+
+    public Aprational mod(Aprational x)
+        throws ApfloatRuntimeException
+    {
+        if (x.signum() == 0)
+        {
+            return x;                           // By definition
+        }
+        else if (signum() == 0)
+        {
+            // 0 % x = 0
+            return this;
+        }
+
+        return subtract(divide(x).truncate().multiply(x));
+    }
+
+    /**
+     * Floor function. Returns the largest (closest to positive infinity) value
+     * that is not greater than this aprational and is equal to a mathematical integer.
+     *
+     * @return This aprational rounded towards negative infinity.
+     */
+
+    public Apint floor()
+        throws ApfloatRuntimeException
+    {
+        if (signum() >= 0)
+        {
+            return truncate();
+        }
+        else
+        {
+            return roundAway();
+        }
+    }
+
+    /**
+     * Ceiling function. Returns the smallest (closest to negative infinity) value
+     * that is not less than this aprational and is equal to a mathematical integer.
+     *
+     * @return This aprational rounded towards positive infinity.
+     */
+
+    public Apint ceil()
+        throws ApfloatRuntimeException
+    {
+        if (signum() <= 0)
+        {
+            return truncate();
+        }
+        else
+        {
+            return roundAway();
+        }
+    }
+
+    /**
+     * Truncates fractional part.
+     *
+     * @return This aprational rounded towards zero.
+     */
+
+    public Apint truncate()
+        throws ApfloatRuntimeException
+    {
+        return numerator().divide(denominator());
+    }
+
+    /**
+     * Returns the fractional part. The fractional part is always <code>0 &lt;= abs(x.frac()) &lt; 1</code>.
+     * The fractional part has the same sign as the number. For the fractional and integer parts, this always holds:<p>
+     *
+     * <code>x = x.truncate() + x.frac()</code>
+     *
+     * @return The fractional part of this aprational.
+     *
+     * @since 1.7.0
+     */
+
+    public Aprational frac()
+        throws ApfloatRuntimeException
+    {
+        return new Aprational(numerator().mod(denominator()), denominator());
+    }
+
+    /**
+     * Convert this aprational to the specified radix.
+     *
+     * @param radix The radix.
+     *
+     * @exception java.lang.NumberFormatException If the radix is invalid.
+     *
+     * @since 1.2
+     */
+
+    public Aprational toRadix(int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        return new Aprational(numerator().toRadix(radix), denominator().toRadix(radix));
+    }
+
+    /**
+     * Compare this aprational to the specified aprational.<p>
+     *
+     * @param x Aprational to which this aprational is to be compared.
+     *
+     * @return -1, 0 or 1 as this aprational is numerically less than, equal to, or greater than <code>x</code>.
+     */
+
+    public int compareTo(Aprational x)
+    {
+        Apint a = numerator().multiply(x.denominator()),
+              b = x.numerator().multiply(denominator());
+
+        return a.compareTo(b);
+    }
+
+    /**
+     * Compare this aprational to the specified apfloat.<p>
+     *
+     * @param x Apfloat to which this aprational is to be compared.
+     *
+     * @return -1, 0 or 1 as this aprational is numerically less than, equal to, or greater than <code>x</code>.
+     */
+
+    public int compareTo(Apfloat x)
+    {
+        if (x instanceof Aprational)
+        {
+            return compareTo((Aprational) x);
+        }
+        else
+        {
+            // Sub-optimal performance wise, but works
+            Apfloat a = numerator().precision(INFINITE),                // Actual class must be Apfloat
+                    b = x.multiply(denominator()).precision(INFINITE);  // Actual class must be Apfloat
+
+            return a.compareTo(b);
+        }
+    }
+
+    public boolean preferCompare(Apfloat x)
+    {
+        return !(x instanceof Aprational);
+    }
+
+    /**
+     * Compares this object to the specified object.<p>
+     *
+     * Note: if two apfloats are compared where one number doesn't have enough
+     * precise digits, the mantissa is assumed to contain zeros.
+     * See {@link Apfloat#compareTo(Apfloat)}.
+     *
+     * @param obj The object to compare with.
+     *
+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.
+     */
+
+    public boolean equals(Object obj)
+    {
+        if (obj == this)
+        {
+            return true;
+        }
+        else if (obj instanceof Aprational)
+        {
+            Aprational that = (Aprational) obj;
+            return numerator().equals(that.numerator()) &&
+                   denominator().equals(that.denominator());
+        }
+        else if (obj instanceof Apfloat)
+        {
+            Apfloat that = (Apfloat) obj;
+
+            // Sub-optimal performance wise, but works
+            Apfloat a = numerator().precision(INFINITE),                    // Actual class must be Apfloat
+                    b = that.multiply(denominator()).precision(INFINITE);   // Actual class must be Apfloat
+
+            return a.equals(b);
+        }
+        else
+        {
+            return super.equals(obj);
+        }
+    }
+
+    /**
+     * Returns a hash code for this aprational.
+     *
+     * @return The hash code value for this object.
+     */
+
+    public int hashCode()
+    {
+        return numerator().hashCode() * 3 +
+               denominator().hashCode();
+    }
+
+    /**
+     * Returns a string representation of this aprational.
+     *
+     * @return A string representing this object.
+     */
+
+    public String toString()
+    {
+        return toString(true);
+    }
+
+    /**
+     * Returns a string representation of this aprational.
+     *
+     * @param pretty <code>true</code> to use a fixed-point notation, <code>false</code> to use an exponential notation.
+     *
+     * @return A string representing this object.
+     */
+
+    public String toString(boolean pretty)
+        throws ApfloatRuntimeException
+    {
+        return numerator().toString(pretty) +
+               (denominator().equals(ONE) ? "" : '/' + denominator().toString(pretty));
+    }
+
+    /**
+     * Write a string representation of this aprational to a <code>Writer</code>.
+     *
+     * @param out The output <code>Writer</code>.
+     *
+     * @exception java.io.IOException In case of I/O error writing to the stream.
+     */
+
+    public void writeTo(Writer out)
+        throws IOException, ApfloatRuntimeException
+    {
+        writeTo(out, true);
+    }
+
+    /**
+     * Write a string representation of this aprational to a <code>Writer</code>.
+     *
+     * @param out The output <code>Writer</code>.
+     * @param pretty <code>true</code> to use a fixed-point notation, <code>false</code> to use an exponential notation.
+     *
+     * @exception java.io.IOException In case of I/O error writing to the stream.
+     */
+
+    public void writeTo(Writer out, boolean pretty)
+        throws IOException, ApfloatRuntimeException
+    {
+        numerator().writeTo(out, pretty);
+        if (!denominator().equals(ONE))
+        {
+            out.write('/');
+            denominator().writeTo(out, pretty);
+        }
+    }
+
+    /**
+     * Formats the object using the provided formatter.
+     *
+     * @param formatter The formatter.
+     * @param flags The flags to modify the output format.
+     * @param width The minimum number of characters to be written to the output, or <code>-1</code> for no minimum.
+     * @param precision The maximum number of characters to be written to the output, or <code>-1</code> for no maximum.
+     *
+     * @since 1.3
+     */
+
+    public void formatTo(Formatter formatter, int flags, int width, int precision)
+    {
+        if (denominator().equals(ONE))
+        {
+            numerator().formatTo(formatter, flags, width, precision);
+        }
+        else
+        {
+            if (width == -1)
+            {
+                numerator().formatTo(formatter, flags, width, precision);
+                formatter.format("/");
+                denominator().formatTo(formatter, flags, width, precision);
+            }
+            else
+            {
+                try
+                {
+                    Writer out = FormattingHelper.wrapAppendableWriter(formatter.out());
+                    out = FormattingHelper.wrapPadWriter(out, (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY);
+                    formatter = new Formatter(out, formatter.locale());
+                    numerator().formatTo(formatter, flags, -1, precision);
+                    formatter.format("/");
+                    denominator().formatTo(formatter, flags, -1, precision);
+                    FormattingHelper.finishPad(out, width);
+                }
+                catch (IOException ioe)
+                {
+                    // Ignore as we can't propagate it; unfortunately we can't set it to the formattable either
+                }
+            }
+        }
+    }
+
+    /**
+     * Returns an <code>ApfloatImpl</code> representing the approximation of this
+     * aprational up to the requested precision.<p>
+     *
+     * @param precision Precision of the <code>ApfloatImpl</code> that is needed.
+     *
+     * @return An <code>ApfloatImpl</code> representing this object to the requested precision.
+     */
+
+    protected ApfloatImpl getImpl(long precision)
+        throws ApfloatRuntimeException
+    {
+        return ensureApprox(precision).getImpl(precision);
+    }
+
+    // Round away from zero i.e. opposite direction of rounding than in truncate()
+    Apint roundAway()
+        throws ApfloatRuntimeException
+    {
+        Apint[] div = ApintMath.div(numerator(), denominator());
+
+        if (div[1].signum() == 0)
+        {
+            // No remainder from division; result is exact
+            return div[0];
+        }
+        else
+        {
+            // Remainder from division; round away from zero
+            return div[0].add(new Apint(signum(), div[0].radix()));
+        }
+    }
+
+    Aprational scale(long scale)
+    {
+        return AprationalMath.scale(this, scale);
+    }
+
+    Aprational abs()
+    {
+        return AprationalMath.abs(this);
+    }
+
+    int compareToHalf()
+    {
+        return RoundingHelper.compareToHalf(this);
+    }
+
+    private void checkDenominator()
+        throws IllegalArgumentException
+    {
+        if (this.denominator.signum() == 0)
+        {
+            throw new IllegalArgumentException("Denominator is zero");
+        }
+    }
+
+    // Reduce the numerator and denominator to smallest possible terms and set the signs properly
+    // NOTE: the method mutates this object, so it must only be called for newly constructed aprationals
+    // Returns this, for convenience
+    private Aprational reduce()
+        throws IllegalArgumentException, ApfloatRuntimeException
+    {
+        if (this.numerator.signum() == 0)
+        {
+            this.denominator = ONES[this.denominator.radix()];
+        }
+        else
+        {
+            if (!this.numerator.equals(ONE) && !this.denominator.equals(ONE))
+            {
+                if (this.numerator.radix() != this.denominator.radix())
+                {
+                    throw new IllegalArgumentException("Numerator and denominator must have the same radix");
+                }
+
+                Apint gcd = ApintMath.gcd(this.numerator, this.denominator);
+                this.numerator = this.numerator.divide(gcd);
+                this.denominator = this.denominator.divide(gcd);
+            }
+
+            int sign = this.numerator.signum() * this.denominator.signum();
+
+            this.denominator = ApintMath.abs(this.denominator);
+
+            if (sign != this.numerator.signum())
+            {
+                this.numerator = this.numerator.negate();
+            }
+        }
+
+        return this;
+    }
+
+    private synchronized Apfloat ensureApprox(long precision)
+        throws ApfloatRuntimeException
+    {
+        Apfloat approx = getApprox(precision);
+        if (approx == null || approx.precision() < precision)
+        {
+            if (denominator().equals(ONE))
+            {
+                approx = numerator();
+            }
+            else
+            {
+                precision = Math.max(precision, 1);     // In case the requested precision would be zero
+
+                if (denominator().isShort())
+                {
+                    approx = numerator().precision(precision).divide(denominator());
+                    setApprox(approx);
+                }
+                else
+                {
+                    Apfloat inverseDen = getInverseDen();
+                    inverseDen = ApfloatMath.inverseRoot(denominator(), 1, precision, inverseDen);
+                    approx = numerator().multiply(inverseDen);
+                    setApprox(approx);
+                    setInverseDen(inverseDen);
+                }
+            }
+        }
+
+        return approx;
+    }
+
+    private Apfloat getApprox(long precision)
+    {
+        return (this.approx == null ? null : this.approx.get());
+    }
+
+    private void setApprox(Apfloat approx)
+    {
+        this.approx = new SoftReference<Apfloat>(approx);
+    }
+
+    private Apfloat getInverseDen()
+    {
+        return (this.inverseDen == null ? null : this.inverseDen.get());
+    }
+
+    private void setInverseDen(Apfloat inverseDen)
+    {
+        this.inverseDen = new SoftReference<Apfloat>(inverseDen);
+    }
+
+    private static final long serialVersionUID = -224128535732558313L;
+
+    private static final long UNDEFINED = 0x8000000000000000L;
+
+    private Apint numerator;
+    private Apint denominator;
+    private volatile long scale = UNDEFINED;
+    private volatile long size = 0;
+    private transient SoftReference<Apfloat> inverseDen = null;
+    private transient SoftReference<Apfloat> approx = null;
+}
Index: src/main/java/org/apfloat/AprationalMath.java
===================================================================
--- src/main/java/org/apfloat/AprationalMath.java	(revision 0)
+++ src/main/java/org/apfloat/AprationalMath.java	(revision 0)
@@ -0,0 +1,284 @@
+package org.apfloat;
+
+import java.math.RoundingMode;
+
+import java.util.Arrays;
+import java.util.Comparator;
+
+/**
+ * Various mathematical functions for arbitrary precision rational numbers.
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class AprationalMath
+{
+    private AprationalMath()
+    {
+    }
+
+    /**
+     * Integer power.
+     *
+     * @param x Base of the power operator.
+     * @param n Exponent of the power operator.
+     *
+     * @return <code>x</code> to the <code>n</code>:th power, that is <code>x<sup>n</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If both <code>x</code> and <code>n</code> are zero.
+     */
+
+    public static Aprational pow(Aprational x, long n)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (n == 0)
+        {
+            if (x.signum() == 0)
+            {
+                throw new ArithmeticException("Zero to power zero");
+            }
+
+            return new Apint(1, x.radix());
+        }
+        else if (n < 0)
+        {
+            x = Aprational.ONE.divide(x);
+            n = -n;
+        }
+
+        // Algorithm improvements by Bernd Kellner
+        int b2pow = 0;
+
+        while ((n & 1) == 0)
+        {
+            b2pow++;
+            n >>>= 1;
+        }
+
+        Aprational r = x;
+
+        while ((n >>>= 1) > 0)
+        {
+            x = x.multiply(x);
+            if ((n & 1) != 0)
+            {
+                r = r.multiply(x);
+            }
+        }
+
+        while (b2pow-- > 0)
+        {
+            r = r.multiply(r);
+        }
+
+        return r;
+    }
+
+    /**
+     * Returns an aprational whose value is <code>-x</code>.
+     *
+     * @deprecated Use {@link Aprational#negate()}.
+     *
+     * @param x The argument.
+     *
+     * @return <code>-x</code>.
+     */
+
+    @Deprecated
+    public static Aprational negate(Aprational x)
+        throws ApfloatRuntimeException
+    {
+        return x.negate();
+    }
+
+    /**
+     * Absolute value.
+     *
+     * @param x The argument.
+     *
+     * @return Absolute value of <code>x</code>.
+     */
+
+    public static Aprational abs(Aprational x)
+        throws ApfloatRuntimeException
+    {
+        if (x.signum() >= 0)
+        {
+            return x;
+        }
+        else
+        {
+            return x.negate();
+        }
+    }
+
+    /**
+     * Copy sign from one argument to another.
+     *
+     * @param x The value whose sign is to be adjusted.
+     * @param y The value whose sign is to be used.
+     *
+     * @return <code>x</code> with its sign changed to match the sign of <code>y</code>.
+     *
+     * @since 1.1
+     */
+
+    public static Aprational copySign(Aprational x, Aprational y)
+        throws ApfloatRuntimeException
+    {
+        if (y.signum() == 0)
+        {
+            return y;
+        }
+        else if (x.signum() != y.signum())
+        {
+            return x.negate();
+        }
+        else
+        {
+            return x;
+        }
+    }
+
+    /**
+     * Multiply by a power of the radix.
+     * Note that this method is prone to intermediate overflow errors.
+     * Also, scaling by a very large negative number won't result in an
+     * underflow and a zero result, but an overflow of the denominator
+     * and an exception thrown.
+     *
+     * @param x The argument.
+     * @param scale The scaling factor.
+     *
+     * @return <code>x * x.radix()<sup>scale</sup></code>.
+     */
+
+    public static Aprational scale(Aprational x, long scale)
+        throws ApfloatRuntimeException
+    {
+        if (scale >= 0)
+        {
+            return new Aprational(ApintMath.scale(x.numerator(), scale), x.denominator());
+        }
+        else if (scale == 0x8000000000000000L)
+        {
+            Apint scaler = ApintMath.pow(new Apint(x.radix(), x.radix()), 0x4000000000000000L);
+            return new Aprational(x.numerator(), x.denominator().multiply(scaler)).divide(scaler);
+        }
+        else
+        {
+            return new Aprational(x.numerator(), ApintMath.scale(x.denominator(), -scale));
+        }
+    }
+
+    /**
+     * Rounds the given number to the specified precision with the specified rounding mode.
+     *
+     * @param x The number to round.
+     * @param precision The precision to round to.
+     * @param roundingMode The rounding mode to use.
+     *
+     * @return The rounded number.
+     *
+     * @exception java.lang.IllegalArgumentException If <code>precision</code> is less than zero or zero.
+     * @exception java.lang.ArithmeticException If rounding is necessary (result is not exact) and rounding mode is {@link RoundingMode#UNNECESSARY}.
+     *
+     * @since 1.7.0
+     */
+
+    public static Apfloat round(Aprational x, long precision, RoundingMode roundingMode)
+        throws IllegalArgumentException, ArithmeticException, ApfloatRuntimeException
+    {
+        return RoundingHelper.round(x, precision, roundingMode);
+    }
+
+    /**
+     * Product of numbers.
+     * This method may perform significantly better
+     * than simply multiplying the numbers sequentially.<p>
+     *
+     * If there are no arguments, the return value is <code>1</code>.
+     *
+     * @param x The argument(s).
+     *
+     * @return The product of the given numbers.
+     *
+     * @since 1.3
+     */
+
+    public static Aprational product(Aprational... x)
+        throws ApfloatRuntimeException
+    {
+        if (x.length == 0)
+        {
+            return Aprational.ONE;
+        }
+
+        Apint[] n = new Apint[x.length],
+                m = new Apint[x.length];
+        for (int i = 0; i < x.length; i++)
+        {
+            if (x[i].signum() == 0)
+            {
+                return Aprational.ZERO;
+            }
+            n[i] = x[i].numerator();
+            m[i] = x[i].denominator();
+        }
+        return new Aprational(ApintMath.product(n), ApintMath.product(m));
+    }
+
+    /**
+     * Sum of numbers.
+     * This method may perform significantly better
+     * than simply adding the numbers sequentially.<p>
+     *
+     * If there are no arguments, the return value is <code>0</code>.
+     *
+     * @param x The argument(s).
+     *
+     * @return The sum of the given numbers.
+     *
+     * @since 1.3
+     */
+
+    public static Aprational sum(Aprational... x)
+        throws ApfloatRuntimeException
+    {
+        if (x.length == 0)
+        {
+            return Aprational.ZERO;
+        }
+
+        // Sort by size
+        x = x.clone();
+
+        Arrays.sort(x, new Comparator<Aprational>()
+        {
+            public int compare(Aprational x, Aprational y)
+            {
+                long xSize = ApfloatHelper.size(x),
+                     ySize = ApfloatHelper.size(y);
+                return (xSize < ySize ? -1 : (xSize > ySize ? 1 : 0));
+            }
+        });
+
+        // Recursively add
+        return recursiveSum(x, 0, x.length - 1);
+    }
+
+    private static Aprational recursiveSum(Aprational[] x, int n, int m)
+        throws ApfloatRuntimeException
+    {
+        if (n == m)
+        {
+            return x[n];
+        }
+        else
+        {
+            int k = (n + m) >>> 1;
+            return recursiveSum(x, n, k).add(recursiveSum(x, k + 1, m));
+        }
+    }
+}
Index: src/main/java/org/apfloat/ConcurrentSoftHashMap.java
===================================================================
--- src/main/java/org/apfloat/ConcurrentSoftHashMap.java	(revision 0)
+++ src/main/java/org/apfloat/ConcurrentSoftHashMap.java	(revision 0)
@@ -0,0 +1,68 @@
+package org.apfloat;
+
+import java.lang.ref.SoftReference;
+import java.util.AbstractMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * Map with an underlying ConcurrentHashMap with softly referenced values.
+ * The maximum map size is assumed to be limited so no effort is made to
+ * expunge entries for stale values.
+ *
+ * @since 1.6
+ * @version 1.6
+ * @author Mikko Tommila
+ */
+
+class ConcurrentSoftHashMap<K, V>
+    extends AbstractMap<K, V>
+{
+    private ConcurrentHashMap<K, SoftReference<V>> map;
+
+    public ConcurrentSoftHashMap()
+    {
+        this.map = new ConcurrentHashMap<K, SoftReference<V>>();
+    }
+
+    public void clear()
+    {
+        this.map.clear();
+    }
+
+    public Set<Map.Entry<K, V>> entrySet()
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public V get(Object key)
+    {
+        return unwrap(this.map.get(key));
+    }
+
+    public V put(K key, V value)
+    {
+        return unwrap(this.map.put(key, wrap(value)));
+    }
+
+    public V remove(Object key)
+    {
+        return unwrap(this.map.remove(key));
+    }
+
+    public int size()
+    {
+        return this.map.size();
+    }
+
+    private SoftReference<V> wrap(V value)
+    {
+        return new SoftReference<V>(value);
+    }
+
+    private V unwrap(SoftReference<V> value)
+    {
+        return (value == null ? null : value.get());
+    }
+}
Index: src/main/java/org/apfloat/ConcurrentWeakHashMap.java
===================================================================
--- src/main/java/org/apfloat/ConcurrentWeakHashMap.java	(revision 0)
+++ src/main/java/org/apfloat/ConcurrentWeakHashMap.java	(revision 0)
@@ -0,0 +1,119 @@
+package org.apfloat;
+
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.WeakReference;
+import java.util.AbstractMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * Combination of WeakHashMap and ConcurrentHashMap,
+ * providing weak keys and non-blocking access.
+ *
+ * @since 1.5
+ * @version 1.8.2
+ * @author Mikko Tommila
+ */
+
+class ConcurrentWeakHashMap<K, V>
+    extends AbstractMap<K, V>
+{
+    private static class Key
+        extends WeakReference<Object>
+    {
+        private int hashCode;
+
+        public Key(Object key, ReferenceQueue<Object> queue)
+        {
+            super(key, queue);
+            this.hashCode = key.hashCode();
+        }
+
+        public int hashCode()
+        {
+            return this.hashCode;
+        }
+
+        public boolean equals(Object obj)
+        {
+            if (this == obj)
+            {
+                // Always matches even if referenced object has been garbage collected, needed for expunging garbage collected keys
+                return true;
+            }
+            if (obj instanceof Key)
+            {
+                Key that = (Key) obj;
+                Object value = get();
+                return (value != null && value.equals(that.get()));
+            }
+            return false;
+        }
+    }
+
+    private ConcurrentHashMap<Key, V> map;
+    private ReferenceQueue<Object> queue;
+
+    public ConcurrentWeakHashMap()
+    {
+        this.map = new ConcurrentHashMap<Key, V>();
+        this.queue = new ReferenceQueue<Object>();
+    }
+
+    public void clear()
+    {
+        expungeStaleEntries();
+        this.map.clear();
+    }
+
+    public Set<Map.Entry<K, V>> entrySet()
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public V get(Object key)
+    {
+        // Do not expunge stale entries here to improve performance
+        return this.map.get(wrap(key));
+    }
+
+    public V put(K key, V value)
+    {
+        expungeStaleEntries();
+        return this.map.put(wrap(key), value);
+    }
+
+    public V remove(Object key)
+    {
+        expungeStaleEntries();
+        return this.map.remove(wrap(key));
+    }
+
+    public boolean isEmpty()
+    {
+        // This is for the quick check, therefore we do not expunge stale entries here
+        return this.map.isEmpty();
+    }
+
+    public int size()
+    {
+        expungeStaleEntries();
+        return this.map.size();
+    }
+
+    private Key wrap(Object key)
+    {
+        return new Key(key, this.queue);
+    }
+
+    private void expungeStaleEntries()
+    {
+        // Should not cause (much) blocking
+        Key key;
+        while ((key = (Key) this.queue.poll()) != null)
+        {
+            this.map.remove(key);
+        }
+    }
+}
Index: src/main/java/org/apfloat/FixedPrecisionApcomplexHelper.java
===================================================================
--- src/main/java/org/apfloat/FixedPrecisionApcomplexHelper.java	(revision 0)
+++ src/main/java/org/apfloat/FixedPrecisionApcomplexHelper.java	(revision 0)
@@ -0,0 +1,782 @@
+package org.apfloat;
+
+import org.apfloat.spi.Util;
+
+/**
+ * Fixed-precision mathematical functions for complex numbers.<p>
+ *
+ * All results of the mathematical operations are set to have the specified precision.
+ * Also all input arguments are set to the specified precision before the operation.
+ * If the specified precision is not infinite, this helper class also avoids 
+ * <code>InfiniteExpansionException</code> e.g. in case where it would happen with
+ * <code>ApcomplexMath.acos(Apcomplex.ZERO)</code>.
+ *
+ * @since 1.5
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class FixedPrecisionApcomplexHelper
+{
+    /**
+     * Constructs an apcomplex fixed-precison helper with the specified precision.
+     * The results of all mathematical operations are set to the specified precision.
+     *
+     * @param precision The precision of the results.
+     *
+     * @exception java.lang.IllegalArgumentException In case the precision is invalid.
+     */
+
+    public FixedPrecisionApcomplexHelper(long precision)
+        throws IllegalArgumentException
+    {
+        ApfloatHelper.checkPrecision(precision);
+        this.precision = precision;
+    }
+
+    /**
+     * Returns the value with the specified precision.
+     *
+     * @param z The value.
+     *
+     * @return The value with to the specified precision.
+     */
+
+    public Apcomplex valueOf(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return z.precision(precision());
+    }
+
+    /**
+     * Negation.
+     *
+     * @param z The value to negate.
+     *
+     * @return <code>-z</code>.
+     */
+
+    public Apcomplex negate(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(z).negate();
+    }
+
+    /**
+     * Complex conjugate.
+     *
+     * @param z The operand.
+     *
+     * @return <code>x - i y</code> where <code>z</code> is <code>x + i y</code>.
+     */
+
+    public Apcomplex conj(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(z).conj();
+    }
+
+    /**
+     * Addition.
+     *
+     * @param z The first operand.
+     * @param w The second operand.
+     *
+     * @return <code>z + w</code>.
+     */
+
+    public Apcomplex add(Apcomplex z, Apcomplex w)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(setPrecision(z).add(setPrecision(w)));
+    }
+
+    /**
+     * Subtraction.
+     *
+     * @param z The first operand.
+     * @param w The second operand.
+     *
+     * @return <code>z - w</code>.
+     */
+
+    public Apcomplex subtract(Apcomplex z, Apcomplex w)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(setPrecision(z).subtract(setPrecision(w)));
+    }
+
+    /**
+     * Multiplication.
+     *
+     * @param z The first operand.
+     * @param w The second operand.
+     *
+     * @return <code>z * w</code>.
+     */
+
+    public Apcomplex multiply(Apcomplex z, Apcomplex w)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(setPrecision(z).multiply(setPrecision(w)));
+    }
+
+    /**
+     * Division.
+     *
+     * @param z The first operand.
+     * @param w The second operand.
+     *
+     * @return <code>z / w</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>w</code> is zero.
+     */
+
+    public Apcomplex divide(Apcomplex z, Apcomplex w)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(setPrecision(z).divide(setPrecision(w)));
+    }
+
+    /**
+     * Power.
+     *
+     * @param z The first operand.
+     * @param w The second operand.
+     *
+     * @return <code>z<sup>w</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> and <code>w</code> are zero.
+     */
+
+    public Apcomplex pow(Apcomplex z, Apcomplex w)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        Apcomplex result = ApfloatHelper.checkPow(z, w, precision());
+        if (result != null)
+        {
+            return valueOf(result);
+        }
+        return exp(multiply(log(z), w));
+    }
+
+    /**
+     * Integer power.
+     *
+     * @param z The first operand.
+     * @param n The first operand.
+     *
+     * @return <code>z<sup>n</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> and <code>n</code> are zero, or <code>z</code> is zero and <code>n</code> is negative.
+     */
+
+    public Apcomplex pow(Apcomplex z, long n)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.pow(setPrecision(z), n));
+    }
+
+    /**
+     * Complex angle.
+     *
+     * @param z The operand.
+     *
+     * @return The angle of <code>z</code> on the complex plane.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> is zero.
+     */
+
+    public Apfloat arg(Apcomplex z)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.arg(setPrecision(z)));
+    }
+
+    /**
+     * Imaginary part.
+     *
+     * @param z The operand.
+     *
+     * @return The imaginary part of <code>z</code>.
+     */
+
+    public Apfloat imag(Apcomplex z)
+    {
+        return valueOf(z.imag());
+    }
+
+    /**
+     * Real part.
+     *
+     * @param z The operand.
+     *
+     * @return The real part of <code>z</code>.
+     */
+
+    public Apfloat real(Apcomplex z)
+    {
+        return valueOf(z.real());
+    }
+
+    /**
+     * Absolute value.
+     *
+     * @param z The operand.
+     *
+     * @return The absolute value of <code>z</code>.
+     */
+
+    public Apfloat abs(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.abs(setPrecision(z)));
+    }
+
+    /**
+     * Norm.
+     *
+     * @param z The operand.
+     *
+     * @return <code>x<sup>2</sup> + y<sup>2</sup></code> where <code>z</code> is <code>x + i y</code>.
+     */
+
+    public Apfloat norm(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.norm(setPrecision(z)));
+    }
+
+    /**
+     * Arc cosine.
+     *
+     * @param z The operand.
+     *
+     * @return The arc cosine of <code>z</code>.
+     */
+
+    public Apcomplex acos(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        if (z.real().signum() == 0 && z.imag().signum() == 0)
+        {
+            // Zero always has infinite precision so when zero input causes nonzero output special care must be taken
+            return divide(pi(z.radix()), new Apfloat(2, precision(), z.radix()));
+        }
+        return valueOf(ApcomplexMath.acos(setPrecision(z)));
+    }
+
+    /**
+     * Hyperbolic arc cosine.
+     *
+     * @param z The operand.
+     *
+     * @return The hyperbolic arc cosine of <code>z</code>.
+     */
+
+    public Apcomplex acosh(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        if (z.real().signum() == 0 && z.imag().signum() == 0)
+        {
+            // Zero always has infinite precision so when zero input causes nonzero output special care must be taken
+            return valueOf(new Apcomplex(Apfloat.ZERO, pi(z.radix()).divide(new Apfloat(2, precision(), z.radix()))));
+        }
+        return valueOf(ApcomplexMath.acosh(setPrecision(z)));
+    }
+
+    /**
+     * Arc sine.
+     *
+     * @param z The operand.
+     *
+     * @return The arc sine of <code>z</code>.
+     */
+
+    public Apcomplex asin(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.asin(setPrecision(z)));
+    }
+
+    /**
+     * Hyperbolic arc sine.
+     *
+     * @param z The operand.
+     *
+     * @return The hyperbolic arc sine of <code>z</code>.
+     */
+
+    public Apcomplex asinh(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.asinh(setPrecision(z)));
+    }
+
+    /**
+     * Arc tangent.
+     *
+     * @param z The operand.
+     *
+     * @return The arc tangent of <code>z</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> is <code>i</code>.
+     */
+
+    public Apcomplex atan(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.atan(setPrecision(z)));
+    }
+
+    /**
+     * Hyperbolic arc tangent.
+     *
+     * @param z The operand.
+     *
+     * @return The hyperbolic arc tangent of <code>z</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> is 1 or -1.
+     */
+
+    public Apcomplex atanh(Apcomplex z)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.atanh(setPrecision(z)));
+    }
+
+    /**
+     * Cube root.
+     *
+     * @param z The operand.
+     *
+     * @return The cube root of <code>z</code>.
+     */
+
+    public Apcomplex cbrt(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.cbrt(setPrecision(z)));
+    }
+
+    /**
+     * Cosine.
+     *
+     * @param z The operand.
+     *
+     * @return The cosine of <code>z</code>.
+     */
+
+    public Apcomplex cos(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.cos(setTrigExpPrecision(z)));
+    }
+
+    /**
+     * Hyperbolic cosine.
+     *
+     * @param z The operand.
+     *
+     * @return The hyperbolic cosine of <code>z</code>.
+     */
+
+    public Apcomplex cosh(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.cosh(setExpTrigPrecision(z)));
+    }
+
+    /**
+     * Exponential function.
+     *
+     * @param z The operand.
+     *
+     * @return <code>e<sup>z</sup></code>.
+     */
+
+    public Apcomplex exp(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.exp(setExpTrigPrecision(z)));
+    }
+
+    /**
+     * Natural logarithm.
+     *
+     * @param z The operand.
+     *
+     * @return The natural logarithm of <code>z</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> is zero.
+     */
+
+    public Apcomplex log(Apcomplex z)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.log(setPrecision(z)));
+    }
+
+    /**
+     * Logarithm in specified base.
+     *
+     * @param z The operand.
+     * @param w The base.
+     *
+     * @return The base-<code>w</code> logarithm of <code>z</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> or <code>w</code> is zero.
+     *
+     * @since 1.6
+     */
+
+    public Apcomplex log(Apcomplex z, Apcomplex w)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.log(setPrecision(z), setPrecision(w)));
+    }
+
+    /**
+     * Sine.
+     *
+     * @param z The operand.
+     *
+     * @return The sine of <code>z</code>.
+     */
+
+    public Apcomplex sin(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.sin(setTrigExpPrecision(z)));
+    }
+
+    /**
+     * Hyperbolic sine.
+     *
+     * @param z The operand.
+     *
+     * @return The hyperbolic sine of <code>z</code>.
+     */
+
+    public Apcomplex sinh(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.sinh(setExpTrigPrecision(z)));
+    }
+
+    /**
+     * Square root.
+     *
+     * @param z The operand.
+     *
+     * @return The square root of <code>z</code>.
+     */
+
+    public Apcomplex sqrt(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.sqrt(setPrecision(z)));
+    }
+
+    /**
+     * Tangent.
+     *
+     * @param z The operand.
+     *
+     * @return The tangent of <code>z</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> is &pi;/2 + n &pi; where n is an integer.
+     */
+
+    public Apcomplex tan(Apcomplex z)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.tan(setTrigExpPrecision(z)));
+    }
+
+    /**
+     * Hyperbolic tangent.
+     *
+     * @param z The operand.
+     *
+     * @return The hyperbolic tangent of <code>z</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> is i (&pi;/2 + n &pi;) where n is an integer.
+     */
+
+    public Apcomplex tanh(Apcomplex z)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.tanh(setExpTrigPrecision(z)));
+    }
+
+    /**
+     * Arithmetic-geometric mean.
+     *
+     * @param a The first operand.
+     * @param b The first operand.
+     *
+     * @return The arithmetic-geometric mean of <code>a</code> and <code>b</code>.
+     */
+
+    public Apcomplex agm(Apcomplex a, Apcomplex b)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.agm(setPrecision(a), setPrecision(b)));
+    }
+
+    /**
+     * Inverse root.
+     *
+     * @param z The operand.
+     * @param n Which inverse root to take.
+     *
+     * @return <code>z<sup>-1/n</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> or <code>n</code> is zero.
+     */
+
+    public Apcomplex inverseRoot(Apcomplex z, long n)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.inverseRoot(setPrecision(z), n));
+    }
+
+    /**
+     * Inverse root with branch.
+     *
+     * @param z The operand.
+     * @param n Which inverse root to take.
+     * @param k Which branch to take.
+     *
+     * @return <code>z<sup>-1/n</sup>e<sup>-i2&pi;k/n</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>z</code> or <code>n</code> is zero.
+     */
+
+    public Apcomplex inverseRoot(Apcomplex z, long n, long k)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.inverseRoot(setPrecision(z), n, k));
+    }
+
+    /**
+     * Root.
+     *
+     * @param z The operand.
+     * @param n Which root to take.
+     *
+     * @return <code>z<sup>1/n</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>n</code> is zero, or <code>z</code> is zero and <code>n</code> is negative.
+     */
+
+    public Apcomplex root(Apcomplex z, long n)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.root(setPrecision(z), n));
+    }
+
+    /**
+     * Root with branch.
+     *
+     * @param z The operand.
+     * @param n Which root to take.
+     * @param k Which branch to take.
+     *
+     * @return <code>z<sup>1/n</sup>e<sup>i2&pi;sk/n</sup></code> where <code>s</code> is the signum of the imaginary part of <code>z</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>n</code> is zero, or <code>z</code> is zero and <code>n</code> is negative.
+     */
+
+    public Apcomplex root(Apcomplex z, long n, long k)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.root(setPrecision(z), n, k));
+    }
+
+    /**
+     * All branches of a root.
+     *
+     * @param z The operand.
+     * @param n Which root to take.
+     *
+     * @return <code>z<sup>1/n</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>n</code> is zero, or <code>z</code> is zero and <code>n</code> is negative.
+     */
+
+    public Apcomplex[] allRoots(Apcomplex z, int n)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        Apcomplex[] allRoots = ApcomplexMath.allRoots(setPrecision(z), n);
+        for (int i = 0; i < allRoots.length; i++)
+        {
+            allRoots[i] = valueOf(allRoots[i]);
+        }
+        return allRoots;
+    }
+
+    /**
+     * Move the radix point.
+     *
+     * @param z The operand.
+     * @param scale The amount to move the radix point.
+     *
+     * @return <code>z * z.radix()<sup>scale</sup></code>.
+     */
+
+    public Apcomplex scale(Apcomplex z, long scale)
+        throws ApfloatRuntimeException
+    {
+        return ApcomplexMath.scale(valueOf(z), scale);
+    }
+
+    /**
+     * Lambert W function.
+     *
+     * @param z The operand.
+     *
+     * @return <code>W<sub>0</sub>(z)</code>.
+     *
+     * @since 1.8.0
+     */
+
+    public Apcomplex w(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.w(setPrecision(z)));
+    }
+
+    /**
+     * Lambert W function for the specified branch.
+     *
+     * @param z The operand.
+     * @param k The branch.
+     *
+     * @return <code>W<sub>k</sub>(z)</code>.
+     *
+     * @since 1.8.0
+     */
+
+    public Apcomplex w(Apcomplex z, long k)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.w(setPrecision(z), k));
+    }
+
+    /**
+     * Product.
+     *
+     * @param z The operand(s).
+     *
+     * @return The product of the operands.
+     */
+
+    public Apcomplex product(Apcomplex... z)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApcomplexMath.product(setPrecision(z)));
+    }
+
+    /**
+     * Sum.
+     *
+     * @param z The operand(s).
+     *
+     * @return The sum of the operands.
+     */
+
+    public Apcomplex sum(Apcomplex... z)
+        throws ApfloatRuntimeException
+    {
+        // This is not entirely optimal as the real and imaginary parts might have different scales and one of them could have thus reduced precision
+        return valueOf(ApcomplexMath.sum(setPrecision(z)));
+    }
+
+    /**
+     * Returns the precision, which is used for the results.
+     *
+     * @return The precision of the results.
+     */
+
+    public long precision()
+    {
+        return this.precision;
+    }
+
+    Apfloat valueOf(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return x.precision(precision());
+    }
+
+    Apfloat pi()
+        throws ApfloatRuntimeException
+    {
+        return ApfloatMath.pi(precision());
+    }
+
+    Apfloat pi(int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        return ApfloatMath.pi(precision(), radix);
+    }
+
+    Apfloat setTrigonometricPrecision(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        long precision = ApfloatHelper.extendPrecision(precision(), Math.max(0, x.scale()));
+        return x.precision(precision);
+    }
+
+    Apfloat setExponentialPrecision(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        if (x.scale() <= -precision())
+        {
+            // Result will be rounded to one so avoid heavy high-precision calculation
+            x = new Apfloat(0, Apfloat.DEFAULT, x.radix());
+        }
+        else if (x.scale() < 0)
+        {
+            // Taylor series would increase precision, thus reduce it
+            long precision = Util.ifFinite(precision(), precision() + x.scale());
+            x = x.precision(precision);
+        }
+        else
+        {
+            x = x.precision(precision());
+        }
+        return x;
+    }
+
+    private Apcomplex setPrecision(Apcomplex z)
+        throws ApfloatRuntimeException
+    {
+        return z.precision(precision());
+    }
+
+    private Apcomplex[] setPrecision(Apcomplex[] z)
+        throws ApfloatRuntimeException
+    {
+        Apcomplex[] tmp = new Apcomplex[z.length];
+        for (int i = 0; i < z.length; i++)
+        {
+            tmp[i] = setPrecision(z[i]);
+        }
+        return tmp;
+    }
+
+    private Apcomplex setExpTrigPrecision(Apcomplex z)
+    {
+        return new Apcomplex(setExponentialPrecision(z.real()), setTrigonometricPrecision(z.imag()));
+    }
+
+    private Apcomplex setTrigExpPrecision(Apcomplex z)
+    {
+        return new Apcomplex(setTrigonometricPrecision(z.real()), setExponentialPrecision(z.imag()));
+    }
+
+    private long precision;
+}
Index: src/main/java/org/apfloat/FixedPrecisionApfloatHelper.java
===================================================================
--- src/main/java/org/apfloat/FixedPrecisionApfloatHelper.java	(revision 0)
+++ src/main/java/org/apfloat/FixedPrecisionApfloatHelper.java	(revision 0)
@@ -0,0 +1,877 @@
+package org.apfloat;
+
+import java.math.RoundingMode;
+
+import org.apfloat.spi.Util;
+
+/**
+ * Fixed-precision mathematical functions for floating-point numbers.<p>
+ *
+ * All results of the mathematical operations are set to have the specified precision.
+ * Also all input arguments are set to the specified precision before the operation.
+ * If the specified precision is not infinite, this helper class also avoids 
+ * <code>InfiniteExpansionException</code> e.g. in case where it would happen with
+ * <code>ApfloatMath.acos(Apfloat.ZERO)</code>.
+ *
+ * @since 1.5
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class FixedPrecisionApfloatHelper
+    extends FixedPrecisionApcomplexHelper
+{
+    /**
+     * Constructs an apfloat fixed-precison helper with the specified precision.
+     * The results of all mathematical operations are set to the specified precision.
+     *
+     * @param precision The precision of the results.
+     *
+     * @exception java.lang.IllegalArgumentException In case the precision is invalid.
+     */
+
+    public FixedPrecisionApfloatHelper(long precision)
+        throws IllegalArgumentException
+    {
+        super(precision);
+    }
+
+    /**
+     * Returns the value with the specified precision.
+     *
+     * @param x The value.
+     *
+     * @return The value with to the specified precision.
+     */
+
+    public Apfloat valueOf(Apfloat x)
+    {
+        return super.valueOf(x);
+    }
+
+    /**
+     * Negation.
+     *
+     * @param x The value to negate.
+     *
+     * @return <code>-x</code>.
+     */
+
+    public Apfloat negate(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(x).negate();
+    }
+
+    /**
+     * Addition.
+     *
+     * @param x The first operand.
+     * @param y The second operand.
+     *
+     * @return <code>x + y</code>.
+     */
+
+    public Apfloat add(Apfloat x, Apfloat y)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(setPrecision(x).add(valueOf(y)));
+    }
+
+    /**
+     * Subtraction.
+     *
+     * @param x The first operand.
+     * @param y The second operand.
+     *
+     * @return <code>x - y</code>.
+     */
+
+    public Apfloat subtract(Apfloat x, Apfloat y)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(setPrecision(x).subtract(setPrecision(y)));
+    }
+
+    /**
+     * Multiplication.
+     *
+     * @param x The first operand.
+     * @param y The second operand.
+     *
+     * @return <code>x * y</code>.
+     */
+
+    public Apfloat multiply(Apfloat x, Apfloat y)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(setPrecision(x).multiply(setPrecision(y)));
+    }
+
+    /**
+     * Division.
+     *
+     * @param x The first operand.
+     * @param y The second operand.
+     *
+     * @return <code>x / y</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>y</code> is zero.
+     */
+
+    public Apfloat divide(Apfloat x, Apfloat y)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(setPrecision(x).divide(setPrecision(y)));
+    }
+
+    /**
+     * Power.
+     *
+     * @param x The first operand.
+     * @param y The second operand.
+     *
+     * @return <code>x<sup>y</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>x</code> and <code>y</code> are zero, or <code>x</code> is negative.
+     */
+
+    public Apfloat pow(Apfloat x, Apfloat y)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        Apfloat result = ApfloatHelper.checkPow(x, y, precision());
+        if (result != null)
+        {
+            return valueOf(result);
+        }
+        return exp(multiply(log(x), y));
+    }
+
+    /**
+     * Integer power.
+     *
+     * @param x The first operand.
+     * @param n The second operand.
+     *
+     * @return <code>x<sup>n</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>x</code> and <code>n</code> are zero, or <code>x</code> is zero and <code>n</code> is negative.
+     */
+
+    public Apfloat pow(Apfloat x, long n)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.pow(setPrecision(x), n));
+    }
+
+    /**
+     * Absolute value.
+     *
+     * @param x The operand.
+     *
+     * @return The absolute value of <code>x</code>.
+     */
+
+    public Apfloat abs(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return ApfloatMath.abs(valueOf(x));
+    }
+
+    /**
+     * Arc cosine.
+     *
+     * @param x The operand.
+     *
+     * @return The arc cosine of <code>x</code>.
+     *
+     * @exception java.lang.ArithmeticException If the absolute value of <code>x</code> is more than one.
+     */
+
+    public Apfloat acos(Apfloat x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (x.signum() == 0)
+        {
+            // Zero always has infinite precision so when zero input causes nonzero output special care must be taken
+            return divide(pi(x.radix()), new Apfloat(2, precision(), x.radix()));
+        }
+        return valueOf(ApfloatMath.acos(setPrecision(x)));
+    }
+
+    /**
+     * Hyperbolic arc cosine.
+     *
+     * @param x The operand.
+     *
+     * @return The hyperbolic arc cosine of <code>x</code>.
+     *
+     * @exception java.lang.ArithmeticException If the <code>x</code> is less than one.
+     */
+
+    public Apfloat acosh(Apfloat x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.acosh(setPrecision(x)));
+    }
+
+    /**
+     * Arc sine.
+     *
+     * @param x The operand.
+     *
+     * @return The arc sine of <code>x</code>.
+     *
+     * @exception java.lang.ArithmeticException If the absolute value of <code>x</code> is more than one.
+     */
+
+    public Apfloat asin(Apfloat x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.asin(setPrecision(x)));
+    }
+
+    /**
+     * Hyperbolic arc sine.
+     *
+     * @param x The operand.
+     *
+     * @return The hyperbolic arc sine of <code>x</code>.
+     */
+
+    public Apfloat asinh(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.asinh(setPrecision(x)));
+    }
+
+    /**
+     * Arc tangent.
+     *
+     * @param x The operand.
+     *
+     * @return The arc tangent of <code>x</code>.
+     */
+
+    public Apfloat atan(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.atan(setPrecision(x)));
+    }
+
+    /**
+     * Hyperbolic arc tangent.
+     *
+     * @param x The operand.
+     *
+     * @return The hyperbolic arc tangent of <code>x</code>.
+     *
+     * @exception java.lang.ArithmeticException If the absolute value of <code>x</code> is equal to or more than one.
+     */
+
+    public Apfloat atanh(Apfloat x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.atanh(setPrecision(x)));
+    }
+
+    /**
+     * Cube root.
+     *
+     * @param x The operand.
+     *
+     * @return The cube root of <code>x</code>.
+     */
+
+    public Apfloat cbrt(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.cbrt(setPrecision(x)));
+    }
+
+    /**
+     * Cosine.
+     *
+     * @param x The operand.
+     *
+     * @return The cosine of <code>x</code>.
+     */
+
+    public Apfloat cos(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.cos(setTrigonometricPrecision(x)));
+    }
+
+    /**
+     * Hyperbolic cosine.
+     *
+     * @param x The operand.
+     *
+     * @return The hyperbolic cosine of <code>x</code>.
+     */
+
+    public Apfloat cosh(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.cosh(setExponentialPrecision(x)));
+    }
+
+    /**
+     * Exponential function.
+     *
+     * @param x The operand.
+     *
+     * @return <code>e<sup>x</sup></code>.
+     */
+
+    public Apfloat exp(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.exp(setExponentialPrecision(x)));
+    }
+
+    /**
+     * Natural logarithm.
+     *
+     * @param x The operand.
+     *
+     * @return The natural logarithm of <code>x</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>x</code> is less than or equal to zero.
+     */
+
+    public Apfloat log(Apfloat x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        // If x is close to one then result will actually have limited accuracy
+        // So, if the argument would have more precision, it could be used, however checking for
+        // this as well as the computation itself could be very time-consuming so we don't do it
+        return valueOf(ApfloatMath.log(setPrecision(x)));
+    }
+
+    /**
+     * Logarithm in specified base.
+     *
+     * @param x The operand.
+     * @param b The base.
+     *
+     * @return The base-<code>b</code> logarithm of <code>x</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>x</code> or <code>b</code> is less than or equal to zero.
+     *
+     * @since 1.6
+     */
+
+    public Apfloat log(Apfloat x, Apfloat b)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        // If x or b is close to one then result will actually have limited accuracy
+        // So, if the argument would have more precision, it could be used, however checking for
+        // this as well as the computation itself could be very time-consuming so we don't do it
+        return valueOf(ApfloatMath.log(setPrecision(x), setPrecision(b)));
+    }
+
+    /**
+     * Sine.
+     *
+     * @param x The operand.
+     *
+     * @return The sine of <code>x</code>.
+     */
+
+    public Apfloat sin(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.sin(setTrigonometricPrecision(x)));
+    }
+
+    /**
+     * Hyperbolic sine.
+     *
+     * @param x The operand.
+     *
+     * @return The hyperbolic sine of <code>x</code>.
+     */
+
+    public Apfloat sinh(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.sinh(setExponentialPrecision(x)));
+    }
+
+    /**
+     * Square root.
+     *
+     * @param x The operand.
+     *
+     * @return The square root of <code>x</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>x</code> is negative.
+     */
+
+    public Apfloat sqrt(Apfloat x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.sqrt(setPrecision(x)));
+    }
+
+    /**
+     * Tangent.
+     *
+     * @param x The operand.
+     *
+     * @return The tangent of <code>x</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>x</code> is &pi;/2 + n &pi; where n is an integer.
+     */
+
+    public Apfloat tan(Apfloat x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.tan(setTrigonometricPrecision(x)));
+    }
+
+    /**
+     * Hyperbolic tangent.
+     *
+     * @param x The operand.
+     *
+     * @return The hyperbolic tangent of <code>x</code>.
+     */
+
+    public Apfloat tanh(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.tanh(setExponentialPrecision(x)));
+    }
+
+    /**
+     * Arithmetic-geometric mean.
+     *
+     * @param a The first operand.
+     * @param b The first operand.
+     *
+     * @return The arithmetic-geometric mean of <code>a</code> and <code>b</code>.
+     */
+
+    public Apfloat agm(Apfloat a, Apfloat b)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.agm(setPrecision(a), setPrecision(b)));
+    }
+
+    /**
+     * Inverse root.
+     *
+     * @param x The operand.
+     * @param n Which inverse root to take.
+     *
+     * @return <code>x<sup>-1/n</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>x</code> or <code>n</code> is zero, or <code>x</code> is negative and <code>n</code> is even.
+     */
+
+    public Apfloat inverseRoot(Apfloat x, long n)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.inverseRoot(setPrecision(x), n));
+    }
+
+    /**
+     * Root.
+     *
+     * @param x The operand.
+     * @param n Which root to take.
+     *
+     * @return <code>x<sup>1/n</sup></code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>n</code> is zero, or <code>x</code> is negative and <code>n</code> is even.
+     */
+
+    public Apfloat root(Apfloat x, long n)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.root(setPrecision(x), n));
+    }
+
+    /**
+     * Move the radix point.
+     *
+     * @param x The operand.
+     * @param scale The amount to move the radix point.
+     *
+     * @return <code>x * x.radix()<sup>scale</sup></code>.
+     */
+
+    public Apfloat scale(Apfloat x, long scale)
+        throws ApfloatRuntimeException
+    {
+        return ApfloatMath.scale(valueOf(x), scale);
+    }
+
+    /**
+     * Modulus.
+     *
+     * @param x The first operand.
+     * @param y The second operand.
+     *
+     * @return <code>x % y</code>.
+     */
+
+    public Apfloat mod(Apfloat x, Apfloat y)
+        throws ApfloatRuntimeException
+    {
+        return fmod(x, y);
+    }
+
+    /**
+     * Ceiling function.
+     *
+     * @param x The operand.
+     *
+     * @return The nearest integer greater than or equal to <code>x</code>.
+     */
+
+    public Apfloat ceil(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.ceil(setPrecision(x)));
+    }
+
+    /**
+     * Floor function.
+     *
+     * @param x The operand.
+     *
+     * @return The nearest integer less than or equal to <code>x</code>.
+     */
+
+    public Apfloat floor(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.floor(setPrecision(x)));
+    }
+
+    /**
+     * Truncate fractional part.
+     *
+     * @param x The operand.
+     *
+     * @return The nearest integer rounded towards zero from <code>x</code>.
+     */
+
+    public Apfloat truncate(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.truncate(setPrecision(x)));
+    }
+
+    /**
+     * Extract fractional part.
+     *
+     * @param x The operand.
+     *
+     * @return The fractional part of <code>x</code>.
+     *
+     * @since 1.7.0
+     */
+
+    public Apfloat frac(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.frac(x));
+    }
+
+    /**
+     * Round with specified rounding mode.
+     *
+     * @param x The operand.
+     * @param roundingMode The rounding mode.
+     *
+     * @return <code>x</code> rounded with the specified rounding mode.
+     *
+     * @since 1.7.0
+     */
+
+    public Apfloat round(Apfloat x, RoundingMode roundingMode)
+        throws ApfloatRuntimeException
+    {
+        return ApfloatMath.round(x, precision(), roundingMode);
+    }
+
+    /**
+     * Lambert W function.
+     *
+     * @param x The operand.
+     *
+     * @return <code>W<sub>0</sub>(x)</code>.
+     *
+     * @since 1.8.0
+     */
+
+    public Apfloat w(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.w(setPrecision(x)));
+    }
+
+    /**
+     * Convert radians to degrees.
+     *
+     * @param x The angle in radians.
+     *
+     * @return <code>x</code> converted to degrees.
+     *
+     * @since 1.8.0
+     */
+
+    public Apfloat toDegrees(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.toDegrees(setPrecision(x)));
+    }
+
+    /**
+     * Convert degrees to radians.
+     *
+     * @param x The angle in degrees.
+     *
+     * @return <code>x</code> converted to radians.
+     *
+     * @since 1.8.0
+     */
+
+    public Apfloat toRadians(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.toRadians(setPrecision(x)));
+    }
+
+    /**
+     * Angle of point.
+     *
+     * @param x The operand.
+     * @param y The operand.
+     *
+     * @return The angle of the point <code>(y, x)</code>.
+     *
+     * @exception java.lang.ArithmeticException If <code>x</code> and <code>y</code> are zero.
+     */
+
+    public Apfloat atan2(Apfloat x, Apfloat y)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.atan2(setPrecision(x), setPrecision(y)));
+    }
+
+    /**
+     * Copies the sign from one number to another.
+     *
+     * @param x The number to copy the sign to.
+     * @param y The number to copy the sign from.
+     *
+     * @return <code>x</code> with the sign of <code>y</code>.
+     */
+
+    public Apfloat copySign(Apfloat x, Apfloat y)
+        throws ApfloatRuntimeException
+    {
+        return ApfloatMath.copySign(valueOf(x), y);
+    }
+
+    /**
+     * Modulus.
+     *
+     * @param x The first operand.
+     * @param y The second operand.
+     *
+     * @return <code>x % y</code>.
+     */
+
+    public Apfloat fmod(Apfloat x, Apfloat y)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.fmod(x, setPrecision(y)));     // Since x might be much larger in scale we do not limit precision yet here
+    }
+
+    /**
+     * Split to integer and fractional parts.
+     *
+     * @param x The operand.
+     *
+     * @return An array of two numbers <code>[i, f]</code> where <code>i</code> is <code>floor(x)</code> and <code>f</code> is <code>x - floor(x)</code>.
+     */
+
+    public Apfloat[] modf(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        if (x.scale() > 0)
+        {
+            long precision = Util.ifFinite(precision(), precision() + x.scale());
+            x = x.precision(precision);
+        }
+        else
+        {
+            x = setPrecision(x);
+        }
+        Apfloat[] modfs = ApfloatMath.modf(x);
+        modfs[0] = valueOf(modfs[0]);
+        modfs[1] = valueOf(modfs[1]);
+        return modfs;
+    }
+
+    /**
+     * Factorial.
+     *
+     * @param n The operand.
+     *
+     * @return <code>n!</code>.
+     */
+
+    public Apfloat factorial(long n)
+        throws ApfloatRuntimeException
+    {
+        // For low precision and high n the result could be approximated faster with Stirling's formula
+        return valueOf(ApfloatMath.factorial(n, precision()));
+    }
+
+    /**
+     * Factorial.
+     *
+     * @param n The operand.
+     * @param radix The radix of the result.
+     *
+     * @return <code>n!</code>.
+     */
+
+    public Apfloat factorial(long n, int radix)
+        throws ApfloatRuntimeException
+    {
+        // For low precision and high n the result could be approximated faster with Stirling's formula
+        return valueOf(ApfloatMath.factorial(n, precision(), radix));
+    }
+
+    /**
+     * &pi;.
+     *
+     * @return <code>&pi;</code>.
+     */
+
+    public Apfloat pi()
+        throws ApfloatRuntimeException
+    {
+        return super.pi();
+    }
+
+    /**
+     * &pi;.
+     *
+     * @param radix The radix of the result.
+     *
+     * @return <code>&pi;</code>.
+     *
+     * @exception java.lang.NumberFormatException If the radix is invalid.
+     */
+
+    public Apfloat pi(int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        return super.pi(radix);
+    }
+
+    /**
+     * Logarithm.
+     *
+     * @param radix The radix of the result.
+     *
+     * @return <code>log(radix)</code>.
+     *
+     * @exception java.lang.NumberFormatException If the radix is invalid.
+     */
+
+    public Apfloat logRadix(int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        return ApfloatMath.logRadix(precision(), radix);
+    }
+
+    /**
+     * Fused multiply-add.
+     *
+     * @param a The first operand.
+     * @param b The second operand.
+     * @param c The third operand.
+     * @param d The fourth operand.
+     *
+     * @return <code>a * b + c * d</code>.
+     */
+
+    public Apfloat multiplyAdd(Apfloat a, Apfloat b, Apfloat c, Apfloat d)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.multiplyAdd(setPrecision(a), setPrecision(b), setPrecision(c), setPrecision(d)));
+    }
+
+    /**
+     * Fused multiply-subtract.
+     *
+     * @param a The first operand.
+     * @param b The second operand.
+     * @param c The third operand.
+     * @param d The fourth operand.
+     *
+     * @return <code>a * b - c * d</code>.
+     */
+
+    public Apfloat multiplySubtract(Apfloat a, Apfloat b, Apfloat c, Apfloat d)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.multiplySubtract(setPrecision(a), setPrecision(b), setPrecision(c), setPrecision(d)));
+    }
+
+    /**
+     * Product.
+     *
+     * @param x The operand(s).
+     *
+     * @return The product of the operands.
+     */
+
+    public Apfloat product(Apfloat... x)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.product(setPrecision(x)));
+    }
+
+    /**
+     * Sum.
+     *
+     * @param x The operand(s).
+     *
+     * @return The sum of the operands.
+     */
+
+    public Apfloat sum(Apfloat... x)
+        throws ApfloatRuntimeException
+    {
+        return valueOf(ApfloatMath.sum(setPrecision(x)));
+    }
+
+    private Apfloat setPrecision(Apfloat x)
+        throws ApfloatRuntimeException
+    {
+        return x.precision(precision());
+    }
+
+    private Apfloat[] setPrecision(Apfloat[] x)
+        throws ApfloatRuntimeException
+    {
+        Apfloat[] tmp = new Apfloat[x.length];
+        for (int i = 0; i < x.length; i++)
+        {
+            tmp[i] = setPrecision(x[i]);
+        }
+        return tmp;
+    }
+}
Index: src/main/java/org/apfloat/FormattingHelper.java
===================================================================
--- src/main/java/org/apfloat/FormattingHelper.java	(revision 0)
+++ src/main/java/org/apfloat/FormattingHelper.java	(revision 0)
@@ -0,0 +1,274 @@
+package org.apfloat;
+
+import java.io.Closeable;
+import java.io.Flushable;
+import java.io.Writer;
+import java.io.FilterWriter;
+import java.io.StringWriter;
+import java.io.IOException;
+import java.text.DecimalFormatSymbols;
+import java.util.Formatter;
+import java.util.Locale;
+
+/**
+ * Helper class for formatting.
+ *
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+class FormattingHelper
+{
+    private static class AppendableWriter
+        extends Writer
+    {
+        public AppendableWriter(Appendable out)
+        {
+            this.out = out;
+        }
+
+        public void write(int c)
+            throws IOException
+        {
+            this.out.append((char) c);
+        }
+
+        public void write(char[] buffer, int offset, int length)
+            throws IOException
+        {
+            for (int i = 0; i < length; i++)
+            {
+                this.out.append(buffer[i + offset]);
+            }
+        }
+
+        public void write(String text, int offset, int length)
+            throws IOException
+        {
+            this.out.append(text, offset, length);
+        }
+
+        public Writer append(CharSequence sequence)
+            throws IOException
+        {
+            this.out.append(sequence);
+            return this;
+        }
+
+        public Writer append(CharSequence sequence, int start, int end)
+            throws IOException
+        {
+            this.out.append(sequence, start, end);
+            return this;
+        }
+
+        public void flush()
+            throws IOException
+        {
+            if (this.out instanceof Flushable)
+            {
+                ((Flushable) this.out).flush();
+            }
+        }
+
+        public void close()
+            throws IOException
+        {
+            if (this.out instanceof Closeable)
+            {
+                ((Closeable) this.out).close();
+            }
+        }
+
+        private Appendable out;
+    }
+
+    private static class LocalizeWriter
+        extends FilterWriter
+    {
+        public LocalizeWriter(Writer out, Locale locale, boolean localizeDigits, boolean isUpperCase)
+        {
+            super(out);
+            this.locale = locale;
+            this.localizeDigits = localizeDigits;
+            this.isUpperCase = isUpperCase;
+            if (locale != null)
+            {
+                DecimalFormatSymbols decimalFormatSymbols = new DecimalFormatSymbols(locale);
+                this.zero = decimalFormatSymbols.getZeroDigit();
+                this.decimalSeparator = decimalFormatSymbols.getDecimalSeparator();
+            }
+            else
+            {
+                this.zero = '0';
+                this.decimalSeparator = '.';
+            }
+        }
+
+        public void write(int c)
+            throws IOException
+        {
+            if (c == '.')
+            {
+                c = this.decimalSeparator;
+            }
+            else if (this.localizeDigits && c >= '0' && c <= '9')
+            {
+                c += this.zero - '0';
+            }
+            if (this.isUpperCase)
+            {
+                String s;
+                if (this.locale == null)
+                {
+                    s = String.valueOf((char) c).toUpperCase();
+                }
+                else
+                {
+                    s = String.valueOf((char) c).toUpperCase(this.locale);
+                }
+                for (int i = 0; i < s.length(); i++)
+                {
+                    super.write(s.charAt(i));
+                }
+            }
+            else
+            {
+                super.write(c);
+            }
+        }
+
+        public void write(char[] buffer, int offset, int length)
+            throws IOException
+        {
+            for (int i = 0; i < length; i++)
+            {
+                write(buffer[i + offset]);
+            }
+        }
+
+        public void write(String text, int offset, int length)
+            throws IOException
+        {
+            for (int i = 0; i < length; i++)
+            {
+                write(text.charAt(i + offset));
+            }
+        }
+
+        private Locale locale;
+        private boolean localizeDigits;
+        private boolean isUpperCase;
+        private char zero;
+        private char decimalSeparator;
+    }
+
+    private static class CountWriter
+        extends FilterWriter
+    {
+        public CountWriter(Writer out)
+        {
+            super(out);
+        }
+
+        public void write(int c)
+            throws IOException
+        {
+            super.write(c);
+            this.count++;
+        }
+
+        public void write(char[] buffer, int offset, int length)
+            throws IOException
+        {
+            super.write(buffer, offset, length);
+            this.count += length;
+        }
+
+        public void write(String text, int offset, int length)
+            throws IOException
+        {
+            super.write(text, offset, length);
+            this.count += length;
+        }
+
+        public long count()
+        {
+            return this.count;
+        }
+
+        private long count;
+    }
+
+    private static class BufferWriter
+        extends StringWriter
+    {
+        public BufferWriter(Writer out)
+        {
+            this.out = out;
+        }
+
+        public Writer out()
+        {
+            return this.out;
+        }
+
+        private Writer out;
+    }
+
+    private FormattingHelper()
+    {
+    }
+
+    @SuppressWarnings("resource")
+    public static Writer wrapAppendableWriter(Appendable out)
+    {
+        return (out instanceof Writer ? (Writer) out : new AppendableWriter(out));
+    }
+
+    public static Writer wrapLocalizeWriter(Writer out, Formatter formatter, int radix, boolean isUpperCase)
+    {
+        return new LocalizeWriter(out, formatter.locale(), radix <= 10, isUpperCase);
+    }
+
+    @SuppressWarnings("resource")
+    public static Writer wrapPadWriter(Writer out, boolean isLeftJustify)
+    {
+        if (isLeftJustify)
+        {
+            out =  new CountWriter(out);
+        }
+        else
+        {
+            out = new BufferWriter(out);
+        }
+        return out;
+    }
+
+    public static void finishPad(Writer out, long width)
+        throws IOException
+    {
+        if (out instanceof CountWriter)
+        {
+            CountWriter counter = (CountWriter) out;
+            long count = width - counter.count();
+            pad(out, count);
+        }
+        else
+        {
+            BufferWriter buffer = (BufferWriter) out;
+            long count = width - buffer.getBuffer().length();
+            pad(buffer.out(), count);
+            buffer.out().append(buffer.getBuffer());
+        }
+    }
+
+    private static void pad(Appendable out, long count)
+        throws IOException
+    {
+        for (long i = 0; i < count; i++)
+        {
+            out.append(' ');
+        }
+    }
+}
Index: src/main/java/org/apfloat/GCDHelper.java
===================================================================
--- src/main/java/org/apfloat/GCDHelper.java	(revision 0)
+++ src/main/java/org/apfloat/GCDHelper.java	(revision 0)
@@ -0,0 +1,267 @@
+package org.apfloat;
+
+import org.apfloat.spi.Util;
+
+import static org.apfloat.ApintMath.abs;
+import static org.apfloat.ApintMath.scale;
+
+/**
+ * Binary recursive GCD algorithm implementation.
+ *
+ * @since 1.6
+ * @version 1.8.1
+ * @author Mikko Tommila
+ */
+
+class GCDHelper
+{
+    // Simple 2x2 matrix class
+    private static class Matrix
+    {
+        public Matrix(Apint r11, Apint r12, Apint r21, Apint r22)
+        {
+            this.r11 = r11;
+            this.r12 = r12;
+            this.r21 = r21;
+            this.r22 = r22;
+        }
+
+        public Matrix multiply(Matrix a)
+            throws ApfloatRuntimeException
+        {
+            return new Matrix(multiplyAdd(this.r11, a.r11, this.r12, a.r21),
+                              multiplyAdd(this.r11, a.r12, this.r12, a.r22),
+                              multiplyAdd(this.r21, a.r11, this.r22, a.r21),
+                              multiplyAdd(this.r21, a.r12, this.r22, a.r22));
+        }
+
+        private static Apint multiplyAdd(Apint a, Apint b, Apint c, Apint d)
+            throws ApfloatRuntimeException
+        {
+            return a.multiply(b).add(c.multiply(d));
+        }
+
+        public final Apint r11;
+        public final Apint r12;
+        public final Apint r21;
+        public final Apint r22;
+    }
+
+    // Return type for the half-gcd method
+    private static class HalfGcdType
+    {
+        public HalfGcdType(long j, Matrix r)
+        {
+            this.j = j;
+            this.r = r;
+        }
+
+        public final long j;
+        public final Matrix r;
+    }
+
+    private GCDHelper()
+    {
+    }
+
+    public static Apint gcd(Apint a, Apint b)
+        throws ApfloatRuntimeException
+    {
+        if (a.signum() == 0)
+        {
+            return b;
+        }
+        if (b.signum() == 0)
+        {
+            return a;
+        }
+
+        // First reduce the numbers so that they have roughly the same size, regardless of algorithm used
+        if (a.scale() > b.scale())
+        {
+            a = a.mod(b);
+        }
+        else if (b.scale() > a.scale())
+        {
+            b = b.mod(a);
+        }
+
+        Apint gcd;
+        if (Math.max(a.scale(), b.scale()) * Math.log(Math.max(a.radix(), b.radix())) < 80000)
+        {
+            // Small number, use the O(n^2) simple algorithm
+            gcd = elementaryGcd(a, b);
+        }
+        else
+        {
+            // Big number, use the O(n log n) divide-and-conquer algorithm
+            gcd = recursiveGcd(a, b);
+        }
+
+        return gcd;
+    }
+
+    private static Apint elementaryGcd(Apint a, Apint b)
+        throws ApfloatRuntimeException
+    {
+        while (b.signum() != 0)
+        {
+            Apint r = a.mod(b);
+            a = b;
+            b = r;
+        }
+
+        return abs(a);
+    }
+
+    private static Apint recursiveGcd(Apint a, Apint b)
+        throws ApfloatRuntimeException
+    {
+        if (a.radix() != 2 || b.radix() != 2)
+        {
+            // This algorithm only works with binary numbers; convert to radix 2 and then back to original radix
+            return recursiveGcd(a.toRadix(2), b.toRadix(2)).toRadix(a.radix());
+        }
+
+        // First count the trailing zero bits of each number - the power of two factor in the gcd
+        long zeros = Math.min(v(a), v(b));
+
+        // Then remove the trailing zeros (it doesn't matter if one number has more zeros than the other), and add one zero to b
+        // The algorithm only works if a has no trailing zeros, and b has at least one
+        a = scale(a, -v(a));
+        b = scale(b, 1 - v(b));
+
+        // Call the recursive algorithm to compute the odd part of the gcd; initial k is the bit length of the numbers
+        long k = Math.max(a.scale(), b.scale());
+        HalfGcdType t = halfBinaryGcd(a, b, k);
+        long j = t.j;
+        Matrix result = t.r;
+
+        // As the output of the recursive algorithm, we get two terms of the remainder sequence (like in the elementary algorithm)
+        Apint c = scale(result.r11.multiply(a).add(result.r12.multiply(b)), -2 * j),
+              d = scale(result.r21.multiply(a).add(result.r22.multiply(b)), -2 * j);
+
+        // We have to check if these terms are the *last* terms of the remainder sequence
+        Apint gcd;
+        if (d.signum() == 0)
+        {
+            // If d = 0 then c is the odd part of the gcd: c and d are the last terms of the remainder sequence.
+            gcd = c;
+        }
+        else
+        {
+            // However, with large numbers, the initial k argument for the recursive algorithm isn't many times sufficient,
+            // and c and d are not actually the last terms of the remainder sequence. So we continue computing the remainder
+            // sequence, until we reach the last terms, to find the gcd (odd part).
+            // The numbers remaining in the sequence are small, O(log n), compared to the original input numbers, so the elementary
+            // algorithm is sufficient for all practical purposes.
+            gcd = elementaryGcd(c, d);
+        }
+
+        // Finally scale the odd part of the gcd by the number of trailing zeros in the original numbers
+        return abs(scale(gcd, zeros));
+    }
+
+    // Based on the "Recursive Binary GCD Algorithm" by Damien Stehlï¿½ and Paul Zimmermann.
+    // Adapted from the algorithm presented in "Modern Computer Arithmetic" v. 0.5.9 by Richard P. Brent and Paul Zimmermann.
+    private static HalfGcdType halfBinaryGcd(Apint a, Apint b, long k)
+        throws ApfloatRuntimeException
+    {
+        assert (v(a) < v(b));
+
+        Apint one = new Apint(1, 2);
+        if (v(b) > k)
+        {
+            return new HalfGcdType(0, new Matrix(one, Apint.ZERO, Apint.ZERO, one));
+        }
+        long k1 = k >> 1;
+        Apint a1 = a.mod(powerOfTwo(2 * k1 + 1)),
+              b1 = b.mod(powerOfTwo(2 * k1 + 1));
+
+        HalfGcdType t1 = halfBinaryGcd(a1, b1, k1);
+        long j1 = t1.j;
+
+        Apint ac = scale(t1.r.r11.multiply(a).add(t1.r.r12.multiply(b)), -2 * j1),
+              bc = scale(t1.r.r21.multiply(a).add(t1.r.r22.multiply(b)), -2 * j1);
+        long j0 = v(bc);
+
+        if (Util.ifFinite(j0, j0 + j1) > k)
+        {
+            return t1;
+        }
+        Apint[] qr = binaryDivide(ac, bc);
+        Apint q = qr[0],
+              r = qr[1];
+        long k2 = k - (j0 + j1);
+        Apint a2 = scale(bc, -j0).mod(powerOfTwo(2 * k2 + 1)),
+              b2 = scale(r, -j0).mod(powerOfTwo(2 * k2 + 1));
+
+        HalfGcdType t2 = halfBinaryGcd(a2, b2, k2);
+        long j2 = t2.j;
+
+        Matrix qm = new Matrix(Apint.ZERO, powerOfTwo(j0), powerOfTwo(j0), q),
+               result = t2.r.multiply(qm).multiply(t1.r);
+        long j = j1 + j0 + j2;
+
+        return new HalfGcdType(j, result);
+    }
+
+    // The fast "generalized binary division" algorithm.
+    // This is another quite strange algorithm, producing a "quotient" and "remainder"
+    // but not like in a normal division algorithm. Instead of removing the high-order
+    // bits (like in normal division) this algorithm removes the lowest-order bits.
+    // It kind of makes sense if you consider the numbers as p-adic numbers.
+    private static Apint[] binaryDivide(Apint a, Apint b)
+        throws ApfloatRuntimeException
+    {
+        assert (a.signum() != 0);
+        assert (b.signum() != 0);
+        assert (v(a) < v(b));
+
+        Apint A = scale(a, -v(a)).negate(),
+              B = scale(b, -v(b)),
+              one = new Apint(1, 2),
+              q = one;
+        long n = v(b) - v(a) + 1;
+        int maxN = Util.log2up(n);
+        for (int i = 1; i <= maxN; i++)
+        {
+            q = q.add(q.multiply(one.subtract(B.multiply(q)))).mod(powerOfTwo(1L << i));
+        }
+
+        q = cmod(A.multiply(q), powerOfTwo(n));
+        Apint r = q.multiply(b).divide(powerOfTwo(n - 1)).add(a);
+
+        return new Apint[] { q, r };
+    }
+
+    // The p-adic valuation of the number i.e. the number of trailing zero bits (for 2-adic numbers)
+    private static long v(Apint a)
+        throws ApfloatRuntimeException
+    {
+        if (a.signum() == 0)
+        {
+            return Apfloat.INFINITE;
+        }
+        return a.scale() - a.size();
+    }
+
+    // Returns 2^n
+    private static Apint powerOfTwo(long n)
+        throws ApfloatRuntimeException
+    {
+        assert (n >= 0);
+        return scale(new Apint(1, 2), n);
+    }
+
+    // Centered modulus i.e. modulus but scaled so that the result is -2/m < r <= 2/m
+    private static Apint cmod(Apint a, Apint m)
+        throws ApfloatRuntimeException
+    {
+        a = a.mod(m);
+        Apint halfM = scale(m, -1);
+        a = (a.compareTo(halfM) > 0 ? a.subtract(m) : a);
+        a = (a.compareTo(halfM.negate()) <= 0 ? a.add(m) : a);
+        return a;
+    }
+}
Index: src/main/java/org/apfloat/InfiniteExpansionException.java
===================================================================
--- src/main/java/org/apfloat/InfiniteExpansionException.java	(revision 0)
+++ src/main/java/org/apfloat/InfiniteExpansionException.java	(revision 0)
@@ -0,0 +1,49 @@
+package org.apfloat;
+
+/**
+ * Exception indicating that the result of an operation
+ * would have infinite size.<p>
+ *
+ * For example, <code>new Apfloat(2).divide(new Apfloat(3))</code>, in radix 10.
+ *
+ * @since 1.5
+ * @version 1.5
+ * @author Mikko Tommila
+ */
+
+public class InfiniteExpansionException
+    extends ApfloatRuntimeException
+{
+    /**
+     * Constructs a new apfloat infinite expansion exception with an empty detail message.
+     */
+
+    public InfiniteExpansionException()
+    {
+    }
+
+    /**
+     * Constructs a new apfloat infinite expansion exception with the specified detail message.
+     *
+     * @param message The detail message.
+     */
+
+    public InfiniteExpansionException(String message)
+    {
+        super(message);
+    }
+
+    /**
+     * Constructs a new apfloat infinite expansion exception with the specified detail message and cause.
+     *
+     * @param message The detail message.
+     * @param cause Originating cause of the exception.
+     */
+
+    public InfiniteExpansionException(String message, Throwable cause)
+    {
+        super(message, cause);
+    }
+
+    private static final long serialVersionUID = -7022924635011038776L;
+}
Index: src/main/java/org/apfloat/LambertWHelper.java
===================================================================
--- src/main/java/org/apfloat/LambertWHelper.java	(revision 0)
+++ src/main/java/org/apfloat/LambertWHelper.java	(revision 0)
@@ -0,0 +1,551 @@
+package org.apfloat;
+
+import static org.apfloat.spi.RadixConstants.*;
+
+import org.apfloat.spi.Util;
+
+/**
+ * Helper class for Lambert W function.
+ *
+ * @since 1.8.0
+ * @version 1.8.1
+ * @author Mikko Tommila
+ */
+
+class LambertWHelper {
+    private static class ComplexException
+        extends Exception
+    {
+        public ComplexException(ArithmeticException cause)
+        {
+            super(cause);
+        }
+
+        public ArithmeticException getCause()
+        {
+            return (ArithmeticException) super.getCause();
+        }
+
+        private static final long serialVersionUID = 1;
+    }
+
+    private static final double BRANCH_POINT_BEYOND = -0.3678794411714460;  // Behind branch point on real axis (-1/e = -0.36787944117144233)
+
+    private LambertWHelper(Apcomplex z, long k)
+    {
+        this.targetPrecision = z.precision();   // The final precision; might be less, but the intermediate steps must still be done to the full precision
+        this.precision = ApfloatHelper.extendPrecision(this.targetPrecision);   // The working precision; must be extended because of accumulated loss of precision
+        this.radix = z.radix();
+        this.z = ApfloatHelper.ensurePrecision(z, this.precision);
+        if (z.imag().signum() == 0)
+        {
+            this.x = z.real();
+        }
+        this.k = k;
+        this.minusOne = new Apint(-1, this.radix);
+        this.one = new Apint(1, this.radix);
+        this.two = new Apint(2, this.radix);
+        this.three = new Apint(3, this.radix);
+        this.minusOnePerE = new Apfloat(BRANCH_POINT_BEYOND, Apfloat.DEFAULT, this.radix);  // Slightly beyond the limit to cater for round-off errors
+        Apfloat distSquare = new Apfloat(1e-8, Apfloat.DEFAULT, this.radix);                // How close is "close" to the branch point, squared; one fourth of double precision
+        this.close = ApcomplexMath.norm(z.subtract(this.minusOnePerE)).compareTo(distSquare) <= 0;
+
+        // In case of large k, the precision (of the imaginary part) is extended
+        if (k != 0)
+        {
+            // If 2 k pi is 10 or more, then increase precision by how many extra digits 2 k pi has
+            double precisionIncrease = Math.log(Math.abs((double) k) * 2 * Math.PI) / Math.log((double) this.radix);
+            this.precision = ApfloatHelper.extendPrecision(this.precision, (long) precisionIncrease);
+            this.targetPrecision = ApfloatHelper.extendPrecision(this.targetPrecision, (long) precisionIncrease);
+        }
+
+        if ((this.z.real().signum() != 0 || this.z.imag().signum() != 0) && this.precision == Apfloat.INFINITE)
+        {
+            throw new InfiniteExpansionException("Cannot calculate W to infinite precision");
+        }
+    }
+
+    public static Apfloat w(Apfloat x)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return new LambertWHelper(x, 0).real();
+    }
+
+    public static Apcomplex w(Apcomplex z)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return w(z, 0);
+    }
+
+    public static Apcomplex w(Apcomplex z, long k)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        return new LambertWHelper(z, k).complex();
+    }
+
+    public Apfloat real()
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        try
+        {
+            return doReal();
+        }
+        catch (ComplexException ce)
+        {
+            throw ce.getCause();
+        }
+    }
+
+    private Apfloat doReal()
+        throws ComplexException, ApfloatRuntimeException
+    {
+        assert (this.k == 0 || this.x.signum() < 0);
+        if (this.x.signum() == 0)
+        {
+            return this.x;
+        }
+
+        // Initial value
+        Apfloat w;
+        long initialPrecision = DOUBLE_PRECISION[this.x.radix()];
+        Apfloat initialX = this.x.precision(initialPrecision);
+        long digits = 0;
+        long oldAccuracy = 0;
+        if (this.x.compareTo(this.minusOnePerE) < 0)
+        {
+            // We know for sure here, but it could still be, even if we don't notice it here
+            throw new ComplexException(new ArithmeticException("Result would be complex"));
+        }
+        else if (this.k == -1 && !this.close)
+        {
+            // Real valued W_-1: log(-x) - log(-log(-x)), -1/e <= x < 0 (not very close to the branch point)
+            Apfloat logx = ApfloatMath.log(initialX.negate());
+            w = logx.subtract(ApfloatMath.log(logx.negate()));
+        }
+        else if (this.k == -1)
+        {
+            // W_-1 close to the branch point -1/e
+            w = negativeRealSeries();
+            digits = oldAccuracy = w.precision();
+            w = w.precision(shiftLeftPrecision(digits, 2));
+        }
+        else if (this.x.scale() > 1)
+        {
+            // Large values
+            Apfloat logx = ApfloatMath.log(initialX);
+            w = logx.subtract(ApfloatMath.log(logx));
+        }
+        else if (this.x.signum() > 0 && this.x.scale() >= 0)
+        {
+            // Moderate values
+            w = ApfloatMath.log(initialX.add(this.one));
+        }
+        else if (!this.close)
+        {
+            // Small but not very close to the branch point; possibly close to zero
+            w = initialX;
+        }
+        else
+        {
+            // Close to the branch point -1/e
+            w = positiveRealSeries();
+            digits = oldAccuracy = w.precision();
+            w = w.precision(shiftLeftPrecision(digits, 2));
+        }
+        if (!this.close)
+        {
+            // If x is slightly close to -1/e, but not very close, precision of the result is still reduced
+            this.targetPrecision -= (this.x.equalDigits(this.minusOnePerE) + 1 ) / 2;
+        }
+        this.targetPrecision = Math.max(this.targetPrecision, 1);   // In case input is -0.3 with precision 1
+
+        boolean done = (digits >= this.targetPrecision);
+        if (!done)
+        {
+            // Precalculate the needed values once to the required precision
+            ApfloatMath.logRadix(this.targetPrecision, this.radix);
+        }
+
+        // Fritsch's iteration (quartic)
+        // For values close to -1/e the convergence is initially worse but eventually becomes quartic
+        Apfloat oldW;
+        boolean converges = false;              // If there are at least a few correct digits in the result
+        for (int i = 0; i < 50 && !done; i++)   // Should be enough iterations
+        {
+            oldW = w;
+
+            // Calculate one Fritsch's iteration
+            Apfloat z = ApfloatMath.log(this.x.divide(w)).subtract(w);
+            Apfloat w1 = this.one.add(w);
+            Apfloat q = z.multiply(this.two).divide(this.three).add(w1).multiply(w1).multiply(this.two);
+            Apfloat e = z.divide(w1).multiply(q.subtract(z)).divide(q.subtract(this.two.multiply(z)));
+
+            // Check the accuracy of the result, initially convergence can be slow but becomes quartic eventually
+            long accuracy = (converges ? -e.scale() : digits);
+            double rate = Math.min(Math.max(accuracy / Math.max(1.0, oldAccuracy), 1.0), 4.0);
+            if (accuracy >= this.targetPrecision / rate)
+            {
+                done = true;
+            }
+            oldAccuracy = accuracy;
+            w = w.multiply(this.one.add(e));
+
+            // If x was close to the limit and we did not notice it earlier, w may now have diverged
+            if (this.k == 0 && w.compareTo(this.minusOne) < 0 || this.k == -1 && w.compareTo(this.minusOne) > 0)
+            {
+                throw new ComplexException(new ArithmeticException("Result would be complex"));
+            }
+
+            // Check the convergence
+            if (!converges)
+            {
+                digits = w.equalDigits(oldW);
+                accuracy = digits;
+                converges = (digits >= initialPrecision / 4);
+            }
+            if (converges)
+            {
+                w = w.precision(shiftLeftPrecision(accuracy, 4, Apcomplex.EXTRA_PRECISION));
+            }
+        }
+
+        return w.precision(this.targetPrecision);
+    }
+
+    public Apcomplex complex()
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        if (this.z.real().signum() == 0 && this.z.imag().signum() == 0)
+        {
+            if (this.k == 0)
+            {
+                return this.z;
+            }
+            else
+            {
+                throw new ArithmeticException("W_" + this.k + " of zero");
+            }
+        }
+
+        // To compute the initial value, we use the algorithms from
+        // "On the Lambert W Function" (https://cs.uwaterloo.ca/research/tr/1993/03/W.pdf) by R. M. Corless et al.:
+        // - (4.20): near zero and near infinity (i.e. all cases not specifically mentioned below):
+        //   W_k(z) = log(z) + 2*pi*k*i-log(log(z) + 2*pi*k*i)
+        // - (4.22): anywhere near the branch point -1/e (very close) for W_0:
+        //   p = sqrt(2*(e*z+1))
+        //   W_0(z) = -1 + p - 1/3 p^2 + 11/72 p^3 ...
+        // - Similarly near the branch point, for W_-1, when imag(z) >= 0, and also for W_1 when imag(z) < 0:
+        //   p = -sqrt(2*(e*z+1))
+        // - (Remark after 4.20): for real-valued W_-1(x):
+        //   W_-1(x) = log(-x) - log(-log(-x))
+        // Note that we don't necessarily need a very accurate initial guess; the iteration only needs to converge (to the correct branch).
+        // Also note that precision is greatly reduced for k = 0, 1, -1 near the branch point -1/e (only on one side for k = +-1)
+        Apcomplex w;
+        long initialPrecision = DOUBLE_PRECISION[this.radix];
+        // If there is an imaginary part, we must keep it and not set it to zero, to get correct log() result later
+        Apcomplex initialZ = ApfloatHelper.limitPrecision(this.z, initialPrecision);
+        long digits = 0;
+        long oldAccuracy = 0;
+        try
+        {
+            // Check if it's a real valued argument, or at least very close to the branch point if it's beyond it
+            if (this.k == 0 && this.z.imag().signum() == 0 && this.z.real().compareTo(this.minusOnePerE) > 0)
+            {
+                // Real valued W_0, x >= -1/e
+                return doReal();
+            }
+            else if (this.k == -1 && this.z.imag().signum() == 0 && this.z.real().signum() < 0 && this.z.real().compareTo(this.minusOnePerE) > 0)
+            {
+                // Real valued W_-1, -1/e <= x < 0
+                return doReal();
+            }
+        }
+        catch (ComplexException ce)
+        {
+            // Value was actually slightly beyond the branch point, retry as complex valued function
+        }
+
+        if (this.k == 0 && this.z.scale() < 0)
+        {
+            // Small and close to zero
+            w = initialZ;
+        }
+        else if (this.k == 0 && this.z.scale() < 1 && !this.close)
+        {
+            // Moderate values close to zero but not close to branch point
+            w = ApcomplexMath.log(initialZ.add(this.one));
+        }
+        else if (this.k > 1 || this.k < -1 || !this.close)
+        {
+            // Close to zero, or close to infinity, or complex branches (i.e. not close to the branch point)
+            w = logApprox(initialZ);
+        }
+        else if (this.k == 0)
+        {
+            // Close to the branch point -1/e
+            w = positiveComplexSeries();
+            digits = oldAccuracy = w.precision();
+            w = w.precision(shiftLeftPrecision(digits, 2));
+        }
+        else if (this.k == -1 && this.z.imag().signum() >= 0 ||
+                 this.k == 1 && this.z.imag().signum() < 0)
+        {
+            // Close to the branch point -1/e
+            w = negativeComplexSeries();
+            digits = oldAccuracy = w.precision();
+            w = w.precision(shiftLeftPrecision(digits, 2));
+        }
+        else
+        {
+            // Close to the branch point on W_1 or W_-1 but on the the side where the default approximation works
+            w = logApprox(initialZ);
+        }
+        if (!this.close && (this.k == 0 ||
+                            this.k == -1 && this.z.imag().signum() >= 0 ||
+                            this.k == 1 && this.z.imag().signum() < 0))
+        {
+            // If x is slightly close to the branch point (from the correct side), but not very close, precision is still reduced
+            this.targetPrecision -= (this.z.equalDigits(this.minusOnePerE) + 1) / 2;
+        }
+        this.targetPrecision = Math.max(this.targetPrecision, 1);   // In case input is -0.3 with precision 1
+
+        boolean done = (digits >= this.targetPrecision);
+        if (!done)
+        {
+            // Precalculate the needed values once to the required precision
+            ApfloatMath.logRadix(this.targetPrecision, this.radix);
+        }
+
+        // Fritsch's iteration (quartic)
+        // For values close to -1/e the convergence is initially worse but eventually becomes quartic
+        Apcomplex oldW;
+        boolean converges = false;              // If there are at least a few correct digits in the result
+        for (int j = 0; j < 50 && !done; j++)   // Should be enough iterations
+        {
+            oldW = w;
+
+            // Calculate one Fritsch's iteration
+            // In order to pick the correct branch of the logarithm, we have to look at the expanded format of the formula
+            // See: F. N. Fritsch, R. E. Shafer, and W. P. Crowley, "Algorithm 443: Solution of the transcendental equation we^w = x", Communications of the ACM, 16 (1973), p. 123-124
+            Apcomplex z = fixLogBranch(log(this.z.divide(w)), w).subtract(w);
+            Apcomplex w1 = this.one.add(w);
+            Apcomplex q = z.multiply(this.two).divide(this.three).add(w1).multiply(w1).multiply(this.two);
+            Apcomplex e = z.divide(w1).multiply(q.subtract(z)).divide(q.subtract(this.two.multiply(z)));
+
+            // Check the accuracy of the result, initially convergence can be slow but becomes quartic eventually
+            long accuracy = (converges ? -e.scale() : digits);
+            double rate = Math.min(Math.max(accuracy / Math.max(1.0, oldAccuracy), 1.0), 4.0);
+            if (accuracy >= this.targetPrecision / rate)
+            {
+                done = true;
+            }
+            oldAccuracy = accuracy;
+            w = w.multiply(this.one.add(e));
+
+            // Check the convergence
+            if (!converges)
+            {
+                digits = w.equalDigits(oldW);
+                accuracy = digits;
+                converges = (digits >= initialPrecision / 4);
+            }
+            if (converges)
+            {
+                w = w.precision(shiftLeftPrecision(accuracy, 4, Apcomplex.EXTRA_PRECISION));
+            }
+        }
+
+        return w.precision(this.targetPrecision);
+    }
+
+    private Apcomplex log(Apcomplex z)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        Apcomplex logz = ApcomplexMath.log(z);
+        if (this.k != 0)
+        {
+            // log(z) + 2*pi*k*i
+            Apcomplex offset = new Apcomplex(Apfloat.ZERO, twoPiK());
+            logz = logz.add(offset);
+        }
+        return logz;
+    }
+
+    private Apcomplex logApprox(Apcomplex z)
+        throws ArithmeticException, ApfloatRuntimeException
+    {
+        // W_k(z) = log(z) + 2*pi*k*i - log(log(z) + 2*pi*k*i)
+        Apcomplex logz = log(z);
+        Apcomplex w = logz.subtract(ApcomplexMath.log(logz));
+        return w;
+    }
+
+    private Apcomplex p()
+        throws ApfloatRuntimeException
+    {
+        // p = sqrt(2 (e z + 1))
+        if (this.p == null)
+        {
+            Apfloat e = new Apfloat(Math.E, Apfloat.DEFAULT, this.radix);
+            this.p = ApcomplexMath.sqrt(this.two.multiply(e.multiply(this.z).add(this.one)));
+            long precision = e.precision();
+            while (this.p.precision() <= -this.p.scale() && precision < this.precision)
+            {
+                // Very close to the branch point; need to get a better approximation
+                precision = shiftLeftPrecision(precision, 1);
+                this.p = ApcomplexMath.sqrt(this.two.multiply(e(precision).multiply(this.z).add(this.one)));
+            }
+            // Target precision is reduced very near the branch point
+            if (this.p.real().signum() == 0 && this.p.imag().signum() == 0)
+            {
+                this.targetPrecision /= 2;
+            }
+            else
+            {
+                this.targetPrecision += this.p.scale() - 1;
+            }
+        }
+        return this.p;
+    }
+
+    private Apfloat positiveRealSeries()
+        throws ComplexException, ApfloatRuntimeException
+    {
+        return realSeries(p());
+    }
+
+    private Apfloat negativeRealSeries()
+        throws ComplexException, ApfloatRuntimeException
+    {
+        return realSeries(p().negate());
+    }
+
+    private Apcomplex positiveComplexSeries()
+        throws ApfloatRuntimeException
+    {
+        return complexSeries(p());
+    }
+
+    private Apcomplex negativeComplexSeries()
+        throws ApfloatRuntimeException
+    {
+        return complexSeries(p().negate());
+    }
+
+    private Apfloat realSeries(Apcomplex p)
+        throws ComplexException, ApfloatRuntimeException
+    {
+        if (p.imag().signum() != 0)
+        {
+            throw new ComplexException(new ArithmeticException("Result would be complex"));
+        }
+        return complexSeries(p).real();
+    }
+
+    private Apcomplex complexSeries(Apcomplex p)
+        throws ApfloatRuntimeException
+    {
+        // -1 + p - 1/3 p^2 + 11/72 p^3 + ...
+        Aprational factor2 = new Aprational(this.one, this.three);
+        Aprational factor3 = new Aprational(new Apint(11, this.radix), new Apint(72, this.radix));
+        Apcomplex p2 = p.multiply(p);
+        Apcomplex p3 = p2.multiply(p);
+        Apcomplex w = this.minusOne.add(p).subtract(factor2.multiply(p2)).add(factor3.multiply(p3));
+        // Error term is O(p^4) so the maximum precision from the above is -4 * p.scale(), but could be less if p is less accurate
+        long seriesPrecision = Util.ifFinite(-p3.scale(), -p3.scale() - p.scale());
+        w = w.precision(Math.min(w.precision(), seriesPrecision));
+        return w;
+    }
+
+    // Multiply the precision and check for overflow, as ifFinite() only works reliably if the result is at most twice the original number
+    private long shiftLeftPrecision(long precision, int i)
+    {
+        return shiftLeftPrecision(precision, i, 0);
+    }
+
+    private long shiftLeftPrecision(long precision, int i, long add)
+    {
+        while (--i >= 0)
+        {
+            precision = ApfloatHelper.extendPrecision(precision, precision);
+        }
+        return ApfloatHelper.extendPrecision(precision, add);
+    }
+
+    // Usually we get the correct branch of W by adding 2 k pi i to the logarithm taken previously,
+    // however sometimes the result just is off by either 2 pi i or -2 pi i and we have to adjust.
+    // Assuming that our initial guess is close enough to the correct branch value, if the 
+    // next value differs by more than pi i, then we adjust by +-2 pi i, and can get the result to
+    // converge to the correct branch of W.
+    // Because we use log(z / w) instead of log(z) - log(w) the branch of the logarithm behaves
+    // quite in a nontrivial way, so this is a heuristic algorithm.
+    // This problem seems to apply only to the Fritsch algorithm as it uses log(); other algorithms
+    // using exp() don't seem to suffer from this issue (like Halley's method).
+    private Apcomplex fixLogBranch(Apcomplex next, Apcomplex previous)
+        throws ApfloatRuntimeException
+    {
+        if (this.k != 0)
+        {
+            int comparePrecision = DOUBLE_PRECISION[next.radix()];
+            double diff = next.imag().precision(comparePrecision).subtract(previous.imag()).doubleValue();
+            if (diff < -Math.PI)
+            {
+                Apcomplex twoPiI = new Apcomplex(Apfloat.ZERO, twoPi());
+                next = next.add(twoPiI);
+            }
+            else if (diff > Math.PI)
+            {
+                Apcomplex twoPiI = new Apcomplex(Apfloat.ZERO, twoPi());
+                next = next.subtract(twoPiI);
+            }
+        }
+        return next;
+    }
+
+    private Apfloat twoPi()
+        throws ApfloatRuntimeException
+    {
+        if (this.twoPi == null)
+        {
+            this.twoPi = this.two.multiply(ApfloatMath.pi(this.precision, this.radix));
+        }
+        return this.twoPi;
+    }
+
+    private Apfloat twoPiK()
+        throws ApfloatRuntimeException
+    {
+        if (this.twoPiK == null)
+        {
+            this.twoPiK = twoPi().multiply(new Apint(this.k, this.radix));
+        }
+        return this.twoPiK;
+    }
+
+    private Apfloat e(long precision)
+        throws ApfloatRuntimeException
+    {
+        if (this.e == null || this.e.precision() < precision)
+        {
+            this.e = ApfloatMath.exp(new Apfloat(1, precision, this.radix));
+        }
+        return this.e;
+    }
+
+    private Apfloat x;
+    private Apcomplex z;
+    private int radix;
+    private long precision;
+    private long targetPrecision;
+    private long k;
+    private boolean close;
+    private Apint minusOne;
+    private Apint one;
+    private Apint two;
+    private Apint three;
+    private Apfloat twoPi;
+    private Apfloat twoPiK;
+    private Apfloat e;
+    private Apfloat minusOnePerE;
+    private Apcomplex p;
+}
Index: src/main/java/org/apfloat/LossOfPrecisionException.java
===================================================================
--- src/main/java/org/apfloat/LossOfPrecisionException.java	(revision 0)
+++ src/main/java/org/apfloat/LossOfPrecisionException.java	(revision 0)
@@ -0,0 +1,52 @@
+package org.apfloat;
+
+/**
+ * Exception indicating a result that would have no significant digits.<p>
+ *
+ * An example would be <code>ApfloatMath.sin(new Apfloat(1e100))</code>.
+ * Rather than returning an arbitrary result, this exception should be thrown.<p>
+ *
+ * Note that a subtraction where a complete loss of digits occurs does not throw
+ * this exception but instead just returns zero.
+ *
+ * @since 1.5
+ * @version 1.5
+ * @author Mikko Tommila
+ */
+
+public class LossOfPrecisionException
+    extends ApfloatRuntimeException
+{
+    /**
+     * Constructs a new apfloat loss of precision exception with an empty detail message.
+     */
+
+    public LossOfPrecisionException()
+    {
+    }
+
+    /**
+     * Constructs a new apfloat loss of precision exception with the specified detail message.
+     *
+     * @param message The detail message.
+     */
+
+    public LossOfPrecisionException(String message)
+    {
+        super(message);
+    }
+
+    /**
+     * Constructs a new apfloat loss of precision exception with the specified detail message and cause.
+     *
+     * @param message The detail message.
+     * @param cause Originating cause of the exception.
+     */
+
+    public LossOfPrecisionException(String message, Throwable cause)
+    {
+        super(message, cause);
+    }
+
+    private static final long serialVersionUID = -7022924635011038776L;
+}
Index: src/main/java/org/apfloat/OverflowException.java
===================================================================
--- src/main/java/org/apfloat/OverflowException.java	(revision 0)
+++ src/main/java/org/apfloat/OverflowException.java	(revision 0)
@@ -0,0 +1,52 @@
+package org.apfloat;
+
+/**
+ * Exception indicating an overflow in a calculation.<p>
+ *
+ * For example <code>ApfloatMath.exp(new Apfloat(1e100))</code>.<p>
+ *
+ * If the exponent is too large to fit in a <code>long</code>,
+ * the situation can't be handled. Note that there is no
+ * "infinity" apfloat value that could be returned as the result.
+ *
+ * @since 1.5
+ * @version 1.5
+ * @author Mikko Tommila
+ */
+
+public class OverflowException
+    extends ApfloatRuntimeException
+{
+    /**
+     * Constructs a new apfloat overflow exception with an empty detail message.
+     */
+
+    public OverflowException()
+    {
+    }
+
+    /**
+     * Constructs a new apfloat overflow exception with the specified detail message.
+     *
+     * @param message The detail message.
+     */
+
+    public OverflowException(String message)
+    {
+        super(message);
+    }
+
+    /**
+     * Constructs a new apfloat overflow exception with the specified detail message and cause.
+     *
+     * @param message The detail message.
+     * @param cause Originating cause of the exception.
+     */
+
+    public OverflowException(String message, Throwable cause)
+    {
+        super(message, cause);
+    }
+
+    private static final long serialVersionUID = -7022924635011038776L;
+}
Index: src/main/java/org/apfloat/ParallelHelper.java
===================================================================
--- src/main/java/org/apfloat/ParallelHelper.java	(revision 0)
+++ src/main/java/org/apfloat/ParallelHelper.java	(revision 0)
@@ -0,0 +1,144 @@
+package org.apfloat;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Queue;
+import java.util.PriorityQueue;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Helper methods for parallel algorithms.
+ *
+ * @since 1.8.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+class ParallelHelper
+{
+    public interface ProductKernel<T extends Apcomplex>
+    {
+        public void run(Queue<T> heap);
+    }
+
+    private ParallelHelper()
+    {
+    }
+
+    /**
+     * Multiply two smallest elements in the heap and put the product back to the heap,
+     * until only one element remains.
+     *
+     * @param x The elements to be multiplied.
+     * @param heap The priority queue to use. Must be initially empty.
+     * @param kernel The multiplication kernel callback.
+     */
+
+    // Thanks to Peter Luschny and Spiro Trikaliotis for the improved algorithm!
+    public static <T extends Apcomplex> void parallelProduct(T[] x, final Queue<T> heap, final ProductKernel<T> kernel)
+    {
+        // If there are lots of numbers then use a fully parallel algorithm, for small products the overhead is not worth it
+        ApfloatContext ctx = ApfloatContext.getContext();
+        final int numberOfProcessors = ctx.getNumberOfProcessors();
+        if (x.length >= 1000 && numberOfProcessors > 1)
+        {
+            // First multiply small numbers in parallel;
+            // number size would be so small that they would not be multiplied using a parallel algorithm (roughly dependent on cache L1 size)
+            final long maxSize = (long) (ctx.getCacheL1Size() * 2.5 / Math.log((double) ctx.getDefaultRadix()));
+            // There is no efficient "ConcurrentPriorityQueue" data structure, so we just split the data
+            final List<Queue<T>> subHeaps = new ArrayList<Queue<T>>();
+            for (int i = 0; i < numberOfProcessors; i++)
+            {
+                subHeaps.add(new PriorityQueue<T>(heap));
+            }
+            int i = 0;
+            for (T a : x)
+            {
+                // Add only small numbers to the parallel heaps, big numbers go to the main heap directly
+                (a.size() <= maxSize ? subHeaps.get(i++) : heap).add(a);
+                i = (i == numberOfProcessors ? 0 : i);
+            }
+            final AtomicInteger index = new AtomicInteger();
+            Runnable runnable = new Runnable()
+            {
+                public void run()
+                {
+                    Queue<T> subHeap = subHeaps.get(index.getAndIncrement());
+                    long size = 0;
+                    // Multiply numbers as long as there are at least two and they are small enough
+                    // Note that with the heap we will start with the smallest numbers and size will grow
+                    while (subHeap.size() > 1 && size <= maxSize)
+                    {
+                        kernel.run(subHeap);
+                        size = subHeap.peek().size();
+                    }
+                    synchronized (heap)
+                    {
+                        // Synchronize the adds; nothing must be reading the heap at the same time
+                        heap.addAll(subHeap);
+                    }
+                }
+            };
+
+            // Run the runnable in multiple threads
+            runParallel(runnable, numberOfProcessors - 1);
+        }
+        else
+        {
+            // Use the single-thread algorithm
+            heap.addAll(Arrays.asList(x));
+        }
+
+        // Then just multiply the remaining numbers;
+        // they will presumably be so big that the multiplications use the parallel algorithm anyway
+        while (heap.size() > 1)
+        {
+            kernel.run(heap);
+        }
+    }
+
+    public static void runParallel(Runnable runnable)
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        int numberOfThreads = ctx.getNumberOfProcessors() - 1;
+
+        runParallel(runnable, numberOfThreads);
+    }
+
+    private static void runParallel(Runnable runnable, int numberOfThreads)
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        ExecutorService executorService = ctx.getExecutorService();
+        Future<?>[] futures = new Future[numberOfThreads];
+
+        // Dispatch other threads, if any
+        for (int i = 0; i < futures.length; i++)
+        {
+            futures[i] = executorService.submit(runnable);
+        }
+
+        // Also run the Runnable in the current thread
+        runnable.run();
+
+        // Join the other threads, if any
+        for (Future<?> future : futures)
+        {
+            try
+            {
+                future.get();
+            }
+            catch (InterruptedException ie)
+            {
+                throw new ApfloatRuntimeException("Waiting for dispatched task to complete was interrupted", ie);
+            }
+            catch (ExecutionException ee)
+            {
+                throw new ApfloatRuntimeException("Task execution failed", ee);
+            }
+        }
+    }
+}
Index: src/main/java/org/apfloat/RadixConversionHelper.java
===================================================================
--- src/main/java/org/apfloat/RadixConversionHelper.java	(revision 0)
+++ src/main/java/org/apfloat/RadixConversionHelper.java	(revision 0)
@@ -0,0 +1,194 @@
+package org.apfloat;
+
+import java.util.List;
+import java.util.ArrayList;
+
+import org.apfloat.spi.Util;
+import static org.apfloat.spi.RadixConstants.*;
+
+/**
+ * Helper class for radix conversion.
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+class RadixConversionHelper
+{
+    private static class RadixPowerList
+    {
+        public RadixPowerList(int fromRadix, int toRadix, long precision)
+            throws ApfloatRuntimeException
+        {
+            this.list = new ArrayList<Apfloat>();
+            this.list.add(new Apfloat(fromRadix, ApfloatHelper.extendPrecision(precision), toRadix));
+        }
+
+        public Apfloat pow(long n)
+            throws ApfloatRuntimeException
+        {
+            if (n == 0)
+            {
+                return Apfloat.ONE;
+            }
+
+            int p = 0;
+
+            while ((n & 1) == 0)
+            {
+                p++;
+                n >>>= 1;
+            }
+
+            Apfloat r = get(p);
+
+            while ((n >>>= 1) > 0)
+            {
+                Apfloat x = get(++p);
+                if ((n & 1) != 0)
+                {
+                    r = r.multiply(x);
+                }
+            }
+
+            return r;
+        }
+
+        private Apfloat get(int index)
+            throws ApfloatRuntimeException
+        {
+            Apfloat x;
+            if (this.list.size() > index)
+            {
+                x = this.list.get(index);
+            }
+            else
+            {
+                x = get(index - 1);
+                x = x.multiply(x);
+                this.list.add(x);
+            }
+            return x;
+        }
+
+        private List<Apfloat> list;
+    }
+
+    private RadixConversionHelper()
+    {
+    }
+
+    public static Apfloat toRadix(Apfloat x, int toRadix)
+        throws ApfloatRuntimeException
+    {
+        if (x.radix() == toRadix)
+        {
+            return x;
+        }
+
+        if (x.signum() == 0)
+        {
+            return new Apfloat(0, toRadix);
+        }
+
+        int fromRadix = x.radix();
+        long size = x.size(),
+             scale = x.scale(),
+             precision = getPrecision(x.precision(), fromRadix, toRadix);
+        RadixPowerList radixPowerList = new RadixPowerList(fromRadix, toRadix, precision);
+
+        return toRadixIntegerPart(x, toRadix, size, scale, radixPowerList)
+          .add(toRadixFractionalPart(x, toRadix, size, scale, radixPowerList))
+          .precision(precision);
+    }
+
+    private static Apfloat toRadixIntegerPart(Apfloat x, int toRadix, long size, long scale, RadixPowerList radixPowerList)
+        throws ApfloatRuntimeException
+    {
+        if (scale <= 0)
+        {
+            // Integer part doesn't exist
+            return Apfloat.ZERO;
+        }
+        else if (scale > size)
+        {
+            // No fractional part; trailing zeros in integer part
+            long shift = scale - size;
+            x = ApfloatMath.scale(x, -shift);
+            x = toRadixNormalizedPart(x, toRadix, size, radixPowerList);
+            return x.multiply(radixPowerList.pow(shift));
+        }
+        else
+        {
+            // Fractional part exists (might be zero-length though)
+            x = x.truncate();
+            return toRadixNormalizedPart(x, toRadix, x.scale(), radixPowerList);
+        }
+    }
+
+    private static Apfloat toRadixFractionalPart(Apfloat x, int toRadix, long size, long scale, RadixPowerList radixPowerList)
+        throws ApfloatRuntimeException
+    {
+        if (size > scale)
+        {
+            // Fractional part exists
+            if (scale > 0)
+            {
+                // Both integer and fractional parts exist
+                x = x.frac();
+                size -= scale;
+                scale = 0;
+            }
+            long precision = getPrecision(x.precision(), x.radix(), toRadix),
+                 shift = size - scale;
+            x = ApfloatMath.scale(x, shift);
+            x = toRadixNormalizedPart(x, toRadix, size, radixPowerList);
+            return x.precision(precision).divide(radixPowerList.pow(shift));
+        }
+        else
+        {
+            // Fractional part doesn't exist
+            return Apfloat.ZERO;
+        }
+    }
+
+    private static Apfloat toRadixNormalizedPart(Apfloat x, int toRadix, long size, RadixPowerList radixPowerList)
+        throws ApfloatRuntimeException
+    {
+        long maxPow2 = Util.round2down(size);
+        return split(x, toRadix, size, maxPow2, radixPowerList);
+    }
+
+    private static Apfloat split(Apfloat x, int toRadix, long size, long split, RadixPowerList radixPowerList)
+        throws ApfloatRuntimeException
+    {
+        if (size <= 0)
+        {
+            return Apfloat.ZERO;
+        }
+        else if (size <= LONG_DIGITS[x.radix()])
+        {
+            return new Apfloat(x.longValue(), Apfloat.INFINITE, toRadix);
+        }
+        else
+        {
+            x = ApfloatMath.scale(x, -split);
+            Apfloat top = x.truncate(),
+                    bottom = ApfloatMath.scale(x.frac(), split);
+            return split(top, toRadix, size - split, split >> 1, radixPowerList).multiply(radixPowerList.pow(split))
+              .add(split(bottom, toRadix, split, split >> 1, radixPowerList));
+        }
+    }
+
+    private static long getPrecision(long precision, int fromRadix, int toRadix)
+        throws ApfloatRuntimeException
+    {
+        long newPrecision = (long) ((double) precision * Math.log((double) fromRadix) / Math.log((double) toRadix));
+        if (fromRadix < toRadix)
+        {
+            // Underflow is possible but overflow not, in the above calculation
+            newPrecision = Math.max(1, newPrecision);
+        }
+        return Util.ifFinite(precision, newPrecision);
+    }
+}
Index: src/main/java/org/apfloat/RoundingHelper.java
===================================================================
--- src/main/java/org/apfloat/RoundingHelper.java	(revision 0)
+++ src/main/java/org/apfloat/RoundingHelper.java	(revision 0)
@@ -0,0 +1,130 @@
+package org.apfloat;
+
+import java.math.RoundingMode;
+
+/**
+ * Helper class for rounding functions.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+class RoundingHelper
+{
+    private RoundingHelper()
+    {
+    }
+
+    public static Apfloat round(Apfloat x, long precision, RoundingMode roundingMode)
+        throws IllegalArgumentException, ArithmeticException, ApfloatRuntimeException
+    {
+        if (precision <= 0)
+        {
+            throw new IllegalArgumentException("Invalid precision: " + precision);
+        }
+        if (x.signum() == 0 || precision == Apfloat.INFINITE)
+        {
+            return x;
+        }
+
+        // Can't optimize by checking x.size() <= precision as the number might have hidden residual digits
+        long scale = x.scale();
+        boolean overflow = (scale - precision >= scale);
+        if (overflow)
+        {
+            // Avoid overflow of longs, do scaling in two parts
+            x = x.scale(-scale);
+            x = x.scale(precision);
+        }
+        else
+        {
+            x = x.scale(precision - scale);
+        }
+        switch (roundingMode)
+        {
+            case UP:
+                x = x.roundAway();
+                break;
+            case DOWN:
+                x = x.truncate();
+                break;
+            case CEILING:
+                x = x.ceil();
+                break;
+            case FLOOR:
+                x = x.floor();
+                break;
+            case HALF_UP:
+            case HALF_DOWN:
+            case HALF_EVEN:
+                Apint whole = x.truncate();
+                Apfloat fraction = x.frac().abs();
+                int comparison = fraction.compareToHalf();
+                if (comparison < 0 || comparison == 0 && roundingMode.equals(RoundingMode.HALF_DOWN))
+                {
+                    x = x.truncate();
+                }
+                else if (comparison > 0 || comparison == 0 && roundingMode.equals(RoundingMode.HALF_UP))
+                {
+                    x = x.roundAway();
+                }
+                else
+                {
+                    x = (isEven(whole) ? x.truncate() : x.roundAway());
+                }
+                break;
+            case UNNECESSARY:
+                if (x.size() > x.scale())
+                {
+                    throw new ArithmeticException("Rounding necessary");
+                }
+                break;
+            default:
+                throw new IllegalArgumentException("Unknown rounding mode: " + roundingMode);
+        }
+        if (overflow)
+        {
+            // Avoid overflow of longs, do scaling in two parts
+            x = ApfloatMath.scale(x, -precision);
+            x = ApfloatMath.scale(x, scale);
+        }
+        else
+        {
+            x = ApfloatMath.scale(x, scale - precision);
+        }
+        return x.precision(precision);
+    }
+
+    public static int compareToHalf(Apfloat x)
+    {
+        int comparison;
+        if (x.radix() % 2 == 0)
+        {
+            comparison = x.compareTo(new Apfloat("0." + Character.forDigit(x.radix() / 2, x.radix()), Apfloat.INFINITE, x.radix()));
+        }
+        else
+        {
+            // In an odd radix, half has an infinite digit expansion
+            Apint one = new Apint(1, x.radix());
+            Apint two = new Apint(2, x.radix());
+            comparison = x.precision(Apfloat.INFINITE).multiply(two).compareTo(one);
+        }
+        return comparison;
+    }
+
+    public static int compareToHalf(Aprational x)
+    {
+        Aprational half = new Aprational(new Apint(1, x.radix()), new Apint(2, x.radix()));
+        int comparison = x.compareTo(half);
+        return comparison;
+    }
+
+    private static boolean isEven(Apint x)
+    {
+        // This could be further optimized if the radix is even
+        // Note that any fractional part can never be exactly half when the radix is odd as a float, only as a rational
+        Apint two = new Apint(2, x.radix());
+        return (x.mod(two).signum() == 0);
+    }
+}
Index: src/main/java/org/apfloat/ShutdownMap.java
===================================================================
--- src/main/java/org/apfloat/ShutdownMap.java	(revision 0)
+++ src/main/java/org/apfloat/ShutdownMap.java	(revision 0)
@@ -0,0 +1,33 @@
+package org.apfloat;
+
+import java.util.Map;
+import java.util.AbstractMap;
+import java.util.Set;
+
+/**
+ * Map that always throws <code>ApfloatRuntimeException</code> on all operations.
+ * Can be used to replace cache maps after JVM shutdown and clean-up
+ * has been initiated to prevent other threads from performing any operations.
+ *
+ * @since 1.6.2
+ * @version 1.6.2
+ * @author Mikko Tommila
+ */
+
+class ShutdownMap<K, V>
+    extends AbstractMap<K, V>
+{
+    public ShutdownMap()
+    {
+    }
+
+    public Set<Map.Entry<K, V>> entrySet()
+    {
+        throw new ApfloatRuntimeException("Shutdown in progress");
+    }
+
+    public V put(K key, V value)
+    {
+        throw new ApfloatRuntimeException("Shutdown in progress");
+    }
+}
Index: src/main/java/org/apfloat/package-info.java
===================================================================
--- src/main/java/org/apfloat/package-info.java	(revision 0)
+++ src/main/java/org/apfloat/package-info.java	(revision 0)
@@ -0,0 +1,100 @@
+/**
+The apfloat Application Programming Interface (API).<p>
+
+All application code using apfloat generally needs to only call
+the classes in this package.<p>
+
+A sample apfloat program might look like this:
+
+<pre>
+import org.apfloat.Apfloat;
+import org.apfloat.ApfloatMath;
+
+public class ApfloatTest
+{
+    public static void main(String[] args)
+    {
+        Apfloat x = new Apfloat(2, 1000);   // Value 2, precision 1000 digits
+
+        Apfloat y = ApfloatMath.sqrt(x);    // Square root of 2, to 1000 digits
+
+        System.out.println(y);
+    }
+}
+</pre>
+
+As apfloats are immutable, they can be easily passed by reference. Also
+the mantissa data of numbers can be efficiently shared in various situations.<p>
+
+An inherent property of an {@link org.apfloat.Apfloat} is the <code>radix</code>.
+The radix is specified at the time an apfloat is created. Due to the way the
+default implementation works, there is no real performance difference in using
+radix 2 or some other radix in the internal calculations. While it's generally
+not possible to use numbers in different radixes in operations, it's possible
+to convert a number to a different radix using the {@link org.apfloat.Apfloat#toRadix(int)}
+method.<p>
+
+The rounding mode for apfloat calculations is undefined. Thus, it's not
+guaranteed that rounding happens to an optimal direction and more often
+than not it doesn't. This should be carefully considered when designing
+numerical algorithms. Round-off errors can accumulate faster than expected,
+and loss of precision (as returned by {@link org.apfloat.Apfloat#precision()})
+can happen quickly. This bad behaviour is further accelerated by using a radix
+bigger than two, e.g. base 10, which is the default. Note that precision is
+defined as the number of digits in the number's radix. If numbers need to
+be rounded in a specific way then the {@link org.apfloat.ApfloatMath#round(Apfloat,long,RoundingMode)}
+method can be invoked explicitly.<p>
+
+Generally, the result of various mathematical operations is accurate to
+the second last digit in the resulting number. This means roughly that the
+last significant digit of the result can be inaccurate. For example, the
+number 12345, with precision 5, should be considered 12345&nbsp;&#177;&nbsp;10.
+This should generally not be a problem, as you should typically be using
+apfloats for calculations with a precision of thousands or millions of
+digits.<p>
+
+There is no concept of an infinity or Not-a-Number with apfloats. Whenever
+the result of an operation would be infinite or undefined, an exception is
+thrown (usually an <code>ArithmeticException</code>).<p>
+
+All of the apfloat-specific exceptions being thrown by the apfloat library
+extend the base class {@link org.apfloat.ApfloatRuntimeException}. This
+exception, or various subclasses can be thrown in different situations, for
+example:
+
+<ul>
+  <li>{@link org.apfloat.InfiniteExpansionException} - The result of an
+      operation would have infinite size. For example,
+      <code>new Apfloat(2).divide(new Apfloat(3))</code>, in radix 10.</li>
+  <li>{@link org.apfloat.OverflowException} - Overflow. If the
+      exponent is too large to fit in a <code>long</code>,
+      the situation can't be handled. Also, there is no "infinity" apfloat
+      value that could be returned as the result.</li>
+  <li>{@link org.apfloat.LossOfPrecisionException} - Total loss of precision.
+      For example, <code>ApfloatMath.sin(new Apfloat(1e100))</code>.
+      If the magnitude (100) is far greater than the precision (1) then
+      the value of the <code>sin()</code> function can't be determined
+      to any accuracy.</li>
+</ul>
+
+The exception is a <code>RuntimeException</code>, because it should "never happen",
+and in general the cases where it is thrown are irrecoverable with the current
+implementation. Also any of the situations mentioned above may be relaxed in
+the future, so this exception handling strategy should be more future-proof
+than others, even if it has its limitations currently.<p>
+
+The {@link org.apfloat.Apfloat} class is the basic building block of all the
+objects used in the apfloat package. An {@link org.apfloat.Apcomplex} simply
+consists of two apfloats, the real part and the imaginary part. An
+{@link org.apfloat.Apint} is implemented with an apfloat and all its operations
+just guarantee that the number never gets a fractional part. Last, an
+{@link org.apfloat.Aprational} is an aggregate of two apints, the numerator
+and the denominator. The relations of these classes are shown in a class
+diagram format below:<p>
+
+<img src="doc-files/apfloat-classes.gif" alt="Class diagram">
+*/
+
+package org.apfloat;
+
+import java.math.RoundingMode;
Index: src/main/java/org/apfloat/internal/AbstractConvolutionBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/AbstractConvolutionBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/AbstractConvolutionBuilder.java	(revision 0)
@@ -0,0 +1,178 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.spi.ConvolutionBuilder;
+import org.apfloat.spi.ConvolutionStrategy;
+import org.apfloat.spi.NTTBuilder;
+import org.apfloat.spi.NTTStrategy;
+import org.apfloat.spi.Util;
+
+/**
+ * Abstract base class for creating convolutions of suitable type for the specified length.<p>
+ *
+ * Based on a work estimate, depending on the operand sizes and implementation-dependent
+ * factors, the O(n<sup>2</sup>) long multiplication, Karatsuba multiplication and
+ * the NTT algorithms are chosen e.g. as follows:
+ *
+ * <table style="border-collapse:collapse; border:1px solid black" border="1" summary="Convolution algorithms">
+ * <tr><th>size1</th><th>size2</th><th>Algorithm</th></tr>
+ * <tr><td>16</td><td>16</td><td>Long</td></tr>
+ * <tr><td>16</td><td>256</td><td>Long</td></tr>
+ * <tr><td>32</td><td>32</td><td>Long</td></tr>
+ * <tr><td>32</td><td>256</td><td>Long</td></tr>
+ * <tr><td>64</td><td>64</td><td>Karatsuba</td></tr>
+ * <tr><td>64</td><td>256</td><td>NTT</td></tr>
+ * <tr><td>64</td><td>65536</td><td>Karatsuba</td></tr>
+ * <tr><td>128</td><td>128</td><td>NTT</td></tr>
+ * <tr><td>128</td><td>65536</td><td>NTT</td></tr>
+ * <tr><td>128</td><td>4294967296</td><td>Karatsuba</td></tr>
+ * <tr><td>256</td><td>256</td><td>NTT</td></tr>
+ * <tr><td>256</td><td>4294967296</td><td>Karatsuba</td></tr>
+ * <tr><td>512</td><td>512</td><td>NTT</td></tr>
+ * <tr><td>512</td><td>4294967296</td><td>NTT</td></tr>
+ * </table>
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public abstract class AbstractConvolutionBuilder
+    implements ConvolutionBuilder
+{
+    /**
+     * Subclass constructor.
+     */
+
+    protected AbstractConvolutionBuilder()
+    {
+    }
+
+    public ConvolutionStrategy createConvolution(int radix, long size1, long size2, long resultSize)
+    {
+        long minSize = Math.min(size1, size2),
+             maxSize = Math.max(size1, size2),
+             totalSize = size1 + size2;
+
+        if (minSize == 1)
+        {
+            return createShortConvolutionStrategy(radix);
+        }
+        else if (minSize <= getKaratsubaCutoffPoint())
+        {
+            return createMediumConvolutionStrategy(radix);
+        }
+        else
+        {
+            float mediumCost = (float) minSize * maxSize,
+                  karatsubaCost = getKaratsubaCostFactor() * (float) Math.pow((double) minSize, LOG2_3) * maxSize / minSize,
+                  nttCost = getNTTCostFactor() * totalSize * Util.log2down(totalSize);
+
+            if (mediumCost <= Math.min(karatsubaCost, nttCost))
+            {
+                return createMediumConvolutionStrategy(radix);
+            }
+            else if (karatsubaCost <= nttCost)
+            {
+                return createKaratsubaConvolutionStrategy(radix);
+            }
+            else
+            {
+                ApfloatContext ctx = ApfloatContext.getContext();
+                NTTBuilder nttBuilder = ctx.getBuilderFactory().getNTTBuilder();
+                NTTStrategy nttStrategy = nttBuilder.createNTT(totalSize);
+
+                return createThreeNTTConvolutionStrategy(radix, nttStrategy);
+            }
+        }
+    }
+
+    /**
+     * Get the Karatsuba convolution cutoff point.
+     * When either operand is shorter than this then the
+     * medium-length convolution strategy should be used instead.
+     *
+     * @return The Karatsuba convolution cutoff point.
+     *
+     * @since 1.7.0
+     */
+
+    protected abstract int getKaratsubaCutoffPoint();
+
+    /**
+     * Get the Karatsuba convolution cost factor.
+     * It is used in determining the most efficient
+     * convolution strategy for the given data lengths.
+     *
+     * @return The Karatsuba convolution cost factor.
+     *
+     * @since 1.7.0
+     */
+
+    protected abstract float getKaratsubaCostFactor();
+
+    /**
+     * Get the NTT convolution cost factor.
+     * It is used in determining the most efficient
+     * convolution strategy for the given data lengths.
+     *
+     * @return The NTT convolution cost factor.
+     *
+     * @since 1.7.0
+     */
+
+    protected abstract float getNTTCostFactor();
+
+    /**
+     * Create a short-length convolution strategy where the size of either
+     * data set is one.
+     *
+     * @param radix The radix that will be used.
+     *
+     * @return A new short-length convolution strategy.
+     *
+     * @since 1.7.0
+     */
+
+    protected abstract ConvolutionStrategy createShortConvolutionStrategy(int radix);
+
+    /**
+     * Create a medium-length convolution strategy where the size of one
+     * of the data sets is relatively small (but more than one).
+     *
+     * @param radix The radix that will be used.
+     *
+     * @return A new medium-length convolution strategy.
+     *
+     * @since 1.7.0
+     */
+
+    protected abstract ConvolutionStrategy createMediumConvolutionStrategy(int radix);
+
+    /**
+     * Create a Karatsuba convolution strategy.
+     *
+     * @param radix The radix that will be used.
+     *
+     * @return A new Karatsuba convolution strategy.
+     *
+     * @since 1.7.0
+     */
+
+    protected abstract ConvolutionStrategy createKaratsubaConvolutionStrategy(int radix);
+
+    /**
+     * Create a 3-NTT convolution strategy.
+     *
+     * @param radix The radix that will be used.
+     * @param nttStrategy The underlying NTT strategy.
+     *
+     * @return A new 3-NTT convolution strategy.
+     *
+     * @since 1.7.0
+     */
+
+    protected abstract ConvolutionStrategy createThreeNTTConvolutionStrategy(int radix, NTTStrategy nttStrategy);
+
+    private static final double LOG2_3 = Math.log(3.0) / Math.log(2.0);
+}
Index: src/main/java/org/apfloat/internal/AbstractDataStorageBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/AbstractDataStorageBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/AbstractDataStorageBuilder.java	(revision 0)
@@ -0,0 +1,121 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.DataStorage;
+
+/**
+ * Abstract base class for a data storage creation strategy.
+ * Depending on the implementation-specific element size, the
+ * requested data length and threshold values configured in the
+ * current {@link ApfloatContext}, different types of data storages
+ * are created.
+ *
+ * @since 1.7.0
+ * @version 1.8.2
+ * @author Mikko Tommila
+ */
+
+public abstract class AbstractDataStorageBuilder
+    implements DataStorageBuilder
+{
+    /**
+     * Subclass constructor.
+     */
+
+    protected AbstractDataStorageBuilder()
+    {
+    }
+
+    public DataStorage createDataStorage(long size)
+        throws ApfloatRuntimeException
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+
+        // Sizes are in bytes
+        if (size <= ctx.getMemoryThreshold() && size <= getMaxCachedSize())
+        {
+            return createCachedDataStorage();
+        }
+        else
+        {
+            return createNonCachedDataStorage();
+        }
+    }
+
+    public DataStorage createCachedDataStorage(long size)
+        throws ApfloatRuntimeException
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+
+        // Sizes are in bytes
+        if (size <= ctx.getMaxMemoryBlockSize() && size <= getMaxCachedSize())
+        {
+            // Use memory data storage if it can fit in memory
+            return createCachedDataStorage();
+        }
+        else
+        {
+            // If it can't fit in memory then still have to use disk data storage
+            return createNonCachedDataStorage();
+        }
+    }
+
+    public DataStorage createDataStorage(DataStorage dataStorage)
+        throws ApfloatRuntimeException
+    {
+        if (isCached(dataStorage))
+        {
+            long size = dataStorage.getSize();
+            ApfloatContext ctx = ApfloatContext.getContext();
+
+            // Sizes are in bytes
+            if (size > ctx.getMemoryThreshold())
+            {
+               // If it is a memory data storage and should be moved to disk then do so
+                DataStorage tmp = createNonCachedDataStorage();
+                tmp.copyFrom(dataStorage);
+                dataStorage = tmp;
+            }
+        }
+        return dataStorage;
+    }
+
+    /**
+     * Get the maximum cached data storage size.
+     *
+     * @return The maximum cached data storage size.
+     */
+
+    protected abstract long getMaxCachedSize();
+
+    /**
+     * Create a cached data storage.
+     *
+     * @return A new cached data storage.
+     */
+
+    protected abstract DataStorage createCachedDataStorage()
+        throws ApfloatRuntimeException;
+
+    /**
+     * Create a non-cached data storage.
+     *
+     * @return A new non-cached data storage.
+     */
+
+    protected abstract DataStorage createNonCachedDataStorage()
+        throws ApfloatRuntimeException;
+
+    /**
+     * Test if the data storage is of cached type.
+     *
+     * @param dataStorage The data storage.
+     *
+     * @return If the data storage is cached.
+     */
+
+    protected abstract boolean isCached(DataStorage dataStorage)
+        throws ApfloatRuntimeException;
+}
Index: src/main/java/org/apfloat/internal/AbstractNTTBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/AbstractNTTBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/AbstractNTTBuilder.java	(revision 0)
@@ -0,0 +1,106 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.spi.BuilderFactory;
+import org.apfloat.spi.NTTBuilder;
+import org.apfloat.spi.NTTStrategy;
+import org.apfloat.spi.Util;
+
+/**
+ * Abstract base class for creating Number Theoretic Transforms suitable for the
+ * specified length, based on available memory configured in the {@link ApfloatContext}.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public abstract class AbstractNTTBuilder
+    implements NTTBuilder
+{
+    /**
+     * Subclass constructor.
+     */
+
+    protected AbstractNTTBuilder()
+    {
+    }
+
+    public NTTStrategy createNTT(long size)
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        BuilderFactory builderFactory = ctx.getBuilderFactory();
+        int cacheSize = ctx.getCacheL1Size() / builderFactory.getElementSize();
+        long maxMemoryBlockSize = ctx.getMaxMemoryBlockSize() / builderFactory.getElementSize();
+
+        NTTStrategy nttStrategy;
+        boolean useFactor3 = false;
+
+        size = Util.round23up(size);        // Round up to the nearest power of two or three times a power of two
+        long power2size = (size & -size);   // Power-of-two factor of the above
+        if (size != power2size)
+        {
+            // A factor of three will be used, so the power-of-two part is one third of the whole transform length
+            useFactor3 = true;
+        }
+
+        // Select transform for the power-of-two part
+        if (power2size <= cacheSize / 2)
+        {
+            // The whole transform plus w-table fits into the cache, so use the simplest approach
+            nttStrategy = createSimpleFNTStrategy();
+        }
+        else if (power2size <= maxMemoryBlockSize && power2size <= Integer.MAX_VALUE)
+        {
+            // The whole transform fits into the available main memory, so use a six-step in-memory approach
+            nttStrategy = createSixStepFNTStrategy();
+        }
+        else
+        {
+            // The whole transform won't fit into available memory, so use a two-pass disk based approach
+            nttStrategy = createTwoPassFNTStrategy();
+        }
+
+        if (useFactor3)
+        {
+            // Allow using a factor of three in any of the above selected transforms
+            nttStrategy = createFactor3NTTStrategy(nttStrategy);
+        }
+
+        return nttStrategy;
+    }
+
+    /**
+     * Create a simple NTT strategy.
+     *
+     * @return A new simple NTT strategy.
+     */
+
+    protected abstract NTTStrategy createSimpleFNTStrategy();
+
+    /**
+     * Create a six-step NTT strategy.
+     *
+     * @return A new six-step NTT strategy.
+     */
+
+    protected abstract NTTStrategy createSixStepFNTStrategy();
+
+    /**
+     * Create a two-pass NTT strategy.
+     *
+     * @return A new two-pass NTT strategy.
+     */
+
+    protected abstract NTTStrategy createTwoPassFNTStrategy();
+
+    /**
+     * Create a factor-3 NTT strategy on top of another NTT strategy.
+     *
+     * @param nttStrategy The underlying factor-2 NTT strategy.
+     *
+     * @return A new factor-3 NTT strategy.
+     */
+
+    protected abstract NTTStrategy createFactor3NTTStrategy(NTTStrategy nttStrategy);
+}
Index: src/main/java/org/apfloat/internal/AbstractStepFNTStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/AbstractStepFNTStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/AbstractStepFNTStrategy.java	(revision 0)
@@ -0,0 +1,134 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.NTTStrategy;
+import org.apfloat.spi.NTTStepStrategy;
+import org.apfloat.spi.Util;
+
+/**
+ * Abstract superclass for step-based FNT strategies.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @see NTTStepStrategy
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public abstract class AbstractStepFNTStrategy
+    implements NTTStrategy, Parallelizable
+{
+    /**
+     * Subclass constructor.
+     */
+
+    protected AbstractStepFNTStrategy()
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        this.stepStrategy = ctx.getBuilderFactory().getNTTBuilder().createNTTSteps();
+    }
+
+    public void transform(DataStorage dataStorage, int modulus)
+        throws ApfloatRuntimeException
+    {
+        long length = dataStorage.getSize();            // Transform length n
+
+        if (length > this.stepStrategy.getMaxTransformLength())
+        {
+            throw new TransformLengthExceededException("Maximum transform length exceeded: " + length + " > " + this.stepStrategy.getMaxTransformLength());
+        }
+
+        if (length < 2)
+        {
+            return;
+        }
+
+        assert (length == (length & -length));          // Must be a power of two
+
+        // Treat the input data as a n1 x n2 matrix
+
+        int logLength = Util.log2down(length),
+            n1 = logLength >> 1,
+            n2 = logLength - n1;
+
+        n1 = 1 << n1;
+        n2 = 1 << n2;
+
+        // Now n2 >= n1
+
+        transform(dataStorage, n1, n2, length, modulus);
+    }
+
+    public void inverseTransform(DataStorage dataStorage, int modulus, long totalTransformLength)
+        throws ApfloatRuntimeException
+    {
+        long length = dataStorage.getSize();            // Transform length n
+
+        if (Math.max(length, totalTransformLength) > this.stepStrategy.getMaxTransformLength())
+        {
+            throw new TransformLengthExceededException("Maximum transform length exceeded: " + Math.max(length, totalTransformLength) + " > " + this.stepStrategy.getMaxTransformLength());
+        }
+
+        if (length < 2)
+        {
+            return;
+        }
+
+        assert (length == (length & -length));          // Must be a power of two
+
+        // Treat the input data as a n1 x n2 matrix
+
+        int logLength = Util.log2down(length),
+            n1 = logLength >> 1,
+            n2 = logLength - n1;
+
+        n1 = 1 << n1;
+        n2 = 1 << n2;
+
+        // Now n2 >= n1
+
+        inverseTransform(dataStorage, n1, n2, length, totalTransformLength, modulus);
+    }
+
+    public long getTransformLength(long size)
+    {
+        return Util.round2up(size);
+    }
+
+    /**
+     * Transform the data in steps.
+     *
+     * @param dataStorage The data.
+     * @param n1 Height of the data matrix.
+     * @param n2 Width of the data matrix.
+     * @param length Length of the data.
+     * @param modulus Which modulus to use.
+     */
+
+    protected abstract void transform(DataStorage dataStorage, int n1, int n2, long length, int modulus)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Inverse transform the data in steps.
+     *
+     * @param dataStorage The data.
+     * @param n1 Height of the data matrix.
+     * @param n2 Width of the data matrix.
+     * @param length Length of the data.
+     * @param totalTransformLength Total transform length.
+     * @param modulus Which modulus to use.
+     */
+
+    protected abstract void inverseTransform(DataStorage dataStorage, int n1, int n2, long length, long totalTransformLength, int modulus)
+        throws ApfloatRuntimeException;
+
+    /**
+     * The NTT steps.
+     */
+
+    protected NTTStepStrategy stepStrategy;
+}
Index: src/main/java/org/apfloat/internal/ApfloatInternalException.java
===================================================================
--- src/main/java/org/apfloat/internal/ApfloatInternalException.java	(revision 0)
+++ src/main/java/org/apfloat/internal/ApfloatInternalException.java	(revision 0)
@@ -0,0 +1,59 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+
+/**
+ * Exception indicating some unexpected apfloat
+ * implementation specific error situation.
+ * This exception can be thrown in different situations, for example:
+ *
+ * <ul>
+ *   <li>Backing storage failure. For example, if a number is stored on disk,
+ *       an <code>IOException</code> can be thrown in any of the disk operations,
+ *       if e.g. a file can't be created, or if the disk is full.</li>
+ *   <li>Operands of some operation have different radixes.</li>
+ *   <li>Other internal limitation, e.g. the maximum transform length
+ *       mathematically possible for the implementation, is exceeded.</li>
+ * </ul>
+ *
+ * @since 1.5
+ * @version 1.5
+ * @author Mikko Tommila
+ */
+
+public class ApfloatInternalException
+    extends ApfloatRuntimeException
+{
+    /**
+     * Constructs a new apfloat internal exception with an empty detail message.
+     */
+
+    public ApfloatInternalException()
+    {
+    }
+
+    /**
+     * Constructs a new apfloat internal exception with the specified detail message.
+     *
+     * @param message The detail message.
+     */
+
+    public ApfloatInternalException(String message)
+    {
+        super(message);
+    }
+
+    /**
+     * Constructs a new apfloat internal exception with the specified detail message and cause.
+     *
+     * @param message The detail message.
+     * @param cause Originating cause of the exception.
+     */
+
+    public ApfloatInternalException(String message, Throwable cause)
+    {
+        super(message, cause);
+    }
+
+    private static final long serialVersionUID = -7022924635011038776L;
+}
Index: src/main/java/org/apfloat/internal/BackingStorageException.java
===================================================================
--- src/main/java/org/apfloat/internal/BackingStorageException.java	(revision 0)
+++ src/main/java/org/apfloat/internal/BackingStorageException.java	(revision 0)
@@ -0,0 +1,51 @@
+package org.apfloat.internal;
+
+/**
+ * Exception indicating a backing storage failure.<p>
+ *
+ * For example, a large number can be stored on disk.
+ * An <code>IOException</code> can be thrown in any of
+ * the disk operations, for example if a file can't be
+ * created, or if the disk is full.
+ *
+ * @since 1.5
+ * @version 1.5
+ * @author Mikko Tommila
+ */
+
+public class BackingStorageException
+    extends ApfloatInternalException
+{
+    /**
+     * Constructs a new apfloat backing storage exception with an empty detail message.
+     */
+
+    public BackingStorageException()
+    {
+    }
+
+    /**
+     * Constructs a new apfloat backing storage exception with the specified detail message.
+     *
+     * @param message The detail message.
+     */
+
+    public BackingStorageException(String message)
+    {
+        super(message);
+    }
+
+    /**
+     * Constructs a new apfloat backing storage exception with the specified detail message and cause.
+     *
+     * @param message The detail message.
+     * @param cause Originating cause of the exception.
+     */
+
+    public BackingStorageException(String message, Throwable cause)
+    {
+        super(message, cause);
+    }
+
+    private static final long serialVersionUID = -7022924635011038776L;
+}
Index: src/main/java/org/apfloat/internal/ConcurrentSoftHashMap.java
===================================================================
--- src/main/java/org/apfloat/internal/ConcurrentSoftHashMap.java	(revision 0)
+++ src/main/java/org/apfloat/internal/ConcurrentSoftHashMap.java	(revision 0)
@@ -0,0 +1,94 @@
+package org.apfloat.internal;
+
+import java.lang.ref.SoftReference;
+import java.util.AbstractMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * ConcurrentHashMap with softly referenced values.
+ * The maximum map size is assumed to be limited so no
+ * effort is made to expunge entries for stale values.<p>
+ *
+ * Values are not properly compared for equality so
+ * the only actual concurrent method implemented is
+ * <code>putIfAbsent()</code>.<p>
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+class ConcurrentSoftHashMap<K, V>
+    extends AbstractMap<K, V>
+    implements ConcurrentMap<K, V>
+{
+    private ConcurrentHashMap<K, SoftReference<V>> map;
+
+    public ConcurrentSoftHashMap()
+    {
+        this.map = new ConcurrentHashMap<K, SoftReference<V>>();
+    }
+
+    public void clear()
+    {
+        this.map.clear();
+    }
+
+    public Set<Map.Entry<K, V>> entrySet()
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public V get(Object key)
+    {
+        return unwrap(this.map.get(key));
+    }
+
+    public V put(K key, V value)
+    {
+        return unwrap(this.map.put(key, wrap(value)));
+    }
+
+    public V putIfAbsent(K key, V value)
+    {
+        return unwrap(this.map.putIfAbsent(key, wrap(value)));
+    }
+
+    public V remove(Object key)
+    {
+        return unwrap(this.map.remove(key));
+    }
+
+    public boolean remove(Object key, Object value)
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public V replace(K key, V value)
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public boolean replace(K key, V oldValue, V newValue)
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public int size()
+    {
+        return this.map.size();
+    }
+
+    private SoftReference<V> wrap(V value)
+    {
+        return new SoftReference<V>(value);
+    }
+
+    private V unwrap(SoftReference<V> value)
+    {
+        return (value == null ? null : value.get());
+    }
+}
Index: src/main/java/org/apfloat/internal/DiskDataStorage.java
===================================================================
--- src/main/java/org/apfloat/internal/DiskDataStorage.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DiskDataStorage.java	(revision 0)
@@ -0,0 +1,872 @@
+package org.apfloat.internal;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.RandomAccessFile;
+import java.io.Serializable;
+import java.lang.ref.PhantomReference;
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.SoftReference;
+import java.nio.ByteBuffer;
+import java.nio.channels.Channels;
+import java.nio.channels.FileChannel;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.channels.WritableByteChannel;
+import java.util.HashSet;
+import java.util.Set;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ArrayAccess;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.FilenameGenerator;
+import org.apfloat.spi.MatrixStrategy;
+
+/**
+ * Abstract base class for disk-based data storage, containing the common
+ * functionality independent of the element type.
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public abstract class DiskDataStorage
+    extends DataStorage
+{
+    private static class FileStorage
+        implements Serializable
+    {
+        public FileStorage()
+            throws ApfloatRuntimeException
+        {
+            init();
+        }
+
+        private void init()
+            throws ApfloatRuntimeException
+        {
+            ApfloatContext ctx = ApfloatContext.getContext();
+            FilenameGenerator generator = ctx.getFilenameGenerator();
+
+            this.filename = generator.generateFilename();
+
+            this.file = new File(this.filename);
+
+            try
+            {
+                if (!this.file.createNewFile())
+                {
+                    throw new BackingStorageException("Failed to create new file \"" + this.filename + '\"');
+                }
+
+                // Ensure file is deleted always
+                this.file.deleteOnExit();
+
+                this.randomAccessFile = new RandomAccessFile(this.file, "rw");
+            }
+            catch (IOException ioe)
+            {
+                throw new BackingStorageException("Unable to access file \"" + this.filename + '\"', ioe);
+            }
+
+            this.fileChannel = this.randomAccessFile.getChannel();
+
+            referenceFileStorage(this);     // To put to reference queue after garbage collection
+        }
+
+        public void setSize(long size)
+            throws IOException, ApfloatRuntimeException
+        {
+            try
+            {
+                getRandomAccessFile().setLength(size);
+            }
+            catch (IOException ioe)
+            {
+                // Probably out of disk space - run garbage collection and process reference queue to delete unused files, then retry
+                System.gc();
+                forceFreeFileStorage();
+                getRandomAccessFile().setLength(size);
+            }
+        }
+
+        public void transferFrom(ReadableByteChannel in, long position, long size)
+            throws ApfloatRuntimeException
+        {
+            try
+            {
+                if (in instanceof FileChannel)
+                {
+                    // Optimized transferFrom() between two FileChannels
+                    while (size > 0)
+                    {
+                        long count = getFileChannel().transferFrom(in, position, size);
+                        position += count;
+                        size -= count;
+                        assert (size >= 0);
+                    }
+                }
+                else
+                {
+                    // The FileChannel transferFrom() uses an 8kB buffer, which is too small and inefficient
+                    // So we use a similar mechanism but with a custom buffer size
+                    ByteBuffer buffer = getDirectByteBuffer();
+                    while (size > 0)
+                    {
+                        buffer.clear();
+                        int readCount = (int) Math.min(size, buffer.capacity());
+                        buffer.limit(readCount);
+                        readCount = in.read(buffer);
+                        buffer.flip();
+                        while (readCount > 0)
+                        {
+                            int writeCount = getFileChannel().write(buffer, position);
+                            position += writeCount;
+                            size -= writeCount;
+                            readCount -= writeCount;
+                        }
+                        assert (readCount == 0);
+                        assert (size >= 0);
+                    }
+                }
+            }
+            catch (IOException ioe)
+            {
+                throw new BackingStorageException("Unable to write to file \"" + getFilename() + '\"', ioe);
+            }
+        }
+
+        public void transferTo(WritableByteChannel out, long position, long size)
+            throws ApfloatRuntimeException
+        {
+            try
+            {
+                if (out instanceof FileChannel)
+                {
+                    // Optimized transferTo() between two FileChannels
+                    while (size > 0)
+                    {
+                        long count = getFileChannel().transferTo(position, size, out);
+                        position += count;
+                        size -= count;
+                        assert (size >= 0);
+                    }
+                }
+                else
+                {
+                    // The DiskChannel transferTo() uses an 8kB buffer, which is too small and inefficient
+                    // So we use a similar mechanism but with a custom buffer size
+                    ByteBuffer buffer = getDirectByteBuffer();
+                    while (size > 0)
+                    {
+                        buffer.clear();
+                        int readCount = (int) Math.min(size, buffer.capacity());
+                        buffer.limit(readCount);
+                        readCount = getFileChannel().read(buffer, position);
+                        buffer.flip();
+                        while (readCount > 0)
+                        {
+                            int writeCount = out.write(buffer);
+                            position += writeCount;
+                            size -= writeCount;
+                            readCount -= writeCount;
+                        }
+                        assert (readCount == 0);
+                        assert (size >= 0);
+                    }
+                }
+            }
+            catch (IOException ioe)
+            {
+                throw new BackingStorageException("Unable to read from file \"" + getFilename() + '\"', ioe);
+            }
+        }
+
+        public String getFilename()
+        {
+            return this.filename;
+        }
+
+        public File getFile()
+        {
+            return this.file;
+        }
+
+        public RandomAccessFile getRandomAccessFile()
+        {
+            return this.randomAccessFile;
+        }
+
+        public FileChannel getFileChannel()
+        {
+            return this.fileChannel;
+        }
+
+        // Writes the file contents to the serialization stream
+        private void writeObject(ObjectOutputStream out)
+            throws IOException
+        {
+            long size = getFileChannel().size();
+            out.writeLong(size);
+
+            transferTo(Channels.newChannel(out), 0, size);
+
+            out.defaultWriteObject();
+        }
+
+        // Reads file contents from the serialization stream
+        private void readObject(ObjectInputStream in)
+            throws IOException, ClassNotFoundException
+        {
+            init();
+
+            long size = in.readLong();
+
+            setSize(size);
+
+            transferFrom(Channels.newChannel(in), 0, size);
+
+            in.defaultReadObject();
+        }
+
+        private static final long serialVersionUID = 2062430603153403341L;
+
+        // These fields are not serialized automatically
+        private transient String filename;
+        private transient File file;
+        private transient RandomAccessFile randomAccessFile;
+        private transient FileChannel fileChannel;
+    }
+
+    // A PhantomReference is used so it's only queued when the Apfloat can't become accessible in any way (e.g. if it's weakly referenced)
+    private static class FileStorageReference
+        extends PhantomReference<FileStorage>
+    {
+        public FileStorageReference(FileStorage fileStorage, ReferenceQueue<FileStorage> queue)
+        {
+            super(fileStorage, queue);
+
+            this.file = fileStorage.getFile();
+            this.randomAccessFile = fileStorage.getRandomAccessFile();
+            this.fileChannel = fileStorage.getFileChannel();
+        }
+
+        public void dispose()
+        {
+            try
+            {
+                this.fileChannel.close();
+            }
+            catch (IOException ioe)
+            {
+                // Ignore
+            }
+
+            try
+            {
+                this.randomAccessFile.close();
+            }
+            catch (IOException ioe)
+            {
+                // Ignore
+            }
+
+            // If deletion fails now, at least deleteOnExit() has been called
+            this.file.delete();
+        }
+
+        private File file;
+        private RandomAccessFile randomAccessFile;
+        private FileChannel fileChannel;
+    }
+
+    /**
+     * Default constructor.
+     */
+
+    protected DiskDataStorage()
+        throws ApfloatRuntimeException
+    {
+        this.fileStorage = createFileStorage();
+    }
+
+    /**
+     * Subsequence constructor.
+     *
+     * @param diskDataStorage The originating data storage.
+     * @param offset The subsequence starting position.
+     * @param length The subsequence length.
+     */
+
+    protected DiskDataStorage(DiskDataStorage diskDataStorage, long offset, long length)
+    {
+        super(diskDataStorage, offset, length);
+        this.fileStorage = diskDataStorage.fileStorage;
+    }
+
+    public boolean isCached()
+    {
+        return false;
+    }
+
+    protected void implCopyFrom(DataStorage dataStorage, long size)
+        throws ApfloatRuntimeException
+    {
+        if (dataStorage == this)
+        {
+            setSize(size);
+            return;
+        }
+
+        assert (size > 0);
+        assert (!isReadOnly());
+        assert (!isSubsequenced());
+
+        int unitSize = getUnitSize();
+        long byteSize = size * unitSize;
+
+        assert (byteSize > 0);
+
+        try
+        {
+            this.fileStorage.setSize(byteSize);
+
+            long readSize = Math.min(size, dataStorage.getSize()),
+                 oldSize = readSize * unitSize,
+                 padSize = byteSize - oldSize;
+
+            if (dataStorage instanceof DiskDataStorage)
+            {
+                // Optimized disk-to-disk copy
+
+                DiskDataStorage that = (DiskDataStorage) dataStorage;
+                that.transferTo(getFileChannel().position(0),
+                                that.getOffset() * unitSize,
+                                oldSize);
+            }
+            else
+            {
+                // Un-optimized copy from arbitrary data storage
+
+                long position = 0;
+                int bufferSize = getBlockSize() / unitSize;
+                while (readSize > 0)
+                {
+                    int length = (int) Math.min(bufferSize, readSize);
+
+                    ArrayAccess readArrayAccess = dataStorage.getArray(READ, position, length);
+                    ArrayAccess writeArrayAccess = getArray(WRITE, position, length);
+                    System.arraycopy(readArrayAccess.getData(), readArrayAccess.getOffset(), writeArrayAccess.getData(), writeArrayAccess.getOffset(), length);
+                    writeArrayAccess.close();
+                    readArrayAccess.close();
+
+                    readSize -= length;
+                    position += length;
+                }
+            }
+            pad(oldSize, padSize);
+        }
+        catch (IOException ioe)
+        {
+            throw new BackingStorageException("Unable to copy to file \"" + getFilename() + '\"', ioe);
+        }
+    }
+
+    protected long implGetSize()
+        throws ApfloatRuntimeException
+    {
+        try
+        {
+            return getFileChannel().size() / getUnitSize();
+        }
+        catch (IOException ioe)
+        {
+            throw new BackingStorageException("Unable to access file \"" + getFilename() + '\"', ioe);
+        }
+    }
+
+    protected void implSetSize(long size)
+        throws ApfloatRuntimeException
+    {
+        assert (size > 0);
+        assert (!isReadOnly());
+        assert (!isSubsequenced());
+
+        size *= getUnitSize();
+
+        assert (size > 0);
+
+        try
+        {
+            long oldSize = getFileChannel().size(),
+                 padSize = size - oldSize;
+            this.fileStorage.setSize(size);
+            pad(oldSize, padSize);
+        }
+        catch (IOException ioe)
+        {
+            throw new BackingStorageException("Unable to access file \"" + getFilename() + '\"', ioe);
+        }
+    }
+
+    protected synchronized ArrayAccess implGetArray(int mode, int startColumn, int columns, int rows)
+        throws ApfloatRuntimeException
+    {
+        int width = (int) (getSize() / rows);
+
+        if (columns != (columns & -columns) || rows != (rows & -rows) || startColumn + columns > width)
+        {
+            throw new ApfloatInternalException("Invalid size");
+        }
+
+        ArrayAccess arrayAccess = createArrayAccess(mode, startColumn, columns, rows);
+
+        if ((mode & READ) != 0)
+        {
+            long readPosition = startColumn;
+            int writePosition = 0;
+            for (int i = 0; i < rows; i++)
+            {
+                readToArray(readPosition, arrayAccess, writePosition, columns);
+
+                readPosition += width;
+                writePosition += columns;
+            }
+        }
+
+        return arrayAccess;
+    }
+
+    protected synchronized ArrayAccess implGetTransposedArray(int mode, int startColumn, int columns, int rows)
+        throws ApfloatRuntimeException
+    {
+        int width = (int) (getSize() / rows);
+
+        if (columns != (columns & -columns) || rows != (rows & -rows) || startColumn + columns > width)
+        {
+            throw new ApfloatInternalException("Invalid size");
+        }
+
+        int blockSize = columns * rows,
+            b = Math.min(columns, rows);
+        ArrayAccess arrayAccess = createTransposedArrayAccess(mode, startColumn, columns, rows);
+
+        if ((mode & READ) != 0)
+        {
+            // Read the data from the input file in b x b blocks
+            ApfloatContext ctx = ApfloatContext.getContext();
+            MatrixStrategy matrixStrategy = ctx.getBuilderFactory().getMatrixBuilder().createMatrix();
+
+            if (columns < rows)
+            {
+                // Taller than wide section
+                long readPosition = startColumn;
+                for (int i = 0; i < rows; i += b)
+                {
+                    int writePosition = i;
+
+                    for (int j = 0; j < b; j++)
+                    {
+                        readToArray(readPosition, arrayAccess, writePosition, b);
+
+                        readPosition += width;
+                        writePosition += rows;
+                    }
+
+                    // Transpose the b x b block
+
+                    ArrayAccess subArrayAccess = arrayAccess.subsequence(i, blockSize - i);
+                    matrixStrategy.transposeSquare(subArrayAccess, b, rows);
+                }
+            }
+            else
+            {
+                // Wider than tall section
+                for (int i = 0; i < b; i++)
+                {
+                    long readPosition = startColumn + i * width;
+                    int writePosition = i * b;
+
+                    for (int j = 0; j < columns; j += b)
+                    {
+                        readToArray(readPosition, arrayAccess, writePosition, b);
+
+                        readPosition += b;
+                        writePosition += b * b;
+                    }
+                }
+
+                for (int i = 0; i < blockSize; i += b * b)
+                {
+                    // Transpose the b x b block
+
+                    ArrayAccess subArrayAccess = arrayAccess.subsequence(i, blockSize - i);
+                    matrixStrategy.transposeSquare(subArrayAccess, b, b);
+                }
+            }
+        }
+
+        return arrayAccess;
+    }
+
+    /**
+     * Write the data back to the same location in the file that was retrieved with
+     * {@link #implGetArray(int,int,int,int)}.
+     *
+     * @param arrayAccess The transposed array access.
+     * @param startColumn The starting column where data is stored.
+     * @param columns The number of columns of data.
+     * @param rows The number of rows of data.
+     *
+     * @since 1.7.0
+     */
+
+    protected synchronized void setArray(ArrayAccess arrayAccess, int startColumn, int columns, int rows)
+        throws ApfloatRuntimeException
+    {
+        int width = (int) (getSize() / rows);
+
+        int readPosition = 0;
+        long writePosition = startColumn;
+        for (int i = 0; i < rows; i++)
+        {
+            writeFromArray(arrayAccess, readPosition, writePosition, columns);
+
+            readPosition += columns;
+            writePosition += width;
+        }
+    }
+
+    /**
+     * Write the data back to the same location in the file that was retrieved with
+     * {@link #implGetTransposedArray(int,int,int,int)}.
+     *
+     * @param arrayAccess The transposed array access.
+     * @param startColumn The starting column where data is stored.
+     * @param columns The number of columns of data.
+     * @param rows The number of rows of data.
+     *
+     * @since 1.7.0
+     */
+
+    protected synchronized void setTransposedArray(ArrayAccess arrayAccess, int startColumn, int columns, int rows)
+        throws ApfloatRuntimeException
+    {
+        int width = (int) (getSize() / rows);
+
+        int blockSize = arrayAccess.getLength(),
+            b = Math.min(columns, rows);
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        MatrixStrategy matrixStrategy = ctx.getBuilderFactory().getMatrixBuilder().createMatrix();
+
+        if (columns < rows)
+        {
+            // Taller than wide section
+            long writePosition = startColumn;
+            for (int i = 0; i < rows; i += b)
+            {
+                int readPosition = i;
+
+                // Transpose the b x b block
+
+                ArrayAccess subArrayAccess = arrayAccess.subsequence(i, blockSize - i);
+                matrixStrategy.transposeSquare(subArrayAccess, b, rows);
+
+                for (int j = 0; j < b; j++)
+                {
+                    writeFromArray(arrayAccess, readPosition, writePosition, b);
+
+                    readPosition += rows;
+                    writePosition += width;
+                }
+            }
+        }
+        else
+        {
+            // Wider than tall section
+            for (int i = 0; i < blockSize; i += b * b)
+            {
+                // Transpose the b x b block
+
+                ArrayAccess subArrayAccess = arrayAccess.subsequence(i, blockSize - i);
+                matrixStrategy.transposeSquare(subArrayAccess, b, b);
+            }
+
+            for (int i = 0; i < b; i++)
+            {
+                long writePosition = startColumn + i * width;
+                int readPosition = i * b;
+
+                for (int j = 0; j < columns; j += b)
+                {
+                    writeFromArray(arrayAccess, readPosition, writePosition, b);
+
+                    readPosition += b * b;
+                    writePosition += b;
+                }
+            }
+        }
+    }
+
+    private void readToArray(long readPosition, ArrayAccess arrayAccess, int writePosition, int length)
+        throws ApfloatRuntimeException
+    {
+        ArrayAccess readArrayAccess = getArray(READ, readPosition, length);
+        System.arraycopy(readArrayAccess.getData(), readArrayAccess.getOffset(), arrayAccess.getData(), arrayAccess.getOffset() + writePosition, length);
+        readArrayAccess.close();
+    }
+
+    private void writeFromArray(ArrayAccess arrayAccess, int readPosition, long writePosition, int length)
+        throws ApfloatRuntimeException
+    {
+        ArrayAccess writeArrayAccess = getArray(WRITE, writePosition, length);
+        System.arraycopy(arrayAccess.getData(), arrayAccess.getOffset() + readPosition, writeArrayAccess.getData(), writeArrayAccess.getOffset(), length);
+        writeArrayAccess.close();
+    }
+
+    /**
+     * Create an empty ArrayAccess.
+     *
+     * @param mode Whether the array is prepared for reading, writing or both. The value should be {@link #READ}, {@link #WRITE} or a combination of these.
+     * @param startColumn The starting column where data is stored.
+     * @param columns The number of columns of data.
+     * @param rows The number of rows of data.
+     *
+     * @return Access to an empty array of the specified size and position.
+     *
+     * @since 1.7.0
+     */
+
+    protected abstract ArrayAccess createArrayAccess(int mode, int startColumn, int columns, int rows);
+
+    /**
+     * Create an empty transposed ArrayAccess.
+     *
+     * @param mode Whether the array is prepared for reading, writing or both. The value should be {@link #READ}, {@link #WRITE} or a combination of these.
+     * @param startColumn The starting column where data is stored.
+     * @param columns The number of columns of data.
+     * @param rows The number of rows of data.
+     *
+     * @return Access to an empty array of the specified size and position.
+     *
+     * @since 1.7.0
+     */
+
+    protected abstract ArrayAccess createTransposedArrayAccess(int mode, int startColumn, int columns, int rows);
+
+    /**
+     * Transfer from a readable channel, possibly in multiple chunks.
+     *
+     * @param in Input channel.
+     * @param position Start position of transfer.
+     * @param size Total number of bytes to transfer.
+     */
+
+    protected void transferFrom(ReadableByteChannel in, long position, long size)
+        throws ApfloatRuntimeException
+    {
+        this.fileStorage.transferFrom(in, position, size);
+    }
+
+    /**
+     * Transfer to a writable channel, possibly in multiple chunks.
+     *
+     * @param out Output channel.
+     * @param position Start position of transfer.
+     * @param size Total number of bytes to transfer.
+     */
+
+    protected void transferTo(WritableByteChannel out, long position, long size)
+        throws ApfloatRuntimeException
+    {
+        this.fileStorage.transferTo(out, position, size);
+    }
+
+    /**
+     * Convenience method for getting the block size (in bytes) for the
+     * current {@link ApfloatContext}.
+     *
+     * @return I/O block size, in bytes.
+     */
+
+    protected static int getBlockSize()
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        return ctx.getBlockSize();
+    }
+
+    /**
+     * Size of the element type, in bytes.
+     *
+     * @return Size of the element type, in bytes.
+     */
+
+    protected abstract int getUnitSize();
+
+    /**
+     * Filename of the underlying disk data storage.
+     *
+     * @return Filename of the underlying disk data storage.
+     */
+
+    protected final String getFilename()
+    {
+        return this.fileStorage.getFilename();
+    }
+
+    /**
+     * The <code>FileChannel</code> of the underlying disk file.
+     *
+     * @return The <code>FileChannel</code> of the underlying disk file.
+     */
+
+    protected final FileChannel getFileChannel()
+    {
+        return this.fileStorage.getFileChannel();
+    }
+
+    static synchronized void cleanUp()
+        throws ApfloatRuntimeException
+    {
+        for (FileStorageReference reference : DiskDataStorage.references)
+        {
+            // Just remove everything that has been created
+            reference.dispose();
+            reference.clear();
+        }
+        DiskDataStorage.references.clear();
+        DiskDataStorage.cleanUp = true;
+    }
+
+    static synchronized void gc()
+        throws ApfloatRuntimeException
+    {
+        forceFreeFileStorage();
+    }
+
+    private void pad(long position, long size)
+        throws IOException, ApfloatRuntimeException
+    {
+        transferFrom(ZERO_CHANNEL, position, size);
+    }
+
+    private static final ReadableByteChannel ZERO_CHANNEL = new ReadableByteChannel()
+    {
+        public int read(ByteBuffer buffer)
+        {
+            int writeLength = buffer.remaining();
+
+            for (int i = 0; i < writeLength; i++)
+            {
+                buffer.put((byte) 0);
+            }
+
+            return writeLength;
+        }
+
+        public void close() {}
+        public boolean isOpen() { return true; }
+    };
+
+    private static synchronized FileStorage createFileStorage()
+        throws ApfloatInternalException
+    {
+        if (DiskDataStorage.cleanUp)
+        {
+            throw new ApfloatInternalException("Shutdown has been initiated, clean-up is in progress");
+        }
+
+        freeFileStorage();                  // Before creating new files, delete the ones that have been garbage collected
+        FileStorage fileStorage = new FileStorage();
+
+        return fileStorage;
+    };
+
+    private static synchronized void referenceFileStorage(FileStorage fileStorage)
+        throws ApfloatInternalException
+    {
+        if (DiskDataStorage.cleanUp)
+        {
+            new FileStorageReference(fileStorage, null).dispose();      // Delete the file immediately; it skipped the clean-up procedure
+            throw new ApfloatInternalException("Shutdown has been initiated, clean-up is in progress");
+        }
+
+        // The reference might not really be needed for anything else than queuing in the reference queue,
+        // but we have to keep a hard reference to it to have it queued
+        FileStorageReference reference = new FileStorageReference(fileStorage, DiskDataStorage.referenceQueue);
+        DiskDataStorage.references.add(reference);
+    }
+
+    private static synchronized void freeFileStorage()
+    {
+        FileStorageReference reference;
+        // Just check if there's anything that can be cleaned up immediately
+        while ((reference = (FileStorageReference) DiskDataStorage.referenceQueue.poll()) != null)
+        {
+            reference.dispose();
+            reference.clear();
+            DiskDataStorage.references.remove(reference);
+        }
+    }
+
+    private static synchronized void forceFreeFileStorage()
+        throws ApfloatInternalException
+    {
+        try
+        {
+            FileStorageReference reference;
+            // Instead of poll(), wait for some time for GC to finish; we want to free as much disk as possible e.g. if we are out of disk space so waiting some time is not that bad
+            while ((reference = (FileStorageReference) DiskDataStorage.referenceQueue.remove(TIMEOUT)) != null)
+            {
+                reference.dispose();
+                reference.clear();
+                DiskDataStorage.references.remove(reference);
+            }
+        }
+        catch (InterruptedException ie)
+        {
+            throw new ApfloatInternalException("Reference queue polling was interrupted", ie);
+        }
+    }
+
+    private static ByteBuffer getDirectByteBuffer()
+    {
+        // Since direct buffers are allocated outside of the heap they can behave strangely in relation to GC
+        // So we try to make them as long-lived as possible and cache them in a ThreadLocal
+        ByteBuffer buffer = null;
+        int blockSize = getBlockSize();
+        SoftReference<ByteBuffer> reference = DiskDataStorage.threadLocal.get();
+        if (reference != null)
+        {
+            buffer = reference.get();
+            if (buffer != null && buffer.capacity() != blockSize)
+            {
+                // Clear references to the direct buffer so it may be GC'd
+                reference.clear();
+                buffer = null;
+            }
+        }
+        if (buffer == null)
+        {
+            buffer = ByteBuffer.allocateDirect(blockSize);
+            reference = new SoftReference<ByteBuffer>(buffer);
+            DiskDataStorage.threadLocal.set(reference);
+        }
+
+        return buffer;
+    }
+
+    private static final long serialVersionUID = 741984828408146034L;
+
+    private static final long TIMEOUT = 1000;   // Reference queue waiting timeout when forcing deleting garbage collected files
+
+    private static ReferenceQueue<FileStorage> referenceQueue = new ReferenceQueue<FileStorage>();
+    private static Set<FileStorageReference> references = new HashSet<FileStorageReference>();
+    private static ThreadLocal<SoftReference<ByteBuffer>> threadLocal = new ThreadLocal<SoftReference<ByteBuffer>>();
+    private static boolean cleanUp = false;
+
+    private FileStorage fileStorage;
+}
Index: src/main/java/org/apfloat/internal/DoubleAdditionBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleAdditionBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleAdditionBuilder.java	(revision 0)
@@ -0,0 +1,30 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.AdditionBuilder;
+import org.apfloat.spi.AdditionStrategy;
+
+/**
+ * Creates additions for the specified radix and the <code>double</code> element type.<p>
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleAdditionBuilder
+    implements AdditionBuilder<Double>
+{
+    /**
+     * Default constructor.
+     */
+
+    public DoubleAdditionBuilder()
+    {
+    }
+
+    public AdditionStrategy<Double> createAddition(int radix)
+    {
+        AdditionStrategy<Double> additionStrategy = new DoubleAdditionStrategy(radix);
+        return additionStrategy;
+    }
+}
Index: src/main/java/org/apfloat/internal/DoubleAdditionStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleAdditionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleAdditionStrategy.java	(revision 0)
@@ -0,0 +1,59 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.AdditionStrategy;
+import org.apfloat.spi.DataStorage.Iterator;
+
+/**
+ * Basic addition strategy for the <code>double</code> element type.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+public class DoubleAdditionStrategy
+    extends DoubleBaseMath
+    implements AdditionStrategy<Double>
+{
+    /**
+     * Creates an addition strategy using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public DoubleAdditionStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public Double add(Iterator src1, Iterator src2, Double carry, Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        return baseAdd(src1, src2, carry, dst, size);
+    }
+
+    public Double subtract(Iterator src1, Iterator src2, Double carry, Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        return baseSubtract(src1, src2, carry, dst, size);
+    }
+
+    public Double multiplyAdd(Iterator src1, Iterator src2, Double src3, Double carry, Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        return baseMultiplyAdd(src1, src2, src3, carry, dst, size);
+    }
+
+    public Double divide(Iterator src1, Double src2, Double carry, Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        return baseDivide(src1, src2, carry, dst, size);
+    }
+
+    public Double zero()
+    {
+        return (double) 0;
+    }
+
+    private static final long serialVersionUID = 6863520700151824670L;
+}
Index: src/main/java/org/apfloat/internal/DoubleApfloatBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleApfloatBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleApfloatBuilder.java	(revision 0)
@@ -0,0 +1,52 @@
+package org.apfloat.internal;
+
+import java.io.PushbackReader;
+import java.io.IOException;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ApfloatBuilder;
+import org.apfloat.spi.ApfloatImpl;
+
+/**
+ * Builder class for building {@link ApfloatImpl} implementations with the
+ * <code>double</code> data element type.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleApfloatBuilder
+    implements ApfloatBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public DoubleApfloatBuilder()
+    {
+    }
+
+    public ApfloatImpl createApfloat(String value, long precision, int radix, boolean isInteger)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        return new DoubleApfloatImpl(value, precision, radix, isInteger);
+    }
+
+    public ApfloatImpl createApfloat(long value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        return new DoubleApfloatImpl(value, precision, radix);
+    }
+
+    public ApfloatImpl createApfloat(double value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        return new DoubleApfloatImpl(value, precision, radix);
+    }
+
+    public ApfloatImpl createApfloat(PushbackReader in, long precision, int radix, boolean isInteger)
+        throws IOException, NumberFormatException, ApfloatRuntimeException
+    {
+        return new DoubleApfloatImpl(in, precision, radix, isInteger);
+    }
+}
Index: src/main/java/org/apfloat/internal/DoubleApfloatImpl.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleApfloatImpl.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleApfloatImpl.java	(revision 0)
@@ -0,0 +1,2449 @@
+package org.apfloat.internal;
+
+import java.io.ObjectInputStream;
+import java.io.PushbackReader;
+import java.io.Writer;
+import java.io.StringWriter;
+import java.io.IOException;
+
+import org.apfloat.Apfloat;
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.InfiniteExpansionException;
+import org.apfloat.OverflowException;
+import org.apfloat.spi.ApfloatImpl;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+import org.apfloat.spi.AdditionBuilder;
+import org.apfloat.spi.AdditionStrategy;
+import org.apfloat.spi.ConvolutionBuilder;
+import org.apfloat.spi.ConvolutionStrategy;
+import org.apfloat.spi.Util;
+import static org.apfloat.spi.RadixConstants.*;
+import static org.apfloat.internal.DoubleRadixConstants.*;
+
+/**
+ * Immutable apfloat implementation class for the
+ * <code>double</code> data element type.<p>
+ *
+ * The associated {@link DataStorage} is assumed to be immutable also.
+ * This way performance can be improved by sharing the data storage between
+ * different <code>ApfloatImpl</code>'s and by only varying the
+ * <code>ApfloatImpl</code> specific fields, like sign, precision and exponent.<p>
+ *
+ * This implementation doesn't necessarily store any extra digits for added
+ * precision, so the last digit of any operation may be inaccurate.
+ *
+ * @version 1.8.2
+ * @author Mikko Tommila
+ */
+
+public class DoubleApfloatImpl
+    extends DoubleBaseMath
+    implements ApfloatImpl
+{
+    // Implementation notes:
+    // - The dataStorage must never contain leading zeros or trailing zeros
+    // - If precision is reduced then the dataStorage can contain trailing zeros (physically in the middle)
+    // - The dataStorage should not be unnecessarily subsequenced if precision is reduced e.g. to allow autoconvolution
+    // - Precision is in digits but exponent is in base units
+    private DoubleApfloatImpl(int sign, long precision, long exponent, DataStorage dataStorage, int radix)
+    {
+        super(radix);
+
+        assert (sign == 0 || sign == -1 || sign == 1);
+        assert (precision > 0);
+        assert (sign != 0 || precision == Apfloat.INFINITE);
+        assert (sign != 0 || exponent == 0);
+        assert (sign != 0 || dataStorage == null);
+        assert (sign == 0 || dataStorage != null);
+        assert (exponent <= MAX_EXPONENT[radix] && exponent >= -MAX_EXPONENT[radix]);
+        assert (dataStorage == null || dataStorage.isReadOnly());
+
+        this.sign = sign;
+        this.precision = precision;
+        this.exponent = exponent;
+        this.dataStorage = dataStorage;
+        this.radix = radix;
+    }
+
+    /**
+     * Create a new <code>DoubleApfloatImpl</code> instance from a String.
+     *
+     * @param value The string to be parsed to a number.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     * @param isInteger Specifies if the number to be parsed from the string is to be treated as an integer or not.
+     *
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public DoubleApfloatImpl(String value, long precision, int radix, boolean isInteger)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        super(checkRadix(radix));
+
+        assert (precision == Apfloat.DEFAULT || precision > 0);
+
+        this.radix = radix;
+
+        // Default sign if not specified
+        this.sign = 1;
+
+        int startIndex = -1,
+            pointIndex = -1,
+            expIndex = -1,
+            leadingZeros = 0,
+            trailingZeros = 0,
+            digitSize = 0;
+
+        // Scan through the string looking for various things
+        for (int i = 0; i < value.length(); i++)
+        {
+            char c = value.charAt(i);
+            int digit = Character.digit(c, radix);
+
+            // Note that checking for a valid digit takes place before checking for e or E in the string
+            if (digit == -1)
+            {
+                if (i == 0 && (c == '-' || c == '+'))
+                {
+                    // Get sign
+                    this.sign = (c == '-' ? -1 : 1);
+                }
+                else if (!isInteger && c == '.' && pointIndex == -1)
+                {
+                    // Mark decimal point location
+                    pointIndex = digitSize;
+                }
+                else if (!isInteger && (c == 'e' || c == 'E') && expIndex == -1)
+                {
+                    // Mark index after which the exponent is specified
+                    expIndex = i;
+                    break;
+                }
+                else
+                {
+                    throw new NumberFormatException("Invalid character: " + c + " at position " + i);
+                }
+            }
+            else
+            {
+                if (leadingZeros == digitSize && digit == 0)
+                {
+                    // Increase number of leading zeros
+                    leadingZeros++;
+                }
+                else if (startIndex == -1)
+                {
+                    // Mark index where the significant digits start
+                    startIndex = i;
+                }
+
+                // Increase number of digits
+                digitSize++;
+
+                if (digit == 0)
+                {
+                    // Increase number of trailing zeros
+                    trailingZeros++;
+                }
+                else
+                {
+                    // Reset number of trailing zeros
+                    trailingZeros = 0;
+                }
+            }
+        }
+
+        // Check if no digits were specified
+        if (digitSize == 0)
+        {
+            throw new NumberFormatException("No digits");
+        }
+
+        // Check if this number is zero
+        if (startIndex == -1)
+        {
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Default precision is number of significant digits, if not specified
+        if (precision == Apfloat.DEFAULT)
+        {
+            assert (!isInteger);
+            precision = digitSize - leadingZeros;
+        }
+        this.precision = precision;
+
+        // Size of integer part
+        int integerSize = (pointIndex >= 0 ? pointIndex : digitSize) - leadingZeros;
+
+        // Read exponent as specified in string
+        if (expIndex >= 0)
+        {
+            // Thanks to Charles Oliver Nutter for finding this bug
+            String expString = value.substring(expIndex + 1);
+            if (expString.startsWith("+"))
+            {
+                expString = expString.substring(1);
+            }
+
+            try
+            {
+                this.exponent = Long.parseLong(expString);
+            }
+            catch (NumberFormatException nfe)
+            {
+                throw new NumberFormatException("Invalid exponent: " + expString);
+            }
+        }
+        else
+        {
+            this.exponent = 0;
+        }
+
+        // Do not allow the exponent to be too close to the limits (MIN_VALUE, MAX_VALUE), leave some slack
+        int slack = BASE_DIGITS[radix];
+
+        // Check for overflow in exponent, roughly
+        if (integerSize >= -slack && this.exponent >= Long.MAX_VALUE - integerSize - slack)
+        {
+            throw new NumberFormatException("Exponent overflow");
+        }
+        else if (integerSize <= slack && this.exponent <= Long.MIN_VALUE - integerSize + slack)
+        {
+            // Underflow
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Adjust exponent by decimal point location
+        this.exponent += integerSize;
+
+        // Exponent rounded towards positive infinity to base unit
+        long baseExp = (this.exponent + (this.exponent > 0 ? BASE_DIGITS[radix] - 1 : 0)) / BASE_DIGITS[radix];
+
+        // Check for overflow in exponent as represented in base units
+        if (baseExp > MAX_EXPONENT[this.radix])
+        {
+            throw new OverflowException("Overflow");
+        }
+        else if (baseExp < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Leading zeros in first base unit
+        int digitsInBase = (int) (baseExp * BASE_DIGITS[radix] - this.exponent);
+
+        // The stored exponent is really the one per base unit
+        this.exponent = baseExp;
+
+        // Remove leading and trailing zeros from size
+        digitSize -= leadingZeros + trailingZeros;
+
+        // Limit number of significant digits by specified precision
+        digitSize = (int) Math.min(digitSize, precision);
+
+        // Needed storage size in doubles
+        int size = (int) getBasePrecision(digitSize, BASE_DIGITS[radix] - digitsInBase);
+
+        this.dataStorage = createDataStorage(size);
+        this.dataStorage.setSize(size);
+
+        // Base unit that is constructed and stored to an element of the data storage
+        double word = 0;
+
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.WRITE, 0, size);
+
+        // Set the data
+        for (int i = startIndex; digitSize > 0; i++)
+        {
+            char c = value.charAt(i);
+            if (c == '.')
+            {
+                continue;
+            }
+
+            int digit = Character.digit(c, radix);
+            word *= (double) radix;
+            word += (double) digit;
+
+            if (digitSize == 1)
+            {
+                // Last digit
+                while (digitsInBase < BASE_DIGITS[radix] - 1)
+                {
+                    // Fill last word with trailing zeros
+                    word *= (double) radix;
+                    digitsInBase++;
+                }
+            }
+
+            if (++digitsInBase == BASE_DIGITS[radix])
+            {
+                // Word is full, write word
+                digitsInBase = 0;
+                iterator.setDouble(word);
+                iterator.next();
+                word = 0;
+            }
+
+            digitSize--;
+        }
+
+        assert (!iterator.hasNext());
+
+        this.dataStorage.setReadOnly();
+    }
+
+    /**
+     * Create a new <code>DoubleApfloatImpl</code> instance from a <code>long</code>.
+     *
+     * @param value The value of the number.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     *
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public DoubleApfloatImpl(long value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        super(checkRadix(radix));
+
+        assert (precision > 0);
+
+        this.radix = radix;
+
+        // Faster to set now than calculate later
+        this.isOne = (value == 1 ? 1 : 0);
+
+        if (value > 0)
+        {
+            this.sign = 1;
+            value = -value;         // Calculate here as negative to handle 0x8000000000000000
+        }
+        else if (value < 0)
+        {
+            this.sign = -1;
+        }
+        else
+        {
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        this.precision = precision;
+
+        int size;
+        double[] data = new double[MAX_LONG_SIZE];
+        long longBase = (long) BASE[radix];
+
+        if (-longBase < value)
+        {
+            size = 1;                               // Nonzero
+            data[MAX_LONG_SIZE - 1] = (double) -value;
+        }
+        else
+        {
+            for (size = 0; value != 0; size++)
+            {
+                long newValue = value / longBase;
+                data[MAX_LONG_SIZE - 1 - size] = (double) (newValue * longBase - value);   // Negated here
+                value = newValue;
+            }
+        }
+
+        this.exponent = size;
+
+        this.initialDigits = getDigits(data[MAX_LONG_SIZE - size]);
+
+        // Check if precision in doubles is less than size; truncate size if so
+        long basePrecision = getBasePrecision(precision, this.initialDigits);
+        if (basePrecision < size)
+        {
+            size = (int) basePrecision;
+        }
+
+        // Remove trailing zeros from data
+        while (data[MAX_LONG_SIZE - 1 - (int) this.exponent + size] == 0)
+        {
+            size--;
+        }
+
+        this.dataStorage = createDataStorage(size);
+        this.dataStorage.setSize(size);
+
+        ArrayAccess arrayAccess = this.dataStorage.getArray(DataStorage.WRITE, 0, size);
+        System.arraycopy(data, MAX_LONG_SIZE - (int) this.exponent, arrayAccess.getData(), arrayAccess.getOffset(), size);
+        arrayAccess.close();
+
+        this.dataStorage.setReadOnly();
+    }
+
+    /**
+     * Create a new <code>DoubleApfloatImpl</code> instance from a <code>double</code>.
+     *
+     * @param value The value of the number.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     *
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public DoubleApfloatImpl(double value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        super(checkRadix(radix));
+
+        if (Double.isInfinite(value) || Double.isNaN(value))
+        {
+            throw new NumberFormatException(value + " is not a valid number");
+        }
+
+        this.radix = radix;
+
+        if (value > 0)
+        {
+            this.sign = 1;
+        }
+        else if (value < 0)
+        {
+            this.sign = -1;
+            value = -value;
+        }
+        else
+        {
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        this.precision = precision;
+
+        int size;
+        double[] data = new double[MAX_DOUBLE_SIZE];
+        double doubleBase = (double) BASE[radix];
+
+        this.exponent = (long) Math.floor(Math.log(value) / Math.log(doubleBase));
+        // Avoid overflow in intermediate value
+        if (this.exponent > 0)
+        {
+            value *= Math.pow(doubleBase, (double) -this.exponent);
+        }
+        else if (this.exponent < 0)
+        {
+            value *= Math.pow(doubleBase, (double) (-this.exponent - MAX_DOUBLE_SIZE));
+            value *= Math.pow(doubleBase, (double) MAX_DOUBLE_SIZE);
+        }
+        this.exponent++;
+
+        if (value < 1.0)
+        {
+            // Round-off error in case the input was very close but just under the base, e.g. 9.999999999999996E-10
+            value = 1.0;
+        }
+
+        for (size = 0; size < MAX_DOUBLE_SIZE && value > 0.0; size++)
+        {
+            double tmp = Math.floor(value);
+
+            assert (tmp <= doubleBase);
+
+            if (tmp == doubleBase)
+            {
+                // Round-off error e.g. in case of the number being exactly 1/radix
+                tmp -= 1.0;
+            }
+
+            data[size] = (double) tmp;
+            value -= tmp;
+            value *= doubleBase;
+        }
+
+        this.initialDigits = getDigits(data[0]);
+
+        // Check if precision in doubles is less than size; truncate size if so
+        long basePrecision = getBasePrecision(precision, this.initialDigits);
+        if (basePrecision < size)
+        {
+            size = (int) basePrecision;
+        }
+
+        // Remove trailing zeros from data
+        while (data[size - 1] == 0)
+        {
+            size--;
+        }
+
+        this.dataStorage = createDataStorage(size);
+        this.dataStorage.setSize(size);
+
+        ArrayAccess arrayAccess = this.dataStorage.getArray(DataStorage.WRITE, 0, size);
+        System.arraycopy(data, 0, arrayAccess.getData(), arrayAccess.getOffset(), size);
+        arrayAccess.close();
+
+        this.dataStorage.setReadOnly();
+    }
+
+    private static long readExponent(PushbackReader in)
+        throws IOException, NumberFormatException
+    {
+        StringBuilder buffer = new StringBuilder(20);
+        int input;
+
+        for (long i = 0; (input = in.read()) != -1; i++)
+        {
+            char c = (char) input;
+            int digit = Character.digit(c, 10);         // Exponent is always in base 10
+
+            if (i == 0 && c == '-' ||
+                digit != -1)
+            {
+                buffer.append(c);
+            }
+            else
+            {
+                // Stop at first invalid character and put it back
+                in.unread(input);
+                break;
+            }
+        }
+
+        return Long.parseLong(buffer.toString());
+    }
+
+    /**
+     * Create a new <code>DoubleApfloatImpl</code> instance reading from a stream.<p>
+     *
+     * Implementation note: this constructor calls the <code>in</code> stream's
+     * single-character <code>read()</code> method. If the underlying stream doesn't
+     * explicitly implement this method in some efficient way, but simply inherits it
+     * from the <code>Reader</code> base class, performance will suffer as the default
+     * <code>Reader</code> method creates a <code>new char[1]</code> on every call to
+     * <code>read()</code>.
+     *
+     * @param in The stream to read from.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     * @param isInteger Specifies if the number to be parsed from the stream is to be treated as an integer or not.
+     *
+     * @exception java.io.IOException If an I/O error occurs accessing the stream.
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public DoubleApfloatImpl(PushbackReader in, long precision, int radix, boolean isInteger)
+        throws IOException, NumberFormatException, ApfloatRuntimeException
+    {
+        super(checkRadix(radix));
+
+        assert (precision == Apfloat.DEFAULT || precision > 0);
+
+        this.radix = radix;
+
+        // Default sign if not specified
+        this.sign = 1;
+
+        // Allocate a maximum memory block, since we don't know how much data to expect
+        ApfloatContext ctx = ApfloatContext.getContext();
+        long initialSize = ctx.getMemoryThreshold() / 8,
+             previousAllocatedSize = 0,
+             allocatedSize = initialSize;
+        this.dataStorage = createDataStorage(initialSize);
+        this.dataStorage.setSize(initialSize);
+
+        // Base unit that is constructed and stored to an element of the data storage
+        double word = 0;
+
+        // Number of digits stored in word
+        int digitsInBase = 0;
+
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.WRITE, previousAllocatedSize, allocatedSize);
+
+        int input;
+        long actualSize = 0,
+             startIndex = -1,
+             pointIndex = -1,
+             leadingZeros = 0,
+             trailingZeros = 0,
+             digitSize = 0;
+
+        // Scan through the string looking for various things
+        for (long i = 0; (input = in.read()) != -1; i++)
+        {
+            char c = (char) input;
+            int digit = Character.digit(c, radix);
+
+            // Note that checking for a valid digit takes place before checking for e or E in the string
+            if (digit == -1)
+            {
+                if (i == 0 && (c == '-' || c == '+'))
+                {
+                    // Get sign
+                    this.sign = (c == '-' ? -1 : 1);
+                }
+                else if (!isInteger && c == '.' && pointIndex == -1)
+                {
+                    // Mark decimal point location
+                    pointIndex = digitSize;
+                }
+                else if (!isInteger && digitSize > 0 && (c == 'e' || c == 'E'))
+                {
+                    // Read the exponent and stop
+                    this.exponent = readExponent(in);
+                    break;
+                }
+                else
+                {
+                    // Stop at first invalid character and put it back
+                    in.unread(input);
+                    break;
+                }
+            }
+            else
+            {
+                if (leadingZeros == digitSize && digit == 0)
+                {
+                    // Increase number of leading zeros
+                    leadingZeros++;
+                }
+                else
+                {
+                    if (startIndex == -1)
+                    {
+                        // Mark index where the significant digits start
+                        startIndex = i;
+                    }
+
+                    // Set the data
+                    word *= (double) radix;
+                    word += (double) digit;
+
+                    // Reallocate storage if needed; done here to prepare storing last (partial) word
+                    if (actualSize == allocatedSize)
+                    {
+                        if (actualSize == initialSize)
+                        {
+                            // Maximum memory block size exceeded; prepare to allocate anything
+                            DataStorage dataStorage = createDataStorage(Long.MAX_VALUE / 8);
+                            dataStorage.copyFrom(this.dataStorage, actualSize);
+                            this.dataStorage = dataStorage;
+                        }
+                        previousAllocatedSize = allocatedSize;
+                        allocatedSize += getBlockSize();
+                        this.dataStorage.setSize(allocatedSize);
+                        iterator.close();
+                        iterator = this.dataStorage.iterator(DataStorage.WRITE, previousAllocatedSize, allocatedSize);
+                    }
+
+                    if (++digitsInBase == BASE_DIGITS[radix])
+                    {
+                        // Word is full, write word
+                        digitsInBase = 0;
+                        iterator.setDouble(word);
+                        iterator.next();
+                        word = 0;
+                        actualSize++;
+                    }
+                }
+
+                // Increase number of digits
+                digitSize++;
+
+                if (digit == 0)
+                {
+                    // Increase number of trailing zeros
+                    trailingZeros++;
+                }
+                else
+                {
+                    // Reset number of trailing zeros
+                    trailingZeros = 0;
+                }
+            }
+        }
+
+        // Check if no digits were specified
+        if (digitSize == 0)
+        {
+            throw new NumberFormatException("No digits");
+        }
+
+        // Check if this number is zero
+        if (startIndex == -1)
+        {
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Handle last word
+        if (digitsInBase > 0 && word != 0)
+        {
+            // Last digit
+            while (digitsInBase < BASE_DIGITS[radix])
+            {
+                // Fill last word with trailing zeros
+                word *= (double) radix;
+                digitsInBase++;
+            }
+
+            // Write word
+            iterator.setDouble(word);
+            actualSize++;
+        }
+
+        iterator.close();
+
+        // Default precision is number of significant digits, if not specified
+        if (precision == Apfloat.DEFAULT)
+        {
+            assert (!isInteger);
+            precision = digitSize - leadingZeros;
+        }
+        this.precision = precision;
+
+        // Size of integer part
+        long integerSize = (pointIndex >= 0 ? pointIndex : digitSize) - leadingZeros;
+
+        // Do not allow the exponent to be too close to the limits (MIN_VALUE, MAX_VALUE), leave some slack
+        int slack = BASE_DIGITS[radix];
+
+        // Check for overflow in exponent, roughly
+        if (integerSize >= -slack && this.exponent >= Long.MAX_VALUE - integerSize - slack)
+        {
+            throw new NumberFormatException("Exponent overflow");
+        }
+        else if (integerSize <= slack && this.exponent <= Long.MIN_VALUE - integerSize + slack)
+        {
+            // Underflow
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Adjust exponent by decimal point location
+        this.exponent += integerSize;
+
+        // Exponent rounded towards negative infinity to base unit
+        long baseExp = (this.exponent - (this.exponent < 0 ? BASE_DIGITS[radix] - 1 : 0)) / BASE_DIGITS[radix];
+
+        // Check for overflow in exponent as represented in base units
+        if (baseExp > MAX_EXPONENT[this.radix])
+        {
+            throw new OverflowException("Overflow");
+        }
+        else if (baseExp < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // How much the data needs to be shifted
+        int bias = (int) (this.exponent - baseExp * BASE_DIGITS[radix]);
+
+        // The stored exponent is really the one per base unit
+        this.exponent = baseExp;
+
+        // Remove leading and trailing zeros from size
+        digitSize -= leadingZeros + trailingZeros;
+
+        // Limit number of significant digits by specified precision
+        digitSize = Math.min(digitSize, precision);
+
+        // Needed storage size in doubles
+        actualSize = (digitSize + BASE_DIGITS[radix] - 1) / BASE_DIGITS[radix];
+
+        // Truncate allocated space to actually used amount
+        this.dataStorage.setSize(actualSize);
+
+        this.dataStorage.setReadOnly();
+
+        if (bias != 0)
+        {
+            // Shift by bias
+            long factor = 1;
+
+            for (int i = 0; i < bias; i++)
+            {
+                factor *= radix;
+            }
+
+            DoubleApfloatImpl tmp = (DoubleApfloatImpl) multiply(new DoubleApfloatImpl(factor, Apfloat.INFINITE, radix));
+
+            this.exponent = tmp.exponent;
+            this.dataStorage = tmp.dataStorage;
+            this.initialDigits = UNDEFINED;     // Needs to be reset
+        }
+    }
+
+    // Returns number of trailing zeros before specified index
+    private static long getTrailingZeros(DataStorage dataStorage, long index)
+        throws ApfloatRuntimeException
+    {
+        long count = 0;
+
+        DataStorage.Iterator iterator = dataStorage.iterator(DataStorage.READ, index, 0);
+
+        while (iterator.hasNext())
+        {
+            if (iterator.getDouble() != 0)
+            {
+                iterator.close();
+                break;
+            }
+
+            iterator.next();
+            count++;
+        }
+
+        return count;
+    }
+
+    // Returns number of leading zeros starting from specified index
+    private static long getLeadingZeros(DataStorage dataStorage, long index)
+        throws ApfloatRuntimeException
+    {
+        long count = 0;
+
+        DataStorage.Iterator iterator = dataStorage.iterator(DataStorage.READ, index, dataStorage.getSize());
+
+        while (iterator.hasNext())
+        {
+            if (iterator.getDouble() != 0)
+            {
+                iterator.close();
+                break;
+            }
+
+            iterator.next();
+            count++;
+        }
+
+        return count;
+    }
+
+    public ApfloatImpl addOrSubtract(ApfloatImpl x, boolean subtract)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof DoubleApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        DoubleApfloatImpl that = (DoubleApfloatImpl) x;
+
+        if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot use numbers with different radixes: " + this.radix + " and " + that.radix);
+        }
+
+        assert (this.sign != 0);
+        assert (that.sign != 0);
+
+        int realThatSign = (subtract ? -that.sign : that.sign);
+        boolean reallySubtract = (this.sign != realThatSign);
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        AdditionBuilder<Double> additionBuilder = ctx.getBuilderFactory().getAdditionBuilder(Double.TYPE);
+        AdditionStrategy<Double> additionStrategy = additionBuilder.createAddition(this.radix);
+
+        int sign;
+        long exponent,
+             precision;
+        DataStorage dataStorage;
+
+        if (this == that)
+        {
+            if (reallySubtract)
+            {
+                // x - x = 0
+
+                return zero();
+            }
+            else
+            {
+                // x + x = 2 * x
+
+                sign = this.sign;
+                exponent = this.exponent;
+                precision = this.precision;
+                long size = getSize() + 1;
+
+                dataStorage = createDataStorage(size);
+                dataStorage.setSize(size);
+
+                DataStorage.Iterator src1 = this.dataStorage.iterator(DataStorage.READ, size - 1, 0),
+                                     src2 = this.dataStorage.iterator(DataStorage.READ, size - 1, 0),   // Sub-optimal: could be the same
+                                     dst = dataStorage.iterator(DataStorage.WRITE, size, 0);
+
+                double carry = additionStrategy.add(src1, src2, (double) 0, dst, size - 1);
+
+                dst.setDouble(carry);
+                dst.close();
+
+                size -= getTrailingZeros(dataStorage, size);
+
+                // Check if carry occurred
+                int carrySize = (int) carry,
+                    leadingZeros = 1 - carrySize;
+
+                dataStorage = dataStorage.subsequence(leadingZeros, size - leadingZeros);
+                exponent += carrySize;
+
+                if (this.exponent == MAX_EXPONENT[this.radix] && carrySize > 0)
+                {
+                    throw new OverflowException("Overflow");
+                }
+
+                if (precision != Apfloat.INFINITE &&
+                    (carrySize > 0 || getInitialDigits(dataStorage) > getInitialDigits()))
+                {
+                    // Carry overflow for most significant digit; number of significant digits increases by one
+                    precision++;
+                }
+            }
+        }
+        else
+        {
+            // Now this != that
+
+            int comparison;
+            if (scale() > that.scale())
+            {
+                comparison = 1;
+            }
+            else if (scale() < that.scale())
+            {
+                comparison = -1;
+            }
+            else if (reallySubtract)
+            {
+                comparison = compareMantissaTo(that);           // Might be sub-optimal, but a more efficient algorithm would be complicated
+            }
+            else
+            {
+                comparison = 1;                                 // Add equally big numbers; arbitrarily choose one
+            }
+
+            DoubleApfloatImpl big,
+                               small;
+
+            if (comparison > 0)
+            {
+                big = this;
+                small = that;
+                sign = this.sign;
+            }
+            else if (comparison < 0)
+            {
+                big = that;
+                small = this;
+                sign = realThatSign;
+            }
+            else
+            {
+                // x - x = 0
+                return zero();
+            }
+
+            long scaleDifference = big.scale() - small.scale(),
+                 exponentDifference,
+                 size,
+                 bigSize,
+                 smallSize;
+
+            if (scaleDifference < 0)
+            {
+                // Small number is completely insignificantly small compared to big
+                precision = big.precision;
+                exponent = big.exponent;
+                bigSize = big.getSize();
+                smallSize = 0;
+                size = bigSize;
+                exponentDifference = bigSize;
+            }
+            else
+            {
+                precision = Math.min(big.precision, Util.ifFinite(small.precision, scaleDifference + small.precision)); // Detects overflow also
+                long basePrecision = Math.min(MAX_EXPONENT[this.radix], getBasePrecision(precision, big.getInitialDigits()));
+                exponent = big.exponent;
+
+                exponentDifference = big.exponent - small.exponent;
+                size = Math.min(basePrecision, Math.max(big.getSize(), exponentDifference + small.getSize()));
+                bigSize = Math.min(size, big.getSize());
+                smallSize = Math.max(0, Math.min(size - exponentDifference, small.getSize()));
+            }
+
+            long dstSize = size + 1;                    // One extra word for carry overflow
+            dataStorage = createDataStorage(dstSize);
+            dataStorage.setSize(dstSize);
+
+            DataStorage.Iterator src1 = big.dataStorage.iterator(DataStorage.READ, bigSize, 0),
+                                 src2 = small.dataStorage.iterator(DataStorage.READ, smallSize, 0),
+                                 dst = dataStorage.iterator(DataStorage.WRITE, dstSize, 0);
+
+            double carry = 0;
+
+            // big:       XXXXXXXX               XXXX
+            // small:         XXXXXXXX        or         XXXX
+            // This part:         XXXX                   XXXX
+            if (size > bigSize)
+            {
+                long blockSize = Math.min(size - bigSize, smallSize);
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(null, src2, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(null, src2, carry, dst, blockSize);
+                }
+            }
+            // big:        XXXXXXXXXXXX
+            // small:          XXXX
+            // This part:          XXXX
+            else if (size > exponentDifference + smallSize)
+            {
+                long blockSize = size - exponentDifference - smallSize;
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(src1, null, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(src1, null, carry, dst, blockSize);
+                }
+            }
+            // big:        XXXX
+            // small:              XXXX
+            // This part:      XXXX
+            if (exponentDifference > bigSize)
+            {
+                long blockSize = exponentDifference - bigSize;
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(null, null, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(null, null, carry, dst, blockSize);
+                }
+            }
+            // big:        XXXXXXXX               XXXXXXXXXXXX
+            // small:          XXXXXXXX        or     XXXX
+            // This part:      XXXX                   XXXX
+            else if (bigSize > exponentDifference)
+            {
+                long blockSize = Math.min(bigSize - exponentDifference, smallSize);
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(src1, src2, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(src1, src2, carry, dst, blockSize);
+                }
+            }
+            // big:        XXXXXXXX               XXXXXXXXXXXX           XXXX
+            // small:          XXXXXXXX        or     XXXX            or         XXXX
+            // This part:  XXXX                   XXXX                   XXXX
+            if (exponentDifference > 0)
+            {
+                long blockSize = Math.min(bigSize, exponentDifference);
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(src1, null, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(src1, null, carry, dst, blockSize);
+                }
+            }
+
+            // Set most significant word
+            dst.setDouble(carry);
+            dst.close();
+
+            long leadingZeros;
+
+            if (reallySubtract)
+            {
+                // Get denormalization
+                leadingZeros = getLeadingZeros(dataStorage, 0);
+
+                assert (leadingZeros <= size);
+            }
+            else
+            {
+                // Check if carry occurred up to and including most significant word
+                leadingZeros = (carry == 0 ? 1 : 0);
+
+                if (this.exponent == MAX_EXPONENT[this.radix] && leadingZeros == 0)
+                {
+                    throw new OverflowException("Overflow");
+                }
+            }
+
+            dstSize -= getTrailingZeros(dataStorage, dstSize);
+
+            dataStorage = dataStorage.subsequence(leadingZeros, dstSize - leadingZeros);
+            exponent += 1 - leadingZeros;
+
+            if (exponent < -MAX_EXPONENT[this.radix])
+            {
+                // Underflow
+                return zero();
+            }
+
+            if (precision != Apfloat.INFINITE)
+            {
+                // If scale of number changes, the number of significant digits changes accordingly
+                long scaleChange = (1 - leadingZeros) * BASE_DIGITS[this.radix] + getInitialDigits(dataStorage) - big.getInitialDigits();
+                if (-scaleChange >= precision)
+                {
+                    // All significant digits were lost anyway, due to trailing garbage digits
+                    return zero();
+                }
+                precision += scaleChange;
+                precision = (precision <= 0 ? Apfloat.INFINITE : precision);    // Detect overflow
+            }
+        }
+
+        dataStorage.setReadOnly();
+
+        return new DoubleApfloatImpl(sign, precision, exponent, dataStorage, this.radix);
+    }
+
+    public ApfloatImpl multiply(ApfloatImpl x)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof DoubleApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        DoubleApfloatImpl that = (DoubleApfloatImpl) x;
+
+        if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot multiply numbers with different radixes: " + this.radix + " and " + that.radix);
+        }
+
+        int sign = this.sign * that.sign;
+
+        if (sign == 0)
+        {
+            return zero();
+        }
+
+        long exponent = this.exponent + that.exponent;
+
+        if (exponent > MAX_EXPONENT[this.radix])
+        {
+            throw new OverflowException("Overflow");
+        }
+        else if (exponent < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            return zero();
+        }
+
+        long precision = Math.min(this.precision, that.precision),
+             basePrecision = getBasePrecision(precision, 0),            // Round up
+             thisSize = getSize(),
+             thatSize = that.getSize(),
+             size = Math.min(Util.ifFinite(basePrecision, basePrecision + 1), thisSize + thatSize),     // Reserve one extra word for carry
+             thisDataSize = Math.min(thisSize, basePrecision),
+             thatDataSize = Math.min(thatSize, basePrecision);
+
+        DataStorage thisDataStorage = this.dataStorage.subsequence(0, thisDataSize),
+                    thatDataStorage = (this.dataStorage == that.dataStorage ?
+                                       thisDataStorage :                                                // Enable auto-convolution
+                                       that.dataStorage.subsequence(0, thatDataSize));
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        ConvolutionBuilder convolutionBuilder = ctx.getBuilderFactory().getConvolutionBuilder();
+        ConvolutionStrategy convolutionStrategy = convolutionBuilder.createConvolution(this.radix, thisDataSize, thatDataSize, size);
+
+        // Possibly sub-optimal: could look up trailing zeros of the subsequences
+        DataStorage dataStorage = convolutionStrategy.convolute(thisDataStorage, thatDataStorage, size);
+
+        // Check if carry occurred up to and including most significant word
+        int leadingZeros = (getMostSignificantWord(dataStorage) == 0 ? 1 : 0);
+
+        exponent -= leadingZeros;
+
+        if (exponent < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            return zero();
+        }
+
+        size -= leadingZeros;
+        dataStorage = dataStorage.subsequence(leadingZeros, size);
+
+        size = Math.min(size, getBasePrecision(precision, getInitialDigits(dataStorage)));
+        size -= getTrailingZeros(dataStorage, size);
+
+        dataStorage = dataStorage.subsequence(0, size);
+
+        dataStorage.setReadOnly();
+
+        return new DoubleApfloatImpl(sign, precision, exponent, dataStorage, this.radix);
+    }
+
+    public boolean isShort()
+        throws ApfloatRuntimeException
+    {
+        return (this.sign == 0 || getSize() == 1);
+    }
+
+    public ApfloatImpl divideShort(ApfloatImpl x)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof DoubleApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        DoubleApfloatImpl that = (DoubleApfloatImpl) x;
+
+        if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot divide numbers with different radixes: " + this.radix + " and " + that.radix);
+        }
+
+        assert (this.sign != 0);
+        assert (that.sign != 0);
+
+        int sign = this.sign * that.sign;
+
+        long exponent = this.exponent - that.exponent + 1;
+
+        if (exponent > MAX_EXPONENT[this.radix])
+        {
+            throw new OverflowException("Overflow");
+        }
+        else if (exponent < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            return zero();
+        }
+
+        long precision = Math.min(this.precision, that.precision),
+             basePrecision = getBasePrecision(),
+             thisDataSize = Math.min(getSize(), basePrecision);
+
+        DataStorage dataStorage;
+
+        double divisor = getMostSignificantWord(that.dataStorage);
+
+        if (divisor == (double) 1)
+        {
+            long size = thisDataSize - getTrailingZeros(this.dataStorage, thisDataSize);
+
+            dataStorage = this.dataStorage.subsequence(0, size);
+        }
+        else
+        {
+            ApfloatContext ctx = ApfloatContext.getContext();
+            AdditionBuilder<Double> additionBuilder = ctx.getBuilderFactory().getAdditionBuilder(Double.TYPE);
+            AdditionStrategy<Double> additionStrategy = additionBuilder.createAddition(this.radix);
+
+            long size;
+            double carry;
+
+            // Check for finite or infinite result sequence
+            double dividend = divisor;
+
+            // Check that the factorization of the divisor consists entirely of factors of the base
+            // E.g. if base is 10=2*5 then the divisor should be 2^n*5^m
+            for (int i = 0; i < RADIX_FACTORS[this.radix].length; i++)
+            {
+                double factor = RADIX_FACTORS[this.radix][i],
+                        quotient;
+
+                // Keep dividing by factor as long as dividend % factor == 0
+                // that is remove factors of the base from the divisor
+                while ((dividend - factor * (quotient = (double) (long) (dividend / factor))) == 0)
+                {
+                    dividend = quotient;
+                }
+            }
+
+            // Check if the divisor was factored all the way to one by just dividing by factors of the base
+            if (dividend != (double) 1)
+            {
+                // Divisor does not contain only factors of the base; infinite nonzero sequence
+
+                if (basePrecision == Apfloat.INFINITE)
+                {
+                    throw new InfiniteExpansionException("Cannot perform inexact division to infinite precision");
+                }
+
+                size = basePrecision;
+            }
+            else
+            {
+                // Divisor contains only factors of the base; calculate maximum sequence length
+                carry = (double) 1;
+                DataStorage.Iterator dummy = new DataStorage.Iterator()
+                {
+                    public void setDouble(double value) {}
+                    public void next() {}
+                    private static final long serialVersionUID = 1L;
+                };
+                long sequenceSize;
+                for (sequenceSize = 0; carry != 0; sequenceSize++)
+                {
+                    carry = additionStrategy.divide(null, divisor, carry, dummy, 1);
+                }
+
+                size = Math.min(basePrecision, thisDataSize + sequenceSize);
+            }
+
+            // One extra word for result in case the initial word becomes zero; to avoid loss of precision
+            size++;
+
+            dataStorage = createDataStorage(size);
+            dataStorage.setSize(size);
+
+            DataStorage.Iterator src = this.dataStorage.iterator(DataStorage.READ, 0, thisDataSize),
+                                 dst = dataStorage.iterator(DataStorage.WRITE, 0, size);
+
+            // Perform actual division
+            carry = additionStrategy.divide(src, divisor, (double) 0, dst, thisDataSize);
+
+            // Produce the trailing sequence of digits due to inexact division
+            carry = additionStrategy.divide(null, divisor, carry, dst, size - thisDataSize);
+
+            size -= getTrailingZeros(dataStorage, size);
+
+            // Check if initial word of result is zero
+            int leadingZeros = (getMostSignificantWord() < divisor ? 1 : 0);
+
+            dataStorage = dataStorage.subsequence(leadingZeros, size - leadingZeros);
+            exponent -= leadingZeros;
+
+            if (exponent < -MAX_EXPONENT[this.radix])
+            {
+                // Underflow
+                return zero();
+            }
+
+            dataStorage.setReadOnly();
+        }
+
+        return new DoubleApfloatImpl(sign, precision, exponent, dataStorage, this.radix);
+    }
+
+    public ApfloatImpl absFloor()
+        throws ApfloatRuntimeException
+    {
+        if (this.sign == 0 ||
+            this.exponent >= this.dataStorage.getSize())        // Is integer already, with no extra hidden trailing digits
+        {
+            return precision(Apfloat.INFINITE);
+        }
+        else if (this.exponent <= 0)                            // Is less than one in absolute value
+        {
+            return zero();
+        }
+
+        long size = this.exponent;                              // Size of integer part, now that this.dataStorage.getSize() > this.exponent
+        size -= getTrailingZeros(this.dataStorage, size);
+
+        DataStorage dataStorage = this.dataStorage.subsequence(0, size);
+
+        ApfloatImpl apfloatImpl = new DoubleApfloatImpl(this.sign, Apfloat.INFINITE, this.exponent, dataStorage, this.radix);
+
+        return apfloatImpl;
+    }
+
+    public ApfloatImpl absCeil()
+        throws ApfloatRuntimeException
+    {
+        if (this.sign == 0)
+        {
+            return this;
+        }
+
+        long exponent;
+        DataStorage dataStorage;
+        DataStorage.Iterator iterator = null;
+
+        if (this.exponent <= 0)
+        {
+            // Number is < 1 but > 0; result is one
+            int size = 1;
+            dataStorage = createDataStorage(size);
+            dataStorage.setSize(size);
+            ArrayAccess arrayAccess = dataStorage.getArray(DataStorage.WRITE, 0, size);
+            arrayAccess.getDoubleData()[arrayAccess.getOffset()] = (double) 1;
+            arrayAccess.close();
+
+            exponent = 1;
+        }
+        else if (getSize() <= this.exponent ||          // Check if the fractional part is nonzero
+                 findMismatch(iterator = getZeroPaddedIterator(this.exponent, getSize()), ZERO_ITERATOR, getSize() - this.exponent) < 0)
+        {
+            // Fractional part is zero; the result is the number itself (to infinite precision)
+            long size = Math.min(this.dataStorage.getSize(), this.exponent);
+            size -= getTrailingZeros(this.dataStorage, size);
+            dataStorage = this.dataStorage.subsequence(0, size);        // Ensure truncation
+
+            exponent = this.exponent;
+        }
+        else
+        {
+            // Fractional part is nonzero; round up
+
+            ApfloatContext ctx = ApfloatContext.getContext();
+            AdditionBuilder<Double> additionBuilder = ctx.getBuilderFactory().getAdditionBuilder(Double.TYPE);
+            AdditionStrategy<Double> additionStrategy = additionBuilder.createAddition(this.radix);
+
+            long size = this.exponent;                  // Size of integer part
+            dataStorage = createDataStorage(size + 1);     // Reserve room for carry overflow
+            dataStorage.setSize(size + 1);
+            DataStorage.Iterator src = this.dataStorage.iterator(DataStorage.READ, size, 0),
+                                 dst = dataStorage.iterator(DataStorage.WRITE, size + 1, 0);
+            double carry = additionStrategy.add(src, null, (double) 1, dst, size);     // Add carry
+            dst.setDouble(carry);                      // Set leading double as overflow carry
+            src.close();
+            dst.close();
+            int carrySize = (int) carry;                // For adjusting size, if carry did overflow or not
+            size -= getTrailingZeros(dataStorage, size + 1);
+            dataStorage = dataStorage.subsequence(1 - carrySize, size + carrySize);
+
+            exponent = this.exponent + carrySize;
+        }
+
+        if (iterator != null)
+        {
+            iterator.close();
+        }
+
+        dataStorage.setReadOnly();
+
+        ApfloatImpl apfloatImpl = new DoubleApfloatImpl(this.sign, Apfloat.INFINITE, exponent, dataStorage, this.radix);
+
+        return apfloatImpl;
+    }
+
+    public ApfloatImpl frac()
+        throws ApfloatRuntimeException
+    {
+        if (this.sign == 0 ||
+            this.exponent <= 0)                                 // Is less than one in absolute value already
+        {
+            return this;
+        }
+        if (this.exponent >= getSize())                         // Is an integer, fractional part is zero
+        {
+            return zero();
+        }
+
+        long size = this.dataStorage.getSize() - this.exponent; // Size of fractional part, now that getSize() > this.exponent
+        long leadingZeros = getLeadingZeros(this.dataStorage, this.exponent);
+        if (this.exponent + leadingZeros >= getSize())
+        {
+            // All significant digits were lost, only trailing garbage digits
+            return zero();
+        }
+
+        DataStorage dataStorage = this.dataStorage.subsequence(this.exponent + leadingZeros, size - leadingZeros);
+
+        long precision;
+        if (this.precision != Apfloat.INFINITE)
+        {
+            // Precision is reduced as the integer part is omitted, plus any leading zeros
+            precision = this.precision - getInitialDigits() - (this.exponent + leadingZeros) * BASE_DIGITS[this.radix] + getInitialDigits(dataStorage);
+            if (precision <= 0)
+            {
+                // All significant digits were lost anyway, only trailing garbage digits
+                return zero();
+            }
+        }
+        else
+        {
+            precision = Apfloat.INFINITE;
+        }
+
+        long exponent = -leadingZeros;
+
+        ApfloatImpl apfloatImpl = new DoubleApfloatImpl(this.sign, precision, exponent, dataStorage, this.radix);
+
+        return apfloatImpl;
+    }
+
+    private ApfloatImpl zero()
+    {
+        return new DoubleApfloatImpl(0, Apfloat.INFINITE, 0, null, this.radix);
+    }
+
+    public int radix()
+    {
+        return this.radix;
+    }
+
+    public long precision()
+    {
+        return this.precision;
+    }
+
+    public long size()
+        throws ApfloatRuntimeException
+    {
+        assert (this.dataStorage != null);
+
+        if (this.size == 0)
+        {
+            // Writes and reads of volatile long values are always atomic so multiple threads can read and write this at the same time
+            this.size = getInitialDigits() + (getSize() - 1) * BASE_DIGITS[this.radix] - getLeastZeros();
+        }
+
+        return this.size;
+    }
+
+    // Get number of trailing zeros
+    private long getLeastZeros()
+        throws ApfloatRuntimeException
+    {
+        if (this.leastZeros == UNDEFINED)
+        {
+            // Cache the value
+            // NOTE: This is not synchronized; it's OK if multiple threads set this at the same time
+            // Writes and reads of volatile long values are always atomic so multiple threads can read and write this at the same time
+            long index = getSize() - 1;
+            double word = getWord(index);
+            word = getLeastSignificantWord(index, word);
+
+            long leastZeros = 0;
+            if (word == 0)
+            {
+                // Usually the last word is nonzero but in case precision was later changed, it might be zero
+                long trailingZeros = getTrailingZeros(this.dataStorage, index) + 1;
+                index -= trailingZeros;
+                word = getWord(index);
+                word = getLeastSignificantWord(index, word);
+
+                leastZeros += trailingZeros * BASE_DIGITS[this.radix];
+            }
+
+            assert (word != 0);
+
+            while (word % this.radix == 0)
+            {
+                leastZeros++;
+                word /= this.radix;
+            }
+            this.leastZeros = leastZeros;
+        }
+
+        return this.leastZeros;
+    }
+
+    public ApfloatImpl precision(long precision)
+    {
+        if (this.sign == 0 || precision == this.precision)
+        {
+            return this;
+        }
+        else
+        {
+            return new DoubleApfloatImpl(this.sign, precision, this.exponent, this.dataStorage, this.radix);
+        }
+    }
+
+    public long scale()
+        throws ApfloatRuntimeException
+    {
+        assert (this.dataStorage != null);
+
+        return (this.exponent - 1) * BASE_DIGITS[this.radix] + getInitialDigits();
+    }
+
+    public int signum()
+    {
+        return this.sign;
+    }
+
+    public ApfloatImpl negate()
+        throws ApfloatRuntimeException
+    {
+        return new DoubleApfloatImpl(-this.sign, this.precision, this.exponent, this.dataStorage, this.radix);
+    }
+
+    public double doubleValue()
+    {
+        if (this.sign == 0)
+        {
+            return 0.0;
+        }
+
+        double value = 0.0,
+               doubleBase = (double) BASE[this.radix];
+
+        int size = (int) Math.min(MAX_DOUBLE_SIZE, getSize());
+
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.READ, size, 0);
+
+        while (iterator.hasNext())
+        {
+            value += (double) iterator.getDouble();
+            value /= doubleBase;
+            iterator.next();
+        }
+
+        // If the end result fits in a double, any intermediate calculation must not overflow
+        // Note that 1/BASE <= value < 1
+        if (this.exponent > 0)
+        {
+            return this.sign * value * Math.pow((double) BASE[this.radix], (double) (this.exponent - 1)) * BASE[this.radix];
+        }
+        else
+        {
+            return this.sign * value * Math.pow((double) BASE[this.radix], (double) this.exponent);
+        }
+    }
+
+    public long longValue()
+    {
+        if (this.sign == 0 || this.exponent <= 0)
+        {
+            return 0;
+        }
+        else if (this.exponent > MAX_LONG_SIZE)
+        {
+            // Overflow for sure
+            return (this.sign > 0 ? Long.MAX_VALUE : Long.MIN_VALUE);
+        }
+
+        long value = 0,
+             longBase = (long) BASE[this.radix],
+             maxPrevious = Long.MIN_VALUE / longBase;
+
+        // Number of words in integer part of the number
+        int size = (int) Math.min(this.exponent, getSize());
+
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.READ, 0, size);
+
+        for (int i = 0; i < (int) this.exponent; i++)
+        {
+            if (value < maxPrevious)
+            {
+                // Overflow
+                value = 0;
+                iterator.close();
+                break;
+            }
+            value *= longBase;
+            if (i < size)
+            {
+                value -= (long) iterator.getDouble();      // Calculate value negated to handle 0x8000000000000000
+                iterator.next();
+            }
+        }
+
+        if (value == Long.MIN_VALUE || value >= 0)
+        {
+            // Overflow
+            return (this.sign > 0 ? Long.MAX_VALUE : Long.MIN_VALUE);
+        }
+        else
+        {
+            return -this.sign * value;
+        }
+    }
+
+    // If this ApfloatImpl is equal to 1
+    public boolean isOne()
+        throws ApfloatRuntimeException
+    {
+        if (this.isOne == UNDEFINED)
+        {
+            // Cache the value
+            // NOTE: This is not synchronized; it's OK if multiple threads set this at the same time
+            this.isOne = (this.sign == 1 && this.exponent == 1 && getSize() == 1 && getMostSignificantWord() == (double) 1 ? 1 : 0);
+        }
+
+        return (this.isOne == 1);
+    }
+
+    public long equalDigits(ApfloatImpl x)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof DoubleApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        DoubleApfloatImpl that = (DoubleApfloatImpl) x;
+
+        if (this.sign == 0 && that.sign == 0)           // Both are zero
+        {
+            return Apfloat.INFINITE;
+        }
+        else if (this.sign != that.sign)                // No match
+        {
+            return 0;
+        }
+        else if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot compare values with different radixes: " + this.radix + " and " + that.radix);
+        }
+
+        long thisScale = scale(),
+             thatScale = that.scale(),
+             minScale = Math.min(thisScale, thatScale),
+             maxScale = Math.max(thisScale, thatScale);
+
+        if (maxScale - 1 > minScale)                    // No match
+        {
+            return 0;
+        }
+
+        // Need to compare mantissas
+        long thisSize = getSize(),
+             thatSize = that.getSize(),
+             size = Math.max(thisSize, thatSize);
+        DataStorage.Iterator thisIterator = getZeroPaddedIterator(0, thisSize),
+                             thatIterator = that.getZeroPaddedIterator(0, thatSize);
+
+        long index,
+             result = Math.min(this.precision, that.precision);         // If mantissas are identical
+        int lastMatchingDigits = -1;                                    // Will be used for deferred comparison hanging in last word, e.g. this = 1.000000000, that = 0.999999999
+        double carry,
+                base = BASE[this.radix];
+
+        if (this.exponent > that.exponent)
+        {
+            // Possible case this = 1.0000000, that = 0.9999999
+            double value = thisIterator.getDouble();                  // Check first word
+
+            if (value != (double) 1)
+            {
+                // No match
+                thisIterator.close();
+                thatIterator.close();
+
+                return 0;
+            }
+
+            carry = base;
+            thisIterator.next();
+        }
+        else if (this.exponent < that.exponent)
+        {
+            // Possible case this = 0.9999999, that = 1.0000000
+            double value = thatIterator.getDouble();                  // Check first word
+
+            if (value != (double) 1)
+            {
+                // No match
+                thisIterator.close();
+                thatIterator.close();
+
+                return 0;
+            }
+
+            carry = -base;
+            thatIterator.next();
+        }
+        else
+        {
+            // Trivial case, e.g. this = 111234, that = 111567
+            carry = 0;
+        }
+
+        // Calculate this - that, stopping at first difference
+        for (index = 0; index < size; index++)
+        {
+            double value = thisIterator.getDouble() - thatIterator.getDouble() + carry;
+
+            if (value == 0)
+            {
+                // Trivial case; words are equal
+                carry = 0;
+            }
+            else if (Math.abs(value) > (double) 1)
+            {
+                // Mismatch found
+                if (Math.abs(value) >= base)
+                {
+                    // Deferred comparison, e.g. this = 1.0000000002, that = 0.9999999991
+                    lastMatchingDigits = -1;
+                }
+                else
+                {
+                    // Any trivial cases and e.g. this = 1.0000000001, that = 0.9999999992
+                    lastMatchingDigits = BASE_DIGITS[this.radix] - getDigits(Math.abs(value));
+                }
+
+                break;
+            }
+            else if (value == (double) 1)
+            {
+                // Case this = 1.0000000..., that = 0.9999999...
+                carry = base;
+            }
+            else if (value == (double) -1)
+            {
+                // Case this = 0.9999999..., that = 1.0000000...
+                carry = -base;
+            }
+
+            thisIterator.next();
+            thatIterator.next();
+        }
+
+        if (index < size || carry != 0)                 // Mismatch found
+        {
+            long initialMatchingDigits = (this.exponent == that.exponent ?
+                                          Math.min(getInitialDigits(), that.getInitialDigits()) :       // Normal case, e.g. this = 10, that = 5
+                                          BASE_DIGITS[this.radix]);                                     // Special case, e.g. this = 1.0, that = 0.9
+
+            // Note that this works even if index == 0
+            long middleMatchingDigits = (index - 1) * BASE_DIGITS[this.radix];                          // This is correct even if exponents are different
+
+            // Limit by available precision
+            result = Math.min(result, initialMatchingDigits + middleMatchingDigits + lastMatchingDigits);
+
+            // Handle some cases e.g. 0.15 vs. 0.04
+            result = Math.max(result, 0);
+        }
+
+        thisIterator.close();
+        thatIterator.close();
+
+        return result;
+    }
+
+    public int compareTo(ApfloatImpl x)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof DoubleApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        DoubleApfloatImpl that = (DoubleApfloatImpl) x;
+
+        if (this.sign == 0 && that.sign == 0)
+        {
+            return 0;
+        }
+        else if (this.sign < that.sign)                 // Now we know that not both are zero
+        {
+            return -1;
+        }
+        else if (this.sign > that.sign)
+        {
+            return 1;
+        }
+        else if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot compare values with different radixes: " + this.radix + " and " + that.radix);
+        }
+        else if (scale() < that.scale())                // Now we know that both have same sign (which is not zero)
+        {
+            return -this.sign;
+        }
+        else if (scale() > that.scale())
+        {
+            return this.sign;
+        }
+
+        // Need to compare mantissas
+        return this.sign * compareMantissaTo(that);
+    }
+
+    // Returns an iterator for this number's data storage from start to end,
+    // least significant word is correctly truncated with getLeastSignificantWord(),
+    // after that the iterator returns zeros only
+    private DataStorage.Iterator getZeroPaddedIterator(final long start, final long end)
+        throws ApfloatRuntimeException
+    {
+        final DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.READ, start, end);
+
+        return new DataStorage.Iterator()
+        {
+            public double getDouble()
+                throws ApfloatRuntimeException
+            {
+                double value;
+
+                if (this.index < end)
+                {
+                    value = iterator.getDouble();
+                    if (this.index == end - 1)
+                    {
+                        value = getLeastSignificantWord(this.index, value);
+                    }
+                }
+                else
+                {
+                    value = 0;
+                }
+
+                return value;
+            }
+
+            public void next()
+                throws ApfloatRuntimeException
+            {
+                if (this.index < end)
+                {
+                    iterator.next();
+                    this.index++;
+                }
+            }
+
+            public void close()
+                throws ApfloatRuntimeException
+            {
+                iterator.close();
+            }
+
+            private static final long serialVersionUID = 1L;
+
+            private long index = start;
+        };
+    }
+
+    // Compare absolute values of mantissas
+    private int compareMantissaTo(DoubleApfloatImpl that)
+        throws ApfloatRuntimeException
+    {
+        long thisSize = getSize(),
+             thatSize = that.getSize(),
+             size = Math.max(thisSize, thatSize);
+        DataStorage.Iterator thisIterator = getZeroPaddedIterator(0, thisSize),
+                             thatIterator = that.getZeroPaddedIterator(0, thatSize);
+        int result = 0;
+
+        long index = findMismatch(thisIterator, thatIterator, size);
+
+        if (index >= 0)                 // Mismatch found
+        {
+            double thisValue = thisIterator.getDouble(),
+                    thatValue = thatIterator.getDouble();
+
+            if (thisValue < thatValue)
+            {
+                result = -1;
+            }
+            else if (thisValue > thatValue)
+            {
+                result = 1;
+            }
+        }
+
+        thisIterator.close();
+        thatIterator.close();
+
+        return result;
+    }
+
+    // Returns index of first mismatching double, or -1 if mantissas are equal
+    // Iterators are left to point to the mismatching words
+    private long findMismatch(DataStorage.Iterator thisIterator, DataStorage.Iterator thatIterator, long size)
+        throws ApfloatRuntimeException
+    {
+        for (long index = 0; index < size; index++)
+        {
+            double thisValue = thisIterator.getDouble(),
+                    thatValue = thatIterator.getDouble();
+
+            if (thisValue != thatValue)
+            {
+                return index;
+            }
+
+            thisIterator.next();
+            thatIterator.next();
+        }
+
+        // All searched words matched exactly
+        return -1;
+    }
+
+    // Truncate insignificant digits from the last double of the number
+    private double getLeastSignificantWord(long index, double word)
+        throws ApfloatRuntimeException
+    {
+        if (this.precision == Apfloat.INFINITE)
+        {
+            return word;
+        }
+
+        // Total digits including the specified index
+        long digits = getInitialDigits() + index * BASE_DIGITS[this.radix];
+
+        if (this.precision >= digits)
+        {
+            return word;
+        }
+
+        // Assert that the second array access will not be out of bounds
+        double divisor = MINIMUM_FOR_DIGITS[this.radix][(int) (digits - this.precision)];
+
+        return (double) (long) (word / divisor) * divisor;
+    }
+
+    /**
+     * Compares this object to the specified object.
+     *
+     * @param obj The object to compare with.
+     *
+     * @return <code>true</code> if the objects are equal; <code>false</code> otherwise.
+     */
+
+    public boolean equals(Object obj)
+    {
+        if (!(obj instanceof ApfloatImpl))
+        {
+            return false;
+        }
+
+        ApfloatImpl thatImpl = (ApfloatImpl) obj;
+
+        // Special comparisons against Apfloat.ZERO and Apfloat.ONE work regardless of radix or implementation class
+        if (signum() == 0 && thatImpl.signum() == 0)
+        {
+            return true;
+        }
+        else if (isOne() && thatImpl.isOne())
+        {
+            return true;
+        }
+
+        if (!(obj instanceof DoubleApfloatImpl))
+        {
+            return false;
+        }
+
+        DoubleApfloatImpl that = (DoubleApfloatImpl) obj;
+
+        if (this.radix != that.radix)
+        {
+            // Limitation: cannot compare values with different radixes
+            return false;
+        }
+        else if (this.sign != that.sign ||
+                 this.exponent != that.exponent)
+        {
+            return false;
+        }
+        else
+        {
+            // Need to compare mantissas
+            return compareMantissaTo(that) == 0;
+        }
+    }
+
+    public int hashCode()
+    {
+        if (this.hashCode == 0)
+        {
+            // Cache the value
+            // NOTE: This is not synchronized; it's OK if multiple threads set this at the same time
+            int hashCode = 1 + this.sign + (int) this.exponent + (int) (this.exponent >>> 32);
+
+            if (this.dataStorage != null)
+            {
+                long size = getSize();
+
+                // Scan through log(size) scattered words in the mantissa
+                for (long i = 0; i < size; i = i + i + 1)
+                {
+                    double word = getWord(i);
+
+                    if (i == size - 1)
+                    {
+                        word = getLeastSignificantWord(i, word);
+                    }
+
+                    long element = (long) word;
+                    hashCode += (int) element + (int) (element >>> 32);
+                }
+            }
+
+            this.hashCode = hashCode;
+        }
+
+        return this.hashCode;
+    }
+
+    public String toString(boolean pretty)
+        throws ApfloatRuntimeException
+    {
+        if (this.sign == 0)
+        {
+            return "0";
+        }
+
+        long size = getSize() * BASE_DIGITS[this.radix],    // This is a rounded up value
+             length;
+        if (pretty)
+        {
+             long scale = scale();
+             if (scale <= 0)
+             {
+                 length = 2 - scale + size;         // Format is 0.xxxx or 0.0000xxx
+             }
+             else if (size > scale)
+             {
+                 length = 1 + size;                 // Format is x.xxx
+             }
+             else
+             {
+                 length = scale;                    // Format is xxxx or xxxx0000
+             }
+             length += (this.sign < 0 ? 1 : 0);     // Room for minus sign
+        }
+        else
+        {
+            length = size + 24;     // Sign, "0.", "e", exponent sign and 19 digits of exponent
+        }
+
+        if (length > Integer.MAX_VALUE || length < 0)           // Detect overflow
+        {
+            throw new ApfloatInternalException("Number is too large to fit in a String");
+        }
+
+        StringWriter writer = new StringWriter((int) length);
+
+        try
+        {
+            writeTo(writer, pretty);
+        }
+        catch (IOException ioe)
+        {
+            throw new ApfloatInternalException("Unexpected I/O error writing to StringWriter", ioe);
+        }
+
+        String value = writer.toString();
+
+        assert (value.length() <= length);      // Postcondition to ensure performance
+
+        return value;
+    }
+
+    private static void writeZeros(Writer out, long count)
+        throws IOException
+    {
+        for (long i = 0; i < count; i++)
+        {
+            out.write('0');
+        }
+    }
+
+    public void writeTo(Writer out, boolean pretty)
+        throws IOException, ApfloatRuntimeException
+    {
+        if (this.sign == 0)
+        {
+            out.write('0');
+            return;
+        }
+
+        if (this.sign < 0)
+        {
+            out.write('-');
+        }
+
+        long integerDigits,                 // Number of digits to write before the decimal point
+             exponent;                      // Exponent to print
+
+        if (pretty)
+        {
+            if (this.exponent <= 0)
+            {
+                out.write("0.");            // Output is 0.xxxx
+                writeZeros(out, -scale());  // Print leading zeros after decimal point before first nonzero digit
+                integerDigits = -1;         // Decimal point is already written
+            }
+            else
+            {
+                integerDigits = scale();    // Decimal point location
+            }
+            exponent = 0;                   // Do not print exponent
+        }
+        else
+        {
+            integerDigits = 1;              // Always write as x.xxxey
+            exponent = scale() - 1;         // Print exponent
+        }
+
+        boolean leftPadZeros = false;       // If the written base unit should be left-padded with zeros
+        long size = getSize(),
+             digitsToWrite = Math.min(this.precision, getInitialDigits() + (size - 1) * BASE_DIGITS[this.radix]),
+             digitsWritten = 0,
+             trailingZeros = 0;
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.READ, 0, size);
+        char[] buffer = new char[BASE_DIGITS[this.radix]];
+
+        while (size > 0)
+        {
+            int start = (leftPadZeros ? 0 : BASE_DIGITS[this.radix] - getInitialDigits()),
+                digits = (int) Math.min(digitsToWrite, BASE_DIGITS[this.radix] - start);
+
+            formatWord(buffer, iterator.getDouble());
+
+            for (int i = 0; i < digits; i++)
+            {
+                int c = buffer[start + i];
+                if (c == '0')
+                {
+                    trailingZeros++;
+                    digitsToWrite--;
+                }
+                else
+                {
+                    while (trailingZeros > 0)
+                    {
+                        if (digitsWritten == integerDigits)
+                        {
+                            out.write('.');
+                        }
+                        out.write('0');
+                        digitsWritten++;
+                        trailingZeros--;
+                    }
+                    if (digitsWritten == integerDigits)
+                    {
+                        out.write('.');
+                    }
+                    out.write(c);
+                    digitsWritten++;
+                    digitsToWrite--;
+                }
+            }
+            leftPadZeros = true;                        // Always pad with zeros after first word
+
+            iterator.next();
+            size--;
+        }
+
+        if (!pretty && exponent != 0)
+        {
+            out.write("e" + exponent);
+        }
+
+        writeZeros(out, integerDigits - digitsWritten); // If format is xxxx0000
+    }
+
+    private void formatWord(char[] buffer, double word)
+    {
+        int position = BASE_DIGITS[this.radix];
+        while (position > 0 && word > 0)
+        {
+            double newWord = (double) (long) (word / this.radix);
+            int digit = (int) (word -  newWord * this.radix);
+            word = newWord;
+            position--;
+            buffer[position] = Character.forDigit(digit, this.radix);
+        }
+
+        // Left pad zeros
+        while (position > 0)
+        {
+            position--;
+            buffer[position] = '0';
+        }
+    }
+
+    // Effective size, in doubles
+    private long getSize()
+        throws ApfloatRuntimeException
+    {
+        assert (this.dataStorage != null);
+
+        return Math.min(getBasePrecision(),
+                        this.dataStorage.getSize());
+    }
+
+    private static int checkRadix(int radix)
+        throws NumberFormatException
+    {
+        if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)
+        {
+            throw new NumberFormatException("Invalid radix " + radix + "; radix must be between " + Character.MIN_RADIX + " and " + Character.MAX_RADIX);
+        }
+
+        return radix;
+    }
+
+    // Get the most significant word of this number
+    private double getMostSignificantWord()
+        throws ApfloatRuntimeException
+    {
+        return getMostSignificantWord(this.dataStorage);
+    }
+
+    // Get the most significant word of the specified data storage
+    private static double getMostSignificantWord(DataStorage dataStorage)
+        throws ApfloatRuntimeException
+    {
+        double msw;
+
+        ArrayAccess arrayAccess = dataStorage.getArray(DataStorage.READ, 0, 1);
+        msw = arrayAccess.getDoubleData()[arrayAccess.getOffset()];
+        arrayAccess.close();
+
+        return msw;
+    }
+
+    // Get number of digits in the most significant word
+    private int getInitialDigits()
+        throws ApfloatRuntimeException
+    {
+        if (this.initialDigits == UNDEFINED)
+        {
+            // Cache the value
+            // NOTE: This is not synchronized; it's OK if multiple threads set this at the same time
+            this.initialDigits = getDigits(getMostSignificantWord());
+        }
+
+        return this.initialDigits;
+    }
+
+    // Get number of digits in the most significant word of specified data
+    private int getInitialDigits(DataStorage dataStorage)
+        throws ApfloatRuntimeException
+    {
+        return getDigits(getMostSignificantWord(dataStorage));
+    }
+
+    // Gets the number of digits in the specified double and this number's radix
+    private int getDigits(double x)
+    {
+        assert (x > 0);
+
+        double[] minimums = MINIMUM_FOR_DIGITS[this.radix];
+        int i = minimums.length;
+
+        while (x < minimums[--i])
+        {
+        }
+
+        return i + 1;
+    }
+
+    // Gets the precision in doubles
+    private long getBasePrecision()
+        throws ApfloatRuntimeException
+    {
+        return getBasePrecision(this.precision, getInitialDigits());
+    }
+
+    // Gets the precision in doubles, based on specified precision (in digits),
+    // number of digits in most significant word and this number's radix
+    private long getBasePrecision(long precision, int mswDigits)
+    {
+        if (precision == Apfloat.INFINITE)
+        {
+            return Apfloat.INFINITE;
+        }
+        else
+        {
+            return (precision + BASE_DIGITS[this.radix] - mswDigits - 1) / BASE_DIGITS[this.radix] + 1;
+        }
+    }
+
+    private double getWord(long index)
+    {
+        ArrayAccess arrayAccess = this.dataStorage.getArray(DataStorage.READ, index, 1);
+        double word = arrayAccess.getDoubleData()[arrayAccess.getOffset()];
+        arrayAccess.close();
+
+        return word;
+    }
+
+    private void readObject(ObjectInputStream in)
+        throws IOException, ClassNotFoundException
+    {
+        this.leastZeros = UNDEFINED;
+        this.isOne = UNDEFINED;
+        in.defaultReadObject();
+    }
+
+    // Gets a new data storage for specified size
+    private static DataStorage createDataStorage(long size)
+        throws ApfloatRuntimeException
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        return dataStorageBuilder.createDataStorage(size * 8);
+    }
+
+    // Gets I/O block size in doubles
+    private static int getBlockSize()
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        return ctx.getBlockSize() / 8;
+    }
+
+    private static final DataStorage.Iterator ZERO_ITERATOR =
+    new DataStorage.Iterator()
+    {
+        public double getDouble() { return 0; }
+        public void next() { }
+        private static final long serialVersionUID = 1L;
+    };
+
+    private static final long serialVersionUID = -4177541592360478544L;
+
+    private static final int UNDEFINED = 0x80000000;
+    private static final int MAX_LONG_SIZE = 4;
+    private static final int MAX_DOUBLE_SIZE = 4;
+
+    private int sign;
+    private long precision;
+    private long exponent;
+    private DataStorage dataStorage;
+    private int radix;
+    private int hashCode = 0;
+    private int initialDigits = UNDEFINED;
+    private int isOne = UNDEFINED;
+    private volatile long leastZeros = UNDEFINED;
+    private volatile long size = 0;
+}
Index: src/main/java/org/apfloat/internal/DoubleBaseMath.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleBaseMath.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleBaseMath.java	(revision 0)
@@ -0,0 +1,227 @@
+package org.apfloat.internal;
+
+import java.io.Serializable;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+import static org.apfloat.internal.DoubleRadixConstants.*;
+
+/**
+ * Mathematical operations on numbers in a base.
+ * Implementation for the <code>double</code> type.
+ *
+ * @version 1.8.2
+ * @author Mikko Tommila
+ */
+
+public class DoubleBaseMath
+    implements Serializable
+{
+    /**
+     * Creates a base math using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public DoubleBaseMath(int radix)
+    {
+        this.radix = radix;
+        this.inverseBase = 1.0 / BASE[radix];
+    }
+
+    /**
+     * Addition in some base. Adds the data words
+     * of <code>src1</code> and <code>src2</code> and stores the result to
+     * <code>dst</code>. <code>src2</code> may be <code>null</code>, in
+     * which case it is ignored (only the carry is propagated).<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] + src2[i]</code>.
+     *
+     * @param src1 First source data sequence. Can be <code>null</code>, in which case it's ignored.
+     * @param src2 Second source data sequence. Can be <code>null</code>, in which case it's ignored.
+     * @param carry Input carry bit. This is added to the first (rightmost) word in the accessed sequence.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Overflow carry bit. Propagated carry bit from the addition of the last (leftmost) word in the accessed sequence.
+     */
+
+    public double baseAdd(DataStorage.Iterator src1, DataStorage.Iterator src2, double carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (src1 == null || src1 != src2);
+
+        boolean sameDst = (src1 == dst || src2 == dst);
+        double base = BASE[this.radix];
+
+        for (long i = 0; i < size; i++)
+        {
+            double result = (src1 == null ? 0 : src1.getDouble()) + carry +
+                            (src2 == null ? 0 : src2.getDouble());
+
+            carry = (result >= base ? 1 : 0);
+            result -= (result >= base ? base : 0);
+
+            dst.setDouble(result);
+
+            if (src1 != null) src1.next();
+            if (src2 != null) src2.next();
+            if (!sameDst) dst.next();
+        }
+
+        return carry;
+    }
+
+    /**
+     * Subtraction in some base. Subtracts the data words
+     * of <code>src1</code> and <code>src2</code> and stores the result to
+     * <code>dst</code>. <code>src1</code> and <code>src2</code> may be
+     * <code>null</code>, in which case they are ignored (the values are assumed
+     * to be zero and only the carry is propagated).<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] - src2[i]</code>.
+     *
+     * @param src1 First source data sequence. Can be <code>null</code>, in which case the input values are assumed to be zero.
+     * @param src2 Second source data sequence. Can be <code>null</code>, in which case it's ignored, or can be the same as <code>dst</code>.
+     * @param carry Input carry bit. This is subtracted from the first (rightmost) word in the accessed sequence.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Overflow carry bit. Propagated carry bit from the subtraction of the last (leftmost) word in the accessed sequence. The value is <code>1</code> if the carry is set, and <code>0</code> otherwise.
+     */
+
+    public double baseSubtract(DataStorage.Iterator src1, DataStorage.Iterator src2, double carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (src1 == null || src1 != src2);
+        assert (src2 != dst);
+
+        double base = BASE[this.radix];
+
+        for (long i = 0; i < size; i++)
+        {
+            double result = (src1 == null ? 0 : src1.getDouble()) - carry -
+                            (src2 == null ? 0 : src2.getDouble());
+
+            carry = (result < 0 ? 1 : 0);
+            result += (result < 0 ? base : 0);
+
+            dst.setDouble(result);
+
+            if (src1 != null && src1 != dst) src1.next();
+            if (src2 != null) src2.next();
+            dst.next();
+        }
+
+        return carry;
+    }
+
+    /**
+     * Multiplication and addition in some base. Multiplies the data words
+     * of <code>src1</code> by <code>src3</code> and adds the result to the
+     * words in <code>src2</code>, and stores the result to <code>dst</code>.
+     * <code>src2</code> may be <code>null</code>, in which case it is ignored
+     * (the values are assumed to be zero).<p>
+     *
+     * Assumes that the result from the addition doesn't overflow the upper
+     * result word (to larger than the base). This is the case e.g. when using
+     * this method to perform an arbitrary precision multiplication.<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] * src3 + src2[i]</code>.
+     *
+     * @param src1 First source data sequence.
+     * @param src2 Second source data sequence. Can be <code>null</code>, in which case it's ignored, or can be the same as <code>dst</code>.
+     * @param src3 Multiplicand. All elements of <code>src1</code> are multiplied by this value.
+     * @param carry Input carry word. This is added to the first (rightmost) word in the accessed sequence.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Overflow carry word. Propagated carry word from the multiplication and addition of the last (leftmost) word in the accessed sequence.
+     */
+
+    public double baseMultiplyAdd(DataStorage.Iterator src1, DataStorage.Iterator src2, double src3, double carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (src1 != src2);
+        assert (src1 != dst);
+
+        double base = BASE[this.radix];
+
+        for (long i = 0; i < size; i++)
+        {
+            double a = src1.getDouble(),
+                   b = src3;
+            carry += (src2 == null ? 0 : src2.getDouble());
+            long tmp = (long) a * (long) b + (long) carry;
+            carry = (double) (long) ((a * b + carry) * this.inverseBase);
+            double result = (double) (tmp - (long) carry * (long) base);
+
+            carry += (result >= base ? 1 : 0);
+            result -= (result >= base ? base : 0);
+
+            carry -= (result < 0 ? 1 : 0);
+            result += (result < 0 ? base : 0);
+
+            dst.setDouble(result);                      // = a * b % base
+
+            src1.next();
+            if (src2 != null && src2 != dst) src2.next();
+            dst.next();
+        }
+
+        return carry;
+    }
+
+    /**
+     * Division in some base. Divides the data words
+     * of <code>src1</code> by <code>src2</code> and stores the result to
+     * <code>dst</code>. <code>src1</code> may be <code>null</code>,
+     * in which case it is ignored (the values are assumed to be
+     * zero and only the carry division is propagated).<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] / src2</code>.
+     *
+     * @param src1 First source data sequence. Can be <code>null</code>, in which case the input values are assumed to be zero.
+     * @param src2 Divisor. All elements of <code>src1</code> are divided by this value.
+     * @param carry Input carry word. Used as the upper word for the division of the first input element. This should be the remainder word returned from the previous block processed.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Remainder word of the propagated division of the last (rightmost) word in the accessed sequence.
+     */
+
+    public double baseDivide(DataStorage.Iterator src1, double src2, double carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (src1 != dst);
+
+        double base = BASE[this.radix],
+               inverseDivisor = 1.0 / src2;
+
+        for (long i = 0; i < size; i++)
+        {
+            double a = (src1 == null ? 0 : src1.getDouble());
+            long tmp = (long) carry * (long) base + (long) a;
+            double result = (double) (long) ((carry * base + a) * inverseDivisor);
+            carry = (double) (tmp - (long) result * (long) src2);
+
+            result += (carry >= src2 ? 1 : 0);
+            carry -= (carry >= src2 ? src2 : 0);
+
+            result -= (carry < 0 ? 1 : 0);
+            carry += (carry < 0 ? src2 : 0);
+
+            dst.setDouble(result);                      // = carry * base % src2
+
+            if (src1 != null) src1.next();
+            dst.next();
+        }
+
+        return carry;
+    }
+
+    private static final long serialVersionUID = 4560898425815362356L;
+
+    private int radix;
+    private double inverseBase;
+}
Index: src/main/java/org/apfloat/internal/DoubleBuilderFactory.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleBuilderFactory.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleBuilderFactory.java	(revision 0)
@@ -0,0 +1,119 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+
+import org.apfloat.spi.AdditionBuilder;
+import org.apfloat.spi.BuilderFactory;
+import org.apfloat.spi.ApfloatBuilder;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.ConvolutionBuilder;
+import org.apfloat.spi.NTTBuilder;
+import org.apfloat.spi.MatrixBuilder;
+import org.apfloat.spi.CarryCRTBuilder;
+
+/**
+ * Factory class for getting instances of the various builder classes needed
+ * to build an <code>ApfloatImpl</code> with the <code>double</code> data element type.
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleBuilderFactory
+    implements BuilderFactory
+{
+    /**
+     * Default constructor.
+     */
+
+    public DoubleBuilderFactory()
+    {
+    }
+
+    public ApfloatBuilder getApfloatBuilder()
+    {
+        return DoubleBuilderFactory.apfloatBuilder;
+    }
+
+    public DataStorageBuilder getDataStorageBuilder()
+    {
+        return DoubleBuilderFactory.dataStorageBuilder;
+    }
+
+    public <T> AdditionBuilder<T> getAdditionBuilder(Class<T> elementType)
+        throws IllegalArgumentException
+    {
+        if (!Double.TYPE.equals(elementType))
+        {
+           throw new IllegalArgumentException("Unsupported element type: " + elementType);
+        }
+        @SuppressWarnings("unchecked")
+        AdditionBuilder<T> additionBuilder = (AdditionBuilder<T>) DoubleBuilderFactory.additionBuilder;
+        return additionBuilder;
+    }
+
+    public ConvolutionBuilder getConvolutionBuilder()
+    {
+        return DoubleBuilderFactory.convolutionBuilder;
+    }
+
+    public NTTBuilder getNTTBuilder()
+    {
+        return DoubleBuilderFactory.nttBuilder;
+    }
+
+    public MatrixBuilder getMatrixBuilder()
+    {
+        return DoubleBuilderFactory.matrixBuilder;
+    }
+
+    public <T> CarryCRTBuilder<T> getCarryCRTBuilder(Class<T> elementArrayType)
+        throws IllegalArgumentException
+    {
+        if (!double[].class.equals(elementArrayType))
+        {
+           throw new IllegalArgumentException("Unsupported element array type: " + elementArrayType);
+        }
+        @SuppressWarnings("unchecked")
+        CarryCRTBuilder<T> carryCRTBuilder = (CarryCRTBuilder<T>) DoubleBuilderFactory.carryCRTBuilder;
+        return carryCRTBuilder;
+    }
+
+    public Class<?> getElementType()
+    {
+        return Double.TYPE;
+    }
+
+    public Class<?> getElementArrayType()
+    {
+        return double[].class;
+    }
+
+    public int getElementSize()
+    {
+        return 8;
+    }
+
+    public void shutdown()
+        throws ApfloatRuntimeException
+    {
+        DiskDataStorage.cleanUp();
+    }
+
+    public void gc()
+        throws ApfloatRuntimeException
+    {
+        System.gc();
+        System.gc();
+        System.runFinalization();
+        DiskDataStorage.gc();
+    }
+
+    private static ApfloatBuilder apfloatBuilder = new DoubleApfloatBuilder();
+    private static DataStorageBuilder dataStorageBuilder = new DoubleDataStorageBuilder();
+    private static AdditionBuilder<Double> additionBuilder = new DoubleAdditionBuilder();
+    private static ConvolutionBuilder convolutionBuilder = new DoubleConvolutionBuilder();
+    private static NTTBuilder nttBuilder = new DoubleNTTBuilder();
+    private static MatrixBuilder matrixBuilder = new DoubleMatrixBuilder();
+    private static CarryCRTBuilder<double[]> carryCRTBuilder = new DoubleCarryCRTBuilder();
+}
Index: src/main/java/org/apfloat/internal/DoubleCRTMath.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleCRTMath.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleCRTMath.java	(revision 0)
@@ -0,0 +1,199 @@
+package org.apfloat.internal;
+
+import static org.apfloat.internal.DoubleModConstants.*;
+import static org.apfloat.internal.DoubleRadixConstants.*;
+
+/**
+ * Basic arithmetic for calculating the Chinese Remainder
+ * Theorem. Works for the <code>double</code> type.
+ *
+ * @version 1.6
+ * @author Mikko Tommila
+ */
+
+public class DoubleCRTMath
+    extends DoubleBaseMath
+{
+    /**
+     * Creates a carry-CRT math using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public DoubleCRTMath(int radix)
+    {
+        super(radix);
+        this.base = (long) BASE[radix];
+        this.inverseBase = 1.0 / BASE[radix];
+    }
+
+    /**
+     * Multiplies two words by one word to produce a result of three words.
+     * Most significant word is stored first.
+     *
+     * @param src Source array, first multiplicand.
+     * @param factor Second multiplicand.
+     * @param dst Destination array.
+     */
+
+    public final void multiply(double[] src, double factor, double[] dst)
+    {
+        long tmp = (long) src[1] * (long) factor,
+             carry = (long) ((src[1] * factor + (double) (tmp & 0x8000000000000000L)) * INVERSE_2_64);
+        carry = (carry << 64 - MAX_POWER_OF_TWO_BITS) | (tmp >>> MAX_POWER_OF_TWO_BITS);
+
+        dst[2] = (double) (tmp & BASE_MASK);    // = tmp % MAX_POWER_OF_TWO_BASE
+
+        tmp = (long) src[0] * (long) factor + carry;
+        carry = (long) ((src[0] * factor + (double) carry + (double) (tmp & 0x8000000000000000L)) * INVERSE_2_64);
+        carry = (carry << 64 - MAX_POWER_OF_TWO_BITS) | (tmp >>> MAX_POWER_OF_TWO_BITS);
+
+        dst[1] = (double) (tmp & BASE_MASK);    // = tmp % MAX_POWER_OF_TWO_BASE
+
+        dst[0] = (double) carry;
+    }
+
+    /**
+     * Compares three words. Most significant word is stored first.
+     *
+     * @param src1 First operand.
+     * @param src2 Second operand.
+     *
+     * @return Less than zero if <code>src1 &lt; src2</code>, greater than zero if <code>src1 &gt; src2</code> and zero if <code>src1 == src2</code>.
+     */
+
+    public final double compare(double[] src1, double[] src2)
+    {
+        double result = src1[0] - src2[0];
+
+        if (result != 0)
+        {
+            return result;
+        }
+
+        result = src1[1] - src2[1];
+
+        if (result != 0)
+        {
+            return result;
+        }
+
+        return src1[2] - src2[2];
+    }
+
+    /**
+     * Adds three words. Most significant word is stored first.
+     *
+     * @param src First operand.
+     * @param srcDst Second operand, and destination of the operation.
+     *
+     * @return Overflow carry bit.
+     */
+
+    public final double add(double[] src, double[] srcDst)
+    {
+        double result = srcDst[2] + src[2],
+               carry = (result >= MAX_POWER_OF_TWO_BASE ? 1 : 0);
+        result = (result >= MAX_POWER_OF_TWO_BASE ? result - MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[2] = result;
+
+        result = srcDst[1] + src[1] + carry;
+        carry = (result >= MAX_POWER_OF_TWO_BASE ? 1 : 0);
+        result = (result >= MAX_POWER_OF_TWO_BASE ? result - MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[1] = result;
+
+        result = srcDst[0] + src[0] + carry;
+        carry = (result >= MAX_POWER_OF_TWO_BASE ? 1 : 0);
+        result = (result >= MAX_POWER_OF_TWO_BASE ? result - MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[0] = result;
+
+        return carry;
+    }
+
+    /**
+     * Subtracts three words. Most significant word is stored first.
+     *
+     * @param src First operand.
+     * @param srcDst Second operand, and destination of the operation.
+     */
+
+    public final void subtract(double[] src, double[] srcDst)
+    {
+        double result = srcDst[2] - src[2],
+               carry = (result < 0 ? 1 : 0);
+        result = (result < 0 ? result + MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[2] = result;
+
+        result = srcDst[1] - src[1] - carry;
+        carry = (result < 0 ? 1 : 0);
+        result = (result < 0 ? result + MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[1] = result;
+
+        result = srcDst[0] - src[0] - carry;
+        // carry = (result < 0 ? 1 : 0);
+        result = (result < 0 ? result + MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[0] = result;
+    }
+
+    /**
+     * Divides three words by the base to produce two words. Most significant word is stored first.
+     *
+     * @param srcDst Source and destination of the operation.
+     *
+     * @return Remainder of the division.
+     */
+
+    public final double divide(double[] srcDst)
+    {
+        long tmp = ((long) srcDst[0] << MAX_POWER_OF_TWO_BITS) + (long) srcDst[1],
+             result = (long) ((srcDst[0] * MAX_POWER_OF_TWO_BASE + srcDst[1]) * this.inverseBase),
+             carry = tmp - result * this.base;          // = tmp % divisor
+
+        if (carry >= this.base)
+        {
+            carry -= this.base;
+            result++;
+        }
+        if (carry < 0)
+        {
+            carry += this.base;
+            result--;
+        }
+
+        srcDst[0] = 0;
+        srcDst[1] = (double) result;
+
+        tmp = (carry << MAX_POWER_OF_TWO_BITS) + (long) srcDst[2];
+        result = (long) (((double) carry * MAX_POWER_OF_TWO_BASE + srcDst[2]) * this.inverseBase);
+        carry = tmp - result * this.base;               // = tmp % divisor
+
+        if (carry >= this.base)
+        {
+            carry -= this.base;
+            result++;
+        }
+        if (carry < 0)
+        {
+            carry += this.base;
+            result--;
+        }
+
+        srcDst[2] = (double) result;
+
+        return (double) carry;
+    }
+
+    private static final long serialVersionUID = -8414531999881223922L;
+
+    private static final long BASE_MASK = (1L << MAX_POWER_OF_TWO_BITS) - 1;
+    private static final double INVERSE_2_64 = 1.0 / 18446744073709551616.0;
+
+    private long base;
+    private double inverseBase;
+}
Index: src/main/java/org/apfloat/internal/DoubleCarryCRTBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleCarryCRTBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleCarryCRTBuilder.java	(revision 0)
@@ -0,0 +1,36 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.CarryCRTBuilder;
+import org.apfloat.spi.CarryCRTStrategy;
+import org.apfloat.spi.CarryCRTStepStrategy;
+
+/**
+ * Creates carry-CRT related objects, for the
+ * <code>double</code> type.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleCarryCRTBuilder
+    implements CarryCRTBuilder<double[]>
+{
+    /**
+     * Default constructor.
+     */
+
+    public DoubleCarryCRTBuilder()
+    {
+    }
+
+    public CarryCRTStrategy createCarryCRT(int radix)
+    {
+        return new StepCarryCRTStrategy(radix);
+    }
+
+    public CarryCRTStepStrategy<double[]> createCarryCRTSteps(int radix)
+    {
+        return new DoubleCarryCRTStepStrategy(radix);
+    }
+}
Index: src/main/java/org/apfloat/internal/DoubleCarryCRTStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleCarryCRTStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleCarryCRTStepStrategy.java	(revision 0)
@@ -0,0 +1,293 @@
+package org.apfloat.internal;
+
+import java.math.BigInteger;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.CarryCRTStepStrategy;
+import org.apfloat.spi.DataStorage;
+import static org.apfloat.internal.DoubleModConstants.*;
+
+/**
+ * Class for performing the final steps of a three-modulus
+ * Number Theoretic Transform based convolution. Works for the
+ * <code>double</code> type.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleCarryCRTStepStrategy
+    extends DoubleCRTMath
+    implements CarryCRTStepStrategy<double[]>
+{
+    /**
+     * Creates a carry-CRT steps object using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public DoubleCarryCRTStepStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public double[] crt(DataStorage resultMod0, DataStorage resultMod1, DataStorage resultMod2, DataStorage dataStorage, long size, long resultSize, long offset, long length)
+        throws ApfloatRuntimeException
+    {
+        long skipSize = (offset == 0 ? size - resultSize + 1: 0);   // For the first block, ignore the first 1-3 elements
+        long lastSize = (offset + length == size ? 1: 0);           // For the last block, add 1 element
+        long nonLastSize = 1 - lastSize;                            // For the other than last blocks, move 1 element
+        long subResultSize = length - skipSize + lastSize;
+
+        long subStart = size - offset,
+             subEnd = subStart - length,
+             subResultStart = size - offset - length + nonLastSize + subResultSize,
+             subResultEnd = subResultStart - subResultSize;
+
+        DataStorage.Iterator src0 = resultMod0.iterator(DataStorage.READ, subStart, subEnd),
+                             src1 = resultMod1.iterator(DataStorage.READ, subStart, subEnd),
+                             src2 = resultMod2.iterator(DataStorage.READ, subStart, subEnd),
+                             dst = dataStorage.iterator(DataStorage.WRITE, subResultStart, subResultEnd);
+
+        double[] carryResult = new double[3],
+                  sum = new double[3],
+                  tmp = new double[3];
+
+        // Preliminary carry-CRT calculation (happens in parallel in multiple blocks)
+        for (long i = 0; i < length; i++)
+        {
+            double y0 = MATH_MOD_0.modMultiply(T0, src0.getDouble()),
+                    y1 = MATH_MOD_1.modMultiply(T1, src1.getDouble()),
+                    y2 = MATH_MOD_2.modMultiply(T2, src2.getDouble());
+
+            multiply(M12, y0, sum);
+            multiply(M02, y1, tmp);
+
+            if (add(tmp, sum) != 0 ||
+                compare(sum, M012) >= 0)
+            {
+                subtract(M012, sum);
+            }
+
+            multiply(M01, y2, tmp);
+
+            if (add(tmp, sum) != 0 ||
+                compare(sum, M012) >= 0)
+            {
+                subtract(M012, sum);
+            }
+
+            add(sum, carryResult);
+
+            double result = divide(carryResult);
+
+            // In the first block, ignore the first element (it's zero in full precision calculations)
+            // and possibly one or two more in limited precision calculations
+            if (i >= skipSize)
+            {
+                dst.setDouble(result);
+                dst.next();
+            }
+
+            src0.next();
+            src1.next();
+            src2.next();
+        }
+
+        // Calculate the last words (in base math)
+        double result0 = divide(carryResult);
+        double result1 = carryResult[2];
+
+        assert (carryResult[0] == 0);
+        assert (carryResult[1] == 0);
+
+        // Last block has one extra element (corresponding to the one skipped in the first block)
+        if (subResultSize == length - skipSize + 1)
+        {
+            dst.setDouble(result0);
+            dst.close();
+
+            result0 = result1;
+            assert (result1 == 0);
+        }
+
+        double[] results = { result1, result0 };
+
+        return results;
+    }
+
+    public double[] carry(DataStorage dataStorage, long size, long resultSize, long offset, long length, double[] results, double[] previousResults)
+        throws ApfloatRuntimeException
+    {
+        long skipSize = (offset == 0 ? size - resultSize + 1: 0);   // For the first block, ignore the first 1-3 elements
+        long lastSize = (offset + length == size ? 1: 0);           // For the last block, add 1 element
+        long nonLastSize = 1 - lastSize;                            // For the other than last blocks, move 1 element
+        long subResultSize = length - skipSize + lastSize;
+
+        long subResultStart = size - offset - length + nonLastSize + subResultSize,
+             subResultEnd = subResultStart - subResultSize;
+
+        // Get iterators for the previous block carries, and dst, padded with this block's carries
+        // Note that size could be 1 but carries size is 2
+        DataStorage.Iterator src = arrayIterator(previousResults);
+        DataStorage.Iterator dst = compositeIterator(dataStorage.iterator(DataStorage.READ_WRITE, subResultStart, subResultEnd), subResultSize, arrayIterator(results));
+
+        // Propagate base addition through dst, and this block's carries
+        double carry = baseAdd(dst, src, 0, dst, previousResults.length);
+        carry = baseCarry(dst, carry, subResultSize);
+        dst.close();                                                    // Iterator likely was not iterated to end
+
+        assert (carry == 0);
+
+        return results;
+    }
+
+    private double baseCarry(DataStorage.Iterator srcDst, double carry, long size)
+        throws ApfloatRuntimeException
+    {
+        for (long i = 0; i < size && carry > 0; i++)
+        {
+            carry = baseAdd(srcDst, null, carry, srcDst, 1);
+        }
+
+        return carry;
+    }
+
+    // Wrap an array in a simple reverse-order iterator, padded with zeros
+    private static DataStorage.Iterator arrayIterator(final double[] data)
+    {
+        return new DataStorage.Iterator()
+        {
+            public boolean hasNext()
+            {
+                return true;
+            }
+
+            public void next()
+            {
+                this.position--;
+            }
+
+            public double getDouble()
+            {
+                assert (this.position >= 0);
+                return data[this.position];
+            }
+
+            public void setDouble(double value)
+            {
+                assert (this.position >= 0);
+                data[this.position] = value;
+            }
+
+            private static final long serialVersionUID = 1L;
+
+            private int position = data.length - 1;
+        };
+    }
+
+    // Composite iterator, made by concatenating two iterators
+    private static DataStorage.Iterator compositeIterator(final DataStorage.Iterator iterator1, final long size, final DataStorage.Iterator iterator2)
+    {
+        return new DataStorage.Iterator()
+        {
+            public boolean hasNext()
+            {
+                return (this.position < size ? iterator1.hasNext() : iterator2.hasNext());
+            }
+
+            public void next()
+                throws ApfloatRuntimeException
+            {
+                (this.position < size ? iterator1 : iterator2).next();
+                this.position++;
+            }
+
+            public double getDouble()
+                throws ApfloatRuntimeException
+            {
+                return (this.position < size ? iterator1 : iterator2).getDouble();
+            }
+
+            public void setDouble(double value)
+                throws ApfloatRuntimeException
+            {
+                (this.position < size ? iterator1 : iterator2).setDouble(value);
+            }
+
+            public void close()
+                throws ApfloatRuntimeException
+            {
+                (this.position < size ? iterator1 : iterator2).close();
+            }
+
+            private static final long serialVersionUID = 1L;
+
+            private long position;
+        };
+    }
+
+    private static final long serialVersionUID = 2974874464027705533L;
+
+    private static final DoubleModMath MATH_MOD_0,
+                                        MATH_MOD_1,
+                                        MATH_MOD_2;
+    private static final double T0,
+                                 T1,
+                                 T2;
+    private static final double[] M01,
+                                   M02,
+                                   M12,
+                                   M012;
+
+    static
+    {
+        MATH_MOD_0 = new DoubleModMath();
+        MATH_MOD_1 = new DoubleModMath();
+        MATH_MOD_2 = new DoubleModMath();
+
+        MATH_MOD_0.setModulus(MODULUS[0]);
+        MATH_MOD_1.setModulus(MODULUS[1]);
+        MATH_MOD_2.setModulus(MODULUS[2]);
+
+        // Probably sub-optimal, but it's a one-time operation
+
+        BigInteger base = BigInteger.valueOf(Math.abs((long) MAX_POWER_OF_TWO_BASE)),   // In int case the base is 0x80000000
+                   m0 = BigInteger.valueOf((long) MODULUS[0]),
+                   m1 = BigInteger.valueOf((long) MODULUS[1]),
+                   m2 = BigInteger.valueOf((long) MODULUS[2]),
+                   m01 = m0.multiply(m1),
+                   m02 = m0.multiply(m2),
+                   m12 = m1.multiply(m2);
+
+        T0 = m12.modInverse(m0).doubleValue();
+        T1 = m02.modInverse(m1).doubleValue();
+        T2 = m01.modInverse(m2).doubleValue();
+
+        M01 = new double[2];
+        M02 = new double[2];
+        M12 = new double[2];
+        M012 = new double[3];
+
+        BigInteger[] qr = m01.divideAndRemainder(base);
+        M01[0] = qr[0].doubleValue();
+        M01[1] = qr[1].doubleValue();
+
+        qr = m02.divideAndRemainder(base);
+        M02[0] = qr[0].doubleValue();
+        M02[1] = qr[1].doubleValue();
+
+        qr = m12.divideAndRemainder(base);
+        M12[0] = qr[0].doubleValue();
+        M12[1] = qr[1].doubleValue();
+
+        qr = m0.multiply(m12).divideAndRemainder(base);
+        M012[2] = qr[1].doubleValue();
+        qr = qr[0].divideAndRemainder(base);
+        M012[0] = qr[0].doubleValue();
+        M012[1] = qr[1].doubleValue();
+    }
+}
Index: src/main/java/org/apfloat/internal/DoubleConstants.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleConstants.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleConstants.java	(revision 0)
@@ -0,0 +1,24 @@
+package org.apfloat.internal;
+
+/**
+ * Constants needed for various algorithms for the <code>double</code> type.
+ *
+ * @since 1.4
+ * @version 1.4
+ * @author Mikko Tommila
+ */
+
+public interface DoubleConstants
+{
+    /**
+     * Relative cost of Karatsuba multiplication.
+     */
+
+    public static final float KARATSUBA_COST_FACTOR = 4.3f;
+
+    /**
+     * Relative cost of NTT multiplication.
+     */
+
+    public static final float NTT_COST_FACTOR = 6.2f;
+}
Index: src/main/java/org/apfloat/internal/DoubleConvolutionBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleConvolutionBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleConvolutionBuilder.java	(revision 0)
@@ -0,0 +1,65 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.ConvolutionStrategy;
+import org.apfloat.spi.NTTStrategy;
+import static org.apfloat.internal.DoubleConstants.*;
+
+/**
+ * Creates convolutions of suitable type for the <code>double</code> type.<p>
+ *
+ * @see DoubleShortConvolutionStrategy
+ * @see DoubleMediumConvolutionStrategy
+ * @see DoubleKaratsubaConvolutionStrategy
+ * @see ThreeNTTConvolutionStrategy
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleConvolutionBuilder
+    extends AbstractConvolutionBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public DoubleConvolutionBuilder()
+    {
+    }
+
+    protected int getKaratsubaCutoffPoint()
+    {
+        return DoubleKaratsubaConvolutionStrategy.CUTOFF_POINT;
+    }
+
+    protected float getKaratsubaCostFactor()
+    {
+        return KARATSUBA_COST_FACTOR;
+    }
+
+    protected float getNTTCostFactor()
+    {
+        return NTT_COST_FACTOR;
+    }
+
+    protected ConvolutionStrategy createShortConvolutionStrategy(int radix)
+    {
+        return new DoubleShortConvolutionStrategy(radix);
+    }
+
+    protected ConvolutionStrategy createMediumConvolutionStrategy(int radix)
+    {
+        return new DoubleMediumConvolutionStrategy(radix);
+    }
+
+    protected ConvolutionStrategy createKaratsubaConvolutionStrategy(int radix)
+    {
+        return new DoubleKaratsubaConvolutionStrategy(radix);
+    }
+
+
+    protected ConvolutionStrategy createThreeNTTConvolutionStrategy(int radix, NTTStrategy nttStrategy)
+    {
+        return new ParallelThreeNTTConvolutionStrategy(radix, nttStrategy);
+    }
+}
Index: src/main/java/org/apfloat/internal/DoubleDataStorageBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleDataStorageBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleDataStorageBuilder.java	(revision 0)
@@ -0,0 +1,49 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+
+/**
+ * Default data storage creation strategy for the <code>double</code> data type.
+ *
+ * @see DoubleMemoryDataStorage
+ * @see DoubleDiskDataStorage
+ *
+ * @version 1.8.2
+ * @author Mikko Tommila
+ */
+
+public class DoubleDataStorageBuilder
+    extends AbstractDataStorageBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public DoubleDataStorageBuilder()
+    {
+    }
+
+    protected long getMaxCachedSize()
+    {
+        return (long) 8 * Integer.MAX_VALUE;
+    }
+
+    protected DataStorage createCachedDataStorage()
+        throws ApfloatRuntimeException
+    {
+        return new DoubleMemoryDataStorage();
+    }
+
+    protected DataStorage createNonCachedDataStorage()
+        throws ApfloatRuntimeException
+    {
+        return new DoubleDiskDataStorage();
+    }
+
+    protected boolean isCached(DataStorage dataStorage)
+        throws ApfloatRuntimeException
+    {
+        return (dataStorage instanceof DoubleMemoryDataStorage);
+    }
+}
Index: src/main/java/org/apfloat/internal/DoubleDiskDataStorage.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleDiskDataStorage.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleDiskDataStorage.java	(revision 0)
@@ -0,0 +1,333 @@
+package org.apfloat.internal;
+
+import java.nio.ByteBuffer;
+import java.nio.DoubleBuffer;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.channels.WritableByteChannel;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Disk-based data storage for the <code>double</code> element type.
+ *
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleDiskDataStorage
+    extends DiskDataStorage
+{
+    /**
+     * Default constructor.
+     */
+
+    public DoubleDiskDataStorage()
+        throws ApfloatRuntimeException
+    {
+    }
+
+    /**
+     * Subsequence constructor.
+     *
+     * @param doubleDiskDataStorage The originating data storage.
+     * @param offset The subsequence starting position.
+     * @param length The subsequence length.
+     */
+
+    protected DoubleDiskDataStorage(DoubleDiskDataStorage doubleDiskDataStorage, long offset, long length)
+    {
+        super(doubleDiskDataStorage, offset, length);
+    }
+
+    protected DataStorage implSubsequence(long offset, long length)
+        throws ApfloatRuntimeException
+    {
+        return new DoubleDiskDataStorage(this, offset + getOffset(), length);
+    }
+
+    private class DoubleDiskArrayAccess
+        extends DoubleMemoryArrayAccess
+    {
+        // fileOffset is absolute position in file
+        public DoubleDiskArrayAccess(int mode, long fileOffset, int length)
+            throws ApfloatRuntimeException
+        {
+            super(new double[length], 0, length);
+            this.mode = mode;
+            this.fileOffset = fileOffset;
+
+            if ((mode & READ) != 0)
+            {
+                final double[] array = getDoubleData();
+                WritableByteChannel out = new WritableByteChannel()
+                {
+                    public int write(ByteBuffer buffer)
+                    {
+                        DoubleBuffer src = buffer.asDoubleBuffer();
+                        int readLength = src.remaining();
+
+                        src.get(array, this.readPosition, readLength);
+
+                        this.readPosition += readLength;
+                        buffer.position(buffer.position() + readLength * 8);
+
+                        return readLength * 8;
+                    }
+
+                    public void close() {}
+                    public boolean isOpen() { return true; }
+
+                    private int readPosition = 0;
+                };
+
+                transferTo(out, fileOffset * 8, (long) length * 8);
+            }
+        }
+
+        public void close()
+            throws ApfloatRuntimeException
+        {
+            if ((this.mode & WRITE) != 0 && getData() != null)
+            {
+                final double[] array = getDoubleData();
+                ReadableByteChannel in = new ReadableByteChannel()
+                {
+                    public int read(ByteBuffer buffer)
+                    {
+                        DoubleBuffer dst = buffer.asDoubleBuffer();
+                        int writeLength = dst.remaining();
+
+                        dst.put(array, this.writePosition, writeLength);
+
+                        this.writePosition += writeLength;
+                        buffer.position(buffer.position() + writeLength * 8);
+
+                        return writeLength * 8;
+                    }
+
+                    public void close() {}
+                    public boolean isOpen() { return true; }
+
+                    private int writePosition = 0;
+                };
+
+                transferFrom(in, this.fileOffset * 8, (long) array.length * 8);
+            }
+
+            super.close();
+        }
+
+        private static final long serialVersionUID = -7097317279839657081L;
+
+        private int mode;
+        private long fileOffset;
+    }
+
+    protected ArrayAccess implGetArray(int mode, long offset, int length)
+        throws ApfloatRuntimeException
+    {
+        return new DoubleDiskArrayAccess(mode, getOffset() + offset, length);
+    }
+
+    protected ArrayAccess createArrayAccess(int mode, int startColumn, int columns, int rows)
+    {
+        return new MemoryArrayAccess(mode, new double[columns * rows], startColumn, columns, rows);
+    }
+
+    protected ArrayAccess createTransposedArrayAccess(int mode, int startColumn, int columns, int rows)
+    {
+        return new TransposedMemoryArrayAccess(mode, new double[columns * rows], startColumn, columns, rows);
+    }
+
+    private class MemoryArrayAccess
+        extends DoubleMemoryArrayAccess
+    {
+        public MemoryArrayAccess(int mode, double[] data, int startColumn, int columns, int rows)
+        {
+            super(data, 0, data.length);
+            this.mode = mode;
+            this.startColumn = startColumn;
+            this.columns = columns;
+            this.rows = rows;
+        }
+
+        public void close()
+            throws ApfloatRuntimeException
+        {
+            if ((this.mode & WRITE) != 0 && getData() != null)
+            {
+                setArray(this, this.startColumn, this.columns, this.rows);
+            }
+            super.close();
+        }
+
+        private static final long serialVersionUID = 3646716922431352928L;
+
+        private int mode,
+                    startColumn,
+                    columns,
+                    rows;
+    }
+
+    private class TransposedMemoryArrayAccess
+        extends DoubleMemoryArrayAccess
+    {
+        public TransposedMemoryArrayAccess(int mode, double[] data, int startColumn, int columns, int rows)
+        {
+            super(data, 0, data.length);
+            this.mode = mode;
+            this.startColumn = startColumn;
+            this.columns = columns;
+            this.rows = rows;
+        }
+
+        public void close()
+            throws ApfloatRuntimeException
+        {
+            if ((this.mode & WRITE) != 0 && getData() != null)
+            {
+                setTransposedArray(this, this.startColumn, this.columns, this.rows);
+            }
+            super.close();
+        }
+
+        private static final long serialVersionUID = -3746109883682965310L;
+
+        private int mode,
+                    startColumn,
+                    columns,
+                    rows;
+    }
+
+    private class BlockIterator
+        extends AbstractIterator
+    {
+        public BlockIterator(int mode, long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            super(mode, startPosition, endPosition);
+            this.arrayAccess = null;
+            this.remaining = 0;
+        }
+
+        public void next()
+            throws IllegalStateException, ApfloatRuntimeException
+        {
+            checkLength();
+
+            assert (this.remaining > 0);
+
+            checkAvailable();
+
+            this.offset += getIncrement();
+            this.remaining--;
+
+            if (this.remaining == 0)
+            {
+                close();
+            }
+
+            super.next();
+        }
+
+        public double getDouble()
+            throws IllegalStateException, ApfloatRuntimeException
+        {
+            checkGet();
+            checkAvailable();
+            return this.data[this.offset];
+        }
+
+        public void setDouble(double value)
+            throws IllegalStateException, ApfloatRuntimeException
+        {
+            checkSet();
+            checkAvailable();
+            this.data[this.offset] = value;
+        }
+
+        public <T> T get(Class<T> type)
+            throws UnsupportedOperationException, IllegalStateException
+        {
+            if (!(type.equals(Double.TYPE)))
+            {
+                throw new UnsupportedOperationException("Unsupported data type " + type.getCanonicalName() + ", the only supported type is double");
+            }
+            @SuppressWarnings("unchecked")
+            T value = (T) (Double) getDouble();
+            return value;
+        }
+
+        public <T> void set(Class<T> type, T value)
+            throws UnsupportedOperationException, IllegalArgumentException, IllegalStateException
+        {
+            if (!(type.equals(Double.TYPE)))
+            {
+                throw new UnsupportedOperationException("Unsupported data type " + type.getCanonicalName() + ", the only supported type is double");
+            }
+            if (!(value instanceof Double))
+            {
+                throw new IllegalArgumentException("Unsupported value type " + value.getClass().getCanonicalName() + ", the only supported type is Double");
+            }
+            setDouble((Double) value);
+        }
+
+        /**
+         * Closes the iterator. This needs to be called only if the
+         * iterator is not iterated to the end.
+         */
+
+        public void close()
+            throws ApfloatRuntimeException
+        {
+            if (this.arrayAccess != null)
+            {
+                this.data = null;
+                this.arrayAccess.close();
+                this.arrayAccess = null;
+            }
+        }
+
+        private void checkAvailable()
+            throws ApfloatRuntimeException
+        {
+            if (this.arrayAccess == null)
+            {
+                boolean isForward = (getIncrement() > 0);
+                int length = (int) Math.min(getLength(), getBlockSize() / 8);
+                long offset = (isForward ? getPosition() : getPosition() - length + 1);
+
+                this.arrayAccess = getArray(getMode(), offset, length);
+                this.data = this.arrayAccess.getDoubleData();
+                this.offset = this.arrayAccess.getOffset() + (isForward ? 0 : length - 1);
+                this.remaining = length;
+            }
+        }
+
+        private static final long serialVersionUID = -1996647087834590031L;
+
+        private ArrayAccess arrayAccess;
+        private double[] data;
+        private int offset,
+                    remaining;
+    }
+
+    public Iterator iterator(int mode, long startPosition, long endPosition)
+        throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+    {
+        if ((mode & READ_WRITE) == 0)
+        {
+            throw new IllegalArgumentException("Illegal mode: " + mode);
+        }
+        return new BlockIterator(mode, startPosition, endPosition);
+    }
+
+    protected int getUnitSize()
+    {
+        return 8;
+    }
+
+    private static final long serialVersionUID = 342871486421108657L;
+}
Index: src/main/java/org/apfloat/internal/DoubleElementaryModMath.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleElementaryModMath.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleElementaryModMath.java	(revision 0)
@@ -0,0 +1,137 @@
+package org.apfloat.internal;
+
+/**
+ * Elementary modulo arithmetic functions for <code>double</code> data.
+ * Note that although a floating-point data type is used, the data
+ * will always be integers.<p>
+ *
+ * Modular addition and subtraction are trivial, when the modulus is less
+ * than 2<sup>52</sup> and overflow can be detected easily.<p>
+ *
+ * Modular multiplication is more complicated, and since it is usually
+ * the single most time consuming operation in the whole program execution,
+ * the very core of the Number Theoretic Transform (NTT), it should be
+ * carefully optimized.<p>
+ *
+ * The algorithm for multiplying two <code>double</code>s containing an
+ * integer and taking the remainder is not entirely obvious. The basic problem
+ * is to get the full 104-bit result of multiplying two 52-bit integers.
+ * This can basically be done in two parts: by multiplying two
+ * <code>long</code>s, the lowest 64 bits can be acquired easily. Multiplying
+ * the <code>double</code>s as floating-point numbers and scaling properly, the
+ * highest (roughly) 52 bits of the result can be acquired.<p>
+ *
+ * The first observation is that since the modulus is practically
+ * constant, it should be more efficient to calculate (once) the inverse
+ * of the modulus, and then subsequently multiply by the inverse of the
+ * modulus instead of dividing by it.<p>
+ *
+ * The second observation is that to get the remainder of the division,
+ * we don't necessarily need the actual result of the division (we just
+ * want the remainder). So, we should discard the topmost 52 bits of the
+ * full 104-bit result whenever possible, to save a few operations.<p>
+ *
+ * The basic approach is to get an approximation of <code>a * b / modulus</code>
+ * (using floating-point operands, that is <code>double</code>s). The approximation
+ * should be within +1 or -1 of the correct result. Then calculate
+ * <code>a * b - approximateDivision * modulus</code> to get the remainder.
+ * This calculation must use the lowest 52 (or more, actually 64) bits
+ * and is done using <code>long</code>s. As the modulus is less than 2<sup>52</sup>
+ * it is easy to detect the case when the approximate division was off by one (and
+ * the remainder is <code>&#177;modulus</code> off).<p>
+ *
+ * To ensure that only one comparison is needed in the check for the approximate
+ * division, we use <code>1 / (modulus + 0.5)</code> as the inverse modulus. In
+ * this case the result of the approximate division is always either correct or
+ * 1 less.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleElementaryModMath
+{
+    /**
+     * Default constructor.
+     */
+
+    public DoubleElementaryModMath()
+    {
+    }
+
+    /**
+     * Modular multiplication.
+     *
+     * @param a First operand.
+     * @param b Second operand.
+     *
+     * @return <code>a * b % modulus</code>
+     */
+
+    public final double modMultiply(double a, double b)
+    {
+        double r = (double) ((long) a * (long) b - this.longModulus * (long) (a * b * this.inverseModulus));
+
+        return (r >= this.modulus ? r - this.modulus : r);
+    }
+
+    /**
+     * Modular addition.
+     *
+     * @param a First operand.
+     * @param b Second operand.
+     *
+     * @return <code>(a + b) % modulus</code>
+     */
+
+    public final double modAdd(double a, double b)
+    {
+        double r = a + b;
+
+        return (r >= this.modulus ? r - this.modulus : r);
+    }
+
+    /**
+     * Modular subtraction. The result is always &gt;= 0.
+     *
+     * @param a First operand.
+     * @param b Second operand.
+     *
+     * @return <code>(a - b + modulus) % modulus</code>
+     */
+
+    public final double modSubtract(double a, double b)
+    {
+        double r = a - b;
+
+        return (r < 0.0 ? r + this.modulus : r);
+    }
+
+    /**
+     * Get the modulus.
+     *
+     * @return The modulus.
+     */
+
+    public final double getModulus()
+    {
+        return this.modulus;
+    }
+
+    /**
+     * Set the modulus.
+     *
+     * @param modulus The modulus.
+     */
+
+    public final void setModulus(double modulus)
+    {
+        this.inverseModulus = 1.0 / (modulus + 0.5);    // Round down
+        this.longModulus = (long) modulus;
+        this.modulus = modulus;
+    }
+
+    private long longModulus;
+    private double modulus;
+    private double inverseModulus;
+}
Index: src/main/java/org/apfloat/internal/DoubleFactor3NTTStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleFactor3NTTStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleFactor3NTTStepStrategy.java	(revision 0)
@@ -0,0 +1,180 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.Factor3NTTStepStrategy;
+import org.apfloat.spi.DataStorage;
+import static org.apfloat.internal.DoubleModConstants.*;
+
+/**
+ * Steps for the factor-3 NTT.<p>
+ *
+ * The transform is done using a parallel algorithm, if the data fits in memory.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleFactor3NTTStepStrategy
+    extends DoubleModMath
+    implements Factor3NTTStepStrategy, Parallelizable
+{
+    // Runnable for transforming the columns in a factor-3 transform
+    private class ColumnTransformRunnable
+        implements Runnable
+    {
+        public ColumnTransformRunnable(DataStorage dataStorage0, DataStorage dataStorage1, DataStorage dataStorage2, long startColumn, long columns, double w, double ww, double w1, double w2, boolean isInverse)
+        {
+            this.dataStorage0 = dataStorage0;
+            this.dataStorage1 = dataStorage1;
+            this.dataStorage2 = dataStorage2;
+            this.startColumn = startColumn;
+            this.columns = columns;
+            this.w = w;
+            this.ww = ww;
+            this.w1 = w1;
+            this.w2 = w2;
+            this.isInverse = isInverse;
+        }
+
+        public void run()
+        {
+            double tmp1 = modPow(this.w, (double) this.startColumn),
+                    tmp2 = modPow(this.ww, (double) this.startColumn);
+
+            DataStorage.Iterator iterator0 = this.dataStorage0.iterator(DataStorage.READ_WRITE, this.startColumn, this.startColumn + this.columns),
+                                 iterator1 = this.dataStorage1.iterator(DataStorage.READ_WRITE, this.startColumn, this.startColumn + this.columns),
+                                 iterator2 = this.dataStorage2.iterator(DataStorage.READ_WRITE, this.startColumn, this.startColumn + this.columns);
+
+            for (long i = 0; i < this.columns; i++)
+            {
+                // 3-point WFTA on the corresponding array elements
+
+                double x0 = iterator0.getDouble(),
+                        x1 = iterator1.getDouble(),
+                        x2 = iterator2.getDouble(),
+                        t;
+
+                if (this.isInverse)
+                {
+                    // Multiply before transform
+                    x1 = modMultiply(x1, tmp1);
+                    x2 = modMultiply(x2, tmp2);
+                }
+
+                // Transform columns
+                t = modAdd(x1, x2);
+                x2 = modSubtract(x1, x2);
+                x0 = modAdd(x0, t);
+                t = modMultiply(t, this.w1);
+                x2 = modMultiply(x2, this.w2);
+                t = modAdd(t, x0);
+                x1 = modAdd(t, x2);
+                x2 = modSubtract(t, x2);
+
+                if (!this.isInverse)
+                {
+                    // Multiply after transform
+                    x1 = modMultiply(x1, tmp1);
+                    x2 = modMultiply(x2, tmp2);
+                }
+
+                iterator0.setDouble(x0);
+                iterator1.setDouble(x1);
+                iterator2.setDouble(x2);
+
+                iterator0.next();
+                iterator1.next();
+                iterator2.next();
+
+                tmp1 = modMultiply(tmp1, this.w);
+                tmp2 = modMultiply(tmp2, this.ww);
+            }
+        }
+
+        private DataStorage dataStorage0;
+        private DataStorage dataStorage1;
+        private DataStorage dataStorage2;
+        private long startColumn;
+        private long columns;
+        private double w;
+        private double ww;
+        private double w1;
+        private double w2;
+        private boolean isInverse;
+    }
+
+    /**
+     * Default constructor.
+     */
+
+    public DoubleFactor3NTTStepStrategy()
+    {
+    }
+
+    public void transformColumns(DataStorage dataStorage0, DataStorage dataStorage1, DataStorage dataStorage2, long startColumn, long columns, long power2length, long length, boolean isInverse, int modulus)
+        throws ApfloatRuntimeException
+    {
+        // Transform length is three times a power of two
+        assert (length == 3 * power2length);
+
+        ParallelRunnable parallelRunnable = createColumnTransformParallelRunnable(dataStorage0, dataStorage1, dataStorage2, startColumn, columns, power2length, length, isInverse, modulus);
+
+        if (columns <= Integer.MAX_VALUE &&                                     // Only if the size fits in an integer, but with memory arrays it should
+            dataStorage0.isCached() &&                                          // Only if the data storage supports efficient parallel random access
+            dataStorage1.isCached() &&
+            dataStorage2.isCached())
+        {
+            ParallelRunner.runParallel(parallelRunnable);
+        }
+        else
+        {
+            parallelRunnable.run();                                             // Just run in current thread without parallelization
+        }
+    }
+
+    public long getMaxTransformLength()
+    {
+        return MAX_TRANSFORM_LENGTH;
+    }
+
+    /**
+     * Create a ParallelRunnable object for transforming the columns of the matrix
+     * using a 3-point NTT transform.
+     *
+     * @param dataStorage0 The data of the first column.
+     * @param dataStorage1 The data of the second column.
+     * @param dataStorage2 The data of the third column.
+     * @param startColumn The starting element index in the data storages to transform.
+     * @param columns How many columns to transform.
+     * @param power2length Length of the column transform.
+     * @param length Length of total transform (three times the length of one column).
+     * @param isInverse <code>true</code> if an inverse transform is performed, <code>false</code> if a forward transform is performed.
+     * @param modulus Index of the modulus.
+     *
+     * @return A suitable object for performing the 3-point transforms in parallel.
+     */
+
+    protected ParallelRunnable createColumnTransformParallelRunnable(final DataStorage dataStorage0, final DataStorage dataStorage1, final DataStorage dataStorage2, final long startColumn, final long columns, long power2length, long length, final boolean isInverse, int modulus)
+    {
+        setModulus(MODULUS[modulus]);                                             // Modulus
+        final double w = (isInverse ?
+                           getInverseNthRoot(PRIMITIVE_ROOT[modulus], length) :
+                           getForwardNthRoot(PRIMITIVE_ROOT[modulus], length)),   // Forward/inverse n:th root
+                      w3 = modPow(w, (double) power2length),                     // Forward/inverse 3rd root
+                      ww = modMultiply(w, w),
+                      w1 = negate(modDivide((double) 3, (double) 2)),
+                      w2 = modAdd(w3, modDivide((double) 1, (double) 2));
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(columns)
+        {
+            public Runnable getRunnable(long strideStartColumn, long strideColumns)
+            {
+                return new ColumnTransformRunnable(dataStorage0, dataStorage1, dataStorage2, startColumn + strideStartColumn, strideColumns, w, ww, w1, w2, isInverse);
+            }
+        };
+        return parallelRunnable;
+    }
+}
Index: src/main/java/org/apfloat/internal/DoubleKaratsubaConvolutionStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleKaratsubaConvolutionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleKaratsubaConvolutionStrategy.java	(revision 0)
@@ -0,0 +1,242 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.DataStorage;
+
+/**
+ * Convolution strategy using the Karatsuba algorithm.
+ * The complexity of the algorithm is O(n<sup>log(3)/log(2)</sup>) as
+ * the operands are split to two and multiplied using three multiplications
+ * (and five additions / subtractions). This splitting is done recursively
+ * until some cut-off point where the basic O(n<sup>2</sup>) algorithm is
+ * applied. The Karatsuba algorithm is faster than the basic O(n<sup>2</sup>)
+ * multiplication algorithm for medium size numbers larger than some certain
+ * size. For very large numbers, the transform-based convolution algorithms
+ * are faster.
+ *
+ * @since 1.4
+ * @version 1.4
+ * @author Mikko Tommila
+ */
+
+public class DoubleKaratsubaConvolutionStrategy
+    extends DoubleMediumConvolutionStrategy
+{
+    /**
+     * Cut-off point for Karatsuba / basic convolution.<p>
+     *
+     * Convolutions where the shorter number is at most this long
+     * are calculated using the basic O(n<sup>2</sup>) algorithm
+     * i.e. <code>super.convolute()</code>.
+     */
+
+    public static final int CUTOFF_POINT = 15;
+
+    /**
+     * Creates a convolution strategy using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public DoubleKaratsubaConvolutionStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public DataStorage convolute(DataStorage x, DataStorage y, long resultSize)
+        throws ApfloatRuntimeException
+    {
+        if (Math.min(x.getSize(), y.getSize()) <= CUTOFF_POINT)
+        {
+            // The numbers are too short for Karatsuba to have any advantage, fall back to O(n^2) algorithm
+            return super.convolute(x, y, resultSize);
+        }
+
+        DataStorage shortStorage, longStorage;
+
+        if (x.getSize() > y.getSize())
+        {
+            shortStorage = y;
+            longStorage = x;
+        }
+        else
+        {
+            shortStorage = x;
+            longStorage = y;
+        }
+
+        long shortSize = shortStorage.getSize(),
+             longSize = longStorage.getSize(),
+             size = shortSize + longSize,
+             halfSize = longSize + 1 >> 1,      // Split point for recursion, round up
+             x1size = longSize - halfSize,
+             x2size = halfSize,
+             y1size = shortSize - halfSize;     // y2size = halfSize
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        DataStorage resultStorage = dataStorageBuilder.createDataStorage(size * 8);
+        resultStorage.setSize(size);
+
+        if (y1size <= 0)
+        {
+            // The shorter number is half of the longer number or less, use simplified algorithm
+            DataStorage.Iterator dst = resultStorage.iterator(DataStorage.WRITE, size, 0),
+                                 src1 = null;
+            double carry = 0;
+            long i = longSize,
+                 xSize;
+
+            // Calculate sub-results in blocks of size shortSize
+            do
+            {
+                xSize = Math.min(i, shortSize);
+                x = longStorage.subsequence(i - xSize, xSize);
+                y = shortStorage;
+
+                // Calculate sub-convolutions recursively
+                DataStorage a = convolute(x, y, xSize + shortSize);
+
+                assert (a.getSize() == xSize + shortSize);
+
+                // Add the sub-results together
+                DataStorage.Iterator src2 = a.iterator(DataStorage.READ, xSize + shortSize, 0);
+
+                carry = baseAdd(src1, src2, carry, dst, shortSize);
+
+                src1 = src2;
+                i -= shortSize;
+            } while (i > 0);
+
+            // Propagate carry through the last sub-result and store to result data
+            carry = baseAdd(src1, null, carry, dst, xSize);
+
+            assert (carry == 0);
+        }
+        else
+        {
+            // The numbers are roughly equal size (shorter is more than half of the longer), use Karatsuba algorithm
+            DataStorage x1 = longStorage.subsequence(0, x1size),
+                        x2 = longStorage.subsequence(x1size, x2size),
+                        y1 = shortStorage.subsequence(0, y1size),
+                        y2 = shortStorage.subsequence(y1size, halfSize);
+
+            // Calculate a = x1 + x2
+            DataStorage a = add(x1, x2);
+
+            // Calculate b = y1 + y2
+            DataStorage b = add(y1, y2);
+
+            // Calculate sub-convolutions recursively
+            DataStorage c = convolute(a, b, a.getSize() + b.getSize());
+            a = convolute(x1, y1, x1size + y1size);
+            b = convolute(x2, y2, 2 * halfSize);
+
+            // Calculate c = c - a - b
+            subtract(c, a);
+            subtract(c, b);
+
+            long cSize = c.getSize(),
+                 c1size = cSize - halfSize;
+
+            if (c1size > x1size + y1size)
+            {
+                // We know that the top one or two words of c are zero
+                // Omit them to avoid later having c1size > x1size + y1size
+                long zeros = c1size - x1size - y1size;
+                assert (isZero(c, 0));
+                assert (zeros == 1 || isZero(c, 1));
+                assert (zeros <= 2);
+                cSize -= zeros;
+                c1size -= zeros;
+                c = c.subsequence(zeros, cSize);
+            }
+
+            assert (a.getSize() == x1size + y1size);
+            assert (b.getSize() == 2 * halfSize);
+            assert (cSize >= 2 * halfSize && cSize <= 2 * halfSize + 2);
+            assert (c1size <= x1size + y1size);
+
+            // Add the sub-results a + b + c together
+            DataStorage.Iterator src1 = a.iterator(DataStorage.READ, x1size + y1size, 0),
+                                 src2 = b.iterator(DataStorage.READ, 2 * halfSize, 0),
+                                 src3 = c.iterator(DataStorage.READ, cSize, 0),
+                                 dst = resultStorage.iterator(DataStorage.WRITE, size, 0);
+
+            double carry = 0;
+            carry = baseAdd(src2, null, carry, dst, halfSize);
+            carry = baseAdd(src2, src3, carry, dst, halfSize);
+            carry = baseAdd(src1, src3, carry, dst, c1size);
+            carry = baseAdd(src1, null, carry, dst, x1size + y1size - c1size);
+
+            assert (carry == 0);
+        }
+
+        return resultStorage;
+    }
+
+    // Return x1 + x2
+    private DataStorage add(DataStorage x1, DataStorage x2)
+    {
+        long x1size = x1.getSize(),
+             x2size = x2.getSize();
+
+        assert (x1size <= x2size);
+
+        long size = x2size + 1;
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        DataStorage resultStorage = dataStorageBuilder.createDataStorage(size * 8);
+        resultStorage.setSize(size);
+
+        // Calculate x1 + x2
+        DataStorage.Iterator src1 = x1.iterator(DataStorage.READ, x1size, 0),
+                             src2 = x2.iterator(DataStorage.READ, x2size, 0),
+                             dst = resultStorage.iterator(DataStorage.WRITE, size, 0);
+
+        double carry = 0;
+        carry = baseAdd(src1, src2, carry, dst, x1size);
+        carry = baseAdd(src2, null, carry, dst, x2size - x1size);
+        baseAdd(null, null, carry, dst, 1);         // Set carry digit to the top word
+        if (carry == 0)
+        {
+            resultStorage = resultStorage.subsequence(1, size - 1);     // Omit zero top word
+        }
+
+        return resultStorage;
+    }
+
+    // x1 -= x2
+    private void subtract(DataStorage x1, DataStorage x2)
+    {
+        long x1size = x1.getSize(),
+             x2size = x2.getSize();
+
+        assert (x1size >= x2size);
+
+        DataStorage.Iterator src1 = x1.iterator(DataStorage.READ_WRITE, x1size, 0),
+                             src2 = x2.iterator(DataStorage.READ, x2size, 0),
+                             dst = src1;
+
+        double carry = 0;
+        carry = baseSubtract(src1, src2, carry, dst, x2size);
+        carry = baseSubtract(src1, null, carry, dst, x1size - x2size);
+
+        assert (carry == 0);
+    }
+
+    private boolean isZero(DataStorage x, long index)
+    {
+        DataStorage.Iterator i = x.iterator(DataStorage.READ, index, index + 1);
+
+        double data = i.getDouble();
+        i.next();
+
+        return data == 0;
+    }
+
+    private static final long serialVersionUID = 3605808557478224821L;
+}
Index: src/main/java/org/apfloat/internal/DoubleMatrixBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleMatrixBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleMatrixBuilder.java	(revision 0)
@@ -0,0 +1,32 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.MatrixBuilder;
+import org.apfloat.spi.MatrixStrategy;
+
+/**
+ * Creates matrix operations objects, for the
+ * <code>double</code> type.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleMatrixBuilder
+    implements MatrixBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public DoubleMatrixBuilder()
+    {
+    }
+
+    public MatrixStrategy createMatrix()
+    {
+        return DoubleMatrixBuilder.matrixStrategy;
+    }
+
+    private static MatrixStrategy matrixStrategy = new DoubleMatrixStrategy();
+}
Index: src/main/java/org/apfloat/internal/DoubleMatrixStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleMatrixStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleMatrixStrategy.java	(revision 0)
@@ -0,0 +1,442 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.MatrixStrategy;
+import org.apfloat.spi.ArrayAccess;
+import org.apfloat.spi.Util;
+
+/**
+ * Optimized matrix transposition methods for the <code>double</code> type.
+ * The matrix transposition algorithm isn't parallelized.<p>
+ *
+ * While the matrix transposition algorithm could easily be parallelized,
+ * on an SMP machine it does not make any sense. If the matrix doesn't fit
+ * in any processor specific cache then the memory (or higher level
+ * shared cache) bandwidth becomes a bottleneck in the algorithm. Matrix
+ * transposition is in principle a very simple algorithm - it doesn't do
+ * anything else than move data from one place to another. If shared memory
+ * is the bottleneck, then the algorithm isn't any faster if the data is being
+ * moved around by one thread or by multiple threads in parallel.<p>
+ *
+ * If the data fits in a processor specific cache, then the algorithm could
+ * theoretically be made faster with parallelization. To make the parallelization
+ * effective however, the data would have to be set up in some kind of a NUMA
+ * way. For example, each processor core would hold an equal section of
+ * the data in the processor cache. Then the algorithm could be made faster
+ * as each processor core could quickly transpose blocks of data that are in the
+ * processor cache, and then exchange blocks with other processor cores via the
+ * slower higher level shared cache or main memory.<p>
+ *
+ * This approach doesn't work well in practice however, at least not in a Java
+ * program. The reason is that there are no guarantees where the data is when
+ * the algorithm starts (in which processor core caches), and further there are
+ * no guarantees of any processor affinity for the threads that are executing
+ * in parallel. Different processor cores could be executing the transposition
+ * of different sections of the data at any moment, depending on how the
+ * operating system (and the JVM) schedule thread execution. And more often
+ * than not, the operating system isn't smart enough to apply any such processor
+ * affinity for the threads.<p>
+ *
+ * An additional problem for any NUMA based attempt is that the data array would
+ * have to be aligned on a cache line (e.g. 64 or 128 bytes), to prevent
+ * cache contention at the edges of each data section. But a JVM makes no such
+ * guarantees about memory alignment. And since pointers do not exist in Java,
+ * manually aligning memory addresses isn't possible.<p>
+ *
+ * Considering all of the above, the parallel algorithm doesn't in practice work
+ * any faster than the single-thread algorithm, as the algorithm is bound by the
+ * memory bandwidth (or shared cache bandwidth). In some cases parallelization
+ * can even make the execution slower due to increased cache contention.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleMatrixStrategy
+    implements MatrixStrategy
+{
+    /**
+     * Default constructor.
+     */
+
+    public DoubleMatrixStrategy()
+    {
+    }
+
+    /**
+     * Transpose a n<sub>1</sub> x n<sub>2</sub> matrix.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two.
+     * Additionally, one of these must be true:<p>
+     *
+     * n<sub>1</sub> = n<sub>2</sub><br>
+     * n<sub>1</sub> = 2*n<sub>2</sub><br>
+     * n<sub>2</sub> = 2*n<sub>1</sub><br>
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be transposed.
+     * @param n1 Number of rows in the matrix.
+     * @param n2 Number of columns in the matrix.
+     */
+
+    public void transpose(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException
+    {
+        double[] data = arrayAccess.getDoubleData();
+        int offset = arrayAccess.getOffset();
+
+        if (n1 != (n1 & -n1) ||
+            n2 != (n2 & -n2) ||
+            n1 <= 0 || n2 <= 0)
+        {
+            throw new ApfloatInternalException("Matrix size must be a power of two, not " + n1 + " x " + n2);
+        }
+        if (n1 == n2)
+        {
+            // Simply transpose
+
+            transposeSquare(data, offset, n1, n1);
+        }
+        else if (n2 == 2 * n1)
+        {
+            // First transpose two n1 x n1 blocks
+            transposeSquare(data, offset, n1, n2);
+            transposeSquare(data, offset + n1, n1, n2);
+
+            // Then permute the rows to correct order
+            permuteToHalfWidth(data, offset, n1, n2);
+        }
+        else if (n1 == 2 * n2)
+        {
+            // First permute the rows to correct order
+            permuteToDoubleWidth(data, offset, n1, n2);
+
+            // Then transpose two n2 x n2 blocks
+            transposeSquare(data, offset, n2, n1);
+            transposeSquare(data, offset + n2, n2, n1);
+        }
+        else
+        {
+            throw new ApfloatInternalException("Must be n1 = n2, n1 = 2*n2 or n2 = 2*n1; matrix is " + n1 + " x " + n2);
+        }
+    }
+
+    /**
+     * Transpose a square n<sub>1</sub> x n<sub>1</sub> block of n<sub>1</sub> x n<sub>2</sub> matrix.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two,
+     * and n<sub>1</sub> &lt;= n<sub>2</sub>.
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be transposed.
+     * @param n1 Number of rows and columns in the block to be transposed.
+     * @param n2 Number of columns in the matrix.
+     */
+
+    public void transposeSquare(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException
+    {
+        transposeSquare(arrayAccess.getDoubleData(), arrayAccess.getOffset(), n1, n2);
+    }
+
+    /**
+     * Permute the rows of the n<sub>1</sub> x n<sub>2</sub> matrix so that it is shaped like a
+     * n<sub>1</sub>/2 x 2*n<sub>2</sub> matrix. Logically, the matrix is split in half, and the
+     * lower half is moved to the right side of the upper half.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two,
+     * and n<sub>1</sub> &gt;= 2.<p>
+     *
+     * E.g. if the matrix layout is originally as follows:
+     * <table style="width:100px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix before">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td>
+     *   </tr>
+     *   <tr>
+     *     <td>4</td><td>5</td><td>6</td><td>7</td>
+     *   </tr>
+     *   <tr>
+     *     <td>8</td><td>9</td><td>10</td><td>11</td>
+     *   </tr>
+     *   <tr>
+     *     <td>12</td><td>13</td><td>14</td><td>15</td>
+     *   </tr>
+     * </table>
+     * <p>
+     *
+     * Then after this method it is as follows:
+     * <table style="width:200px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix after">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td><td>8</td><td>9</td><td>10</td><td>11</td>
+     *   </tr>
+     *   <tr>
+     *     <td>4</td><td>5</td><td>6</td><td>7</td><td>12</td><td>13</td><td>14</td><td>15</td>
+     *   </tr>
+     * </table>
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be permuted.
+     * @param n1 Number of rows in the matrix.
+     * @param n2 Number of columns in the matrix.
+     *
+     * @since 1.7.0
+     */
+
+    public void permuteToDoubleWidth(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException
+    {
+        if (n1 != (n1 & -n1) ||
+            n2 != (n2 & -n2) ||
+            n1 <= 0 || n2 <= 0)
+        {
+            throw new ApfloatInternalException("Matrix size must be a power of two, not " + n1 + " x " + n2);
+        }
+        if (n1 < 2)
+        {
+            throw new ApfloatInternalException("Matrix height must be at least 2.");
+        }
+        permuteToDoubleWidth(arrayAccess.getDoubleData(), arrayAccess.getOffset(), n1, n2);
+    }
+
+    /**
+     * Permute the rows of the n<sub>1</sub> x n<sub>2</sub> matrix so that it is shaped like a
+     * 2*n<sub>1</sub> x n<sub>2</sub>/2 matrix. Logically, the matrix is split in half, and the
+     * right half is moved below the left half.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two.
+     *
+     * E.g. if the matrix layout is originally as follows:
+     * <table style="width:200px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix before">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td>
+     *   </tr>
+     *   <tr>
+     *     <td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td>
+     *   </tr>
+     * </table>
+     * <p>
+     *
+     * Then after this method it is as follows:
+     * <table style="width:100px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix after">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td>
+     *   </tr>
+     *   <tr>
+     *     <td>8</td><td>9</td><td>10</td><td>11</td>
+     *   </tr>
+     *   <tr>
+     *     <td>4</td><td>5</td><td>6</td><td>7</td>
+     *   </tr>
+     *   <tr>
+     *     <td>12</td><td>13</td><td>14</td><td>15</td>
+     *   </tr>
+     * </table>
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be permuted.
+     * @param n1 Number of rows in the matrix.
+     * @param n2 Number of columns in the matrix.
+     *
+     * @since 1.7.0
+     */
+
+    public void permuteToHalfWidth(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException
+    {
+        if (n1 != (n1 & -n1) ||
+            n2 != (n2 & -n2) ||
+            n1 <= 0 || n2 <= 0)
+        {
+            throw new ApfloatInternalException("Matrix size must be a power of two, not " + n1 + " x " + n2);
+        }
+        permuteToHalfWidth(arrayAccess.getDoubleData(), arrayAccess.getOffset(), n1, n2);
+    }
+
+    // Move a b x b block from source to dest
+    private static void moveBlock(double[] source, int sourceOffset, int sourceWidth, double[] dest, int destOffset, int destWidth, int b)
+    {
+        for (int i = 0; i < b; i++)
+        {
+            System.arraycopy(source, sourceOffset, dest, destOffset, b);
+
+            destOffset += destWidth;
+            sourceOffset += sourceWidth;
+        }
+    }
+
+    // Transpose two b x b blocks of matrix with specified width
+    // data based on offset1 is accessed in columns, data based on offset2 in rows
+    private static void transpose2blocks(double[] data, int offset1, int offset2, int width, int b)
+    {
+        for (int i = 0, position1 = offset2; i < b; i++, position1 += width)
+        {
+            for (int j = 0, position2 = offset1 + i; j < b; j++, position2 += width)
+            {
+                double tmp = data[position1 + j];
+                data[position1 + j] = data[position2];
+                data[position2] = tmp;
+            }
+        }
+    }
+
+    // Transpose a b x b block of matrix with specified width
+    private static void transposeBlock(double[] data, int offset, int width, int b)
+    {
+        for (int i = 0, position1 = offset; i < b; i++, position1 += width)
+        {
+            for (int j = i + 1, position2 = offset + j * width + i; j < b; j++, position2 += width)
+            {
+                double tmp = data[position1 + j];
+                data[position1 + j] = data[position2];
+                data[position2] = tmp;
+            }
+        }
+    }
+
+    // Transpose a square n1 x n1 block of n1 x n2 matrix in b x b blocks
+    private static void transposeSquare(double[] data, int offset, int n1, int n2)
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        int cacheBurstBlockSize = Util.round2down(ctx.getCacheBurst() / 8),   // Cache burst in doubles
+            cacheBlockSize = Util.sqrt4down(ctx.getCacheL1Size() / 8),        // Transpose block size b that fits in processor L1 cache
+            cacheTreshold = Util.round2down(ctx.getCacheL2Size() / 8);        // Size of matrix that fits in L2 cache
+
+        if (n1 <= cacheBurstBlockSize || n1 <= cacheBlockSize)
+        {
+            // Whole matrix fits in L1 cache
+
+            transposeBlock(data, offset, n2, n1);
+        }
+        else if (n1 * n2 <= cacheTreshold)
+        {
+            // Whole matrix fits in L2 cache (but not in L1 cache)
+            // Sometimes the first algorithm (the block above) is faster, if your L2 cache is very fast
+
+            int b = cacheBurstBlockSize;
+
+            for (int i = 0, position1 = offset; i < n1; i += b, position1 += b * n2)
+            {
+                transposeBlock(data, position1 + i, n2, b);
+
+                for (int j = i + b, position2 = offset + j * n2 + i; j < n1; j += b, position2 += b * n2)
+                {
+                    transpose2blocks(data, position1 + j, position2, n2, b);
+                }
+            }
+        }
+        else
+        {
+            // Whole matrix doesn't fit in L2 cache
+            // This algorithm works fastest if L1 cache size is set correctly
+
+            int b = cacheBlockSize;
+
+            double[] tmp1 = new double[b * b],
+                      tmp2 = new double[b * b];
+
+            for (int i = 0, position1 = offset; i < n1; i += b, position1 += b * n2)
+            {
+                moveBlock(data, position1 + i, n2, tmp1, 0, b, b);
+                transposeBlock(tmp1, 0, b, b);
+                moveBlock(tmp1, 0, b, data, position1 + i, n2, b);
+
+                for (int j = i + b, position2 = offset + j * n2 + i; j < n1; j += b, position2 += b * n2)
+                {
+                    moveBlock(data, position1 + j, n2, tmp1, 0, b, b);
+                    transposeBlock(tmp1, 0, b, b);
+
+                    moveBlock(data, position2, n2, tmp2, 0, b, b);
+                    transposeBlock(tmp2, 0, b, b);
+
+                    moveBlock(tmp2, 0, b, data, position1 + j, n2, b);
+                    moveBlock(tmp1, 0, b, data, position2, n2, b);
+                }
+            }
+        }
+    }
+
+    // Permute the rows of matrix to correct order, to make the n1 x n2 matrix half as wide (2*n1 x n2/2)
+    private static void permuteToHalfWidth(double[] data, int offset, int n1, int n2)
+    {
+        if (n1 < 2)
+        {
+            return;
+        }
+
+        int twicen1 = 2 * n1;
+        int halfn2 = n2 / 2;
+        double[] tmp = new double[halfn2];
+        boolean[] isRowDone = new boolean[twicen1];
+
+        int j = 1;
+        do
+        {
+            int o = j,
+                m = j;
+
+            System.arraycopy(data, offset + halfn2 * m, tmp, 0, halfn2);
+
+            isRowDone[m] = true;
+
+            m = (m < n1 ? 2 * m : 2 * (m - n1) + 1);
+
+            while (m != j)
+            {
+                isRowDone[m] = true;
+
+                System.arraycopy(data, offset + halfn2 * m, data, offset + halfn2 * o, halfn2);
+
+                o = m;
+                m = (m < n1 ? 2 * m : 2 * (m - n1) + 1);
+            }
+
+            System.arraycopy(tmp, 0, data, offset + halfn2 * o, halfn2);
+
+            while (isRowDone[j])
+            {
+                j++;
+            }
+        } while (j < twicen1 - 1);
+    }
+
+    // Permute the rows of matrix to correct order, to make the n1 x n2 matrix twice as wide (n1/2 x 2*n2)
+    private static void permuteToDoubleWidth(double[] data, int offset, int n1, int n2)
+    {
+        if (n1 < 4)
+        {
+            return;
+        }
+
+        int halfn1 = n1 / 2;
+        double[] tmp = new double[n2];
+        boolean[] isRowDone = new boolean[n1];
+
+        int j = 1;
+        do
+        {
+            int o = j,
+                m = j;
+
+            System.arraycopy(data, offset + n2 * m, tmp, 0, n2);
+
+            isRowDone[m] = true;
+
+            m = ((m & 1) != 0 ? m / 2 + halfn1 : m / 2);
+
+            while (m != j)
+            {
+                isRowDone[m] = true;
+
+                System.arraycopy(data, offset + n2 * m, data, offset + n2 * o, n2);
+
+                o = m;
+                m = ((m & 1) != 0 ? m / 2 + halfn1 : m / 2);
+            }
+
+            System.arraycopy(tmp, 0, data, offset + n2 * o, n2);
+
+            while (isRowDone[j])
+            {
+                j++;
+            }
+        } while (j < n1 - 1);
+    }
+}
Index: src/main/java/org/apfloat/internal/DoubleMediumConvolutionStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleMediumConvolutionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleMediumConvolutionStrategy.java	(revision 0)
@@ -0,0 +1,125 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ConvolutionStrategy;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.DataStorage;
+
+/**
+ * Medium-length convolution strategy.
+ * Performs a simple O(n<sup>2</sup>) multiplication when the size of one operand is relatively short.
+ *
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleMediumConvolutionStrategy
+    extends DoubleBaseMath
+    implements ConvolutionStrategy
+{
+    // Implementation notes:
+    // - Assumes that the operands have been already truncated to match resultSize (the resultSize argument is ignored)
+    // - This class probably shouldn't be converted to a single class using generics because there is some performance impact
+
+    /**
+     * Creates a convolution strategy using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public DoubleMediumConvolutionStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public DataStorage convolute(DataStorage x, DataStorage y, long resultSize)
+        throws ApfloatRuntimeException
+    {
+        DataStorage shortStorage, longStorage;
+
+        if (x.getSize() > y.getSize())
+        {
+            shortStorage = y;
+            longStorage = x;
+        }
+        else
+        {
+            shortStorage = x;
+            longStorage = y;
+        }
+
+        long shortSize = shortStorage.getSize(),
+             longSize = longStorage.getSize(),
+             size = shortSize + longSize;
+
+        if (shortSize > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Too long shorter number, size = " + shortSize);
+        }
+
+        final int bufferSize = (int) shortSize;
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        DataStorage resultStorage = dataStorageBuilder.createDataStorage(size * 8);
+        resultStorage.setSize(size);
+
+        DataStorage.Iterator src = longStorage.iterator(DataStorage.READ, longSize, 0),
+                             dst = resultStorage.iterator(DataStorage.WRITE, size, 0),
+                             tmpDst = new DataStorage.Iterator()                        // Cyclic iterator
+                             {
+                                 public void next()
+                                 {
+                                     this.position++;
+                                     this.position = (this.position == bufferSize ? 0 : this.position);
+                                 }
+
+                                 public double getDouble()
+                                 {
+                                     return this.buffer[this.position];
+                                 }
+
+                                 public void setDouble(double value)
+                                 {
+                                     this.buffer[this.position] = value;
+                                 }
+
+                                 private static final long serialVersionUID = 1L;
+
+                                 private double[] buffer = new double[bufferSize];
+                                 private int position = 0;
+                             };
+
+        for (long i = 0; i < longSize; i++)
+        {
+            DataStorage.Iterator tmpSrc = shortStorage.iterator(DataStorage.READ, shortSize, 0);        // Sub-optimal: this could be cyclic also
+
+            double factor = src.getDouble(),          // Get one word of source data
+                    carry = baseMultiplyAdd(tmpSrc, tmpDst, factor, 0, tmpDst, shortSize),
+                    result = tmpDst.getDouble();       // Least significant word of the result
+
+            dst.setDouble(result);     // Store one word of result
+
+            tmpDst.setDouble(carry);   // Set carry from calculation as new last word in cyclic buffer
+
+            tmpDst.next();              // Cycle buffer; current first word becomes last
+            src.next();
+            dst.next();
+        }
+
+        // Exhaust last words from temporary cyclic buffer and store them to result data
+        for (int i = 0; i < bufferSize; i++)
+        {
+            double result = tmpDst.getDouble();
+            dst.setDouble(result);
+
+            tmpDst.next();
+            dst.next();
+        }
+
+        return resultStorage;
+    }
+
+    private static final long serialVersionUID = 3566451570697893745L;
+}
Index: src/main/java/org/apfloat/internal/DoubleMemoryArrayAccess.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleMemoryArrayAccess.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleMemoryArrayAccess.java	(revision 0)
@@ -0,0 +1,54 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Array access class based on a <code>double[]</code>.
+ *
+ * @version 1.6.3
+ * @author Mikko Tommila
+ */
+
+public class DoubleMemoryArrayAccess
+    extends ArrayAccess
+{
+    /**
+     * Create an array access.<p>
+     *
+     * @param data The underlying array.
+     * @param offset The offset of the access segment within the array.
+     * @param length The access segment.
+     */
+
+    public DoubleMemoryArrayAccess(double[] data, int offset, int length)
+    {
+        super(offset, length);
+        this.data = data;
+    }
+
+    public ArrayAccess subsequence(int offset, int length)
+    {
+        return new DoubleMemoryArrayAccess(this.data, getOffset() + offset, length);
+    }
+
+    public Object getData()
+    {
+        return this.data;
+    }
+
+    public double[] getDoubleData()
+    {
+        return this.data;
+    }
+
+    public void close()
+        throws ApfloatRuntimeException
+    {
+        this.data = null;       // Might have an impact on garbage collection
+    }
+
+    private static final long serialVersionUID = -8917010087742357783L;
+
+    private double[] data;
+}
Index: src/main/java/org/apfloat/internal/DoubleMemoryDataStorage.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleMemoryDataStorage.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleMemoryDataStorage.java	(revision 0)
@@ -0,0 +1,287 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Memory based data storage implementation for the <code>double</code>
+ * element type.
+ *
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleMemoryDataStorage
+    extends DataStorage
+{
+    /**
+     * Default constructor.
+     */
+
+    public DoubleMemoryDataStorage()
+    {
+        this.data = new double[0];
+    }
+
+    /**
+     * Subsequence constructor.
+     *
+     * @param doubleMemoryDataStorage The originating data storage.
+     * @param offset The subsequence starting position.
+     * @param length The subsequence length.
+     */
+
+    protected DoubleMemoryDataStorage(DoubleMemoryDataStorage doubleMemoryDataStorage, long offset, long length)
+    {
+        super(doubleMemoryDataStorage, offset, length);
+        this.data = doubleMemoryDataStorage.data;
+    }
+
+    public boolean isCached()
+    {
+        return true;
+    }
+
+    protected DataStorage implSubsequence(long offset, long length)
+        throws ApfloatRuntimeException
+    {
+        return new DoubleMemoryDataStorage(this, offset + getOffset(), length);
+    }
+
+    protected void implCopyFrom(DataStorage dataStorage, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (size > 0);
+        assert (!isReadOnly());
+        assert (!isSubsequenced());
+
+        if (size > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Size too big for memory array: " + size);
+        }
+
+        if (dataStorage == this)
+        {
+            setSize(size);
+            return;
+        }
+
+        this.data = new double[(int) size];
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        int readSize = (int) Math.min(size, dataStorage.getSize()),
+            position = 0,
+            bufferSize = ctx.getBlockSize() / 8;
+
+        while (readSize > 0)
+        {
+            int length = (int) Math.min(bufferSize, readSize);
+
+            ArrayAccess arrayAccess = dataStorage.getArray(READ, position, length);
+            System.arraycopy(arrayAccess.getDoubleData(), arrayAccess.getOffset(), this.data, position, length);
+            arrayAccess.close();
+
+            readSize -= length;
+            position += length;
+       }
+    }
+
+    protected long implGetSize()
+    {
+        return this.data.length;
+    }
+
+    protected void implSetSize(long size)
+        throws ApfloatRuntimeException
+    {
+        assert (size > 0);
+        assert (!isReadOnly());
+        assert (!isSubsequenced());
+
+        if (size == this.data.length)
+        {
+            return;
+        }
+
+        if (size > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Size too big for memory array: " + size);
+        }
+
+        int newSize = (int) size;
+
+        double[] newData = new double[newSize];
+        System.arraycopy(this.data, 0, newData, 0, Math.min(this.data.length, newSize));
+        this.data = newData;
+    }
+
+    protected ArrayAccess implGetArray(int mode, long offset, int length)
+        throws ApfloatRuntimeException
+    {
+        return new DoubleMemoryArrayAccess(this.data, (int) (offset + getOffset()), length);
+    }
+
+    protected ArrayAccess implGetArray(int mode, int startColumn, int columns, int rows)
+        throws ApfloatRuntimeException
+    {
+        throw new ApfloatInternalException("Method not implemented - would be sub-optimal; change the apfloat configuration settings");
+    }
+
+    protected ArrayAccess implGetTransposedArray(int mode, int startColumn, int columns, int rows)
+        throws ApfloatRuntimeException
+    {
+        throw new ApfloatInternalException("Method not implemented - would be sub-optimal; change the apfloat configuration settings");
+    }
+
+    private class ReadWriteIterator
+        extends AbstractIterator
+    {
+        public ReadWriteIterator(long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            this(READ_WRITE, startPosition, endPosition);
+        }
+
+        protected ReadWriteIterator(int mode, long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            super(mode, startPosition, endPosition);
+
+            this.data = DoubleMemoryDataStorage.this.data;
+
+            this.position = (int) getPosition() + (int) getOffset();
+            this.length = (int) getLength();
+        }
+
+        public boolean hasNext()
+        {
+            return (this.length > 0);
+        }
+
+        public void next()
+            throws IllegalStateException
+        {
+            checkLength();
+            this.position += getIncrement();
+            this.length--;
+        }
+
+        public double getDouble()
+            throws IllegalStateException
+        {
+            checkLength();
+            return this.data[this.position];
+        }
+
+        public void setDouble(double value)
+            throws IllegalStateException
+        {
+            checkLength();
+            this.data[this.position] = value;
+        }
+
+        public <T> T get(Class<T> type)
+            throws UnsupportedOperationException, IllegalStateException
+        {
+            if (!(type.equals(Double.TYPE)))
+            {
+                throw new UnsupportedOperationException("Unsupported data type " + type.getCanonicalName() + ", the only supported type is double");
+            }
+            @SuppressWarnings("unchecked")
+            T value = (T) (Double) getDouble();
+            return value;
+        }
+
+        public <T> void set(Class<T> type, T value)
+            throws UnsupportedOperationException, IllegalArgumentException, IllegalStateException
+        {
+            if (!(type.equals(Double.TYPE)))
+            {
+                throw new UnsupportedOperationException("Unsupported data type " + type.getCanonicalName() + ", the only supported type is double");
+            }
+            if (!(value instanceof Double))
+            {
+                throw new IllegalArgumentException("Unsupported value type " + value.getClass().getCanonicalName() + ", the only supported type is Double");
+            }
+            setDouble((Double) value);
+        }
+
+        protected void checkLength()
+            throws IllegalStateException
+        {
+            if (this.length == 0)
+            {
+                throw new IllegalStateException("At the end of iterator");
+            }
+        }
+
+        private static final long serialVersionUID = -9012199261873349608L;
+
+        private double[] data;
+        private int position,
+                    length;
+    }
+
+    private class ReadOnlyIterator
+        extends ReadWriteIterator
+    {
+        public ReadOnlyIterator(long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            super(READ, startPosition, endPosition);
+        }
+
+        public void setDouble(double value)
+            throws IllegalStateException
+        {
+            throw new IllegalStateException("Not a writable iterator");
+        }
+
+        private static final long serialVersionUID = 5449985546703735328L;
+    }
+
+    private class WriteOnlyIterator
+        extends ReadWriteIterator
+    {
+        public WriteOnlyIterator(long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            super(WRITE, startPosition, endPosition);
+        }
+
+        public double getDouble()
+            throws IllegalStateException
+        {
+            throw new IllegalStateException("Not a readable iterator");
+        }
+
+        private static final long serialVersionUID = 3758519654059499404L;
+    }
+
+    public Iterator iterator(int mode, long startPosition, long endPosition)
+        throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+    {
+        Iterator iterator;
+        switch (mode & READ_WRITE)
+        {
+            case READ:
+                iterator = new ReadOnlyIterator(startPosition, endPosition);
+                break;
+            case WRITE:
+                iterator = new WriteOnlyIterator(startPosition, endPosition);
+                break;
+            case READ_WRITE:
+                iterator = new ReadWriteIterator(startPosition, endPosition);
+                break;
+            default:
+                throw new IllegalArgumentException("Illegal mode: " + mode);
+        }
+        return iterator;
+    }
+
+    private static final long serialVersionUID = 5093781604796636929L;
+
+    private double[] data;
+}
Index: src/main/java/org/apfloat/internal/DoubleModConstants.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleModConstants.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleModConstants.java	(revision 0)
@@ -0,0 +1,42 @@
+package org.apfloat.internal;
+
+/**
+ * Constants needed for various modular arithmetic operations for the <code>double</code> type.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public interface DoubleModConstants
+{
+    /**
+     * Moduli to be used in number theoretic transforms.
+     * Allows transform lengths upto 3*2<sup>43</sup>.
+     */
+
+    public static final double MODULUS[] = { 1952732650930177.0, 1899956092796929.0, 1636073302130689.0 };
+
+    /**
+     * Primitive roots for the corresponding moduli.
+     */
+
+    public static final double PRIMITIVE_ROOT[] = { 5.0, 7.0, 17.0 };
+
+    /**
+     * Maximum transform length for the moduli.
+     */
+
+    public static final long MAX_TRANSFORM_LENGTH = 26388279066624L;
+
+    /**
+     * Maximum bits in a power-of-two base that fits in a <code>double</code>.
+     */
+
+    public static final int MAX_POWER_OF_TWO_BITS = 51;
+
+    /**
+     * Maximum power-of-two base that fits in a <code>double</code>.
+     */
+
+    public static final double MAX_POWER_OF_TWO_BASE = (double) (1L << MAX_POWER_OF_TWO_BITS);
+}
Index: src/main/java/org/apfloat/internal/DoubleModMath.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleModMath.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleModMath.java	(revision 0)
@@ -0,0 +1,159 @@
+package org.apfloat.internal;
+
+/**
+ * Modulo arithmetic functions for <code>double</code> data.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleModMath
+    extends DoubleElementaryModMath
+{
+    /**
+     * Default constructor.
+     */
+
+    public DoubleModMath()
+    {
+    }
+
+    /**
+     * Create a table of powers of n:th root of unity.
+     *
+     * @param w The n:th root of unity modulo the current modulus.
+     * @param n The table length (= transform length).
+     *
+     * @return Table of <code>table[i]=w<sup>i</sup> mod m</code>, i = 0, ..., n-1.
+     */
+
+    public final double[] createWTable(double w, int n)
+    {
+        double[] wTable = new double[n];
+        double wTemp = 1;
+
+        for (int i = 0; i < n; i++)
+        {
+            wTable[i] = wTemp;
+            wTemp = modMultiply(wTemp, w);
+        }
+
+        return wTable;
+    }
+
+    /**
+     * Get forward n:th root of unity. This is <code>w</code>.<p>
+     *
+     * Assumes that the modulus is prime.
+     *
+     * @param primitiveRoot Primitive root of the modulus.
+     * @param n The transform length.
+     *
+     * @return Forward n:th root of unity.
+     */
+
+    public double getForwardNthRoot(double primitiveRoot, long n)
+    {
+        return modPow(primitiveRoot, getModulus() - 1 - (getModulus() - 1) / (double) n);
+    }
+
+    /**
+     * Get inverse n:th root of unity. This is <code>w<sup>-1</sup></code>.<p>
+     *
+     * Assumes that the modulus is prime.
+     *
+     * @param primitiveRoot Primitive root of the modulus.
+     * @param n The transform length.
+     *
+     * @return Inverse n:th root of unity.
+     */
+
+    public double getInverseNthRoot(double primitiveRoot, long n)
+    {
+        return modPow(primitiveRoot, (getModulus() - 1) / (double) n);
+    }
+
+    /**
+     * Modular inverse, that is <code>1 / a</code>. Assumes that the modulus is prime.
+     *
+     * @param a The operand.
+     *
+     * @return <code>a<sup>-1</sup> mod m</code>.
+     */
+
+    public final double modInverse(double a)
+    {
+        return modPow(a, getModulus() - 2);
+    }
+
+    /**
+     * Modular division. Assumes that the modulus is prime.
+     *
+     * @param a The dividend.
+     * @param b The divisor.
+     *
+     * @return <code>a*b<sup>-1</sup> mod m</code>.
+     */
+
+    public final double modDivide(double a, double b)
+    {
+        return modMultiply(a, modInverse(b));
+    }
+
+    /**
+     * Modular negation.
+     *
+     * @param a The argument.
+     *
+     * @return <code>-a mod m</code>.
+     */
+
+    public final double negate(double a)
+    {
+        return (a == 0 ? 0 : getModulus() - a);
+    }
+
+    /**
+     * Modular power. Assumes that the modulus is prime.
+     *
+     * @param a The base.
+     * @param n The exponent.
+     *
+     * @return <code>a<sup>n</sup> mod m</code>.
+     */
+
+    public final double modPow(double a, double n)
+    {
+        assert (a != 0 || n != 0);
+
+        if (n == 0)
+        {
+            return 1;
+        }
+        else if (n < 0)
+        {
+            return modPow(a, getModulus() - 1 + n);
+        }
+
+        long exponent = (long) n;
+
+        while ((exponent & 1) == 0)
+        {
+            a = modMultiply(a, a);
+            exponent >>= 1;
+        }
+
+        double r = a;
+
+        while ((exponent >>= 1) > 0)
+        {
+            a = modMultiply(a, a);
+            if ((exponent & 1) != 0)
+            {
+                r = modMultiply(r, a);
+            }
+        }
+
+        return r;
+    }
+}
Index: src/main/java/org/apfloat/internal/DoubleNTTBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleNTTBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleNTTBuilder.java	(revision 0)
@@ -0,0 +1,66 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.NTTStrategy;
+import org.apfloat.spi.NTTStepStrategy;
+import org.apfloat.spi.Factor3NTTStepStrategy;
+import org.apfloat.spi.NTTConvolutionStepStrategy;
+
+/**
+ * Creates Number Theoretic Transforms for the
+ * <code>double</code> type.
+ *
+ * @see DoubleTableFNTStrategy
+ * @see SixStepFNTStrategy
+ * @see TwoPassFNTStrategy
+ * @see Factor3NTTStrategy
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleNTTBuilder
+    extends AbstractNTTBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public DoubleNTTBuilder()
+    {
+    }
+
+    public NTTStepStrategy createNTTSteps()
+    {
+        return new DoubleNTTStepStrategy();
+    }
+
+    public NTTConvolutionStepStrategy createNTTConvolutionSteps()
+    {
+        return new DoubleNTTConvolutionStepStrategy();
+    }
+
+    public Factor3NTTStepStrategy createFactor3NTTSteps()
+    {
+        return new DoubleFactor3NTTStepStrategy();
+    }
+
+    protected NTTStrategy createSimpleFNTStrategy()
+    {
+        return new DoubleTableFNTStrategy();
+    }
+
+    protected NTTStrategy createSixStepFNTStrategy()
+    {
+        return new SixStepFNTStrategy();
+    }
+
+    protected NTTStrategy createTwoPassFNTStrategy()
+    {
+        return new TwoPassFNTStrategy();
+    }
+
+    protected NTTStrategy createFactor3NTTStrategy(NTTStrategy nttStrategy)
+    {
+        return new Factor3NTTStrategy(nttStrategy);
+    }
+}
Index: src/main/java/org/apfloat/internal/DoubleNTTConvolutionStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleNTTConvolutionStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleNTTConvolutionStepStrategy.java	(revision 0)
@@ -0,0 +1,186 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.NTTConvolutionStepStrategy;
+import org.apfloat.spi.DataStorage;
+import static org.apfloat.internal.DoubleModConstants.*;
+
+/**
+ * Steps of a three-NTT convolution for the <code>double</code> type.
+ * This class implements the details of the element-by-element multiplication
+ * and element-by-element squaring of the transformed elements.<p>
+ *
+ * The in-place multiplication and squaring of the data elements is done
+ * using a parallel algorithm, if the data fits in memory.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleNTTConvolutionStepStrategy
+    extends DoubleModMath
+    implements NTTConvolutionStepStrategy, Parallelizable
+{
+    // Runnable for multiplying elements in place
+    private class MultiplyInPlaceRunnable
+        implements Runnable
+    {
+        public MultiplyInPlaceRunnable(DataStorage sourceAndDestination, DataStorage source, long offset, long length)
+        {
+            this.sourceAndDestination = sourceAndDestination;
+            this.source = source;
+            this.offset = offset;
+            this.length = length;
+        }
+
+        public void run()
+        {
+            DataStorage.Iterator dest = this.sourceAndDestination.iterator(DataStorage.READ_WRITE, this.offset, this.offset + this.length),
+                                 src = this.source.iterator(DataStorage.READ, this.offset, this.offset + this.length);
+
+            while (this.length > 0)
+            {
+                dest.setDouble(modMultiply(dest.getDouble(), src.getDouble()));
+
+                dest.next();
+                src.next();
+                this.length--;
+            }
+        }
+
+        private DataStorage sourceAndDestination,
+                            source;
+        private long offset,
+                     length;
+    }
+
+    // Runnable for squaring elements in place
+    private class SquareInPlaceRunnable
+        implements Runnable
+    {
+        public SquareInPlaceRunnable(DataStorage sourceAndDestination, long offset, long length)
+        {
+            this.sourceAndDestination = sourceAndDestination;
+            this.offset = offset;
+            this.length = length;
+        }
+
+        public void run()
+        {
+            DataStorage.Iterator iterator = this.sourceAndDestination.iterator(DataStorage.READ_WRITE, this.offset, this.offset + this.length);
+
+            while (this.length > 0)
+            {
+                double value = iterator.getDouble();
+                iterator.setDouble(modMultiply(value, value));
+
+                iterator.next();
+                this.length--;
+            }
+        }
+
+        private DataStorage sourceAndDestination;
+        private long offset,
+                     length;
+    }
+
+    /**
+     * Default constructor.
+     */
+
+    public DoubleNTTConvolutionStepStrategy()
+    {
+    }
+
+    public void multiplyInPlace(DataStorage sourceAndDestination, DataStorage source, int modulus)
+        throws ApfloatRuntimeException
+    {
+        assert (sourceAndDestination != source);
+
+        long size = sourceAndDestination.getSize();
+
+        ParallelRunnable parallelRunnable = createMultiplyInPlaceParallelRunnable(sourceAndDestination, source, modulus);
+
+        if (size <= Integer.MAX_VALUE &&                                        // Only if the size fits in an integer, but with memory arrays it should
+            sourceAndDestination.isCached() && source.isCached())               // Only if the data storage supports efficient parallel random access
+        {
+            ParallelRunner.runParallel(parallelRunnable);
+        }
+        else
+        {
+            parallelRunnable.run();                                             // Just run in current thread without parallelization
+        }
+    }
+
+    public void squareInPlace(DataStorage sourceAndDestination, int modulus)
+        throws ApfloatRuntimeException
+    {
+        long size = sourceAndDestination.getSize();
+
+        ParallelRunnable parallelRunnable = createSquareInPlaceParallelRunnable(sourceAndDestination, modulus);
+
+        if (size <= Integer.MAX_VALUE &&                                    // Only if the size fits in an integer, but with memory arrays it should
+            sourceAndDestination.isCached())                                // Only if the data storage supports efficient parallel random access
+        {
+            ParallelRunner.runParallel(parallelRunnable);
+        }
+        else
+        {
+            parallelRunnable.run();                                         // Just run in current thread without parallelization
+        }
+    }
+
+    /**
+     * Create a ParallelRunnable for multiplying the elements in-place.
+     *
+     * @param sourceAndDestination The first source data storage, which is also the destination.
+     * @param source The second source data storage.
+     * @param modulus Which modulus to use (0, 1, 2)
+     *
+     * @return An object suitable for multiplying the elements in parallel.
+     */
+
+    protected ParallelRunnable createMultiplyInPlaceParallelRunnable(final DataStorage sourceAndDestination, final DataStorage source, int modulus)
+    {
+        final long size = sourceAndDestination.getSize();
+
+        setModulus(MODULUS[modulus]);
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(size)
+        {
+            public Runnable getRunnable(long offset, long length)
+            {
+                return new MultiplyInPlaceRunnable(sourceAndDestination, source, offset, length);
+            }
+        };
+        return parallelRunnable;
+    }
+
+    /**
+     * Create a ParallelRunnable for squaring the elements in-place.
+     *
+     * @param sourceAndDestination The source data storage, which is also the destination.
+     * @param modulus Which modulus to use (0, 1, 2)
+     *
+     * @return An object suitable for squaring the elements in parallel.
+     */
+
+    protected ParallelRunnable createSquareInPlaceParallelRunnable(final DataStorage sourceAndDestination, int modulus)
+    {
+        final long size = sourceAndDestination.getSize();
+
+        setModulus(MODULUS[modulus]);
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(size)
+        {
+            public Runnable getRunnable(long offset, long length)
+            {
+                return new SquareInPlaceRunnable(sourceAndDestination, offset, length);
+            }
+        };
+        return parallelRunnable;
+    }
+}
Index: src/main/java/org/apfloat/internal/DoubleNTTStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleNTTStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleNTTStepStrategy.java	(revision 0)
@@ -0,0 +1,210 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ArrayAccess;
+import org.apfloat.spi.NTTStepStrategy;
+import static org.apfloat.internal.DoubleModConstants.*;
+
+/**
+ * Common methods to calculate Fast Number Theoretic Transforms
+ * in parallel using multiple threads.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleNTTStepStrategy
+    extends DoubleTableFNT
+    implements NTTStepStrategy, Parallelizable
+{
+    // Runnable for calculating the row transforms in parallel
+    private class TableFNTRunnable
+        implements Runnable
+    {
+        public TableFNTRunnable(int length, boolean isInverse, ArrayAccess arrayAccess, double[] wTable, int[] permutationTable)
+        {
+            this.length = length;               // Transform length
+            this.isInverse = isInverse;
+            this.arrayAccess = arrayAccess;
+            this.wTable = wTable;
+            this.permutationTable = permutationTable;
+        }
+
+        public void run()
+        {
+            int maxI = this.arrayAccess.getLength();
+
+            for (int i = 0; i < maxI; i += this.length)
+            {
+                ArrayAccess arrayAccess = this.arrayAccess.subsequence(i, this.length);
+
+                if (this.isInverse)
+                {
+                    inverseTableFNT(arrayAccess, this.wTable, this.permutationTable);
+                }
+                else
+                {
+                    tableFNT(arrayAccess, this.wTable, this.permutationTable);
+                }
+            }
+        }
+
+        private int length;
+        private boolean isInverse;
+        private ArrayAccess arrayAccess;
+        private double[] wTable;
+        private int[] permutationTable;
+    }
+
+    // Runnable for multiplying elements in the matrix
+    private class MultiplyRunnable
+        implements Runnable
+    {
+        public MultiplyRunnable(ArrayAccess arrayAccess, int startRow, int startColumn, int rows, int columns, double w, double scaleFactor)
+        {
+            this.arrayAccess = arrayAccess;
+            this.startRow = startRow;
+            this.startColumn = startColumn;
+            this.rows = rows;
+            this.columns = columns;
+            this.w = w;
+            this.scaleFactor = scaleFactor;
+        }
+
+        public void run()
+        {
+            double[] data = this.arrayAccess.getDoubleData();
+            int position = this.arrayAccess.getOffset();
+            double rowFactor = modPow(this.w, (double) this.startRow);
+            double columnFactor = modPow(this.w, (double) this.startColumn);
+            double rowStartFactor = modMultiply(this.scaleFactor, modPow(rowFactor, (double) this.startColumn));
+
+            for (int i = 0; i < this.rows; i++)
+            {
+                double factor = rowStartFactor;
+
+                for (int j = 0; j < this.columns; j++, position++)
+                {
+                    data[position] = modMultiply(data[position], factor);
+                    factor = modMultiply(factor, rowFactor);
+                }
+
+                rowFactor = modMultiply(rowFactor, this.w);
+                rowStartFactor = modMultiply(rowStartFactor, columnFactor);
+            }
+         }
+
+        private ArrayAccess arrayAccess;
+        private int startRow;
+        private int startColumn;
+        private int rows;
+        private int columns;
+        private double w;
+        private double scaleFactor;
+    }
+
+    /**
+     * Default constructor.
+     */
+
+    public DoubleNTTStepStrategy()
+    {
+    }
+
+    public void multiplyElements(ArrayAccess arrayAccess, int startRow, int startColumn, int rows, int columns, long length, long totalTransformLength, boolean isInverse, int modulus)
+        throws ApfloatRuntimeException
+    {
+        ParallelRunnable parallelRunnable = createMultiplyElementsParallelRunnable(arrayAccess, startRow, startColumn, rows, columns, length, totalTransformLength, isInverse, modulus);
+
+        ParallelRunner.runParallel(parallelRunnable);
+    }
+
+    public void transformRows(ArrayAccess arrayAccess, int length, int count, boolean isInverse, boolean permute, int modulus)
+        throws ApfloatRuntimeException
+    {
+        ParallelRunnable parallelRunnable = createTransformRowsParallelRunnable(arrayAccess, length, count, isInverse, permute, modulus);
+
+        ParallelRunner.runParallel(parallelRunnable);
+    }
+
+    public long getMaxTransformLength()
+    {
+        return MAX_TRANSFORM_LENGTH;
+    }
+
+    /**
+     * Create a ParallelRunnable object for multiplying the elements of the matrix.
+     *
+     * @param arrayAccess The memory array to multiply.
+     * @param startRow Which row in the whole matrix the starting row in the <code>arrayAccess</code> is.
+     * @param startColumn Which column in the whole matrix the starting column in the <code>arrayAccess</code> is.
+     * @param rows The number of rows in the <code>arrayAccess</code> to multiply.
+     * @param columns The number of columns in the matrix (= n<sub>2</sub>).
+     * @param length The length of data in the matrix being transformed.
+     * @param totalTransformLength The total transform length, for the scaling factor. Used only for the inverse case.
+     * @param isInverse If the multiplication is done for the inverse transform or not.
+     * @param modulus Index of the modulus.
+     *
+     * @return An object suitable for multiplying the elements of the matrix in parallel.
+     */
+
+    protected ParallelRunnable createMultiplyElementsParallelRunnable(final ArrayAccess arrayAccess, final int startRow, final int startColumn, final int rows, final int columns, long length, long totalTransformLength, boolean isInverse, int modulus)
+        throws ApfloatRuntimeException
+    {
+        setModulus(MODULUS[modulus]);
+        final double w = (isInverse ?
+                           getInverseNthRoot(PRIMITIVE_ROOT[modulus], length) :
+                           getForwardNthRoot(PRIMITIVE_ROOT[modulus], length));
+        final double scaleFactor = (isInverse ?
+                                     modDivide((double) 1, (double) totalTransformLength) :
+                                     (double) 1);
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(rows)
+        {
+            public Runnable getRunnable(int strideStartRow, int strideRows)
+            {
+                ArrayAccess subArrayAccess = arrayAccess.subsequence(strideStartRow * columns, strideRows * columns);
+                return new MultiplyRunnable(subArrayAccess, startRow + strideStartRow, startColumn, strideRows, columns, w, scaleFactor);
+            }
+        };
+
+        return parallelRunnable;
+    }
+
+    /**
+     * Create a ParallelRunnable object for transforming the rows of the matrix.
+     *
+     * @param arrayAccess The memory array to split to rows and to transform.
+     * @param length Length of one transform (one row).
+     * @param count Number of rows.
+     * @param isInverse <code>true</code> if an inverse transform is performed, <code>false</code> if a forward transform is performed.
+     * @param permute If permutation should be done.
+     * @param modulus Index of the modulus.
+     *
+     * @return An object suitable for transforming the rows of the matrix in parallel.
+     */
+
+    protected ParallelRunnable createTransformRowsParallelRunnable(final ArrayAccess arrayAccess, final int length, final int count, final boolean isInverse, boolean permute, int modulus)
+        throws ApfloatRuntimeException
+    {
+        setModulus(MODULUS[modulus]);
+        final double[] wTable = (isInverse ?
+                                  DoubleWTables.getInverseWTable(modulus, length) :
+                                  DoubleWTables.getWTable(modulus, length));
+        final int[] permutationTable = (permute ? Scramble.createScrambleTable(length) : null);
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(count)
+        {
+            public Runnable getRunnable(int startIndex, int strideCount)
+            {
+                ArrayAccess subArrayAccess = arrayAccess.subsequence(startIndex * length, strideCount * length);
+                return new TableFNTRunnable(length, isInverse, subArrayAccess, wTable, permutationTable);
+            }
+        };
+
+        return parallelRunnable;
+    }
+}
Index: src/main/java/org/apfloat/internal/DoubleRadixConstants.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleRadixConstants.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleRadixConstants.java	(revision 0)
@@ -0,0 +1,36 @@
+package org.apfloat.internal;
+
+/**
+ * Constants related to different radixes for the <code>double</code> data type.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public interface DoubleRadixConstants
+{
+    /**
+     * Bases for radixes 2, ..., 36. The base is the radix to the maximum power
+     * so that the base is less than all moduli used.
+     */
+
+    public static final double BASE[] = { (double) -1L, (double) -1L, (double) 1125899906842624L, (double) 617673396283947L, (double) 1125899906842624L, (double) 476837158203125L, (double) 609359740010496L, (double) 1628413597910449L, (double) 281474976710656L, (double) 205891132094649L, (double) 1000000000000000L, (double) 379749833583241L, (double) 1283918464548864L, (double) 302875106592253L, (double) 793714773254144L, (double) 129746337890625L, (double) 281474976710656L, (double) 582622237229761L, (double) 1156831381426176L, (double) 116490258898219L, (double) 204800000000000L, (double) 350277500542221L, (double) 584318301411328L, (double) 952809757913927L, (double) 1521681143169024L, (double) 95367431640625L, (double) 141167095653376L, (double) 205891132094649L, (double) 296196766695424L, (double) 420707233300201L, (double) 590490000000000L, (double) 819628286980801L, (double) 1125899906842624L, (double) 1531578985264449L, (double) 60716992766464L, (double) 78815638671875L, (double) 101559956668416L };
+
+    /**
+     * The power of the radix in each base.
+     */
+
+    public static final int BASE_DIGITS[] = { -1, -1, 50, 31, 25, 21, 19, 18, 16, 15, 15, 14, 14, 13, 13, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9 };
+
+    /**
+     * The minimum number in each radix to have the specified amount of digits.
+     */
+
+    public static final double MINIMUM_FOR_DIGITS[][] = { null, null, { (double) 1L, (double) 2L, (double) 4L, (double) 8L, (double) 16L, (double) 32L, (double) 64L, (double) 128L, (double) 256L, (double) 512L, (double) 1024L, (double) 2048L, (double) 4096L, (double) 8192L, (double) 16384L, (double) 32768L, (double) 65536L, (double) 131072L, (double) 262144L, (double) 524288L, (double) 1048576L, (double) 2097152L, (double) 4194304L, (double) 8388608L, (double) 16777216L, (double) 33554432L, (double) 67108864L, (double) 134217728L, (double) 268435456L, (double) 536870912L, (double) 1073741824L, (double) 2147483648L, (double) 4294967296L, (double) 8589934592L, (double) 17179869184L, (double) 34359738368L, (double) 68719476736L, (double) 137438953472L, (double) 274877906944L, (double) 549755813888L, (double) 1099511627776L, (double) 2199023255552L, (double) 4398046511104L, (double) 8796093022208L, (double) 17592186044416L, (double) 35184372088832L, (double) 70368744177664L, (double) 140737488355328L, (double) 281474976710656L, (double) 562949953421312L }, { (double) 1L, (double) 3L, (double) 9L, (double) 27L, (double) 81L, (double) 243L, (double) 729L, (double) 2187L, (double) 6561L, (double) 19683L, (double) 59049L, (double) 177147L, (double) 531441L, (double) 1594323L, (double) 4782969L, (double) 14348907L, (double) 43046721L, (double) 129140163L, (double) 387420489L, (double) 1162261467L, (double) 3486784401L, (double) 10460353203L, (double) 31381059609L, (double) 94143178827L, (double) 282429536481L, (double) 847288609443L, (double) 2541865828329L, (double) 7625597484987L, (double) 22876792454961L, (double) 68630377364883L, (double) 205891132094649L }, { (double) 1L, (double) 4L, (double) 16L, (double) 64L, (double) 256L, (double) 1024L, (double) 4096L, (double) 16384L, (double) 65536L, (double) 262144L, (double) 1048576L, (double) 4194304L, (double) 16777216L, (double) 67108864L, (double) 268435456L, (double) 1073741824L, (double) 4294967296L, (double) 17179869184L, (double) 68719476736L, (double) 274877906944L, (double) 1099511627776L, (double) 4398046511104L, (double) 17592186044416L, (double) 70368744177664L, (double) 281474976710656L }, { (double) 1L, (double) 5L, (double) 25L, (double) 125L, (double) 625L, (double) 3125L, (double) 15625L, (double) 78125L, (double) 390625L, (double) 1953125L, (double) 9765625L, (double) 48828125L, (double) 244140625L, (double) 1220703125L, (double) 6103515625L, (double) 30517578125L, (double) 152587890625L, (double) 762939453125L, (double) 3814697265625L, (double) 19073486328125L, (double) 95367431640625L }, { (double) 1L, (double) 6L, (double) 36L, (double) 216L, (double) 1296L, (double) 7776L, (double) 46656L, (double) 279936L, (double) 1679616L, (double) 10077696L, (double) 60466176L, (double) 362797056L, (double) 2176782336L, (double) 13060694016L, (double) 78364164096L, (double) 470184984576L, (double) 2821109907456L, (double) 16926659444736L, (double) 101559956668416L }, { (double) 1L, (double) 7L, (double) 49L, (double) 343L, (double) 2401L, (double) 16807L, (double) 117649L, (double) 823543L, (double) 5764801L, (double) 40353607L, (double) 282475249L, (double) 1977326743L, (double) 13841287201L, (double) 96889010407L, (double) 678223072849L, (double) 4747561509943L, (double) 33232930569601L, (double) 232630513987207L }, { (double) 1L, (double) 8L, (double) 64L, (double) 512L, (double) 4096L, (double) 32768L, (double) 262144L, (double) 2097152L, (double) 16777216L, (double) 134217728L, (double) 1073741824L, (double) 8589934592L, (double) 68719476736L, (double) 549755813888L, (double) 4398046511104L, (double) 35184372088832L }, { (double) 1L, (double) 9L, (double) 81L, (double) 729L, (double) 6561L, (double) 59049L, (double) 531441L, (double) 4782969L, (double) 43046721L, (double) 387420489L, (double) 3486784401L, (double) 31381059609L, (double) 282429536481L, (double) 2541865828329L, (double) 22876792454961L }, { (double) 1L, (double) 10L, (double) 100L, (double) 1000L, (double) 10000L, (double) 100000L, (double) 1000000L, (double) 10000000L, (double) 100000000L, (double) 1000000000L, (double) 10000000000L, (double) 100000000000L, (double) 1000000000000L, (double) 10000000000000L, (double) 100000000000000L }, { (double) 1L, (double) 11L, (double) 121L, (double) 1331L, (double) 14641L, (double) 161051L, (double) 1771561L, (double) 19487171L, (double) 214358881L, (double) 2357947691L, (double) 25937424601L, (double) 285311670611L, (double) 3138428376721L, (double) 34522712143931L }, { (double) 1L, (double) 12L, (double) 144L, (double) 1728L, (double) 20736L, (double) 248832L, (double) 2985984L, (double) 35831808L, (double) 429981696L, (double) 5159780352L, (double) 61917364224L, (double) 743008370688L, (double) 8916100448256L, (double) 106993205379072L }, { (double) 1L, (double) 13L, (double) 169L, (double) 2197L, (double) 28561L, (double) 371293L, (double) 4826809L, (double) 62748517L, (double) 815730721L, (double) 10604499373L, (double) 137858491849L, (double) 1792160394037L, (double) 23298085122481L }, { (double) 1L, (double) 14L, (double) 196L, (double) 2744L, (double) 38416L, (double) 537824L, (double) 7529536L, (double) 105413504L, (double) 1475789056L, (double) 20661046784L, (double) 289254654976L, (double) 4049565169664L, (double) 56693912375296L }, { (double) 1L, (double) 15L, (double) 225L, (double) 3375L, (double) 50625L, (double) 759375L, (double) 11390625L, (double) 170859375L, (double) 2562890625L, (double) 38443359375L, (double) 576650390625L, (double) 8649755859375L }, { (double) 1L, (double) 16L, (double) 256L, (double) 4096L, (double) 65536L, (double) 1048576L, (double) 16777216L, (double) 268435456L, (double) 4294967296L, (double) 68719476736L, (double) 1099511627776L, (double) 17592186044416L }, { (double) 1L, (double) 17L, (double) 289L, (double) 4913L, (double) 83521L, (double) 1419857L, (double) 24137569L, (double) 410338673L, (double) 6975757441L, (double) 118587876497L, (double) 2015993900449L, (double) 34271896307633L }, { (double) 1L, (double) 18L, (double) 324L, (double) 5832L, (double) 104976L, (double) 1889568L, (double) 34012224L, (double) 612220032L, (double) 11019960576L, (double) 198359290368L, (double) 3570467226624L, (double) 64268410079232L }, { (double) 1L, (double) 19L, (double) 361L, (double) 6859L, (double) 130321L, (double) 2476099L, (double) 47045881L, (double) 893871739L, (double) 16983563041L, (double) 322687697779L, (double) 6131066257801L }, { (double) 1L, (double) 20L, (double) 400L, (double) 8000L, (double) 160000L, (double) 3200000L, (double) 64000000L, (double) 1280000000L, (double) 25600000000L, (double) 512000000000L, (double) 10240000000000L }, { (double) 1L, (double) 21L, (double) 441L, (double) 9261L, (double) 194481L, (double) 4084101L, (double) 85766121L, (double) 1801088541L, (double) 37822859361L, (double) 794280046581L, (double) 16679880978201L }, { (double) 1L, (double) 22L, (double) 484L, (double) 10648L, (double) 234256L, (double) 5153632L, (double) 113379904L, (double) 2494357888L, (double) 54875873536L, (double) 1207269217792L, (double) 26559922791424L }, { (double) 1L, (double) 23L, (double) 529L, (double) 12167L, (double) 279841L, (double) 6436343L, (double) 148035889L, (double) 3404825447L, (double) 78310985281L, (double) 1801152661463L, (double) 41426511213649L }, { (double) 1L, (double) 24L, (double) 576L, (double) 13824L, (double) 331776L, (double) 7962624L, (double) 191102976L, (double) 4586471424L, (double) 110075314176L, (double) 2641807540224L, (double) 63403380965376L }, { (double) 1L, (double) 25L, (double) 625L, (double) 15625L, (double) 390625L, (double) 9765625L, (double) 244140625L, (double) 6103515625L, (double) 152587890625L, (double) 3814697265625L }, { (double) 1L, (double) 26L, (double) 676L, (double) 17576L, (double) 456976L, (double) 11881376L, (double) 308915776L, (double) 8031810176L, (double) 208827064576L, (double) 5429503678976L }, { (double) 1L, (double) 27L, (double) 729L, (double) 19683L, (double) 531441L, (double) 14348907L, (double) 387420489L, (double) 10460353203L, (double) 282429536481L, (double) 7625597484987L }, { (double) 1L, (double) 28L, (double) 784L, (double) 21952L, (double) 614656L, (double) 17210368L, (double) 481890304L, (double) 13492928512L, (double) 377801998336L, (double) 10578455953408L }, { (double) 1L, (double) 29L, (double) 841L, (double) 24389L, (double) 707281L, (double) 20511149L, (double) 594823321L, (double) 17249876309L, (double) 500246412961L, (double) 14507145975869L }, { (double) 1L, (double) 30L, (double) 900L, (double) 27000L, (double) 810000L, (double) 24300000L, (double) 729000000L, (double) 21870000000L, (double) 656100000000L, (double) 19683000000000L }, { (double) 1L, (double) 31L, (double) 961L, (double) 29791L, (double) 923521L, (double) 28629151L, (double) 887503681L, (double) 27512614111L, (double) 852891037441L, (double) 26439622160671L }, { (double) 1L, (double) 32L, (double) 1024L, (double) 32768L, (double) 1048576L, (double) 33554432L, (double) 1073741824L, (double) 34359738368L, (double) 1099511627776L, (double) 35184372088832L }, { (double) 1L, (double) 33L, (double) 1089L, (double) 35937L, (double) 1185921L, (double) 39135393L, (double) 1291467969L, (double) 42618442977L, (double) 1406408618241L, (double) 46411484401953L }, { (double) 1L, (double) 34L, (double) 1156L, (double) 39304L, (double) 1336336L, (double) 45435424L, (double) 1544804416L, (double) 52523350144L, (double) 1785793904896L }, { (double) 1L, (double) 35L, (double) 1225L, (double) 42875L, (double) 1500625L, (double) 52521875L, (double) 1838265625L, (double) 64339296875L, (double) 2251875390625L }, { (double) 1L, (double) 36L, (double) 1296L, (double) 46656L, (double) 1679616L, (double) 60466176L, (double) 2176782336L, (double) 78364164096L, (double) 2821109907456L } };
+
+    /**
+     * Maximum allowed exponent for each radix.
+     */
+
+    public static final long MAX_EXPONENT[] = { -1L, -1L, 184467440737095510L, 297528130221121794L, 368934881474191026L, 439208192231179794L, 485440633518672404L, 512409557603043094L, 576460752303423481L, 614891469123651714L, 614891469123651714L, 658812288346769694L, 658812288346769694L, 709490156681136594L, 709490156681136594L, 768614336404564644L, 768614336404564644L, 768614336404564644L, 768614336404564644L, 838488366986797794L, 838488366986797794L, 838488366986797794L, 838488366986797794L, 838488366986797794L, 838488366986797794L, 922337203685477574L, 922337203685477574L, 922337203685477574L, 922337203685477574L, 922337203685477574L, 922337203685477574L, 922337203685477574L, 922337203685477574L, 922337203685477574L, 1024819115206086194L, 1024819115206086194L, 1024819115206086194L };
+}
Index: src/main/java/org/apfloat/internal/DoubleScramble.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleScramble.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleScramble.java	(revision 0)
@@ -0,0 +1,38 @@
+package org.apfloat.internal;
+
+/**
+ * Functions to perform bit-reverse ordering of <code>double</code> data.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleScramble
+{
+    private DoubleScramble()
+    {
+    }
+
+    /**
+     * Permute the data in the table to bit-reversed order.<p>
+     *
+     * The permutation table argument should contain pairs of indexes
+     * that indicate array elements whose contents are swapped.
+     *
+     * @param data The array to permute.
+     * @param offset The offset within the array to permute.
+     * @param permutationTable Table of indexes indicating, which elements in the <code>data</code> are to be swapped.
+     */
+
+    public static void scramble(double[] data, int offset, int[] permutationTable)
+    {
+        for (int k = 0; k < permutationTable.length; k += 2)
+        {
+            int i = offset + permutationTable[k],
+                j = offset + permutationTable[k + 1];
+            double tmp = data[i];
+            data[i] = data[j];
+            data[j] = tmp;
+        }
+    }
+}
Index: src/main/java/org/apfloat/internal/DoubleShortConvolutionStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleShortConvolutionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleShortConvolutionStrategy.java	(revision 0)
@@ -0,0 +1,77 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ConvolutionStrategy;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Short convolution strategy.
+ * Performs a simple multiplication when the size of one operand is 1.
+ *
+ * @version 1.1
+ * @author Mikko Tommila
+ */
+
+public class DoubleShortConvolutionStrategy
+    extends DoubleBaseMath
+    implements ConvolutionStrategy
+{
+    // Implementation notes:
+    // - Assumes that the operands have been already truncated to match resultSize (the resultSize argument is ignored)
+    // - This class shouldn't be converted to a single class using generics because the performance impact is noticeable
+
+    /**
+     * Creates a convolution strategy using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public DoubleShortConvolutionStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public DataStorage convolute(DataStorage x, DataStorage y, long resultSize)
+        throws ApfloatRuntimeException
+    {
+        DataStorage shortStorage, longStorage, resultStorage;
+
+        if (x.getSize() > 1)
+        {
+            shortStorage = y;
+            longStorage = x;
+        }
+        else
+        {
+            shortStorage = x;
+            longStorage = y;
+        }
+
+        assert (shortStorage.getSize() == 1);
+
+        long size = longStorage.getSize() + 1;
+
+        ArrayAccess arrayAccess = shortStorage.getArray(DataStorage.READ, 0, 1);
+        double factor = arrayAccess.getDoubleData()[arrayAccess.getOffset()];
+        arrayAccess.close();
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        resultStorage = dataStorageBuilder.createDataStorage(size * 8);
+        resultStorage.setSize(size);
+
+        DataStorage.Iterator src = longStorage.iterator(DataStorage.READ, size - 1, 0),
+                             dst = resultStorage.iterator(DataStorage.WRITE, size, 0);
+
+        double carry = baseMultiplyAdd(src, null, factor, 0, dst, size - 1);
+        dst.setDouble(carry);
+        dst.close();
+
+        return resultStorage;
+    }
+
+    private static final long serialVersionUID = -2048097533911386543L;
+}
Index: src/main/java/org/apfloat/internal/DoubleTableFNT.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleTableFNT.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleTableFNT.java	(revision 0)
@@ -0,0 +1,159 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Fast Number Theoretic Transform that uses lookup tables
+ * for powers of n:th root of unity and permutation indexes.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleTableFNT
+    extends DoubleModMath
+{
+    /**
+     * Default constructor.
+     */
+
+    public DoubleTableFNT()
+    {
+    }
+
+    /**
+     * Forward (Sande-Tukey) fast Number Theoretic Transform.
+     * Data length must be a power of two.
+     *
+     * @param arrayAccess The data array to transform.
+     * @param wTable Table of powers of n:th root of unity <code>w</code> modulo the current modulus.
+     * @param permutationTable Table of permutation indexes, or <code>null</code> if the data should not be permuted.
+     */
+
+    public void tableFNT(ArrayAccess arrayAccess, double[] wTable, int[] permutationTable)
+        throws ApfloatRuntimeException
+    {
+        int nn, offset, istep, mmax, r;
+        double[] data;
+
+        data   = arrayAccess.getDoubleData();
+        offset = arrayAccess.getOffset();
+        nn     = arrayAccess.getLength();
+
+        assert (nn == (nn & -nn));
+
+        if (nn < 2)
+        {
+            return;
+        }
+
+        r = 1;
+        mmax = nn >> 1;
+        while (mmax > 0)
+        {
+            istep = mmax << 1;
+
+            // Optimize first step when wr = 1
+
+            for (int i = offset; i < offset + nn; i += istep)
+            {
+                int j = i + mmax;
+                double a = data[i];
+                double b = data[j];
+                data[i] = modAdd(a, b);
+                data[j] = modSubtract(a, b);
+            }
+
+            int t = r;
+
+            for (int m = 1; m < mmax; m++)
+            {
+                for (int i = offset + m; i < offset + nn; i += istep)
+                {
+                    int j = i + mmax;
+                    double a = data[i];
+                    double b = data[j];
+                    data[i] = modAdd(a, b);
+                    data[j] = modMultiply(wTable[t], modSubtract(a, b));
+                }
+                t += r;
+            }
+            r <<= 1;
+            mmax >>= 1;
+        }
+
+        if (permutationTable != null)
+        {
+            DoubleScramble.scramble(data, offset, permutationTable);
+        }
+    }
+
+    /**
+     * Inverse (Cooley-Tukey) fast Number Theoretic Transform.
+     * Data length must be a power of two.
+     *
+     * @param arrayAccess The data array to transform.
+     * @param wTable Table of powers of n:th root of unity <code>w</code> modulo the current modulus.
+     * @param permutationTable Table of permutation indexes, or <code>null</code> if the data should not be permuted.
+     */
+
+    public void inverseTableFNT(ArrayAccess arrayAccess, double[] wTable, int[] permutationTable)
+        throws ApfloatRuntimeException
+    {
+        int nn, offset, istep, mmax, r;
+        double[] data;
+
+        data   = arrayAccess.getDoubleData();
+        offset = arrayAccess.getOffset();
+        nn     = arrayAccess.getLength();
+
+        assert (nn == (nn & -nn));
+
+        if (nn < 2)
+        {
+            return;
+        }
+
+        if (permutationTable != null)
+        {
+            DoubleScramble.scramble(data, offset, permutationTable);
+        }
+
+        r = nn;
+        mmax = 1;
+        while (nn > mmax)
+        {
+            istep = mmax << 1;
+            r >>= 1;
+
+            // Optimize first step when w = 1
+
+            for (int i = offset; i < offset + nn; i += istep)
+            {
+                int j = i + mmax;
+                double wTemp = data[j];
+                data[j] = modSubtract(data[i], wTemp);
+                data[i] = modAdd(data[i], wTemp);
+            }
+
+            int t = r;
+
+            for (int m = 1; m < mmax; m++)
+            {
+                for (int i = offset + m; i < offset + nn; i += istep)
+                {
+                    int j = i + mmax;
+                    double wTemp = modMultiply(wTable[t], data[j]);
+                    data[j] = modSubtract(data[i], wTemp);
+                    data[i] = modAdd(data[i], wTemp);
+                }
+                t += r;
+            }
+            mmax = istep;
+        }
+    }
+}
Index: src/main/java/org/apfloat/internal/DoubleTableFNTStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleTableFNTStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleTableFNTStrategy.java	(revision 0)
@@ -0,0 +1,100 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.NTTStrategy;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+import org.apfloat.spi.Util;
+import static org.apfloat.internal.DoubleModConstants.*;
+
+/**
+ * Fast Number Theoretic Transform strategy that uses lookup tables
+ * for powers of n:th root of unity and permutation indexes.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleTableFNTStrategy
+    extends DoubleTableFNT
+    implements NTTStrategy
+{
+    /**
+     * Default constructor.
+     */
+
+    public DoubleTableFNTStrategy()
+    {
+    }
+
+    public void transform(DataStorage dataStorage, int modulus)
+        throws ApfloatRuntimeException
+    {
+        long length = dataStorage.getSize();            // Transform length n
+
+        if (length > MAX_TRANSFORM_LENGTH)
+        {
+            throw new TransformLengthExceededException("Maximum transform length exceeded: " + length + " > " + MAX_TRANSFORM_LENGTH);
+        }
+        else if (length > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Maximum array length exceeded: " + length);
+        }
+
+        setModulus(MODULUS[modulus]);                                       // Modulus
+        double[] wTable = DoubleWTables.getWTable(modulus, (int) length);
+
+        ArrayAccess arrayAccess = dataStorage.getArray(DataStorage.READ_WRITE, 0, (int) length);
+
+        tableFNT(arrayAccess, wTable, null);
+
+        arrayAccess.close();
+    }
+
+    public void inverseTransform(DataStorage dataStorage, int modulus, long totalTransformLength)
+        throws ApfloatRuntimeException
+    {
+        long length = dataStorage.getSize();            // Transform length n
+
+        if (Math.max(length, totalTransformLength) > MAX_TRANSFORM_LENGTH)
+        {
+            throw new TransformLengthExceededException("Maximum transform length exceeded: " + Math.max(length, totalTransformLength) + " > " + MAX_TRANSFORM_LENGTH);
+        }
+        else if (length > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Maximum array length exceeded: " + length);
+        }
+
+        setModulus(MODULUS[modulus]);                                       // Modulus
+        double[] wTable = DoubleWTables.getInverseWTable(modulus, (int) length);
+
+        ArrayAccess arrayAccess = dataStorage.getArray(DataStorage.READ_WRITE, 0, (int) length);
+
+        inverseTableFNT(arrayAccess, wTable, null);
+
+        divideElements(arrayAccess, (double) totalTransformLength);
+
+        arrayAccess.close();
+    }
+
+    public long getTransformLength(long size)
+    {
+        return Util.round2up(size);
+    }
+
+    private void divideElements(ArrayAccess arrayAccess, double divisor)
+        throws ApfloatRuntimeException
+    {
+        double inverseFactor = modDivide((double) 1, divisor);
+        double[] data = arrayAccess.getDoubleData();
+        int length = arrayAccess.getLength(),
+            offset = arrayAccess.getOffset();
+
+        for (int i = 0; i < length; i++)
+        {
+            data[i + offset] = modMultiply(data[i + offset], inverseFactor);
+        }
+    }
+}
Index: src/main/java/org/apfloat/internal/DoubleWTables.java
===================================================================
--- src/main/java/org/apfloat/internal/DoubleWTables.java	(revision 0)
+++ src/main/java/org/apfloat/internal/DoubleWTables.java	(revision 0)
@@ -0,0 +1,86 @@
+package org.apfloat.internal;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.ConcurrentMap;
+
+import org.apfloat.internal.DoubleModMath;
+import static org.apfloat.internal.DoubleModConstants.*;
+
+/**
+ * Helper class for generating and caching tables of powers of the n:th root of unity.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class DoubleWTables
+    extends DoubleModMath
+{
+    private DoubleWTables()
+    {
+        // Default constructor
+    }
+
+    /**
+     * Get a table of powers of n:th root of unity.
+     *
+     * @param modulus The index of the modulus to be used.
+     * @param length The length of the table to be returned, i.e. n.
+     *
+     * @return The table of powers of the n:th root of unity.
+     */
+
+    public static double[] getWTable(int modulus, int length)
+    {
+        return getWTable(modulus, length, false);
+    }
+
+    /**
+     * Get a table of inverses of powers of n:th root of unity.
+     *
+     * @param modulus The index of the modulus to be used.
+     * @param length The length of the table to be returned, i.e. n.
+     *
+     * @return The table of inverses of powers of the n:th root of unity.
+     */
+
+    public static double[] getInverseWTable(int modulus, int length)
+    {
+        return getWTable(modulus, length, true);
+    }
+
+    private static double[] getWTable(int modulus, int length, boolean isInverse)
+    {
+        List<Integer> key = Arrays.asList(isInverse ? 1 : 0, modulus, length);
+        double[] wTable = DoubleWTables.cache.get(key);
+        // Do not synchronize, multiple threads may do this at the same time, but only one gets to put the value in the cache
+        if (wTable == null)
+        {
+            DoubleModMath instance = getInstance(modulus);
+            double w = (isInverse ?
+                         instance.getInverseNthRoot(PRIMITIVE_ROOT[modulus], length) :  // Inverse n:th root
+                         instance.getForwardNthRoot(PRIMITIVE_ROOT[modulus], length));  // Forward n:th root
+            wTable = instance.createWTable(w, length);
+            // Check if another thread already put the wTable in the cache; if so then use it
+            double[] value = DoubleWTables.cache.putIfAbsent(key, wTable);
+            if (value != null)
+            {
+                // Another thread did put the value in the cache so use it
+                wTable = value;
+            }
+        }
+        return wTable;
+    }
+
+    private static DoubleModMath getInstance(int modulus)
+    {
+        DoubleModMath instance = new DoubleModMath();
+        instance.setModulus(MODULUS[modulus]);
+        return instance;
+    }
+
+    // With inverses, three moduli and lengths being powers of two, the theoretical maximum map size is 2 * 3 * 30 = 180 entries
+    private static ConcurrentMap<List<Integer>, double[]> cache = new ConcurrentSoftHashMap<List<Integer>, double[]>();
+}
Index: src/main/java/org/apfloat/internal/Factor3NTTStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/Factor3NTTStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/Factor3NTTStrategy.java	(revision 0)
@@ -0,0 +1,119 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.NTTStrategy;
+import org.apfloat.spi.Factor3NTTStepStrategy;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.Util;
+
+/**
+ * A transform that implements a 3-point transform on
+ * top of another Number Theoretic Transform that does
+ * transforms of length 2<sup>n</sup>.
+ *
+ * @see Factor3NTTStepStrategy
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class Factor3NTTStrategy
+    implements NTTStrategy, Parallelizable
+{
+    /**
+     * Creates a new factor-3 transform strategy on top of an existing transform.
+     * The underlying transform needs to be capable of only doing transforms of
+     * length 2<sup>n</sup>.
+     *
+     * @param factor2Strategy The underlying transformation strategy, that can be capable of only doing radix-2 transforms.
+     */
+
+    public Factor3NTTStrategy(NTTStrategy factor2Strategy)
+    {
+        this.factor2Strategy = factor2Strategy;
+        ApfloatContext ctx = ApfloatContext.getContext();
+        this.stepStrategy = ctx.getBuilderFactory().getNTTBuilder().createFactor3NTTSteps();
+    }
+
+    public void transform(DataStorage dataStorage, int modulus)
+        throws ApfloatRuntimeException
+    {
+        long length = dataStorage.getSize(),
+             power2length = (length & -length);
+
+        if (length > this.stepStrategy.getMaxTransformLength())
+        {
+            throw new TransformLengthExceededException("Maximum transform length exceeded: " + length + " > " + this.stepStrategy.getMaxTransformLength());
+        }
+
+        if (length == power2length)
+        {
+            // Transform length is a power of two
+            this.factor2Strategy.transform(dataStorage, modulus);
+        }
+        else
+        {
+            // Transform length is three times a power of two
+            assert (length == 3 * power2length);
+
+            DataStorage dataStorage0 = dataStorage.subsequence(0, power2length),
+                        dataStorage1 = dataStorage.subsequence(power2length, power2length),
+                        dataStorage2 = dataStorage.subsequence(2 * power2length, power2length);
+
+            // Transform the columns
+            this.stepStrategy.transformColumns(dataStorage0, dataStorage1, dataStorage2, 0, power2length, power2length, length, false, modulus);
+
+            // Transform the rows
+            this.factor2Strategy.transform(dataStorage0, modulus);
+            this.factor2Strategy.transform(dataStorage1, modulus);
+            this.factor2Strategy.transform(dataStorage2, modulus);
+        }
+    }
+
+    public void inverseTransform(DataStorage dataStorage, int modulus, long totalTransformLength)
+        throws ApfloatRuntimeException
+    {
+        long length = dataStorage.getSize(),
+             power2length = (length & -length);
+
+        if (Math.max(length, totalTransformLength) > this.stepStrategy.getMaxTransformLength())
+        {
+            throw new TransformLengthExceededException("Maximum transform length exceeded: " + Math.max(length, totalTransformLength) + " > " + this.stepStrategy.getMaxTransformLength());
+        }
+
+        if (length == power2length)
+        {
+            // Transform length is a power of two
+            this.factor2Strategy.inverseTransform(dataStorage, modulus, totalTransformLength);
+        }
+        else
+        {
+            // Transform length is three times a power of two
+            assert (length == 3 * power2length);
+
+            DataStorage dataStorage0 = dataStorage.subsequence(0, power2length),
+                        dataStorage1 = dataStorage.subsequence(power2length, power2length),
+                        dataStorage2 = dataStorage.subsequence(2 * power2length, power2length);
+
+            // Transform the rows
+            this.factor2Strategy.inverseTransform(dataStorage0, modulus, totalTransformLength);
+            this.factor2Strategy.inverseTransform(dataStorage1, modulus, totalTransformLength);
+            this.factor2Strategy.inverseTransform(dataStorage2, modulus, totalTransformLength);
+
+            // Transform the columns
+            this.stepStrategy.transformColumns(dataStorage0, dataStorage1, dataStorage2, 0, power2length, power2length, length, true, modulus);
+        }
+    }
+
+    public long getTransformLength(long size)
+    {
+        // Calculates the needed transform length, that is
+        // a power of two, or three times a power of two
+        return Util.round23up(size);
+    }
+
+    private NTTStrategy factor2Strategy;
+    private Factor3NTTStepStrategy stepStrategy;
+}
Index: src/main/java/org/apfloat/internal/FloatAdditionBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatAdditionBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatAdditionBuilder.java	(revision 0)
@@ -0,0 +1,30 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.AdditionBuilder;
+import org.apfloat.spi.AdditionStrategy;
+
+/**
+ * Creates additions for the specified radix and the <code>float</code> element type.<p>
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class FloatAdditionBuilder
+    implements AdditionBuilder<Float>
+{
+    /**
+     * Default constructor.
+     */
+
+    public FloatAdditionBuilder()
+    {
+    }
+
+    public AdditionStrategy<Float> createAddition(int radix)
+    {
+        AdditionStrategy<Float> additionStrategy = new FloatAdditionStrategy(radix);
+        return additionStrategy;
+    }
+}
Index: src/main/java/org/apfloat/internal/FloatAdditionStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatAdditionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatAdditionStrategy.java	(revision 0)
@@ -0,0 +1,59 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.AdditionStrategy;
+import org.apfloat.spi.DataStorage.Iterator;
+
+/**
+ * Basic addition strategy for the <code>float</code> element type.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+public class FloatAdditionStrategy
+    extends FloatBaseMath
+    implements AdditionStrategy<Float>
+{
+    /**
+     * Creates an addition strategy using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public FloatAdditionStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public Float add(Iterator src1, Iterator src2, Float carry, Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        return baseAdd(src1, src2, carry, dst, size);
+    }
+
+    public Float subtract(Iterator src1, Iterator src2, Float carry, Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        return baseSubtract(src1, src2, carry, dst, size);
+    }
+
+    public Float multiplyAdd(Iterator src1, Iterator src2, Float src3, Float carry, Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        return baseMultiplyAdd(src1, src2, src3, carry, dst, size);
+    }
+
+    public Float divide(Iterator src1, Float src2, Float carry, Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        return baseDivide(src1, src2, carry, dst, size);
+    }
+
+    public Float zero()
+    {
+        return (float) 0;
+    }
+
+    private static final long serialVersionUID = -8811571288007744481L;
+}
Index: src/main/java/org/apfloat/internal/FloatApfloatBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatApfloatBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatApfloatBuilder.java	(revision 0)
@@ -0,0 +1,52 @@
+package org.apfloat.internal;
+
+import java.io.PushbackReader;
+import java.io.IOException;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ApfloatBuilder;
+import org.apfloat.spi.ApfloatImpl;
+
+/**
+ * Builder class for building {@link ApfloatImpl} implementations with the
+ * <code>float</code> data element type.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public class FloatApfloatBuilder
+    implements ApfloatBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public FloatApfloatBuilder()
+    {
+    }
+
+    public ApfloatImpl createApfloat(String value, long precision, int radix, boolean isInteger)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        return new FloatApfloatImpl(value, precision, radix, isInteger);
+    }
+
+    public ApfloatImpl createApfloat(long value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        return new FloatApfloatImpl(value, precision, radix);
+    }
+
+    public ApfloatImpl createApfloat(double value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        return new FloatApfloatImpl(value, precision, radix);
+    }
+
+    public ApfloatImpl createApfloat(PushbackReader in, long precision, int radix, boolean isInteger)
+        throws IOException, NumberFormatException, ApfloatRuntimeException
+    {
+        return new FloatApfloatImpl(in, precision, radix, isInteger);
+    }
+}
Index: src/main/java/org/apfloat/internal/FloatApfloatImpl.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatApfloatImpl.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatApfloatImpl.java	(revision 0)
@@ -0,0 +1,2449 @@
+package org.apfloat.internal;
+
+import java.io.ObjectInputStream;
+import java.io.PushbackReader;
+import java.io.Writer;
+import java.io.StringWriter;
+import java.io.IOException;
+
+import org.apfloat.Apfloat;
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.InfiniteExpansionException;
+import org.apfloat.OverflowException;
+import org.apfloat.spi.ApfloatImpl;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+import org.apfloat.spi.AdditionBuilder;
+import org.apfloat.spi.AdditionStrategy;
+import org.apfloat.spi.ConvolutionBuilder;
+import org.apfloat.spi.ConvolutionStrategy;
+import org.apfloat.spi.Util;
+import static org.apfloat.spi.RadixConstants.*;
+import static org.apfloat.internal.FloatRadixConstants.*;
+
+/**
+ * Immutable apfloat implementation class for the
+ * <code>float</code> data element type.<p>
+ *
+ * The associated {@link DataStorage} is assumed to be immutable also.
+ * This way performance can be improved by sharing the data storage between
+ * different <code>ApfloatImpl</code>'s and by only varying the
+ * <code>ApfloatImpl</code> specific fields, like sign, precision and exponent.<p>
+ *
+ * This implementation doesn't necessarily store any extra digits for added
+ * precision, so the last digit of any operation may be inaccurate.
+ *
+ * @version 1.8.2
+ * @author Mikko Tommila
+ */
+
+public class FloatApfloatImpl
+    extends FloatBaseMath
+    implements ApfloatImpl
+{
+    // Implementation notes:
+    // - The dataStorage must never contain leading zeros or trailing zeros
+    // - If precision is reduced then the dataStorage can contain trailing zeros (physically in the middle)
+    // - The dataStorage should not be unnecessarily subsequenced if precision is reduced e.g. to allow autoconvolution
+    // - Precision is in digits but exponent is in base units
+    private FloatApfloatImpl(int sign, long precision, long exponent, DataStorage dataStorage, int radix)
+    {
+        super(radix);
+
+        assert (sign == 0 || sign == -1 || sign == 1);
+        assert (precision > 0);
+        assert (sign != 0 || precision == Apfloat.INFINITE);
+        assert (sign != 0 || exponent == 0);
+        assert (sign != 0 || dataStorage == null);
+        assert (sign == 0 || dataStorage != null);
+        assert (exponent <= MAX_EXPONENT[radix] && exponent >= -MAX_EXPONENT[radix]);
+        assert (dataStorage == null || dataStorage.isReadOnly());
+
+        this.sign = sign;
+        this.precision = precision;
+        this.exponent = exponent;
+        this.dataStorage = dataStorage;
+        this.radix = radix;
+    }
+
+    /**
+     * Create a new <code>FloatApfloatImpl</code> instance from a String.
+     *
+     * @param value The string to be parsed to a number.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     * @param isInteger Specifies if the number to be parsed from the string is to be treated as an integer or not.
+     *
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public FloatApfloatImpl(String value, long precision, int radix, boolean isInteger)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        super(checkRadix(radix));
+
+        assert (precision == Apfloat.DEFAULT || precision > 0);
+
+        this.radix = radix;
+
+        // Default sign if not specified
+        this.sign = 1;
+
+        int startIndex = -1,
+            pointIndex = -1,
+            expIndex = -1,
+            leadingZeros = 0,
+            trailingZeros = 0,
+            digitSize = 0;
+
+        // Scan through the string looking for various things
+        for (int i = 0; i < value.length(); i++)
+        {
+            char c = value.charAt(i);
+            int digit = Character.digit(c, radix);
+
+            // Note that checking for a valid digit takes place before checking for e or E in the string
+            if (digit == -1)
+            {
+                if (i == 0 && (c == '-' || c == '+'))
+                {
+                    // Get sign
+                    this.sign = (c == '-' ? -1 : 1);
+                }
+                else if (!isInteger && c == '.' && pointIndex == -1)
+                {
+                    // Mark decimal point location
+                    pointIndex = digitSize;
+                }
+                else if (!isInteger && (c == 'e' || c == 'E') && expIndex == -1)
+                {
+                    // Mark index after which the exponent is specified
+                    expIndex = i;
+                    break;
+                }
+                else
+                {
+                    throw new NumberFormatException("Invalid character: " + c + " at position " + i);
+                }
+            }
+            else
+            {
+                if (leadingZeros == digitSize && digit == 0)
+                {
+                    // Increase number of leading zeros
+                    leadingZeros++;
+                }
+                else if (startIndex == -1)
+                {
+                    // Mark index where the significant digits start
+                    startIndex = i;
+                }
+
+                // Increase number of digits
+                digitSize++;
+
+                if (digit == 0)
+                {
+                    // Increase number of trailing zeros
+                    trailingZeros++;
+                }
+                else
+                {
+                    // Reset number of trailing zeros
+                    trailingZeros = 0;
+                }
+            }
+        }
+
+        // Check if no digits were specified
+        if (digitSize == 0)
+        {
+            throw new NumberFormatException("No digits");
+        }
+
+        // Check if this number is zero
+        if (startIndex == -1)
+        {
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Default precision is number of significant digits, if not specified
+        if (precision == Apfloat.DEFAULT)
+        {
+            assert (!isInteger);
+            precision = digitSize - leadingZeros;
+        }
+        this.precision = precision;
+
+        // Size of integer part
+        int integerSize = (pointIndex >= 0 ? pointIndex : digitSize) - leadingZeros;
+
+        // Read exponent as specified in string
+        if (expIndex >= 0)
+        {
+            // Thanks to Charles Oliver Nutter for finding this bug
+            String expString = value.substring(expIndex + 1);
+            if (expString.startsWith("+"))
+            {
+                expString = expString.substring(1);
+            }
+
+            try
+            {
+                this.exponent = Long.parseLong(expString);
+            }
+            catch (NumberFormatException nfe)
+            {
+                throw new NumberFormatException("Invalid exponent: " + expString);
+            }
+        }
+        else
+        {
+            this.exponent = 0;
+        }
+
+        // Do not allow the exponent to be too close to the limits (MIN_VALUE, MAX_VALUE), leave some slack
+        int slack = BASE_DIGITS[radix];
+
+        // Check for overflow in exponent, roughly
+        if (integerSize >= -slack && this.exponent >= Long.MAX_VALUE - integerSize - slack)
+        {
+            throw new NumberFormatException("Exponent overflow");
+        }
+        else if (integerSize <= slack && this.exponent <= Long.MIN_VALUE - integerSize + slack)
+        {
+            // Underflow
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Adjust exponent by decimal point location
+        this.exponent += integerSize;
+
+        // Exponent rounded towards positive infinity to base unit
+        long baseExp = (this.exponent + (this.exponent > 0 ? BASE_DIGITS[radix] - 1 : 0)) / BASE_DIGITS[radix];
+
+        // Check for overflow in exponent as represented in base units
+        if (baseExp > MAX_EXPONENT[this.radix])
+        {
+            throw new OverflowException("Overflow");
+        }
+        else if (baseExp < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Leading zeros in first base unit
+        int digitsInBase = (int) (baseExp * BASE_DIGITS[radix] - this.exponent);
+
+        // The stored exponent is really the one per base unit
+        this.exponent = baseExp;
+
+        // Remove leading and trailing zeros from size
+        digitSize -= leadingZeros + trailingZeros;
+
+        // Limit number of significant digits by specified precision
+        digitSize = (int) Math.min(digitSize, precision);
+
+        // Needed storage size in floats
+        int size = (int) getBasePrecision(digitSize, BASE_DIGITS[radix] - digitsInBase);
+
+        this.dataStorage = createDataStorage(size);
+        this.dataStorage.setSize(size);
+
+        // Base unit that is constructed and stored to an element of the data storage
+        float word = 0;
+
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.WRITE, 0, size);
+
+        // Set the data
+        for (int i = startIndex; digitSize > 0; i++)
+        {
+            char c = value.charAt(i);
+            if (c == '.')
+            {
+                continue;
+            }
+
+            int digit = Character.digit(c, radix);
+            word *= (float) radix;
+            word += (float) digit;
+
+            if (digitSize == 1)
+            {
+                // Last digit
+                while (digitsInBase < BASE_DIGITS[radix] - 1)
+                {
+                    // Fill last word with trailing zeros
+                    word *= (float) radix;
+                    digitsInBase++;
+                }
+            }
+
+            if (++digitsInBase == BASE_DIGITS[radix])
+            {
+                // Word is full, write word
+                digitsInBase = 0;
+                iterator.setFloat(word);
+                iterator.next();
+                word = 0;
+            }
+
+            digitSize--;
+        }
+
+        assert (!iterator.hasNext());
+
+        this.dataStorage.setReadOnly();
+    }
+
+    /**
+     * Create a new <code>FloatApfloatImpl</code> instance from a <code>long</code>.
+     *
+     * @param value The value of the number.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     *
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public FloatApfloatImpl(long value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        super(checkRadix(radix));
+
+        assert (precision > 0);
+
+        this.radix = radix;
+
+        // Faster to set now than calculate later
+        this.isOne = (value == 1 ? 1 : 0);
+
+        if (value > 0)
+        {
+            this.sign = 1;
+            value = -value;         // Calculate here as negative to handle 0x8000000000000000
+        }
+        else if (value < 0)
+        {
+            this.sign = -1;
+        }
+        else
+        {
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        this.precision = precision;
+
+        int size;
+        float[] data = new float[MAX_LONG_SIZE];
+        long longBase = (long) BASE[radix];
+
+        if (-longBase < value)
+        {
+            size = 1;                               // Nonzero
+            data[MAX_LONG_SIZE - 1] = (float) -value;
+        }
+        else
+        {
+            for (size = 0; value != 0; size++)
+            {
+                long newValue = value / longBase;
+                data[MAX_LONG_SIZE - 1 - size] = (float) (newValue * longBase - value);   // Negated here
+                value = newValue;
+            }
+        }
+
+        this.exponent = size;
+
+        this.initialDigits = getDigits(data[MAX_LONG_SIZE - size]);
+
+        // Check if precision in floats is less than size; truncate size if so
+        long basePrecision = getBasePrecision(precision, this.initialDigits);
+        if (basePrecision < size)
+        {
+            size = (int) basePrecision;
+        }
+
+        // Remove trailing zeros from data
+        while (data[MAX_LONG_SIZE - 1 - (int) this.exponent + size] == 0)
+        {
+            size--;
+        }
+
+        this.dataStorage = createDataStorage(size);
+        this.dataStorage.setSize(size);
+
+        ArrayAccess arrayAccess = this.dataStorage.getArray(DataStorage.WRITE, 0, size);
+        System.arraycopy(data, MAX_LONG_SIZE - (int) this.exponent, arrayAccess.getData(), arrayAccess.getOffset(), size);
+        arrayAccess.close();
+
+        this.dataStorage.setReadOnly();
+    }
+
+    /**
+     * Create a new <code>FloatApfloatImpl</code> instance from a <code>double</code>.
+     *
+     * @param value The value of the number.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     *
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public FloatApfloatImpl(double value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        super(checkRadix(radix));
+
+        if (Double.isInfinite(value) || Double.isNaN(value))
+        {
+            throw new NumberFormatException(value + " is not a valid number");
+        }
+
+        this.radix = radix;
+
+        if (value > 0)
+        {
+            this.sign = 1;
+        }
+        else if (value < 0)
+        {
+            this.sign = -1;
+            value = -value;
+        }
+        else
+        {
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        this.precision = precision;
+
+        int size;
+        float[] data = new float[MAX_DOUBLE_SIZE];
+        double doubleBase = (double) BASE[radix];
+
+        this.exponent = (long) Math.floor(Math.log(value) / Math.log(doubleBase));
+        // Avoid overflow in intermediate value
+        if (this.exponent > 0)
+        {
+            value *= Math.pow(doubleBase, (double) -this.exponent);
+        }
+        else if (this.exponent < 0)
+        {
+            value *= Math.pow(doubleBase, (double) (-this.exponent - MAX_DOUBLE_SIZE));
+            value *= Math.pow(doubleBase, (double) MAX_DOUBLE_SIZE);
+        }
+        this.exponent++;
+
+        if (value < 1.0)
+        {
+            // Round-off error in case the input was very close but just under the base, e.g. 9.999999999999996E-10
+            value = 1.0;
+        }
+
+        for (size = 0; size < MAX_DOUBLE_SIZE && value > 0.0; size++)
+        {
+            double tmp = Math.floor(value);
+
+            assert (tmp <= doubleBase);
+
+            if (tmp == doubleBase)
+            {
+                // Round-off error e.g. in case of the number being exactly 1/radix
+                tmp -= 1.0;
+            }
+
+            data[size] = (float) tmp;
+            value -= tmp;
+            value *= doubleBase;
+        }
+
+        this.initialDigits = getDigits(data[0]);
+
+        // Check if precision in floats is less than size; truncate size if so
+        long basePrecision = getBasePrecision(precision, this.initialDigits);
+        if (basePrecision < size)
+        {
+            size = (int) basePrecision;
+        }
+
+        // Remove trailing zeros from data
+        while (data[size - 1] == 0)
+        {
+            size--;
+        }
+
+        this.dataStorage = createDataStorage(size);
+        this.dataStorage.setSize(size);
+
+        ArrayAccess arrayAccess = this.dataStorage.getArray(DataStorage.WRITE, 0, size);
+        System.arraycopy(data, 0, arrayAccess.getData(), arrayAccess.getOffset(), size);
+        arrayAccess.close();
+
+        this.dataStorage.setReadOnly();
+    }
+
+    private static long readExponent(PushbackReader in)
+        throws IOException, NumberFormatException
+    {
+        StringBuilder buffer = new StringBuilder(20);
+        int input;
+
+        for (long i = 0; (input = in.read()) != -1; i++)
+        {
+            char c = (char) input;
+            int digit = Character.digit(c, 10);         // Exponent is always in base 10
+
+            if (i == 0 && c == '-' ||
+                digit != -1)
+            {
+                buffer.append(c);
+            }
+            else
+            {
+                // Stop at first invalid character and put it back
+                in.unread(input);
+                break;
+            }
+        }
+
+        return Long.parseLong(buffer.toString());
+    }
+
+    /**
+     * Create a new <code>FloatApfloatImpl</code> instance reading from a stream.<p>
+     *
+     * Implementation note: this constructor calls the <code>in</code> stream's
+     * single-character <code>read()</code> method. If the underlying stream doesn't
+     * explicitly implement this method in some efficient way, but simply inherits it
+     * from the <code>Reader</code> base class, performance will suffer as the default
+     * <code>Reader</code> method creates a <code>new char[1]</code> on every call to
+     * <code>read()</code>.
+     *
+     * @param in The stream to read from.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     * @param isInteger Specifies if the number to be parsed from the stream is to be treated as an integer or not.
+     *
+     * @exception java.io.IOException If an I/O error occurs accessing the stream.
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public FloatApfloatImpl(PushbackReader in, long precision, int radix, boolean isInteger)
+        throws IOException, NumberFormatException, ApfloatRuntimeException
+    {
+        super(checkRadix(radix));
+
+        assert (precision == Apfloat.DEFAULT || precision > 0);
+
+        this.radix = radix;
+
+        // Default sign if not specified
+        this.sign = 1;
+
+        // Allocate a maximum memory block, since we don't know how much data to expect
+        ApfloatContext ctx = ApfloatContext.getContext();
+        long initialSize = ctx.getMemoryThreshold() / 4,
+             previousAllocatedSize = 0,
+             allocatedSize = initialSize;
+        this.dataStorage = createDataStorage(initialSize);
+        this.dataStorage.setSize(initialSize);
+
+        // Base unit that is constructed and stored to an element of the data storage
+        float word = 0;
+
+        // Number of digits stored in word
+        int digitsInBase = 0;
+
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.WRITE, previousAllocatedSize, allocatedSize);
+
+        int input;
+        long actualSize = 0,
+             startIndex = -1,
+             pointIndex = -1,
+             leadingZeros = 0,
+             trailingZeros = 0,
+             digitSize = 0;
+
+        // Scan through the string looking for various things
+        for (long i = 0; (input = in.read()) != -1; i++)
+        {
+            char c = (char) input;
+            int digit = Character.digit(c, radix);
+
+            // Note that checking for a valid digit takes place before checking for e or E in the string
+            if (digit == -1)
+            {
+                if (i == 0 && (c == '-' || c == '+'))
+                {
+                    // Get sign
+                    this.sign = (c == '-' ? -1 : 1);
+                }
+                else if (!isInteger && c == '.' && pointIndex == -1)
+                {
+                    // Mark decimal point location
+                    pointIndex = digitSize;
+                }
+                else if (!isInteger && digitSize > 0 && (c == 'e' || c == 'E'))
+                {
+                    // Read the exponent and stop
+                    this.exponent = readExponent(in);
+                    break;
+                }
+                else
+                {
+                    // Stop at first invalid character and put it back
+                    in.unread(input);
+                    break;
+                }
+            }
+            else
+            {
+                if (leadingZeros == digitSize && digit == 0)
+                {
+                    // Increase number of leading zeros
+                    leadingZeros++;
+                }
+                else
+                {
+                    if (startIndex == -1)
+                    {
+                        // Mark index where the significant digits start
+                        startIndex = i;
+                    }
+
+                    // Set the data
+                    word *= (float) radix;
+                    word += (float) digit;
+
+                    // Reallocate storage if needed; done here to prepare storing last (partial) word
+                    if (actualSize == allocatedSize)
+                    {
+                        if (actualSize == initialSize)
+                        {
+                            // Maximum memory block size exceeded; prepare to allocate anything
+                            DataStorage dataStorage = createDataStorage(Long.MAX_VALUE / 4);
+                            dataStorage.copyFrom(this.dataStorage, actualSize);
+                            this.dataStorage = dataStorage;
+                        }
+                        previousAllocatedSize = allocatedSize;
+                        allocatedSize += getBlockSize();
+                        this.dataStorage.setSize(allocatedSize);
+                        iterator.close();
+                        iterator = this.dataStorage.iterator(DataStorage.WRITE, previousAllocatedSize, allocatedSize);
+                    }
+
+                    if (++digitsInBase == BASE_DIGITS[radix])
+                    {
+                        // Word is full, write word
+                        digitsInBase = 0;
+                        iterator.setFloat(word);
+                        iterator.next();
+                        word = 0;
+                        actualSize++;
+                    }
+                }
+
+                // Increase number of digits
+                digitSize++;
+
+                if (digit == 0)
+                {
+                    // Increase number of trailing zeros
+                    trailingZeros++;
+                }
+                else
+                {
+                    // Reset number of trailing zeros
+                    trailingZeros = 0;
+                }
+            }
+        }
+
+        // Check if no digits were specified
+        if (digitSize == 0)
+        {
+            throw new NumberFormatException("No digits");
+        }
+
+        // Check if this number is zero
+        if (startIndex == -1)
+        {
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Handle last word
+        if (digitsInBase > 0 && word != 0)
+        {
+            // Last digit
+            while (digitsInBase < BASE_DIGITS[radix])
+            {
+                // Fill last word with trailing zeros
+                word *= (float) radix;
+                digitsInBase++;
+            }
+
+            // Write word
+            iterator.setFloat(word);
+            actualSize++;
+        }
+
+        iterator.close();
+
+        // Default precision is number of significant digits, if not specified
+        if (precision == Apfloat.DEFAULT)
+        {
+            assert (!isInteger);
+            precision = digitSize - leadingZeros;
+        }
+        this.precision = precision;
+
+        // Size of integer part
+        long integerSize = (pointIndex >= 0 ? pointIndex : digitSize) - leadingZeros;
+
+        // Do not allow the exponent to be too close to the limits (MIN_VALUE, MAX_VALUE), leave some slack
+        int slack = BASE_DIGITS[radix];
+
+        // Check for overflow in exponent, roughly
+        if (integerSize >= -slack && this.exponent >= Long.MAX_VALUE - integerSize - slack)
+        {
+            throw new NumberFormatException("Exponent overflow");
+        }
+        else if (integerSize <= slack && this.exponent <= Long.MIN_VALUE - integerSize + slack)
+        {
+            // Underflow
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Adjust exponent by decimal point location
+        this.exponent += integerSize;
+
+        // Exponent rounded towards negative infinity to base unit
+        long baseExp = (this.exponent - (this.exponent < 0 ? BASE_DIGITS[radix] - 1 : 0)) / BASE_DIGITS[radix];
+
+        // Check for overflow in exponent as represented in base units
+        if (baseExp > MAX_EXPONENT[this.radix])
+        {
+            throw new OverflowException("Overflow");
+        }
+        else if (baseExp < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // How much the data needs to be shifted
+        int bias = (int) (this.exponent - baseExp * BASE_DIGITS[radix]);
+
+        // The stored exponent is really the one per base unit
+        this.exponent = baseExp;
+
+        // Remove leading and trailing zeros from size
+        digitSize -= leadingZeros + trailingZeros;
+
+        // Limit number of significant digits by specified precision
+        digitSize = Math.min(digitSize, precision);
+
+        // Needed storage size in floats
+        actualSize = (digitSize + BASE_DIGITS[radix] - 1) / BASE_DIGITS[radix];
+
+        // Truncate allocated space to actually used amount
+        this.dataStorage.setSize(actualSize);
+
+        this.dataStorage.setReadOnly();
+
+        if (bias != 0)
+        {
+            // Shift by bias
+            long factor = 1;
+
+            for (int i = 0; i < bias; i++)
+            {
+                factor *= radix;
+            }
+
+            FloatApfloatImpl tmp = (FloatApfloatImpl) multiply(new FloatApfloatImpl(factor, Apfloat.INFINITE, radix));
+
+            this.exponent = tmp.exponent;
+            this.dataStorage = tmp.dataStorage;
+            this.initialDigits = UNDEFINED;     // Needs to be reset
+        }
+    }
+
+    // Returns number of trailing zeros before specified index
+    private static long getTrailingZeros(DataStorage dataStorage, long index)
+        throws ApfloatRuntimeException
+    {
+        long count = 0;
+
+        DataStorage.Iterator iterator = dataStorage.iterator(DataStorage.READ, index, 0);
+
+        while (iterator.hasNext())
+        {
+            if (iterator.getFloat() != 0)
+            {
+                iterator.close();
+                break;
+            }
+
+            iterator.next();
+            count++;
+        }
+
+        return count;
+    }
+
+    // Returns number of leading zeros starting from specified index
+    private static long getLeadingZeros(DataStorage dataStorage, long index)
+        throws ApfloatRuntimeException
+    {
+        long count = 0;
+
+        DataStorage.Iterator iterator = dataStorage.iterator(DataStorage.READ, index, dataStorage.getSize());
+
+        while (iterator.hasNext())
+        {
+            if (iterator.getFloat() != 0)
+            {
+                iterator.close();
+                break;
+            }
+
+            iterator.next();
+            count++;
+        }
+
+        return count;
+    }
+
+    public ApfloatImpl addOrSubtract(ApfloatImpl x, boolean subtract)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof FloatApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        FloatApfloatImpl that = (FloatApfloatImpl) x;
+
+        if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot use numbers with different radixes: " + this.radix + " and " + that.radix);
+        }
+
+        assert (this.sign != 0);
+        assert (that.sign != 0);
+
+        int realThatSign = (subtract ? -that.sign : that.sign);
+        boolean reallySubtract = (this.sign != realThatSign);
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        AdditionBuilder<Float> additionBuilder = ctx.getBuilderFactory().getAdditionBuilder(Float.TYPE);
+        AdditionStrategy<Float> additionStrategy = additionBuilder.createAddition(this.radix);
+
+        int sign;
+        long exponent,
+             precision;
+        DataStorage dataStorage;
+
+        if (this == that)
+        {
+            if (reallySubtract)
+            {
+                // x - x = 0
+
+                return zero();
+            }
+            else
+            {
+                // x + x = 2 * x
+
+                sign = this.sign;
+                exponent = this.exponent;
+                precision = this.precision;
+                long size = getSize() + 1;
+
+                dataStorage = createDataStorage(size);
+                dataStorage.setSize(size);
+
+                DataStorage.Iterator src1 = this.dataStorage.iterator(DataStorage.READ, size - 1, 0),
+                                     src2 = this.dataStorage.iterator(DataStorage.READ, size - 1, 0),   // Sub-optimal: could be the same
+                                     dst = dataStorage.iterator(DataStorage.WRITE, size, 0);
+
+                float carry = additionStrategy.add(src1, src2, (float) 0, dst, size - 1);
+
+                dst.setFloat(carry);
+                dst.close();
+
+                size -= getTrailingZeros(dataStorage, size);
+
+                // Check if carry occurred
+                int carrySize = (int) carry,
+                    leadingZeros = 1 - carrySize;
+
+                dataStorage = dataStorage.subsequence(leadingZeros, size - leadingZeros);
+                exponent += carrySize;
+
+                if (this.exponent == MAX_EXPONENT[this.radix] && carrySize > 0)
+                {
+                    throw new OverflowException("Overflow");
+                }
+
+                if (precision != Apfloat.INFINITE &&
+                    (carrySize > 0 || getInitialDigits(dataStorage) > getInitialDigits()))
+                {
+                    // Carry overflow for most significant digit; number of significant digits increases by one
+                    precision++;
+                }
+            }
+        }
+        else
+        {
+            // Now this != that
+
+            int comparison;
+            if (scale() > that.scale())
+            {
+                comparison = 1;
+            }
+            else if (scale() < that.scale())
+            {
+                comparison = -1;
+            }
+            else if (reallySubtract)
+            {
+                comparison = compareMantissaTo(that);           // Might be sub-optimal, but a more efficient algorithm would be complicated
+            }
+            else
+            {
+                comparison = 1;                                 // Add equally big numbers; arbitrarily choose one
+            }
+
+            FloatApfloatImpl big,
+                               small;
+
+            if (comparison > 0)
+            {
+                big = this;
+                small = that;
+                sign = this.sign;
+            }
+            else if (comparison < 0)
+            {
+                big = that;
+                small = this;
+                sign = realThatSign;
+            }
+            else
+            {
+                // x - x = 0
+                return zero();
+            }
+
+            long scaleDifference = big.scale() - small.scale(),
+                 exponentDifference,
+                 size,
+                 bigSize,
+                 smallSize;
+
+            if (scaleDifference < 0)
+            {
+                // Small number is completely insignificantly small compared to big
+                precision = big.precision;
+                exponent = big.exponent;
+                bigSize = big.getSize();
+                smallSize = 0;
+                size = bigSize;
+                exponentDifference = bigSize;
+            }
+            else
+            {
+                precision = Math.min(big.precision, Util.ifFinite(small.precision, scaleDifference + small.precision)); // Detects overflow also
+                long basePrecision = Math.min(MAX_EXPONENT[this.radix], getBasePrecision(precision, big.getInitialDigits()));
+                exponent = big.exponent;
+
+                exponentDifference = big.exponent - small.exponent;
+                size = Math.min(basePrecision, Math.max(big.getSize(), exponentDifference + small.getSize()));
+                bigSize = Math.min(size, big.getSize());
+                smallSize = Math.max(0, Math.min(size - exponentDifference, small.getSize()));
+            }
+
+            long dstSize = size + 1;                    // One extra word for carry overflow
+            dataStorage = createDataStorage(dstSize);
+            dataStorage.setSize(dstSize);
+
+            DataStorage.Iterator src1 = big.dataStorage.iterator(DataStorage.READ, bigSize, 0),
+                                 src2 = small.dataStorage.iterator(DataStorage.READ, smallSize, 0),
+                                 dst = dataStorage.iterator(DataStorage.WRITE, dstSize, 0);
+
+            float carry = 0;
+
+            // big:       XXXXXXXX               XXXX
+            // small:         XXXXXXXX        or         XXXX
+            // This part:         XXXX                   XXXX
+            if (size > bigSize)
+            {
+                long blockSize = Math.min(size - bigSize, smallSize);
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(null, src2, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(null, src2, carry, dst, blockSize);
+                }
+            }
+            // big:        XXXXXXXXXXXX
+            // small:          XXXX
+            // This part:          XXXX
+            else if (size > exponentDifference + smallSize)
+            {
+                long blockSize = size - exponentDifference - smallSize;
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(src1, null, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(src1, null, carry, dst, blockSize);
+                }
+            }
+            // big:        XXXX
+            // small:              XXXX
+            // This part:      XXXX
+            if (exponentDifference > bigSize)
+            {
+                long blockSize = exponentDifference - bigSize;
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(null, null, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(null, null, carry, dst, blockSize);
+                }
+            }
+            // big:        XXXXXXXX               XXXXXXXXXXXX
+            // small:          XXXXXXXX        or     XXXX
+            // This part:      XXXX                   XXXX
+            else if (bigSize > exponentDifference)
+            {
+                long blockSize = Math.min(bigSize - exponentDifference, smallSize);
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(src1, src2, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(src1, src2, carry, dst, blockSize);
+                }
+            }
+            // big:        XXXXXXXX               XXXXXXXXXXXX           XXXX
+            // small:          XXXXXXXX        or     XXXX            or         XXXX
+            // This part:  XXXX                   XXXX                   XXXX
+            if (exponentDifference > 0)
+            {
+                long blockSize = Math.min(bigSize, exponentDifference);
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(src1, null, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(src1, null, carry, dst, blockSize);
+                }
+            }
+
+            // Set most significant word
+            dst.setFloat(carry);
+            dst.close();
+
+            long leadingZeros;
+
+            if (reallySubtract)
+            {
+                // Get denormalization
+                leadingZeros = getLeadingZeros(dataStorage, 0);
+
+                assert (leadingZeros <= size);
+            }
+            else
+            {
+                // Check if carry occurred up to and including most significant word
+                leadingZeros = (carry == 0 ? 1 : 0);
+
+                if (this.exponent == MAX_EXPONENT[this.radix] && leadingZeros == 0)
+                {
+                    throw new OverflowException("Overflow");
+                }
+            }
+
+            dstSize -= getTrailingZeros(dataStorage, dstSize);
+
+            dataStorage = dataStorage.subsequence(leadingZeros, dstSize - leadingZeros);
+            exponent += 1 - leadingZeros;
+
+            if (exponent < -MAX_EXPONENT[this.radix])
+            {
+                // Underflow
+                return zero();
+            }
+
+            if (precision != Apfloat.INFINITE)
+            {
+                // If scale of number changes, the number of significant digits changes accordingly
+                long scaleChange = (1 - leadingZeros) * BASE_DIGITS[this.radix] + getInitialDigits(dataStorage) - big.getInitialDigits();
+                if (-scaleChange >= precision)
+                {
+                    // All significant digits were lost anyway, due to trailing garbage digits
+                    return zero();
+                }
+                precision += scaleChange;
+                precision = (precision <= 0 ? Apfloat.INFINITE : precision);    // Detect overflow
+            }
+        }
+
+        dataStorage.setReadOnly();
+
+        return new FloatApfloatImpl(sign, precision, exponent, dataStorage, this.radix);
+    }
+
+    public ApfloatImpl multiply(ApfloatImpl x)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof FloatApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        FloatApfloatImpl that = (FloatApfloatImpl) x;
+
+        if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot multiply numbers with different radixes: " + this.radix + " and " + that.radix);
+        }
+
+        int sign = this.sign * that.sign;
+
+        if (sign == 0)
+        {
+            return zero();
+        }
+
+        long exponent = this.exponent + that.exponent;
+
+        if (exponent > MAX_EXPONENT[this.radix])
+        {
+            throw new OverflowException("Overflow");
+        }
+        else if (exponent < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            return zero();
+        }
+
+        long precision = Math.min(this.precision, that.precision),
+             basePrecision = getBasePrecision(precision, 0),            // Round up
+             thisSize = getSize(),
+             thatSize = that.getSize(),
+             size = Math.min(Util.ifFinite(basePrecision, basePrecision + 1), thisSize + thatSize),     // Reserve one extra word for carry
+             thisDataSize = Math.min(thisSize, basePrecision),
+             thatDataSize = Math.min(thatSize, basePrecision);
+
+        DataStorage thisDataStorage = this.dataStorage.subsequence(0, thisDataSize),
+                    thatDataStorage = (this.dataStorage == that.dataStorage ?
+                                       thisDataStorage :                                                // Enable auto-convolution
+                                       that.dataStorage.subsequence(0, thatDataSize));
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        ConvolutionBuilder convolutionBuilder = ctx.getBuilderFactory().getConvolutionBuilder();
+        ConvolutionStrategy convolutionStrategy = convolutionBuilder.createConvolution(this.radix, thisDataSize, thatDataSize, size);
+
+        // Possibly sub-optimal: could look up trailing zeros of the subsequences
+        DataStorage dataStorage = convolutionStrategy.convolute(thisDataStorage, thatDataStorage, size);
+
+        // Check if carry occurred up to and including most significant word
+        int leadingZeros = (getMostSignificantWord(dataStorage) == 0 ? 1 : 0);
+
+        exponent -= leadingZeros;
+
+        if (exponent < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            return zero();
+        }
+
+        size -= leadingZeros;
+        dataStorage = dataStorage.subsequence(leadingZeros, size);
+
+        size = Math.min(size, getBasePrecision(precision, getInitialDigits(dataStorage)));
+        size -= getTrailingZeros(dataStorage, size);
+
+        dataStorage = dataStorage.subsequence(0, size);
+
+        dataStorage.setReadOnly();
+
+        return new FloatApfloatImpl(sign, precision, exponent, dataStorage, this.radix);
+    }
+
+    public boolean isShort()
+        throws ApfloatRuntimeException
+    {
+        return (this.sign == 0 || getSize() == 1);
+    }
+
+    public ApfloatImpl divideShort(ApfloatImpl x)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof FloatApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        FloatApfloatImpl that = (FloatApfloatImpl) x;
+
+        if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot divide numbers with different radixes: " + this.radix + " and " + that.radix);
+        }
+
+        assert (this.sign != 0);
+        assert (that.sign != 0);
+
+        int sign = this.sign * that.sign;
+
+        long exponent = this.exponent - that.exponent + 1;
+
+        if (exponent > MAX_EXPONENT[this.radix])
+        {
+            throw new OverflowException("Overflow");
+        }
+        else if (exponent < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            return zero();
+        }
+
+        long precision = Math.min(this.precision, that.precision),
+             basePrecision = getBasePrecision(),
+             thisDataSize = Math.min(getSize(), basePrecision);
+
+        DataStorage dataStorage;
+
+        float divisor = getMostSignificantWord(that.dataStorage);
+
+        if (divisor == (float) 1)
+        {
+            long size = thisDataSize - getTrailingZeros(this.dataStorage, thisDataSize);
+
+            dataStorage = this.dataStorage.subsequence(0, size);
+        }
+        else
+        {
+            ApfloatContext ctx = ApfloatContext.getContext();
+            AdditionBuilder<Float> additionBuilder = ctx.getBuilderFactory().getAdditionBuilder(Float.TYPE);
+            AdditionStrategy<Float> additionStrategy = additionBuilder.createAddition(this.radix);
+
+            long size;
+            float carry;
+
+            // Check for finite or infinite result sequence
+            float dividend = divisor;
+
+            // Check that the factorization of the divisor consists entirely of factors of the base
+            // E.g. if base is 10=2*5 then the divisor should be 2^n*5^m
+            for (int i = 0; i < RADIX_FACTORS[this.radix].length; i++)
+            {
+                float factor = RADIX_FACTORS[this.radix][i],
+                        quotient;
+
+                // Keep dividing by factor as long as dividend % factor == 0
+                // that is remove factors of the base from the divisor
+                while ((dividend - factor * (quotient = (float) (long) (dividend / factor))) == 0)
+                {
+                    dividend = quotient;
+                }
+            }
+
+            // Check if the divisor was factored all the way to one by just dividing by factors of the base
+            if (dividend != (float) 1)
+            {
+                // Divisor does not contain only factors of the base; infinite nonzero sequence
+
+                if (basePrecision == Apfloat.INFINITE)
+                {
+                    throw new InfiniteExpansionException("Cannot perform inexact division to infinite precision");
+                }
+
+                size = basePrecision;
+            }
+            else
+            {
+                // Divisor contains only factors of the base; calculate maximum sequence length
+                carry = (float) 1;
+                DataStorage.Iterator dummy = new DataStorage.Iterator()
+                {
+                    public void setFloat(float value) {}
+                    public void next() {}
+                    private static final long serialVersionUID = 1L;
+                };
+                long sequenceSize;
+                for (sequenceSize = 0; carry != 0; sequenceSize++)
+                {
+                    carry = additionStrategy.divide(null, divisor, carry, dummy, 1);
+                }
+
+                size = Math.min(basePrecision, thisDataSize + sequenceSize);
+            }
+
+            // One extra word for result in case the initial word becomes zero; to avoid loss of precision
+            size++;
+
+            dataStorage = createDataStorage(size);
+            dataStorage.setSize(size);
+
+            DataStorage.Iterator src = this.dataStorage.iterator(DataStorage.READ, 0, thisDataSize),
+                                 dst = dataStorage.iterator(DataStorage.WRITE, 0, size);
+
+            // Perform actual division
+            carry = additionStrategy.divide(src, divisor, (float) 0, dst, thisDataSize);
+
+            // Produce the trailing sequence of digits due to inexact division
+            carry = additionStrategy.divide(null, divisor, carry, dst, size - thisDataSize);
+
+            size -= getTrailingZeros(dataStorage, size);
+
+            // Check if initial word of result is zero
+            int leadingZeros = (getMostSignificantWord() < divisor ? 1 : 0);
+
+            dataStorage = dataStorage.subsequence(leadingZeros, size - leadingZeros);
+            exponent -= leadingZeros;
+
+            if (exponent < -MAX_EXPONENT[this.radix])
+            {
+                // Underflow
+                return zero();
+            }
+
+            dataStorage.setReadOnly();
+        }
+
+        return new FloatApfloatImpl(sign, precision, exponent, dataStorage, this.radix);
+    }
+
+    public ApfloatImpl absFloor()
+        throws ApfloatRuntimeException
+    {
+        if (this.sign == 0 ||
+            this.exponent >= this.dataStorage.getSize())        // Is integer already, with no extra hidden trailing digits
+        {
+            return precision(Apfloat.INFINITE);
+        }
+        else if (this.exponent <= 0)                            // Is less than one in absolute value
+        {
+            return zero();
+        }
+
+        long size = this.exponent;                              // Size of integer part, now that this.dataStorage.getSize() > this.exponent
+        size -= getTrailingZeros(this.dataStorage, size);
+
+        DataStorage dataStorage = this.dataStorage.subsequence(0, size);
+
+        ApfloatImpl apfloatImpl = new FloatApfloatImpl(this.sign, Apfloat.INFINITE, this.exponent, dataStorage, this.radix);
+
+        return apfloatImpl;
+    }
+
+    public ApfloatImpl absCeil()
+        throws ApfloatRuntimeException
+    {
+        if (this.sign == 0)
+        {
+            return this;
+        }
+
+        long exponent;
+        DataStorage dataStorage;
+        DataStorage.Iterator iterator = null;
+
+        if (this.exponent <= 0)
+        {
+            // Number is < 1 but > 0; result is one
+            int size = 1;
+            dataStorage = createDataStorage(size);
+            dataStorage.setSize(size);
+            ArrayAccess arrayAccess = dataStorage.getArray(DataStorage.WRITE, 0, size);
+            arrayAccess.getFloatData()[arrayAccess.getOffset()] = (float) 1;
+            arrayAccess.close();
+
+            exponent = 1;
+        }
+        else if (getSize() <= this.exponent ||          // Check if the fractional part is nonzero
+                 findMismatch(iterator = getZeroPaddedIterator(this.exponent, getSize()), ZERO_ITERATOR, getSize() - this.exponent) < 0)
+        {
+            // Fractional part is zero; the result is the number itself (to infinite precision)
+            long size = Math.min(this.dataStorage.getSize(), this.exponent);
+            size -= getTrailingZeros(this.dataStorage, size);
+            dataStorage = this.dataStorage.subsequence(0, size);        // Ensure truncation
+
+            exponent = this.exponent;
+        }
+        else
+        {
+            // Fractional part is nonzero; round up
+
+            ApfloatContext ctx = ApfloatContext.getContext();
+            AdditionBuilder<Float> additionBuilder = ctx.getBuilderFactory().getAdditionBuilder(Float.TYPE);
+            AdditionStrategy<Float> additionStrategy = additionBuilder.createAddition(this.radix);
+
+            long size = this.exponent;                  // Size of integer part
+            dataStorage = createDataStorage(size + 1);     // Reserve room for carry overflow
+            dataStorage.setSize(size + 1);
+            DataStorage.Iterator src = this.dataStorage.iterator(DataStorage.READ, size, 0),
+                                 dst = dataStorage.iterator(DataStorage.WRITE, size + 1, 0);
+            float carry = additionStrategy.add(src, null, (float) 1, dst, size);     // Add carry
+            dst.setFloat(carry);                      // Set leading float as overflow carry
+            src.close();
+            dst.close();
+            int carrySize = (int) carry;                // For adjusting size, if carry did overflow or not
+            size -= getTrailingZeros(dataStorage, size + 1);
+            dataStorage = dataStorage.subsequence(1 - carrySize, size + carrySize);
+
+            exponent = this.exponent + carrySize;
+        }
+
+        if (iterator != null)
+        {
+            iterator.close();
+        }
+
+        dataStorage.setReadOnly();
+
+        ApfloatImpl apfloatImpl = new FloatApfloatImpl(this.sign, Apfloat.INFINITE, exponent, dataStorage, this.radix);
+
+        return apfloatImpl;
+    }
+
+    public ApfloatImpl frac()
+        throws ApfloatRuntimeException
+    {
+        if (this.sign == 0 ||
+            this.exponent <= 0)                                 // Is less than one in absolute value already
+        {
+            return this;
+        }
+        if (this.exponent >= getSize())                         // Is an integer, fractional part is zero
+        {
+            return zero();
+        }
+
+        long size = this.dataStorage.getSize() - this.exponent; // Size of fractional part, now that getSize() > this.exponent
+        long leadingZeros = getLeadingZeros(this.dataStorage, this.exponent);
+        if (this.exponent + leadingZeros >= getSize())
+        {
+            // All significant digits were lost, only trailing garbage digits
+            return zero();
+        }
+
+        DataStorage dataStorage = this.dataStorage.subsequence(this.exponent + leadingZeros, size - leadingZeros);
+
+        long precision;
+        if (this.precision != Apfloat.INFINITE)
+        {
+            // Precision is reduced as the integer part is omitted, plus any leading zeros
+            precision = this.precision - getInitialDigits() - (this.exponent + leadingZeros) * BASE_DIGITS[this.radix] + getInitialDigits(dataStorage);
+            if (precision <= 0)
+            {
+                // All significant digits were lost anyway, only trailing garbage digits
+                return zero();
+            }
+        }
+        else
+        {
+            precision = Apfloat.INFINITE;
+        }
+
+        long exponent = -leadingZeros;
+
+        ApfloatImpl apfloatImpl = new FloatApfloatImpl(this.sign, precision, exponent, dataStorage, this.radix);
+
+        return apfloatImpl;
+    }
+
+    private ApfloatImpl zero()
+    {
+        return new FloatApfloatImpl(0, Apfloat.INFINITE, 0, null, this.radix);
+    }
+
+    public int radix()
+    {
+        return this.radix;
+    }
+
+    public long precision()
+    {
+        return this.precision;
+    }
+
+    public long size()
+        throws ApfloatRuntimeException
+    {
+        assert (this.dataStorage != null);
+
+        if (this.size == 0)
+        {
+            // Writes and reads of volatile long values are always atomic so multiple threads can read and write this at the same time
+            this.size = getInitialDigits() + (getSize() - 1) * BASE_DIGITS[this.radix] - getLeastZeros();
+        }
+
+        return this.size;
+    }
+
+    // Get number of trailing zeros
+    private long getLeastZeros()
+        throws ApfloatRuntimeException
+    {
+        if (this.leastZeros == UNDEFINED)
+        {
+            // Cache the value
+            // NOTE: This is not synchronized; it's OK if multiple threads set this at the same time
+            // Writes and reads of volatile long values are always atomic so multiple threads can read and write this at the same time
+            long index = getSize() - 1;
+            float word = getWord(index);
+            word = getLeastSignificantWord(index, word);
+
+            long leastZeros = 0;
+            if (word == 0)
+            {
+                // Usually the last word is nonzero but in case precision was later changed, it might be zero
+                long trailingZeros = getTrailingZeros(this.dataStorage, index) + 1;
+                index -= trailingZeros;
+                word = getWord(index);
+                word = getLeastSignificantWord(index, word);
+
+                leastZeros += trailingZeros * BASE_DIGITS[this.radix];
+            }
+
+            assert (word != 0);
+
+            while (word % this.radix == 0)
+            {
+                leastZeros++;
+                word /= this.radix;
+            }
+            this.leastZeros = leastZeros;
+        }
+
+        return this.leastZeros;
+    }
+
+    public ApfloatImpl precision(long precision)
+    {
+        if (this.sign == 0 || precision == this.precision)
+        {
+            return this;
+        }
+        else
+        {
+            return new FloatApfloatImpl(this.sign, precision, this.exponent, this.dataStorage, this.radix);
+        }
+    }
+
+    public long scale()
+        throws ApfloatRuntimeException
+    {
+        assert (this.dataStorage != null);
+
+        return (this.exponent - 1) * BASE_DIGITS[this.radix] + getInitialDigits();
+    }
+
+    public int signum()
+    {
+        return this.sign;
+    }
+
+    public ApfloatImpl negate()
+        throws ApfloatRuntimeException
+    {
+        return new FloatApfloatImpl(-this.sign, this.precision, this.exponent, this.dataStorage, this.radix);
+    }
+
+    public double doubleValue()
+    {
+        if (this.sign == 0)
+        {
+            return 0.0;
+        }
+
+        double value = 0.0,
+               doubleBase = (double) BASE[this.radix];
+
+        int size = (int) Math.min(MAX_DOUBLE_SIZE, getSize());
+
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.READ, size, 0);
+
+        while (iterator.hasNext())
+        {
+            value += (double) iterator.getFloat();
+            value /= doubleBase;
+            iterator.next();
+        }
+
+        // If the end result fits in a double, any intermediate calculation must not overflow
+        // Note that 1/BASE <= value < 1
+        if (this.exponent > 0)
+        {
+            return this.sign * value * Math.pow((double) BASE[this.radix], (double) (this.exponent - 1)) * BASE[this.radix];
+        }
+        else
+        {
+            return this.sign * value * Math.pow((double) BASE[this.radix], (double) this.exponent);
+        }
+    }
+
+    public long longValue()
+    {
+        if (this.sign == 0 || this.exponent <= 0)
+        {
+            return 0;
+        }
+        else if (this.exponent > MAX_LONG_SIZE)
+        {
+            // Overflow for sure
+            return (this.sign > 0 ? Long.MAX_VALUE : Long.MIN_VALUE);
+        }
+
+        long value = 0,
+             longBase = (long) BASE[this.radix],
+             maxPrevious = Long.MIN_VALUE / longBase;
+
+        // Number of words in integer part of the number
+        int size = (int) Math.min(this.exponent, getSize());
+
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.READ, 0, size);
+
+        for (int i = 0; i < (int) this.exponent; i++)
+        {
+            if (value < maxPrevious)
+            {
+                // Overflow
+                value = 0;
+                iterator.close();
+                break;
+            }
+            value *= longBase;
+            if (i < size)
+            {
+                value -= (long) iterator.getFloat();      // Calculate value negated to handle 0x8000000000000000
+                iterator.next();
+            }
+        }
+
+        if (value == Long.MIN_VALUE || value >= 0)
+        {
+            // Overflow
+            return (this.sign > 0 ? Long.MAX_VALUE : Long.MIN_VALUE);
+        }
+        else
+        {
+            return -this.sign * value;
+        }
+    }
+
+    // If this ApfloatImpl is equal to 1
+    public boolean isOne()
+        throws ApfloatRuntimeException
+    {
+        if (this.isOne == UNDEFINED)
+        {
+            // Cache the value
+            // NOTE: This is not synchronized; it's OK if multiple threads set this at the same time
+            this.isOne = (this.sign == 1 && this.exponent == 1 && getSize() == 1 && getMostSignificantWord() == (float) 1 ? 1 : 0);
+        }
+
+        return (this.isOne == 1);
+    }
+
+    public long equalDigits(ApfloatImpl x)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof FloatApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        FloatApfloatImpl that = (FloatApfloatImpl) x;
+
+        if (this.sign == 0 && that.sign == 0)           // Both are zero
+        {
+            return Apfloat.INFINITE;
+        }
+        else if (this.sign != that.sign)                // No match
+        {
+            return 0;
+        }
+        else if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot compare values with different radixes: " + this.radix + " and " + that.radix);
+        }
+
+        long thisScale = scale(),
+             thatScale = that.scale(),
+             minScale = Math.min(thisScale, thatScale),
+             maxScale = Math.max(thisScale, thatScale);
+
+        if (maxScale - 1 > minScale)                    // No match
+        {
+            return 0;
+        }
+
+        // Need to compare mantissas
+        long thisSize = getSize(),
+             thatSize = that.getSize(),
+             size = Math.max(thisSize, thatSize);
+        DataStorage.Iterator thisIterator = getZeroPaddedIterator(0, thisSize),
+                             thatIterator = that.getZeroPaddedIterator(0, thatSize);
+
+        long index,
+             result = Math.min(this.precision, that.precision);         // If mantissas are identical
+        int lastMatchingDigits = -1;                                    // Will be used for deferred comparison hanging in last word, e.g. this = 1.000000000, that = 0.999999999
+        float carry,
+                base = BASE[this.radix];
+
+        if (this.exponent > that.exponent)
+        {
+            // Possible case this = 1.0000000, that = 0.9999999
+            float value = thisIterator.getFloat();                  // Check first word
+
+            if (value != (float) 1)
+            {
+                // No match
+                thisIterator.close();
+                thatIterator.close();
+
+                return 0;
+            }
+
+            carry = base;
+            thisIterator.next();
+        }
+        else if (this.exponent < that.exponent)
+        {
+            // Possible case this = 0.9999999, that = 1.0000000
+            float value = thatIterator.getFloat();                  // Check first word
+
+            if (value != (float) 1)
+            {
+                // No match
+                thisIterator.close();
+                thatIterator.close();
+
+                return 0;
+            }
+
+            carry = -base;
+            thatIterator.next();
+        }
+        else
+        {
+            // Trivial case, e.g. this = 111234, that = 111567
+            carry = 0;
+        }
+
+        // Calculate this - that, stopping at first difference
+        for (index = 0; index < size; index++)
+        {
+            float value = thisIterator.getFloat() - thatIterator.getFloat() + carry;
+
+            if (value == 0)
+            {
+                // Trivial case; words are equal
+                carry = 0;
+            }
+            else if (Math.abs(value) > (float) 1)
+            {
+                // Mismatch found
+                if (Math.abs(value) >= base)
+                {
+                    // Deferred comparison, e.g. this = 1.0000000002, that = 0.9999999991
+                    lastMatchingDigits = -1;
+                }
+                else
+                {
+                    // Any trivial cases and e.g. this = 1.0000000001, that = 0.9999999992
+                    lastMatchingDigits = BASE_DIGITS[this.radix] - getDigits(Math.abs(value));
+                }
+
+                break;
+            }
+            else if (value == (float) 1)
+            {
+                // Case this = 1.0000000..., that = 0.9999999...
+                carry = base;
+            }
+            else if (value == (float) -1)
+            {
+                // Case this = 0.9999999..., that = 1.0000000...
+                carry = -base;
+            }
+
+            thisIterator.next();
+            thatIterator.next();
+        }
+
+        if (index < size || carry != 0)                 // Mismatch found
+        {
+            long initialMatchingDigits = (this.exponent == that.exponent ?
+                                          Math.min(getInitialDigits(), that.getInitialDigits()) :       // Normal case, e.g. this = 10, that = 5
+                                          BASE_DIGITS[this.radix]);                                     // Special case, e.g. this = 1.0, that = 0.9
+
+            // Note that this works even if index == 0
+            long middleMatchingDigits = (index - 1) * BASE_DIGITS[this.radix];                          // This is correct even if exponents are different
+
+            // Limit by available precision
+            result = Math.min(result, initialMatchingDigits + middleMatchingDigits + lastMatchingDigits);
+
+            // Handle some cases e.g. 0.15 vs. 0.04
+            result = Math.max(result, 0);
+        }
+
+        thisIterator.close();
+        thatIterator.close();
+
+        return result;
+    }
+
+    public int compareTo(ApfloatImpl x)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof FloatApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        FloatApfloatImpl that = (FloatApfloatImpl) x;
+
+        if (this.sign == 0 && that.sign == 0)
+        {
+            return 0;
+        }
+        else if (this.sign < that.sign)                 // Now we know that not both are zero
+        {
+            return -1;
+        }
+        else if (this.sign > that.sign)
+        {
+            return 1;
+        }
+        else if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot compare values with different radixes: " + this.radix + " and " + that.radix);
+        }
+        else if (scale() < that.scale())                // Now we know that both have same sign (which is not zero)
+        {
+            return -this.sign;
+        }
+        else if (scale() > that.scale())
+        {
+            return this.sign;
+        }
+
+        // Need to compare mantissas
+        return this.sign * compareMantissaTo(that);
+    }
+
+    // Returns an iterator for this number's data storage from start to end,
+    // least significant word is correctly truncated with getLeastSignificantWord(),
+    // after that the iterator returns zeros only
+    private DataStorage.Iterator getZeroPaddedIterator(final long start, final long end)
+        throws ApfloatRuntimeException
+    {
+        final DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.READ, start, end);
+
+        return new DataStorage.Iterator()
+        {
+            public float getFloat()
+                throws ApfloatRuntimeException
+            {
+                float value;
+
+                if (this.index < end)
+                {
+                    value = iterator.getFloat();
+                    if (this.index == end - 1)
+                    {
+                        value = getLeastSignificantWord(this.index, value);
+                    }
+                }
+                else
+                {
+                    value = 0;
+                }
+
+                return value;
+            }
+
+            public void next()
+                throws ApfloatRuntimeException
+            {
+                if (this.index < end)
+                {
+                    iterator.next();
+                    this.index++;
+                }
+            }
+
+            public void close()
+                throws ApfloatRuntimeException
+            {
+                iterator.close();
+            }
+
+            private static final long serialVersionUID = 1L;
+
+            private long index = start;
+        };
+    }
+
+    // Compare absolute values of mantissas
+    private int compareMantissaTo(FloatApfloatImpl that)
+        throws ApfloatRuntimeException
+    {
+        long thisSize = getSize(),
+             thatSize = that.getSize(),
+             size = Math.max(thisSize, thatSize);
+        DataStorage.Iterator thisIterator = getZeroPaddedIterator(0, thisSize),
+                             thatIterator = that.getZeroPaddedIterator(0, thatSize);
+        int result = 0;
+
+        long index = findMismatch(thisIterator, thatIterator, size);
+
+        if (index >= 0)                 // Mismatch found
+        {
+            float thisValue = thisIterator.getFloat(),
+                    thatValue = thatIterator.getFloat();
+
+            if (thisValue < thatValue)
+            {
+                result = -1;
+            }
+            else if (thisValue > thatValue)
+            {
+                result = 1;
+            }
+        }
+
+        thisIterator.close();
+        thatIterator.close();
+
+        return result;
+    }
+
+    // Returns index of first mismatching float, or -1 if mantissas are equal
+    // Iterators are left to point to the mismatching words
+    private long findMismatch(DataStorage.Iterator thisIterator, DataStorage.Iterator thatIterator, long size)
+        throws ApfloatRuntimeException
+    {
+        for (long index = 0; index < size; index++)
+        {
+            float thisValue = thisIterator.getFloat(),
+                    thatValue = thatIterator.getFloat();
+
+            if (thisValue != thatValue)
+            {
+                return index;
+            }
+
+            thisIterator.next();
+            thatIterator.next();
+        }
+
+        // All searched words matched exactly
+        return -1;
+    }
+
+    // Truncate insignificant digits from the last float of the number
+    private float getLeastSignificantWord(long index, float word)
+        throws ApfloatRuntimeException
+    {
+        if (this.precision == Apfloat.INFINITE)
+        {
+            return word;
+        }
+
+        // Total digits including the specified index
+        long digits = getInitialDigits() + index * BASE_DIGITS[this.radix];
+
+        if (this.precision >= digits)
+        {
+            return word;
+        }
+
+        // Assert that the second array access will not be out of bounds
+        float divisor = MINIMUM_FOR_DIGITS[this.radix][(int) (digits - this.precision)];
+
+        return (float) (long) (word / divisor) * divisor;
+    }
+
+    /**
+     * Compares this object to the specified object.
+     *
+     * @param obj The object to compare with.
+     *
+     * @return <code>true</code> if the objects are equal; <code>false</code> otherwise.
+     */
+
+    public boolean equals(Object obj)
+    {
+        if (!(obj instanceof ApfloatImpl))
+        {
+            return false;
+        }
+
+        ApfloatImpl thatImpl = (ApfloatImpl) obj;
+
+        // Special comparisons against Apfloat.ZERO and Apfloat.ONE work regardless of radix or implementation class
+        if (signum() == 0 && thatImpl.signum() == 0)
+        {
+            return true;
+        }
+        else if (isOne() && thatImpl.isOne())
+        {
+            return true;
+        }
+
+        if (!(obj instanceof FloatApfloatImpl))
+        {
+            return false;
+        }
+
+        FloatApfloatImpl that = (FloatApfloatImpl) obj;
+
+        if (this.radix != that.radix)
+        {
+            // Limitation: cannot compare values with different radixes
+            return false;
+        }
+        else if (this.sign != that.sign ||
+                 this.exponent != that.exponent)
+        {
+            return false;
+        }
+        else
+        {
+            // Need to compare mantissas
+            return compareMantissaTo(that) == 0;
+        }
+    }
+
+    public int hashCode()
+    {
+        if (this.hashCode == 0)
+        {
+            // Cache the value
+            // NOTE: This is not synchronized; it's OK if multiple threads set this at the same time
+            int hashCode = 1 + this.sign + (int) this.exponent + (int) (this.exponent >>> 32);
+
+            if (this.dataStorage != null)
+            {
+                long size = getSize();
+
+                // Scan through log(size) scattered words in the mantissa
+                for (long i = 0; i < size; i = i + i + 1)
+                {
+                    float word = getWord(i);
+
+                    if (i == size - 1)
+                    {
+                        word = getLeastSignificantWord(i, word);
+                    }
+
+                    long element = (long) word;
+                    hashCode += (int) element + (int) (element >>> 32);
+                }
+            }
+
+            this.hashCode = hashCode;
+        }
+
+        return this.hashCode;
+    }
+
+    public String toString(boolean pretty)
+        throws ApfloatRuntimeException
+    {
+        if (this.sign == 0)
+        {
+            return "0";
+        }
+
+        long size = getSize() * BASE_DIGITS[this.radix],    // This is a rounded up value
+             length;
+        if (pretty)
+        {
+             long scale = scale();
+             if (scale <= 0)
+             {
+                 length = 2 - scale + size;         // Format is 0.xxxx or 0.0000xxx
+             }
+             else if (size > scale)
+             {
+                 length = 1 + size;                 // Format is x.xxx
+             }
+             else
+             {
+                 length = scale;                    // Format is xxxx or xxxx0000
+             }
+             length += (this.sign < 0 ? 1 : 0);     // Room for minus sign
+        }
+        else
+        {
+            length = size + 24;     // Sign, "0.", "e", exponent sign and 19 digits of exponent
+        }
+
+        if (length > Integer.MAX_VALUE || length < 0)           // Detect overflow
+        {
+            throw new ApfloatInternalException("Number is too large to fit in a String");
+        }
+
+        StringWriter writer = new StringWriter((int) length);
+
+        try
+        {
+            writeTo(writer, pretty);
+        }
+        catch (IOException ioe)
+        {
+            throw new ApfloatInternalException("Unexpected I/O error writing to StringWriter", ioe);
+        }
+
+        String value = writer.toString();
+
+        assert (value.length() <= length);      // Postcondition to ensure performance
+
+        return value;
+    }
+
+    private static void writeZeros(Writer out, long count)
+        throws IOException
+    {
+        for (long i = 0; i < count; i++)
+        {
+            out.write('0');
+        }
+    }
+
+    public void writeTo(Writer out, boolean pretty)
+        throws IOException, ApfloatRuntimeException
+    {
+        if (this.sign == 0)
+        {
+            out.write('0');
+            return;
+        }
+
+        if (this.sign < 0)
+        {
+            out.write('-');
+        }
+
+        long integerDigits,                 // Number of digits to write before the decimal point
+             exponent;                      // Exponent to print
+
+        if (pretty)
+        {
+            if (this.exponent <= 0)
+            {
+                out.write("0.");            // Output is 0.xxxx
+                writeZeros(out, -scale());  // Print leading zeros after decimal point before first nonzero digit
+                integerDigits = -1;         // Decimal point is already written
+            }
+            else
+            {
+                integerDigits = scale();    // Decimal point location
+            }
+            exponent = 0;                   // Do not print exponent
+        }
+        else
+        {
+            integerDigits = 1;              // Always write as x.xxxey
+            exponent = scale() - 1;         // Print exponent
+        }
+
+        boolean leftPadZeros = false;       // If the written base unit should be left-padded with zeros
+        long size = getSize(),
+             digitsToWrite = Math.min(this.precision, getInitialDigits() + (size - 1) * BASE_DIGITS[this.radix]),
+             digitsWritten = 0,
+             trailingZeros = 0;
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.READ, 0, size);
+        char[] buffer = new char[BASE_DIGITS[this.radix]];
+
+        while (size > 0)
+        {
+            int start = (leftPadZeros ? 0 : BASE_DIGITS[this.radix] - getInitialDigits()),
+                digits = (int) Math.min(digitsToWrite, BASE_DIGITS[this.radix] - start);
+
+            formatWord(buffer, iterator.getFloat());
+
+            for (int i = 0; i < digits; i++)
+            {
+                int c = buffer[start + i];
+                if (c == '0')
+                {
+                    trailingZeros++;
+                    digitsToWrite--;
+                }
+                else
+                {
+                    while (trailingZeros > 0)
+                    {
+                        if (digitsWritten == integerDigits)
+                        {
+                            out.write('.');
+                        }
+                        out.write('0');
+                        digitsWritten++;
+                        trailingZeros--;
+                    }
+                    if (digitsWritten == integerDigits)
+                    {
+                        out.write('.');
+                    }
+                    out.write(c);
+                    digitsWritten++;
+                    digitsToWrite--;
+                }
+            }
+            leftPadZeros = true;                        // Always pad with zeros after first word
+
+            iterator.next();
+            size--;
+        }
+
+        if (!pretty && exponent != 0)
+        {
+            out.write("e" + exponent);
+        }
+
+        writeZeros(out, integerDigits - digitsWritten); // If format is xxxx0000
+    }
+
+    private void formatWord(char[] buffer, float word)
+    {
+        int position = BASE_DIGITS[this.radix];
+        while (position > 0 && word > 0)
+        {
+            float newWord = (float) (long) (word / this.radix);
+            int digit = (int) (word -  newWord * this.radix);
+            word = newWord;
+            position--;
+            buffer[position] = Character.forDigit(digit, this.radix);
+        }
+
+        // Left pad zeros
+        while (position > 0)
+        {
+            position--;
+            buffer[position] = '0';
+        }
+    }
+
+    // Effective size, in floats
+    private long getSize()
+        throws ApfloatRuntimeException
+    {
+        assert (this.dataStorage != null);
+
+        return Math.min(getBasePrecision(),
+                        this.dataStorage.getSize());
+    }
+
+    private static int checkRadix(int radix)
+        throws NumberFormatException
+    {
+        if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)
+        {
+            throw new NumberFormatException("Invalid radix " + radix + "; radix must be between " + Character.MIN_RADIX + " and " + Character.MAX_RADIX);
+        }
+
+        return radix;
+    }
+
+    // Get the most significant word of this number
+    private float getMostSignificantWord()
+        throws ApfloatRuntimeException
+    {
+        return getMostSignificantWord(this.dataStorage);
+    }
+
+    // Get the most significant word of the specified data storage
+    private static float getMostSignificantWord(DataStorage dataStorage)
+        throws ApfloatRuntimeException
+    {
+        float msw;
+
+        ArrayAccess arrayAccess = dataStorage.getArray(DataStorage.READ, 0, 1);
+        msw = arrayAccess.getFloatData()[arrayAccess.getOffset()];
+        arrayAccess.close();
+
+        return msw;
+    }
+
+    // Get number of digits in the most significant word
+    private int getInitialDigits()
+        throws ApfloatRuntimeException
+    {
+        if (this.initialDigits == UNDEFINED)
+        {
+            // Cache the value
+            // NOTE: This is not synchronized; it's OK if multiple threads set this at the same time
+            this.initialDigits = getDigits(getMostSignificantWord());
+        }
+
+        return this.initialDigits;
+    }
+
+    // Get number of digits in the most significant word of specified data
+    private int getInitialDigits(DataStorage dataStorage)
+        throws ApfloatRuntimeException
+    {
+        return getDigits(getMostSignificantWord(dataStorage));
+    }
+
+    // Gets the number of digits in the specified float and this number's radix
+    private int getDigits(float x)
+    {
+        assert (x > 0);
+
+        float[] minimums = MINIMUM_FOR_DIGITS[this.radix];
+        int i = minimums.length;
+
+        while (x < minimums[--i])
+        {
+        }
+
+        return i + 1;
+    }
+
+    // Gets the precision in floats
+    private long getBasePrecision()
+        throws ApfloatRuntimeException
+    {
+        return getBasePrecision(this.precision, getInitialDigits());
+    }
+
+    // Gets the precision in floats, based on specified precision (in digits),
+    // number of digits in most significant word and this number's radix
+    private long getBasePrecision(long precision, int mswDigits)
+    {
+        if (precision == Apfloat.INFINITE)
+        {
+            return Apfloat.INFINITE;
+        }
+        else
+        {
+            return (precision + BASE_DIGITS[this.radix] - mswDigits - 1) / BASE_DIGITS[this.radix] + 1;
+        }
+    }
+
+    private float getWord(long index)
+    {
+        ArrayAccess arrayAccess = this.dataStorage.getArray(DataStorage.READ, index, 1);
+        float word = arrayAccess.getFloatData()[arrayAccess.getOffset()];
+        arrayAccess.close();
+
+        return word;
+    }
+
+    private void readObject(ObjectInputStream in)
+        throws IOException, ClassNotFoundException
+    {
+        this.leastZeros = UNDEFINED;
+        this.isOne = UNDEFINED;
+        in.defaultReadObject();
+    }
+
+    // Gets a new data storage for specified size
+    private static DataStorage createDataStorage(long size)
+        throws ApfloatRuntimeException
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        return dataStorageBuilder.createDataStorage(size * 4);
+    }
+
+    // Gets I/O block size in floats
+    private static int getBlockSize()
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        return ctx.getBlockSize() / 4;
+    }
+
+    private static final DataStorage.Iterator ZERO_ITERATOR =
+    new DataStorage.Iterator()
+    {
+        public float getFloat() { return 0; }
+        public void next() { }
+        private static final long serialVersionUID = 1L;
+    };
+
+    private static final long serialVersionUID = 4198839366471670758L;
+
+    private static final int UNDEFINED = 0x80000000;
+    private static final int MAX_LONG_SIZE = 4;
+    private static final int MAX_DOUBLE_SIZE = 4;
+
+    private int sign;
+    private long precision;
+    private long exponent;
+    private DataStorage dataStorage;
+    private int radix;
+    private int hashCode = 0;
+    private int initialDigits = UNDEFINED;
+    private int isOne = UNDEFINED;
+    private volatile long leastZeros = UNDEFINED;
+    private volatile long size = 0;
+}
Index: src/main/java/org/apfloat/internal/FloatBaseMath.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatBaseMath.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatBaseMath.java	(revision 0)
@@ -0,0 +1,212 @@
+package org.apfloat.internal;
+
+import java.io.Serializable;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+import static org.apfloat.internal.FloatRadixConstants.*;
+
+/**
+ * Mathematical operations on numbers in a base.
+ * Implementation for the <code>float</code> type.
+ *
+ * @version 1.8.2
+ * @author Mikko Tommila
+ */
+
+public class FloatBaseMath
+    implements Serializable
+{
+    /**
+     * Creates a base math using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public FloatBaseMath(int radix)
+    {
+        this.radix = radix;
+    }
+
+    /**
+     * Addition in some base. Adds the data words
+     * of <code>src1</code> and <code>src2</code> and stores the result to
+     * <code>dst</code>. <code>src2</code> may be <code>null</code>, in
+     * which case it is ignored (only the carry is propagated).<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] + src2[i]</code>.
+     *
+     * @param src1 First source data sequence. Can be <code>null</code>, in which case it's ignored.
+     * @param src2 Second source data sequence. Can be <code>null</code>, in which case it's ignored.
+     * @param carry Input carry bit. This is added to the first (rightmost) word in the accessed sequence.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Overflow carry bit. Propagated carry bit from the addition of the last (leftmost) word in the accessed sequence.
+     */
+
+    public float baseAdd(DataStorage.Iterator src1, DataStorage.Iterator src2, float carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (src1 == null || src1 != src2);
+
+        boolean sameDst = (src1 == dst || src2 == dst);
+        float base = BASE[this.radix];
+
+        for (long i = 0; i < size; i++)
+        {
+            double result = (double) (src1 == null ? 0 : src1.getFloat()) + (double) carry +
+                            (double) (src2 == null ? 0 : src2.getFloat());
+
+            carry = (result >= base ? 1 : 0);
+            result -= (result >= base ? base : 0);
+
+            dst.setFloat((float) result);
+
+            if (src1 != null) src1.next();
+            if (src2 != null) src2.next();
+            if (!sameDst) dst.next();
+        }
+
+        return carry;
+    }
+
+    /**
+     * Subtraction in some base. Subtracts the data words
+     * of <code>src1</code> and <code>src2</code> and stores the result to
+     * <code>dst</code>. <code>src1</code> and <code>src2</code> may be
+     * <code>null</code>, in which case they are ignored (the values are assumed
+     * to be zero and only the carry is propagated).<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] - src2[i]</code>.
+     *
+     * @param src1 First source data sequence. Can be <code>null</code>, in which case the input values are assumed to be zero.
+     * @param src2 Second source data sequence. Can be <code>null</code>, in which case it's ignored, or can be the same as <code>dst</code>.
+     * @param carry Input carry bit. This is subtracted from the first (rightmost) word in the accessed sequence.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Overflow carry bit. Propagated carry bit from the subtraction of the last (leftmost) word in the accessed sequence. The value is <code>1</code> if the carry is set, and <code>0</code> otherwise.
+     */
+
+    public float baseSubtract(DataStorage.Iterator src1, DataStorage.Iterator src2, float carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (src1 == null || src1 != src2);
+        assert (src2 != dst);
+
+        float base = BASE[this.radix];
+
+        for (long i = 0; i < size; i++)
+        {
+            float result = (src1 == null ? 0 : src1.getFloat()) - carry -
+                           (src2 == null ? 0 : src2.getFloat());
+
+            carry = (result < 0 ? 1 : 0);
+            result += (result < 0 ? base : 0);
+
+            dst.setFloat(result);
+
+            if (src1 != null && src1 != dst) src1.next();
+            if (src2 != null) src2.next();
+            dst.next();
+        }
+
+        return carry;
+    }
+
+    /**
+     * Multiplication and addition in some base. Multiplies the data words
+     * of <code>src1</code> by <code>src3</code> and adds the result to the
+     * words in <code>src2</code>, and stores the result to <code>dst</code>.
+     * <code>src2</code> may be <code>null</code>, in which case it is ignored
+     * (the values are assumed to be zero).<p>
+     *
+     * Assumes that the result from the addition doesn't overflow the upper
+     * result word (to larger than the base). This is the case e.g. when using
+     * this method to perform an arbitrary precision multiplication.<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] * src3 + src2[i]</code>.
+     *
+     * @param src1 First source data sequence.
+     * @param src2 Second source data sequence. Can be <code>null</code>, in which case it's ignored, or can be the same as <code>dst</code>.
+     * @param src3 Multiplicand. All elements of <code>src1</code> are multiplied by this value.
+     * @param carry Input carry word. This is added to the first (rightmost) word in the accessed sequence.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Overflow carry word. Propagated carry word from the multiplication and addition of the last (leftmost) word in the accessed sequence.
+     */
+
+    public float baseMultiplyAdd(DataStorage.Iterator src1, DataStorage.Iterator src2, float src3, float carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (src1 != src2);
+        assert (src1 != dst);
+
+        double base = BASE[this.radix];
+
+        for (long i = 0; i < size; i++)
+        {
+            double tmp = (double) src1.getFloat() * (double) src3 +
+                         (double) (src2 == null ? 0 : src2.getFloat()) + (double) carry;
+
+            carry = (float) (int) (tmp / base);
+
+            dst.setFloat((float) (tmp - (double) carry * base));        // = tmp % base
+
+            src1.next();
+            if (src2 != null && src2 != dst) src2.next();
+            dst.next();
+        }
+
+        return carry;
+    }
+
+    /**
+     * Division in some base. Divides the data words
+     * of <code>src1</code> by <code>src2</code> and stores the result to
+     * <code>dst</code>. <code>src1</code> may be <code>null</code>,
+     * in which case it is ignored (the values are assumed to be
+     * zero and only the carry division is propagated).<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] / src2</code>.
+     *
+     * @param src1 First source data sequence. Can be <code>null</code>, in which case the input values are assumed to be zero.
+     * @param src2 Divisor. All elements of <code>src1</code> are divided by this value.
+     * @param carry Input carry word. Used as the upper word for the division of the first input element. This should be the remainder word returned from the previous block processed.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Remainder word of the propagated division of the last (rightmost) word in the accessed sequence.
+     */
+
+    public float baseDivide(DataStorage.Iterator src1, float src2, float carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (src1 != dst);
+
+        double base = BASE[this.radix],
+               divisor = src2;
+
+        for (long i = 0; i < size; i++)
+        {
+            double tmp = (double) carry * base +
+                         (double) (src1 == null ? 0 : src1.getFloat());
+            float result = (float) (int) (tmp / divisor);
+
+            carry = (float) (tmp - (double) result * divisor);          // = tmp % src2
+
+            dst.setFloat(result);
+
+            if (src1 != null) src1.next();
+            dst.next();
+        }
+
+        return carry;
+    }
+
+    private static final long serialVersionUID = -2321698097908304307L;
+
+    private int radix;
+}
Index: src/main/java/org/apfloat/internal/FloatBuilderFactory.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatBuilderFactory.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatBuilderFactory.java	(revision 0)
@@ -0,0 +1,119 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+
+import org.apfloat.spi.AdditionBuilder;
+import org.apfloat.spi.BuilderFactory;
+import org.apfloat.spi.ApfloatBuilder;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.ConvolutionBuilder;
+import org.apfloat.spi.NTTBuilder;
+import org.apfloat.spi.MatrixBuilder;
+import org.apfloat.spi.CarryCRTBuilder;
+
+/**
+ * Factory class for getting instances of the various builder classes needed
+ * to build an <code>ApfloatImpl</code> with the <code>float</code> data element type.
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class FloatBuilderFactory
+    implements BuilderFactory
+{
+    /**
+     * Default constructor.
+     */
+
+    public FloatBuilderFactory()
+    {
+    }
+
+    public ApfloatBuilder getApfloatBuilder()
+    {
+        return FloatBuilderFactory.apfloatBuilder;
+    }
+
+    public DataStorageBuilder getDataStorageBuilder()
+    {
+        return FloatBuilderFactory.dataStorageBuilder;
+    }
+
+    public <T> AdditionBuilder<T> getAdditionBuilder(Class<T> elementType)
+        throws IllegalArgumentException
+    {
+        if (!Float.TYPE.equals(elementType))
+        {
+           throw new IllegalArgumentException("Unsupported element type: " + elementType);
+        }
+        @SuppressWarnings("unchecked")
+        AdditionBuilder<T> additionBuilder = (AdditionBuilder<T>) FloatBuilderFactory.additionBuilder;
+        return additionBuilder;
+    }
+
+    public ConvolutionBuilder getConvolutionBuilder()
+    {
+        return FloatBuilderFactory.convolutionBuilder;
+    }
+
+    public NTTBuilder getNTTBuilder()
+    {
+        return FloatBuilderFactory.nttBuilder;
+    }
+
+    public MatrixBuilder getMatrixBuilder()
+    {
+        return FloatBuilderFactory.matrixBuilder;
+    }
+
+    public <T> CarryCRTBuilder<T> getCarryCRTBuilder(Class<T> elementArrayType)
+        throws IllegalArgumentException
+    {
+        if (!float[].class.equals(elementArrayType))
+        {
+           throw new IllegalArgumentException("Unsupported element array type: " + elementArrayType);
+        }
+        @SuppressWarnings("unchecked")
+        CarryCRTBuilder<T> carryCRTBuilder = (CarryCRTBuilder<T>) FloatBuilderFactory.carryCRTBuilder;
+        return carryCRTBuilder;
+    }
+
+    public Class<?> getElementType()
+    {
+        return Float.TYPE;
+    }
+
+    public Class<?> getElementArrayType()
+    {
+        return float[].class;
+    }
+
+    public int getElementSize()
+    {
+        return 4;
+    }
+
+    public void shutdown()
+        throws ApfloatRuntimeException
+    {
+        DiskDataStorage.cleanUp();
+    }
+
+    public void gc()
+        throws ApfloatRuntimeException
+    {
+        System.gc();
+        System.gc();
+        System.runFinalization();
+        DiskDataStorage.gc();
+    }
+
+    private static ApfloatBuilder apfloatBuilder = new FloatApfloatBuilder();
+    private static DataStorageBuilder dataStorageBuilder = new FloatDataStorageBuilder();
+    private static AdditionBuilder<Float> additionBuilder = new FloatAdditionBuilder();
+    private static ConvolutionBuilder convolutionBuilder = new FloatConvolutionBuilder();
+    private static NTTBuilder nttBuilder = new FloatNTTBuilder();
+    private static MatrixBuilder matrixBuilder = new FloatMatrixBuilder();
+    private static CarryCRTBuilder<float[]> carryCRTBuilder = new FloatCarryCRTBuilder();
+}
Index: src/main/java/org/apfloat/internal/FloatCRTMath.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatCRTMath.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatCRTMath.java	(revision 0)
@@ -0,0 +1,172 @@
+package org.apfloat.internal;
+
+import static org.apfloat.internal.FloatModConstants.*;
+import static org.apfloat.internal.FloatRadixConstants.*;
+
+/**
+ * Basic arithmetic for calculating the Chinese Remainder
+ * Theorem. Works for the <code>float</code> type.
+ *
+ * @version 1.6
+ * @author Mikko Tommila
+ */
+
+public class FloatCRTMath
+    extends FloatBaseMath
+{
+    /**
+     * Creates a carry-CRT math using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public FloatCRTMath(int radix)
+    {
+        super(radix);
+        this.base = BASE[radix];
+    }
+
+    /**
+     * Multiplies two words by one word to produce a result of three words.
+     * Most significant word is stored first.
+     *
+     * @param src Source array, first multiplicand.
+     * @param factor Second multiplicand.
+     * @param dst Destination array.
+     */
+
+    public final void multiply(float[] src, float factor, float[] dst)
+    {
+        double tmp = (double) src[1] * (double) factor;
+        float carry = (float) (int) (tmp * INVERSE_MAX_POWER_OF_TWO_BASE);
+
+        dst[2] = (float) (tmp - carry * MAX_POWER_OF_TWO_BASE);     // = tmp % MAX_POWER_OF_TWO_BASE
+
+        tmp = (double) src[0] * (double) factor + carry;
+        carry = (float) (int) (tmp * INVERSE_MAX_POWER_OF_TWO_BASE);
+
+        dst[1] = (float) (tmp - carry * MAX_POWER_OF_TWO_BASE);     // = tmp % MAX_POWER_OF_TWO_BASE
+
+        dst[0] = carry;
+    }
+
+    /**
+     * Compares three words. Most significant word is stored first.
+     *
+     * @param src1 First operand.
+     * @param src2 Second operand.
+     *
+     * @return Less than zero if <code>src1 &lt; src2</code>, greater than zero if <code>src1 &gt; src2</code> and zero if <code>src1 == src2</code>.
+     */
+
+    public final float compare(float[] src1, float[] src2)
+    {
+        float result = src1[0] - src2[0];
+
+        if (result != 0)
+        {
+            return result;
+        }
+
+        result = src1[1] - src2[1];
+
+        if (result != 0)
+        {
+            return result;
+        }
+
+        return src1[2] - src2[2];
+    }
+
+    /**
+     * Adds three words. Most significant word is stored first.
+     *
+     * @param src First operand.
+     * @param srcDst Second operand, and destination of the operation.
+     *
+     * @return Overflow carry bit.
+     */
+
+    public final float add(float[] src, float[] srcDst)
+    {
+        double result = (double) srcDst[2] + (double) src[2];
+        float carry = (result >= MAX_POWER_OF_TWO_BASE ? 1 : 0);
+        result = (result >= MAX_POWER_OF_TWO_BASE ? result - MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[2] = (float) result;
+
+        result = (double) srcDst[1] + (double) src[1] + carry;
+        carry = (result >= MAX_POWER_OF_TWO_BASE ? 1 : 0);
+        result = (result >= MAX_POWER_OF_TWO_BASE ? result - MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[1] = (float) result;
+
+        result = (double) srcDst[0] + (double) src[0] + carry;
+        carry = (result >= MAX_POWER_OF_TWO_BASE ? 1 : 0);
+        result = (result >= MAX_POWER_OF_TWO_BASE ? result - MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[0] = (float) result;
+
+        return carry;
+    }
+
+    /**
+     * Subtracts three words. Most significant word is stored first.
+     *
+     * @param src First operand.
+     * @param srcDst Second operand, and destination of the operation.
+     */
+
+    public final void subtract(float[] src, float[] srcDst)
+    {
+        float result = srcDst[2] - src[2],
+              carry = (result < 0 ? 1 : 0);
+        result = (result < 0 ? result + MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[2] = result;
+
+        result = srcDst[1] - src[1] - carry;
+        carry = (result < 0 ? 1 : 0);
+        result = (result < 0 ? result + MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[1] = result;
+
+        result = srcDst[0] - src[0] - carry;
+        // carry = (result < 0 ? 1 : 0);
+        result = (result < 0 ? result + MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[0] = result;
+    }
+
+    /**
+     * Divides three words by the base to produce two words. Most significant word is stored first.
+     *
+     * @param srcDst Source and destination of the operation.
+     *
+     * @return Remainder of the division.
+     */
+
+    public final float divide(float[] srcDst)
+    {
+        double tmp = (double) srcDst[0] * MAX_POWER_OF_TWO_BASE + srcDst[1];
+        float result = (float) (int) (tmp / this.base),
+              carry = (float) (tmp - result * this.base);       // = tmp % this.base
+
+        srcDst[0] = 0;
+        srcDst[1] = result;
+
+        tmp = (double) carry * MAX_POWER_OF_TWO_BASE + srcDst[2];
+        result = (float) (int) (tmp / this.base);
+        carry = (float) (tmp - result * this.base);             // = tmp % this.base
+
+        srcDst[2] = result;
+
+        return carry;
+    }
+
+    private static final long serialVersionUID = 2778445457339436642L;
+
+    private static final double INVERSE_MAX_POWER_OF_TWO_BASE = 1.0 / MAX_POWER_OF_TWO_BASE;
+
+    private double base;
+}
Index: src/main/java/org/apfloat/internal/FloatCarryCRTBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatCarryCRTBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatCarryCRTBuilder.java	(revision 0)
@@ -0,0 +1,36 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.CarryCRTBuilder;
+import org.apfloat.spi.CarryCRTStrategy;
+import org.apfloat.spi.CarryCRTStepStrategy;
+
+/**
+ * Creates carry-CRT related objects, for the
+ * <code>float</code> type.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class FloatCarryCRTBuilder
+    implements CarryCRTBuilder<float[]>
+{
+    /**
+     * Default constructor.
+     */
+
+    public FloatCarryCRTBuilder()
+    {
+    }
+
+    public CarryCRTStrategy createCarryCRT(int radix)
+    {
+        return new StepCarryCRTStrategy(radix);
+    }
+
+    public CarryCRTStepStrategy<float[]> createCarryCRTSteps(int radix)
+    {
+        return new FloatCarryCRTStepStrategy(radix);
+    }
+}
Index: src/main/java/org/apfloat/internal/FloatCarryCRTStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatCarryCRTStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatCarryCRTStepStrategy.java	(revision 0)
@@ -0,0 +1,293 @@
+package org.apfloat.internal;
+
+import java.math.BigInteger;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.CarryCRTStepStrategy;
+import org.apfloat.spi.DataStorage;
+import static org.apfloat.internal.FloatModConstants.*;
+
+/**
+ * Class for performing the final steps of a three-modulus
+ * Number Theoretic Transform based convolution. Works for the
+ * <code>float</code> type.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class FloatCarryCRTStepStrategy
+    extends FloatCRTMath
+    implements CarryCRTStepStrategy<float[]>
+{
+    /**
+     * Creates a carry-CRT steps object using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public FloatCarryCRTStepStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public float[] crt(DataStorage resultMod0, DataStorage resultMod1, DataStorage resultMod2, DataStorage dataStorage, long size, long resultSize, long offset, long length)
+        throws ApfloatRuntimeException
+    {
+        long skipSize = (offset == 0 ? size - resultSize + 1: 0);   // For the first block, ignore the first 1-3 elements
+        long lastSize = (offset + length == size ? 1: 0);           // For the last block, add 1 element
+        long nonLastSize = 1 - lastSize;                            // For the other than last blocks, move 1 element
+        long subResultSize = length - skipSize + lastSize;
+
+        long subStart = size - offset,
+             subEnd = subStart - length,
+             subResultStart = size - offset - length + nonLastSize + subResultSize,
+             subResultEnd = subResultStart - subResultSize;
+
+        DataStorage.Iterator src0 = resultMod0.iterator(DataStorage.READ, subStart, subEnd),
+                             src1 = resultMod1.iterator(DataStorage.READ, subStart, subEnd),
+                             src2 = resultMod2.iterator(DataStorage.READ, subStart, subEnd),
+                             dst = dataStorage.iterator(DataStorage.WRITE, subResultStart, subResultEnd);
+
+        float[] carryResult = new float[3],
+                  sum = new float[3],
+                  tmp = new float[3];
+
+        // Preliminary carry-CRT calculation (happens in parallel in multiple blocks)
+        for (long i = 0; i < length; i++)
+        {
+            float y0 = MATH_MOD_0.modMultiply(T0, src0.getFloat()),
+                    y1 = MATH_MOD_1.modMultiply(T1, src1.getFloat()),
+                    y2 = MATH_MOD_2.modMultiply(T2, src2.getFloat());
+
+            multiply(M12, y0, sum);
+            multiply(M02, y1, tmp);
+
+            if (add(tmp, sum) != 0 ||
+                compare(sum, M012) >= 0)
+            {
+                subtract(M012, sum);
+            }
+
+            multiply(M01, y2, tmp);
+
+            if (add(tmp, sum) != 0 ||
+                compare(sum, M012) >= 0)
+            {
+                subtract(M012, sum);
+            }
+
+            add(sum, carryResult);
+
+            float result = divide(carryResult);
+
+            // In the first block, ignore the first element (it's zero in full precision calculations)
+            // and possibly one or two more in limited precision calculations
+            if (i >= skipSize)
+            {
+                dst.setFloat(result);
+                dst.next();
+            }
+
+            src0.next();
+            src1.next();
+            src2.next();
+        }
+
+        // Calculate the last words (in base math)
+        float result0 = divide(carryResult);
+        float result1 = carryResult[2];
+
+        assert (carryResult[0] == 0);
+        assert (carryResult[1] == 0);
+
+        // Last block has one extra element (corresponding to the one skipped in the first block)
+        if (subResultSize == length - skipSize + 1)
+        {
+            dst.setFloat(result0);
+            dst.close();
+
+            result0 = result1;
+            assert (result1 == 0);
+        }
+
+        float[] results = { result1, result0 };
+
+        return results;
+    }
+
+    public float[] carry(DataStorage dataStorage, long size, long resultSize, long offset, long length, float[] results, float[] previousResults)
+        throws ApfloatRuntimeException
+    {
+        long skipSize = (offset == 0 ? size - resultSize + 1: 0);   // For the first block, ignore the first 1-3 elements
+        long lastSize = (offset + length == size ? 1: 0);           // For the last block, add 1 element
+        long nonLastSize = 1 - lastSize;                            // For the other than last blocks, move 1 element
+        long subResultSize = length - skipSize + lastSize;
+
+        long subResultStart = size - offset - length + nonLastSize + subResultSize,
+             subResultEnd = subResultStart - subResultSize;
+
+        // Get iterators for the previous block carries, and dst, padded with this block's carries
+        // Note that size could be 1 but carries size is 2
+        DataStorage.Iterator src = arrayIterator(previousResults);
+        DataStorage.Iterator dst = compositeIterator(dataStorage.iterator(DataStorage.READ_WRITE, subResultStart, subResultEnd), subResultSize, arrayIterator(results));
+
+        // Propagate base addition through dst, and this block's carries
+        float carry = baseAdd(dst, src, 0, dst, previousResults.length);
+        carry = baseCarry(dst, carry, subResultSize);
+        dst.close();                                                    // Iterator likely was not iterated to end
+
+        assert (carry == 0);
+
+        return results;
+    }
+
+    private float baseCarry(DataStorage.Iterator srcDst, float carry, long size)
+        throws ApfloatRuntimeException
+    {
+        for (long i = 0; i < size && carry > 0; i++)
+        {
+            carry = baseAdd(srcDst, null, carry, srcDst, 1);
+        }
+
+        return carry;
+    }
+
+    // Wrap an array in a simple reverse-order iterator, padded with zeros
+    private static DataStorage.Iterator arrayIterator(final float[] data)
+    {
+        return new DataStorage.Iterator()
+        {
+            public boolean hasNext()
+            {
+                return true;
+            }
+
+            public void next()
+            {
+                this.position--;
+            }
+
+            public float getFloat()
+            {
+                assert (this.position >= 0);
+                return data[this.position];
+            }
+
+            public void setFloat(float value)
+            {
+                assert (this.position >= 0);
+                data[this.position] = value;
+            }
+
+            private static final long serialVersionUID = 1L;
+
+            private int position = data.length - 1;
+        };
+    }
+
+    // Composite iterator, made by concatenating two iterators
+    private static DataStorage.Iterator compositeIterator(final DataStorage.Iterator iterator1, final long size, final DataStorage.Iterator iterator2)
+    {
+        return new DataStorage.Iterator()
+        {
+            public boolean hasNext()
+            {
+                return (this.position < size ? iterator1.hasNext() : iterator2.hasNext());
+            }
+
+            public void next()
+                throws ApfloatRuntimeException
+            {
+                (this.position < size ? iterator1 : iterator2).next();
+                this.position++;
+            }
+
+            public float getFloat()
+                throws ApfloatRuntimeException
+            {
+                return (this.position < size ? iterator1 : iterator2).getFloat();
+            }
+
+            public void setFloat(float value)
+                throws ApfloatRuntimeException
+            {
+                (this.position < size ? iterator1 : iterator2).setFloat(value);
+            }
+
+            public void close()
+                throws ApfloatRuntimeException
+            {
+                (this.position < size ? iterator1 : iterator2).close();
+            }
+
+            private static final long serialVersionUID = 1L;
+
+            private long position;
+        };
+    }
+
+    private static final long serialVersionUID = 3192182234524626533L;
+
+    private static final FloatModMath MATH_MOD_0,
+                                        MATH_MOD_1,
+                                        MATH_MOD_2;
+    private static final float T0,
+                                 T1,
+                                 T2;
+    private static final float[] M01,
+                                   M02,
+                                   M12,
+                                   M012;
+
+    static
+    {
+        MATH_MOD_0 = new FloatModMath();
+        MATH_MOD_1 = new FloatModMath();
+        MATH_MOD_2 = new FloatModMath();
+
+        MATH_MOD_0.setModulus(MODULUS[0]);
+        MATH_MOD_1.setModulus(MODULUS[1]);
+        MATH_MOD_2.setModulus(MODULUS[2]);
+
+        // Probably sub-optimal, but it's a one-time operation
+
+        BigInteger base = BigInteger.valueOf(Math.abs((long) MAX_POWER_OF_TWO_BASE)),   // In int case the base is 0x80000000
+                   m0 = BigInteger.valueOf((long) MODULUS[0]),
+                   m1 = BigInteger.valueOf((long) MODULUS[1]),
+                   m2 = BigInteger.valueOf((long) MODULUS[2]),
+                   m01 = m0.multiply(m1),
+                   m02 = m0.multiply(m2),
+                   m12 = m1.multiply(m2);
+
+        T0 = m12.modInverse(m0).floatValue();
+        T1 = m02.modInverse(m1).floatValue();
+        T2 = m01.modInverse(m2).floatValue();
+
+        M01 = new float[2];
+        M02 = new float[2];
+        M12 = new float[2];
+        M012 = new float[3];
+
+        BigInteger[] qr = m01.divideAndRemainder(base);
+        M01[0] = qr[0].floatValue();
+        M01[1] = qr[1].floatValue();
+
+        qr = m02.divideAndRemainder(base);
+        M02[0] = qr[0].floatValue();
+        M02[1] = qr[1].floatValue();
+
+        qr = m12.divideAndRemainder(base);
+        M12[0] = qr[0].floatValue();
+        M12[1] = qr[1].floatValue();
+
+        qr = m0.multiply(m12).divideAndRemainder(base);
+        M012[2] = qr[1].floatValue();
+        qr = qr[0].divideAndRemainder(base);
+        M012[0] = qr[0].floatValue();
+        M012[1] = qr[1].floatValue();
+    }
+}
Index: src/main/java/org/apfloat/internal/FloatConstants.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatConstants.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatConstants.java	(revision 0)
@@ -0,0 +1,24 @@
+package org.apfloat.internal;
+
+/**
+ * Constants needed for various algorithms for the <code>float</code> type.
+ *
+ * @since 1.4
+ * @version 1.4
+ * @author Mikko Tommila
+ */
+
+public interface FloatConstants
+{
+    /**
+     * Relative cost of Karatsuba multiplication.
+     */
+
+    public static final float KARATSUBA_COST_FACTOR = 6.1f;
+
+    /**
+     * Relative cost of NTT multiplication.
+     */
+
+    public static final float NTT_COST_FACTOR = 7.4f;
+}
Index: src/main/java/org/apfloat/internal/FloatConvolutionBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatConvolutionBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatConvolutionBuilder.java	(revision 0)
@@ -0,0 +1,65 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.ConvolutionStrategy;
+import org.apfloat.spi.NTTStrategy;
+import static org.apfloat.internal.FloatConstants.*;
+
+/**
+ * Creates convolutions of suitable type for the <code>float</code> type.<p>
+ *
+ * @see FloatShortConvolutionStrategy
+ * @see FloatMediumConvolutionStrategy
+ * @see FloatKaratsubaConvolutionStrategy
+ * @see ThreeNTTConvolutionStrategy
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class FloatConvolutionBuilder
+    extends AbstractConvolutionBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public FloatConvolutionBuilder()
+    {
+    }
+
+    protected int getKaratsubaCutoffPoint()
+    {
+        return FloatKaratsubaConvolutionStrategy.CUTOFF_POINT;
+    }
+
+    protected float getKaratsubaCostFactor()
+    {
+        return KARATSUBA_COST_FACTOR;
+    }
+
+    protected float getNTTCostFactor()
+    {
+        return NTT_COST_FACTOR;
+    }
+
+    protected ConvolutionStrategy createShortConvolutionStrategy(int radix)
+    {
+        return new FloatShortConvolutionStrategy(radix);
+    }
+
+    protected ConvolutionStrategy createMediumConvolutionStrategy(int radix)
+    {
+        return new FloatMediumConvolutionStrategy(radix);
+    }
+
+    protected ConvolutionStrategy createKaratsubaConvolutionStrategy(int radix)
+    {
+        return new FloatKaratsubaConvolutionStrategy(radix);
+    }
+
+
+    protected ConvolutionStrategy createThreeNTTConvolutionStrategy(int radix, NTTStrategy nttStrategy)
+    {
+        return new ParallelThreeNTTConvolutionStrategy(radix, nttStrategy);
+    }
+}
Index: src/main/java/org/apfloat/internal/FloatDataStorageBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatDataStorageBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatDataStorageBuilder.java	(revision 0)
@@ -0,0 +1,49 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+
+/**
+ * Default data storage creation strategy for the <code>float</code> data type.
+ *
+ * @see FloatMemoryDataStorage
+ * @see FloatDiskDataStorage
+ *
+ * @version 1.8.2
+ * @author Mikko Tommila
+ */
+
+public class FloatDataStorageBuilder
+    extends AbstractDataStorageBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public FloatDataStorageBuilder()
+    {
+    }
+
+    protected long getMaxCachedSize()
+    {
+        return (long) 4 * Integer.MAX_VALUE;
+    }
+
+    protected DataStorage createCachedDataStorage()
+        throws ApfloatRuntimeException
+    {
+        return new FloatMemoryDataStorage();
+    }
+
+    protected DataStorage createNonCachedDataStorage()
+        throws ApfloatRuntimeException
+    {
+        return new FloatDiskDataStorage();
+    }
+
+    protected boolean isCached(DataStorage dataStorage)
+        throws ApfloatRuntimeException
+    {
+        return (dataStorage instanceof FloatMemoryDataStorage);
+    }
+}
Index: src/main/java/org/apfloat/internal/FloatDiskDataStorage.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatDiskDataStorage.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatDiskDataStorage.java	(revision 0)
@@ -0,0 +1,333 @@
+package org.apfloat.internal;
+
+import java.nio.ByteBuffer;
+import java.nio.FloatBuffer;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.channels.WritableByteChannel;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Disk-based data storage for the <code>float</code> element type.
+ *
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class FloatDiskDataStorage
+    extends DiskDataStorage
+{
+    /**
+     * Default constructor.
+     */
+
+    public FloatDiskDataStorage()
+        throws ApfloatRuntimeException
+    {
+    }
+
+    /**
+     * Subsequence constructor.
+     *
+     * @param floatDiskDataStorage The originating data storage.
+     * @param offset The subsequence starting position.
+     * @param length The subsequence length.
+     */
+
+    protected FloatDiskDataStorage(FloatDiskDataStorage floatDiskDataStorage, long offset, long length)
+    {
+        super(floatDiskDataStorage, offset, length);
+    }
+
+    protected DataStorage implSubsequence(long offset, long length)
+        throws ApfloatRuntimeException
+    {
+        return new FloatDiskDataStorage(this, offset + getOffset(), length);
+    }
+
+    private class FloatDiskArrayAccess
+        extends FloatMemoryArrayAccess
+    {
+        // fileOffset is absolute position in file
+        public FloatDiskArrayAccess(int mode, long fileOffset, int length)
+            throws ApfloatRuntimeException
+        {
+            super(new float[length], 0, length);
+            this.mode = mode;
+            this.fileOffset = fileOffset;
+
+            if ((mode & READ) != 0)
+            {
+                final float[] array = getFloatData();
+                WritableByteChannel out = new WritableByteChannel()
+                {
+                    public int write(ByteBuffer buffer)
+                    {
+                        FloatBuffer src = buffer.asFloatBuffer();
+                        int readLength = src.remaining();
+
+                        src.get(array, this.readPosition, readLength);
+
+                        this.readPosition += readLength;
+                        buffer.position(buffer.position() + readLength * 4);
+
+                        return readLength * 4;
+                    }
+
+                    public void close() {}
+                    public boolean isOpen() { return true; }
+
+                    private int readPosition = 0;
+                };
+
+                transferTo(out, fileOffset * 4, (long) length * 4);
+            }
+        }
+
+        public void close()
+            throws ApfloatRuntimeException
+        {
+            if ((this.mode & WRITE) != 0 && getData() != null)
+            {
+                final float[] array = getFloatData();
+                ReadableByteChannel in = new ReadableByteChannel()
+                {
+                    public int read(ByteBuffer buffer)
+                    {
+                        FloatBuffer dst = buffer.asFloatBuffer();
+                        int writeLength = dst.remaining();
+
+                        dst.put(array, this.writePosition, writeLength);
+
+                        this.writePosition += writeLength;
+                        buffer.position(buffer.position() + writeLength * 4);
+
+                        return writeLength * 4;
+                    }
+
+                    public void close() {}
+                    public boolean isOpen() { return true; }
+
+                    private int writePosition = 0;
+                };
+
+                transferFrom(in, this.fileOffset * 4, (long) array.length * 4);
+            }
+
+            super.close();
+        }
+
+        private static final long serialVersionUID = 1750388414420962922L;
+
+        private int mode;
+        private long fileOffset;
+    }
+
+    protected ArrayAccess implGetArray(int mode, long offset, int length)
+        throws ApfloatRuntimeException
+    {
+        return new FloatDiskArrayAccess(mode, getOffset() + offset, length);
+    }
+
+    protected ArrayAccess createArrayAccess(int mode, int startColumn, int columns, int rows)
+    {
+        return new MemoryArrayAccess(mode, new float[columns * rows], startColumn, columns, rows);
+    }
+
+    protected ArrayAccess createTransposedArrayAccess(int mode, int startColumn, int columns, int rows)
+    {
+        return new TransposedMemoryArrayAccess(mode, new float[columns * rows], startColumn, columns, rows);
+    }
+
+    private class MemoryArrayAccess
+        extends FloatMemoryArrayAccess
+    {
+        public MemoryArrayAccess(int mode, float[] data, int startColumn, int columns, int rows)
+        {
+            super(data, 0, data.length);
+            this.mode = mode;
+            this.startColumn = startColumn;
+            this.columns = columns;
+            this.rows = rows;
+        }
+
+        public void close()
+            throws ApfloatRuntimeException
+        {
+            if ((this.mode & WRITE) != 0 && getData() != null)
+            {
+                setArray(this, this.startColumn, this.columns, this.rows);
+            }
+            super.close();
+        }
+
+        private static final long serialVersionUID = -3536582909010606907L;
+
+        private int mode,
+                    startColumn,
+                    columns,
+                    rows;
+    }
+
+    private class TransposedMemoryArrayAccess
+        extends FloatMemoryArrayAccess
+    {
+        public TransposedMemoryArrayAccess(int mode, float[] data, int startColumn, int columns, int rows)
+        {
+            super(data, 0, data.length);
+            this.mode = mode;
+            this.startColumn = startColumn;
+            this.columns = columns;
+            this.rows = rows;
+        }
+
+        public void close()
+            throws ApfloatRuntimeException
+        {
+            if ((this.mode & WRITE) != 0 && getData() != null)
+            {
+                setTransposedArray(this, this.startColumn, this.columns, this.rows);
+            }
+            super.close();
+        }
+
+        private static final long serialVersionUID = 898289922606519237L;
+
+        private int mode,
+                    startColumn,
+                    columns,
+                    rows;
+    }
+
+    private class BlockIterator
+        extends AbstractIterator
+    {
+        public BlockIterator(int mode, long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            super(mode, startPosition, endPosition);
+            this.arrayAccess = null;
+            this.remaining = 0;
+        }
+
+        public void next()
+            throws IllegalStateException, ApfloatRuntimeException
+        {
+            checkLength();
+
+            assert (this.remaining > 0);
+
+            checkAvailable();
+
+            this.offset += getIncrement();
+            this.remaining--;
+
+            if (this.remaining == 0)
+            {
+                close();
+            }
+
+            super.next();
+        }
+
+        public float getFloat()
+            throws IllegalStateException, ApfloatRuntimeException
+        {
+            checkGet();
+            checkAvailable();
+            return this.data[this.offset];
+        }
+
+        public void setFloat(float value)
+            throws IllegalStateException, ApfloatRuntimeException
+        {
+            checkSet();
+            checkAvailable();
+            this.data[this.offset] = value;
+        }
+
+        public <T> T get(Class<T> type)
+            throws UnsupportedOperationException, IllegalStateException
+        {
+            if (!(type.equals(Float.TYPE)))
+            {
+                throw new UnsupportedOperationException("Unsupported data type " + type.getCanonicalName() + ", the only supported type is float");
+            }
+            @SuppressWarnings("unchecked")
+            T value = (T) (Float) getFloat();
+            return value;
+        }
+
+        public <T> void set(Class<T> type, T value)
+            throws UnsupportedOperationException, IllegalArgumentException, IllegalStateException
+        {
+            if (!(type.equals(Float.TYPE)))
+            {
+                throw new UnsupportedOperationException("Unsupported data type " + type.getCanonicalName() + ", the only supported type is float");
+            }
+            if (!(value instanceof Float))
+            {
+                throw new IllegalArgumentException("Unsupported value type " + value.getClass().getCanonicalName() + ", the only supported type is Float");
+            }
+            setFloat((Float) value);
+        }
+
+        /**
+         * Closes the iterator. This needs to be called only if the
+         * iterator is not iterated to the end.
+         */
+
+        public void close()
+            throws ApfloatRuntimeException
+        {
+            if (this.arrayAccess != null)
+            {
+                this.data = null;
+                this.arrayAccess.close();
+                this.arrayAccess = null;
+            }
+        }
+
+        private void checkAvailable()
+            throws ApfloatRuntimeException
+        {
+            if (this.arrayAccess == null)
+            {
+                boolean isForward = (getIncrement() > 0);
+                int length = (int) Math.min(getLength(), getBlockSize() / 4);
+                long offset = (isForward ? getPosition() : getPosition() - length + 1);
+
+                this.arrayAccess = getArray(getMode(), offset, length);
+                this.data = this.arrayAccess.getFloatData();
+                this.offset = this.arrayAccess.getOffset() + (isForward ? 0 : length - 1);
+                this.remaining = length;
+            }
+        }
+
+        private static final long serialVersionUID = 8503701548995236882L;
+
+        private ArrayAccess arrayAccess;
+        private float[] data;
+        private int offset,
+                    remaining;
+    }
+
+    public Iterator iterator(int mode, long startPosition, long endPosition)
+        throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+    {
+        if ((mode & READ_WRITE) == 0)
+        {
+            throw new IllegalArgumentException("Illegal mode: " + mode);
+        }
+        return new BlockIterator(mode, startPosition, endPosition);
+    }
+
+    protected int getUnitSize()
+    {
+        return 4;
+    }
+
+    private static final long serialVersionUID = 1045290368963828503L;
+}
Index: src/main/java/org/apfloat/internal/FloatElementaryModMath.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatElementaryModMath.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatElementaryModMath.java	(revision 0)
@@ -0,0 +1,133 @@
+package org.apfloat.internal;
+
+/**
+ * Elementary modulo arithmetic functions for <code>float</code> data.
+ * Note that although a floating-point data type is used, the data
+ * will always be integers.<p>
+ *
+ * Since the moduli are close to 2<sup>24</sup> some attention must be paid
+ * to avoiding overflow in modular addition and subtraction. This can be
+ * done easily e.g. by casting the operands to <code>double</code>. Note
+ * that an IEEE float has a mantissa with a precision of 24 bits (1 + 23).<p>
+ *
+ * Modular multiplication is more complicated, and since it is usually
+ * the single most time consuming operation in the whole program execution,
+ * the very core of the Number Theoretic Transform (NTT), it should be
+ * carefully optimized.<p>
+ *
+ * Some obvious (but not very efficient) algorithms for multiplying two
+ * <code>float</code>s and taking the remainder would be to call
+ * <code>Math.IEEEremainder()</code>, or cast the operands to
+ * <code>long</code>, e.g.<p>
+ *
+ * <code>(float) ((long) a * (long) b % (long) modulus)</code><p>
+ *
+ * Since the modulus is practically constant, it should be more efficient
+ * to calculate (once) the inverse of the modulus, and then subsequently
+ * multiply by the inverse modulus instead of dividing by the modulus.<p>
+ *
+ * The algorithm used in this implementation casts the operands to
+ * <code>double</code>, performs the multiplication, multiplies by the
+ * inverse modulus, then takes the integer part. Getting the integer
+ * part is typically a lot faster by casting to <code>int</code> compared
+ * to e.g. calling <code>Math.floor()</code>. An <code>int</code>, holding
+ * 32 bits, can easily contain the result of the cast, which will have a
+ * maximum of 24 bits.<p>
+ *
+ * Overflow is not a problem, since a <code>double</code> can hold 53 bits
+ * precisely in the mantissa &#150; more than doubly what a <code>float</code>
+ * can. Note that multiplying by the inverse modulus is also trivial, when
+ * the inverse modulus has more than twice accurate bits than what are in
+ * each of the multiplicands. Since the modulus is assumed to be prime, there
+ * can be no situations where multiplication by the inverse modulus would
+ * have a near-integer result that would be rounded incorrectly, e.g. as in
+ * <code>0.333... * 3 = 0.999...</code>.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public class FloatElementaryModMath
+{
+    /**
+     * Default constructor.
+     */
+
+    public FloatElementaryModMath()
+    {
+    }
+
+    /**
+     * Modular multiplication.
+     *
+     * @param a First operand.
+     * @param b Second operand.
+     *
+     * @return <code>a * b % modulus</code>
+     */
+
+    public final float modMultiply(float a, float b)
+    {
+        double r = (double) a * (double) b;
+
+        return (float) (r - (double) this.modulus * (double) (int) (this.inverseModulus * r));
+    }
+
+    /**
+     * Modular addition.
+     *
+     * @param a First operand.
+     * @param b Second operand.
+     *
+     * @return <code>(a + b) % modulus</code>
+     */
+
+    public final float modAdd(float a, float b)
+    {
+        double r = (double) a + (double) b;
+
+        return (float) (r >= (double) this.modulus ? r - (double) this.modulus : r);
+    }
+
+    /**
+     * Modular subtraction. The result is always &gt;= 0.
+     *
+     * @param a First operand.
+     * @param b Second operand.
+     *
+     * @return <code>(a - b + modulus) % modulus</code>
+     */
+
+    public final float modSubtract(float a, float b)
+    {
+        float r = a - b;
+
+        return (r < 0.0f ? r + this.modulus : r);
+    }
+
+    /**
+     * Get the modulus.
+     *
+     * @return The modulus.
+     */
+
+    public final float getModulus()
+    {
+        return this.modulus;
+    }
+
+    /**
+     * Set the modulus.
+     *
+     * @param modulus The modulus.
+     */
+
+    public final void setModulus(float modulus)
+    {
+        this.inverseModulus = 1.0 / (double) modulus;
+        this.modulus = modulus;
+    }
+
+    private float modulus;
+    private double inverseModulus;
+}
Index: src/main/java/org/apfloat/internal/FloatFactor3NTTStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatFactor3NTTStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatFactor3NTTStepStrategy.java	(revision 0)
@@ -0,0 +1,180 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.Factor3NTTStepStrategy;
+import org.apfloat.spi.DataStorage;
+import static org.apfloat.internal.FloatModConstants.*;
+
+/**
+ * Steps for the factor-3 NTT.<p>
+ *
+ * The transform is done using a parallel algorithm, if the data fits in memory.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class FloatFactor3NTTStepStrategy
+    extends FloatModMath
+    implements Factor3NTTStepStrategy, Parallelizable
+{
+    // Runnable for transforming the columns in a factor-3 transform
+    private class ColumnTransformRunnable
+        implements Runnable
+    {
+        public ColumnTransformRunnable(DataStorage dataStorage0, DataStorage dataStorage1, DataStorage dataStorage2, long startColumn, long columns, float w, float ww, float w1, float w2, boolean isInverse)
+        {
+            this.dataStorage0 = dataStorage0;
+            this.dataStorage1 = dataStorage1;
+            this.dataStorage2 = dataStorage2;
+            this.startColumn = startColumn;
+            this.columns = columns;
+            this.w = w;
+            this.ww = ww;
+            this.w1 = w1;
+            this.w2 = w2;
+            this.isInverse = isInverse;
+        }
+
+        public void run()
+        {
+            float tmp1 = modPow(this.w, (float) this.startColumn),
+                    tmp2 = modPow(this.ww, (float) this.startColumn);
+
+            DataStorage.Iterator iterator0 = this.dataStorage0.iterator(DataStorage.READ_WRITE, this.startColumn, this.startColumn + this.columns),
+                                 iterator1 = this.dataStorage1.iterator(DataStorage.READ_WRITE, this.startColumn, this.startColumn + this.columns),
+                                 iterator2 = this.dataStorage2.iterator(DataStorage.READ_WRITE, this.startColumn, this.startColumn + this.columns);
+
+            for (long i = 0; i < this.columns; i++)
+            {
+                // 3-point WFTA on the corresponding array elements
+
+                float x0 = iterator0.getFloat(),
+                        x1 = iterator1.getFloat(),
+                        x2 = iterator2.getFloat(),
+                        t;
+
+                if (this.isInverse)
+                {
+                    // Multiply before transform
+                    x1 = modMultiply(x1, tmp1);
+                    x2 = modMultiply(x2, tmp2);
+                }
+
+                // Transform columns
+                t = modAdd(x1, x2);
+                x2 = modSubtract(x1, x2);
+                x0 = modAdd(x0, t);
+                t = modMultiply(t, this.w1);
+                x2 = modMultiply(x2, this.w2);
+                t = modAdd(t, x0);
+                x1 = modAdd(t, x2);
+                x2 = modSubtract(t, x2);
+
+                if (!this.isInverse)
+                {
+                    // Multiply after transform
+                    x1 = modMultiply(x1, tmp1);
+                    x2 = modMultiply(x2, tmp2);
+                }
+
+                iterator0.setFloat(x0);
+                iterator1.setFloat(x1);
+                iterator2.setFloat(x2);
+
+                iterator0.next();
+                iterator1.next();
+                iterator2.next();
+
+                tmp1 = modMultiply(tmp1, this.w);
+                tmp2 = modMultiply(tmp2, this.ww);
+            }
+        }
+
+        private DataStorage dataStorage0;
+        private DataStorage dataStorage1;
+        private DataStorage dataStorage2;
+        private long startColumn;
+        private long columns;
+        private float w;
+        private float ww;
+        private float w1;
+        private float w2;
+        private boolean isInverse;
+    }
+
+    /**
+     * Default constructor.
+     */
+
+    public FloatFactor3NTTStepStrategy()
+    {
+    }
+
+    public void transformColumns(DataStorage dataStorage0, DataStorage dataStorage1, DataStorage dataStorage2, long startColumn, long columns, long power2length, long length, boolean isInverse, int modulus)
+        throws ApfloatRuntimeException
+    {
+        // Transform length is three times a power of two
+        assert (length == 3 * power2length);
+
+        ParallelRunnable parallelRunnable = createColumnTransformParallelRunnable(dataStorage0, dataStorage1, dataStorage2, startColumn, columns, power2length, length, isInverse, modulus);
+
+        if (columns <= Integer.MAX_VALUE &&                                     // Only if the size fits in an integer, but with memory arrays it should
+            dataStorage0.isCached() &&                                          // Only if the data storage supports efficient parallel random access
+            dataStorage1.isCached() &&
+            dataStorage2.isCached())
+        {
+            ParallelRunner.runParallel(parallelRunnable);
+        }
+        else
+        {
+            parallelRunnable.run();                                             // Just run in current thread without parallelization
+        }
+    }
+
+    public long getMaxTransformLength()
+    {
+        return MAX_TRANSFORM_LENGTH;
+    }
+
+    /**
+     * Create a ParallelRunnable object for transforming the columns of the matrix
+     * using a 3-point NTT transform.
+     *
+     * @param dataStorage0 The data of the first column.
+     * @param dataStorage1 The data of the second column.
+     * @param dataStorage2 The data of the third column.
+     * @param startColumn The starting element index in the data storages to transform.
+     * @param columns How many columns to transform.
+     * @param power2length Length of the column transform.
+     * @param length Length of total transform (three times the length of one column).
+     * @param isInverse <code>true</code> if an inverse transform is performed, <code>false</code> if a forward transform is performed.
+     * @param modulus Index of the modulus.
+     *
+     * @return A suitable object for performing the 3-point transforms in parallel.
+     */
+
+    protected ParallelRunnable createColumnTransformParallelRunnable(final DataStorage dataStorage0, final DataStorage dataStorage1, final DataStorage dataStorage2, final long startColumn, final long columns, long power2length, long length, final boolean isInverse, int modulus)
+    {
+        setModulus(MODULUS[modulus]);                                             // Modulus
+        final float w = (isInverse ?
+                           getInverseNthRoot(PRIMITIVE_ROOT[modulus], length) :
+                           getForwardNthRoot(PRIMITIVE_ROOT[modulus], length)),   // Forward/inverse n:th root
+                      w3 = modPow(w, (float) power2length),                     // Forward/inverse 3rd root
+                      ww = modMultiply(w, w),
+                      w1 = negate(modDivide((float) 3, (float) 2)),
+                      w2 = modAdd(w3, modDivide((float) 1, (float) 2));
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(columns)
+        {
+            public Runnable getRunnable(long strideStartColumn, long strideColumns)
+            {
+                return new ColumnTransformRunnable(dataStorage0, dataStorage1, dataStorage2, startColumn + strideStartColumn, strideColumns, w, ww, w1, w2, isInverse);
+            }
+        };
+        return parallelRunnable;
+    }
+}
Index: src/main/java/org/apfloat/internal/FloatKaratsubaConvolutionStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatKaratsubaConvolutionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatKaratsubaConvolutionStrategy.java	(revision 0)
@@ -0,0 +1,242 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.DataStorage;
+
+/**
+ * Convolution strategy using the Karatsuba algorithm.
+ * The complexity of the algorithm is O(n<sup>log(3)/log(2)</sup>) as
+ * the operands are split to two and multiplied using three multiplications
+ * (and five additions / subtractions). This splitting is done recursively
+ * until some cut-off point where the basic O(n<sup>2</sup>) algorithm is
+ * applied. The Karatsuba algorithm is faster than the basic O(n<sup>2</sup>)
+ * multiplication algorithm for medium size numbers larger than some certain
+ * size. For very large numbers, the transform-based convolution algorithms
+ * are faster.
+ *
+ * @since 1.4
+ * @version 1.4
+ * @author Mikko Tommila
+ */
+
+public class FloatKaratsubaConvolutionStrategy
+    extends FloatMediumConvolutionStrategy
+{
+    /**
+     * Cut-off point for Karatsuba / basic convolution.<p>
+     *
+     * Convolutions where the shorter number is at most this long
+     * are calculated using the basic O(n<sup>2</sup>) algorithm
+     * i.e. <code>super.convolute()</code>.
+     */
+
+    public static final int CUTOFF_POINT = 15;
+
+    /**
+     * Creates a convolution strategy using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public FloatKaratsubaConvolutionStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public DataStorage convolute(DataStorage x, DataStorage y, long resultSize)
+        throws ApfloatRuntimeException
+    {
+        if (Math.min(x.getSize(), y.getSize()) <= CUTOFF_POINT)
+        {
+            // The numbers are too short for Karatsuba to have any advantage, fall back to O(n^2) algorithm
+            return super.convolute(x, y, resultSize);
+        }
+
+        DataStorage shortStorage, longStorage;
+
+        if (x.getSize() > y.getSize())
+        {
+            shortStorage = y;
+            longStorage = x;
+        }
+        else
+        {
+            shortStorage = x;
+            longStorage = y;
+        }
+
+        long shortSize = shortStorage.getSize(),
+             longSize = longStorage.getSize(),
+             size = shortSize + longSize,
+             halfSize = longSize + 1 >> 1,      // Split point for recursion, round up
+             x1size = longSize - halfSize,
+             x2size = halfSize,
+             y1size = shortSize - halfSize;     // y2size = halfSize
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        DataStorage resultStorage = dataStorageBuilder.createDataStorage(size * 4);
+        resultStorage.setSize(size);
+
+        if (y1size <= 0)
+        {
+            // The shorter number is half of the longer number or less, use simplified algorithm
+            DataStorage.Iterator dst = resultStorage.iterator(DataStorage.WRITE, size, 0),
+                                 src1 = null;
+            float carry = 0;
+            long i = longSize,
+                 xSize;
+
+            // Calculate sub-results in blocks of size shortSize
+            do
+            {
+                xSize = Math.min(i, shortSize);
+                x = longStorage.subsequence(i - xSize, xSize);
+                y = shortStorage;
+
+                // Calculate sub-convolutions recursively
+                DataStorage a = convolute(x, y, xSize + shortSize);
+
+                assert (a.getSize() == xSize + shortSize);
+
+                // Add the sub-results together
+                DataStorage.Iterator src2 = a.iterator(DataStorage.READ, xSize + shortSize, 0);
+
+                carry = baseAdd(src1, src2, carry, dst, shortSize);
+
+                src1 = src2;
+                i -= shortSize;
+            } while (i > 0);
+
+            // Propagate carry through the last sub-result and store to result data
+            carry = baseAdd(src1, null, carry, dst, xSize);
+
+            assert (carry == 0);
+        }
+        else
+        {
+            // The numbers are roughly equal size (shorter is more than half of the longer), use Karatsuba algorithm
+            DataStorage x1 = longStorage.subsequence(0, x1size),
+                        x2 = longStorage.subsequence(x1size, x2size),
+                        y1 = shortStorage.subsequence(0, y1size),
+                        y2 = shortStorage.subsequence(y1size, halfSize);
+
+            // Calculate a = x1 + x2
+            DataStorage a = add(x1, x2);
+
+            // Calculate b = y1 + y2
+            DataStorage b = add(y1, y2);
+
+            // Calculate sub-convolutions recursively
+            DataStorage c = convolute(a, b, a.getSize() + b.getSize());
+            a = convolute(x1, y1, x1size + y1size);
+            b = convolute(x2, y2, 2 * halfSize);
+
+            // Calculate c = c - a - b
+            subtract(c, a);
+            subtract(c, b);
+
+            long cSize = c.getSize(),
+                 c1size = cSize - halfSize;
+
+            if (c1size > x1size + y1size)
+            {
+                // We know that the top one or two words of c are zero
+                // Omit them to avoid later having c1size > x1size + y1size
+                long zeros = c1size - x1size - y1size;
+                assert (isZero(c, 0));
+                assert (zeros == 1 || isZero(c, 1));
+                assert (zeros <= 2);
+                cSize -= zeros;
+                c1size -= zeros;
+                c = c.subsequence(zeros, cSize);
+            }
+
+            assert (a.getSize() == x1size + y1size);
+            assert (b.getSize() == 2 * halfSize);
+            assert (cSize >= 2 * halfSize && cSize <= 2 * halfSize + 2);
+            assert (c1size <= x1size + y1size);
+
+            // Add the sub-results a + b + c together
+            DataStorage.Iterator src1 = a.iterator(DataStorage.READ, x1size + y1size, 0),
+                                 src2 = b.iterator(DataStorage.READ, 2 * halfSize, 0),
+                                 src3 = c.iterator(DataStorage.READ, cSize, 0),
+                                 dst = resultStorage.iterator(DataStorage.WRITE, size, 0);
+
+            float carry = 0;
+            carry = baseAdd(src2, null, carry, dst, halfSize);
+            carry = baseAdd(src2, src3, carry, dst, halfSize);
+            carry = baseAdd(src1, src3, carry, dst, c1size);
+            carry = baseAdd(src1, null, carry, dst, x1size + y1size - c1size);
+
+            assert (carry == 0);
+        }
+
+        return resultStorage;
+    }
+
+    // Return x1 + x2
+    private DataStorage add(DataStorage x1, DataStorage x2)
+    {
+        long x1size = x1.getSize(),
+             x2size = x2.getSize();
+
+        assert (x1size <= x2size);
+
+        long size = x2size + 1;
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        DataStorage resultStorage = dataStorageBuilder.createDataStorage(size * 4);
+        resultStorage.setSize(size);
+
+        // Calculate x1 + x2
+        DataStorage.Iterator src1 = x1.iterator(DataStorage.READ, x1size, 0),
+                             src2 = x2.iterator(DataStorage.READ, x2size, 0),
+                             dst = resultStorage.iterator(DataStorage.WRITE, size, 0);
+
+        float carry = 0;
+        carry = baseAdd(src1, src2, carry, dst, x1size);
+        carry = baseAdd(src2, null, carry, dst, x2size - x1size);
+        baseAdd(null, null, carry, dst, 1);         // Set carry digit to the top word
+        if (carry == 0)
+        {
+            resultStorage = resultStorage.subsequence(1, size - 1);     // Omit zero top word
+        }
+
+        return resultStorage;
+    }
+
+    // x1 -= x2
+    private void subtract(DataStorage x1, DataStorage x2)
+    {
+        long x1size = x1.getSize(),
+             x2size = x2.getSize();
+
+        assert (x1size >= x2size);
+
+        DataStorage.Iterator src1 = x1.iterator(DataStorage.READ_WRITE, x1size, 0),
+                             src2 = x2.iterator(DataStorage.READ, x2size, 0),
+                             dst = src1;
+
+        float carry = 0;
+        carry = baseSubtract(src1, src2, carry, dst, x2size);
+        carry = baseSubtract(src1, null, carry, dst, x1size - x2size);
+
+        assert (carry == 0);
+    }
+
+    private boolean isZero(DataStorage x, long index)
+    {
+        DataStorage.Iterator i = x.iterator(DataStorage.READ, index, index + 1);
+
+        float data = i.getFloat();
+        i.next();
+
+        return data == 0;
+    }
+
+    private static final long serialVersionUID = -4438101427690647475L;
+}
Index: src/main/java/org/apfloat/internal/FloatMatrixBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatMatrixBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatMatrixBuilder.java	(revision 0)
@@ -0,0 +1,32 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.MatrixBuilder;
+import org.apfloat.spi.MatrixStrategy;
+
+/**
+ * Creates matrix operations objects, for the
+ * <code>float</code> type.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class FloatMatrixBuilder
+    implements MatrixBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public FloatMatrixBuilder()
+    {
+    }
+
+    public MatrixStrategy createMatrix()
+    {
+        return FloatMatrixBuilder.matrixStrategy;
+    }
+
+    private static MatrixStrategy matrixStrategy = new FloatMatrixStrategy();
+}
Index: src/main/java/org/apfloat/internal/FloatMatrixStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatMatrixStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatMatrixStrategy.java	(revision 0)
@@ -0,0 +1,442 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.MatrixStrategy;
+import org.apfloat.spi.ArrayAccess;
+import org.apfloat.spi.Util;
+
+/**
+ * Optimized matrix transposition methods for the <code>float</code> type.
+ * The matrix transposition algorithm isn't parallelized.<p>
+ *
+ * While the matrix transposition algorithm could easily be parallelized,
+ * on an SMP machine it does not make any sense. If the matrix doesn't fit
+ * in any processor specific cache then the memory (or higher level
+ * shared cache) bandwidth becomes a bottleneck in the algorithm. Matrix
+ * transposition is in principle a very simple algorithm - it doesn't do
+ * anything else than move data from one place to another. If shared memory
+ * is the bottleneck, then the algorithm isn't any faster if the data is being
+ * moved around by one thread or by multiple threads in parallel.<p>
+ *
+ * If the data fits in a processor specific cache, then the algorithm could
+ * theoretically be made faster with parallelization. To make the parallelization
+ * effective however, the data would have to be set up in some kind of a NUMA
+ * way. For example, each processor core would hold an equal section of
+ * the data in the processor cache. Then the algorithm could be made faster
+ * as each processor core could quickly transpose blocks of data that are in the
+ * processor cache, and then exchange blocks with other processor cores via the
+ * slower higher level shared cache or main memory.<p>
+ *
+ * This approach doesn't work well in practice however, at least not in a Java
+ * program. The reason is that there are no guarantees where the data is when
+ * the algorithm starts (in which processor core caches), and further there are
+ * no guarantees of any processor affinity for the threads that are executing
+ * in parallel. Different processor cores could be executing the transposition
+ * of different sections of the data at any moment, depending on how the
+ * operating system (and the JVM) schedule thread execution. And more often
+ * than not, the operating system isn't smart enough to apply any such processor
+ * affinity for the threads.<p>
+ *
+ * An additional problem for any NUMA based attempt is that the data array would
+ * have to be aligned on a cache line (e.g. 64 or 128 bytes), to prevent
+ * cache contention at the edges of each data section. But a JVM makes no such
+ * guarantees about memory alignment. And since pointers do not exist in Java,
+ * manually aligning memory addresses isn't possible.<p>
+ *
+ * Considering all of the above, the parallel algorithm doesn't in practice work
+ * any faster than the single-thread algorithm, as the algorithm is bound by the
+ * memory bandwidth (or shared cache bandwidth). In some cases parallelization
+ * can even make the execution slower due to increased cache contention.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class FloatMatrixStrategy
+    implements MatrixStrategy
+{
+    /**
+     * Default constructor.
+     */
+
+    public FloatMatrixStrategy()
+    {
+    }
+
+    /**
+     * Transpose a n<sub>1</sub> x n<sub>2</sub> matrix.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two.
+     * Additionally, one of these must be true:<p>
+     *
+     * n<sub>1</sub> = n<sub>2</sub><br>
+     * n<sub>1</sub> = 2*n<sub>2</sub><br>
+     * n<sub>2</sub> = 2*n<sub>1</sub><br>
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be transposed.
+     * @param n1 Number of rows in the matrix.
+     * @param n2 Number of columns in the matrix.
+     */
+
+    public void transpose(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException
+    {
+        float[] data = arrayAccess.getFloatData();
+        int offset = arrayAccess.getOffset();
+
+        if (n1 != (n1 & -n1) ||
+            n2 != (n2 & -n2) ||
+            n1 <= 0 || n2 <= 0)
+        {
+            throw new ApfloatInternalException("Matrix size must be a power of two, not " + n1 + " x " + n2);
+        }
+        if (n1 == n2)
+        {
+            // Simply transpose
+
+            transposeSquare(data, offset, n1, n1);
+        }
+        else if (n2 == 2 * n1)
+        {
+            // First transpose two n1 x n1 blocks
+            transposeSquare(data, offset, n1, n2);
+            transposeSquare(data, offset + n1, n1, n2);
+
+            // Then permute the rows to correct order
+            permuteToHalfWidth(data, offset, n1, n2);
+        }
+        else if (n1 == 2 * n2)
+        {
+            // First permute the rows to correct order
+            permuteToDoubleWidth(data, offset, n1, n2);
+
+            // Then transpose two n2 x n2 blocks
+            transposeSquare(data, offset, n2, n1);
+            transposeSquare(data, offset + n2, n2, n1);
+        }
+        else
+        {
+            throw new ApfloatInternalException("Must be n1 = n2, n1 = 2*n2 or n2 = 2*n1; matrix is " + n1 + " x " + n2);
+        }
+    }
+
+    /**
+     * Transpose a square n<sub>1</sub> x n<sub>1</sub> block of n<sub>1</sub> x n<sub>2</sub> matrix.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two,
+     * and n<sub>1</sub> &lt;= n<sub>2</sub>.
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be transposed.
+     * @param n1 Number of rows and columns in the block to be transposed.
+     * @param n2 Number of columns in the matrix.
+     */
+
+    public void transposeSquare(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException
+    {
+        transposeSquare(arrayAccess.getFloatData(), arrayAccess.getOffset(), n1, n2);
+    }
+
+    /**
+     * Permute the rows of the n<sub>1</sub> x n<sub>2</sub> matrix so that it is shaped like a
+     * n<sub>1</sub>/2 x 2*n<sub>2</sub> matrix. Logically, the matrix is split in half, and the
+     * lower half is moved to the right side of the upper half.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two,
+     * and n<sub>1</sub> &gt;= 2.<p>
+     *
+     * E.g. if the matrix layout is originally as follows:
+     * <table style="width:100px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix before">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td>
+     *   </tr>
+     *   <tr>
+     *     <td>4</td><td>5</td><td>6</td><td>7</td>
+     *   </tr>
+     *   <tr>
+     *     <td>8</td><td>9</td><td>10</td><td>11</td>
+     *   </tr>
+     *   <tr>
+     *     <td>12</td><td>13</td><td>14</td><td>15</td>
+     *   </tr>
+     * </table>
+     * <p>
+     *
+     * Then after this method it is as follows:
+     * <table style="width:200px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix after">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td><td>8</td><td>9</td><td>10</td><td>11</td>
+     *   </tr>
+     *   <tr>
+     *     <td>4</td><td>5</td><td>6</td><td>7</td><td>12</td><td>13</td><td>14</td><td>15</td>
+     *   </tr>
+     * </table>
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be permuted.
+     * @param n1 Number of rows in the matrix.
+     * @param n2 Number of columns in the matrix.
+     *
+     * @since 1.7.0
+     */
+
+    public void permuteToDoubleWidth(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException
+    {
+        if (n1 != (n1 & -n1) ||
+            n2 != (n2 & -n2) ||
+            n1 <= 0 || n2 <= 0)
+        {
+            throw new ApfloatInternalException("Matrix size must be a power of two, not " + n1 + " x " + n2);
+        }
+        if (n1 < 2)
+        {
+            throw new ApfloatInternalException("Matrix height must be at least 2.");
+        }
+        permuteToDoubleWidth(arrayAccess.getFloatData(), arrayAccess.getOffset(), n1, n2);
+    }
+
+    /**
+     * Permute the rows of the n<sub>1</sub> x n<sub>2</sub> matrix so that it is shaped like a
+     * 2*n<sub>1</sub> x n<sub>2</sub>/2 matrix. Logically, the matrix is split in half, and the
+     * right half is moved below the left half.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two.
+     *
+     * E.g. if the matrix layout is originally as follows:
+     * <table style="width:200px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix before">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td>
+     *   </tr>
+     *   <tr>
+     *     <td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td>
+     *   </tr>
+     * </table>
+     * <p>
+     *
+     * Then after this method it is as follows:
+     * <table style="width:100px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix after">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td>
+     *   </tr>
+     *   <tr>
+     *     <td>8</td><td>9</td><td>10</td><td>11</td>
+     *   </tr>
+     *   <tr>
+     *     <td>4</td><td>5</td><td>6</td><td>7</td>
+     *   </tr>
+     *   <tr>
+     *     <td>12</td><td>13</td><td>14</td><td>15</td>
+     *   </tr>
+     * </table>
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be permuted.
+     * @param n1 Number of rows in the matrix.
+     * @param n2 Number of columns in the matrix.
+     *
+     * @since 1.7.0
+     */
+
+    public void permuteToHalfWidth(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException
+    {
+        if (n1 != (n1 & -n1) ||
+            n2 != (n2 & -n2) ||
+            n1 <= 0 || n2 <= 0)
+        {
+            throw new ApfloatInternalException("Matrix size must be a power of two, not " + n1 + " x " + n2);
+        }
+        permuteToHalfWidth(arrayAccess.getFloatData(), arrayAccess.getOffset(), n1, n2);
+    }
+
+    // Move a b x b block from source to dest
+    private static void moveBlock(float[] source, int sourceOffset, int sourceWidth, float[] dest, int destOffset, int destWidth, int b)
+    {
+        for (int i = 0; i < b; i++)
+        {
+            System.arraycopy(source, sourceOffset, dest, destOffset, b);
+
+            destOffset += destWidth;
+            sourceOffset += sourceWidth;
+        }
+    }
+
+    // Transpose two b x b blocks of matrix with specified width
+    // data based on offset1 is accessed in columns, data based on offset2 in rows
+    private static void transpose2blocks(float[] data, int offset1, int offset2, int width, int b)
+    {
+        for (int i = 0, position1 = offset2; i < b; i++, position1 += width)
+        {
+            for (int j = 0, position2 = offset1 + i; j < b; j++, position2 += width)
+            {
+                float tmp = data[position1 + j];
+                data[position1 + j] = data[position2];
+                data[position2] = tmp;
+            }
+        }
+    }
+
+    // Transpose a b x b block of matrix with specified width
+    private static void transposeBlock(float[] data, int offset, int width, int b)
+    {
+        for (int i = 0, position1 = offset; i < b; i++, position1 += width)
+        {
+            for (int j = i + 1, position2 = offset + j * width + i; j < b; j++, position2 += width)
+            {
+                float tmp = data[position1 + j];
+                data[position1 + j] = data[position2];
+                data[position2] = tmp;
+            }
+        }
+    }
+
+    // Transpose a square n1 x n1 block of n1 x n2 matrix in b x b blocks
+    private static void transposeSquare(float[] data, int offset, int n1, int n2)
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        int cacheBurstBlockSize = Util.round2down(ctx.getCacheBurst() / 8),   // Cache burst in floats
+            cacheBlockSize = Util.sqrt4down(ctx.getCacheL1Size() / 8),        // Transpose block size b that fits in processor L1 cache
+            cacheTreshold = Util.round2down(ctx.getCacheL2Size() / 8);        // Size of matrix that fits in L2 cache
+
+        if (n1 <= cacheBurstBlockSize || n1 <= cacheBlockSize)
+        {
+            // Whole matrix fits in L1 cache
+
+            transposeBlock(data, offset, n2, n1);
+        }
+        else if (n1 * n2 <= cacheTreshold)
+        {
+            // Whole matrix fits in L2 cache (but not in L1 cache)
+            // Sometimes the first algorithm (the block above) is faster, if your L2 cache is very fast
+
+            int b = cacheBurstBlockSize;
+
+            for (int i = 0, position1 = offset; i < n1; i += b, position1 += b * n2)
+            {
+                transposeBlock(data, position1 + i, n2, b);
+
+                for (int j = i + b, position2 = offset + j * n2 + i; j < n1; j += b, position2 += b * n2)
+                {
+                    transpose2blocks(data, position1 + j, position2, n2, b);
+                }
+            }
+        }
+        else
+        {
+            // Whole matrix doesn't fit in L2 cache
+            // This algorithm works fastest if L1 cache size is set correctly
+
+            int b = cacheBlockSize;
+
+            float[] tmp1 = new float[b * b],
+                      tmp2 = new float[b * b];
+
+            for (int i = 0, position1 = offset; i < n1; i += b, position1 += b * n2)
+            {
+                moveBlock(data, position1 + i, n2, tmp1, 0, b, b);
+                transposeBlock(tmp1, 0, b, b);
+                moveBlock(tmp1, 0, b, data, position1 + i, n2, b);
+
+                for (int j = i + b, position2 = offset + j * n2 + i; j < n1; j += b, position2 += b * n2)
+                {
+                    moveBlock(data, position1 + j, n2, tmp1, 0, b, b);
+                    transposeBlock(tmp1, 0, b, b);
+
+                    moveBlock(data, position2, n2, tmp2, 0, b, b);
+                    transposeBlock(tmp2, 0, b, b);
+
+                    moveBlock(tmp2, 0, b, data, position1 + j, n2, b);
+                    moveBlock(tmp1, 0, b, data, position2, n2, b);
+                }
+            }
+        }
+    }
+
+    // Permute the rows of matrix to correct order, to make the n1 x n2 matrix half as wide (2*n1 x n2/2)
+    private static void permuteToHalfWidth(float[] data, int offset, int n1, int n2)
+    {
+        if (n1 < 2)
+        {
+            return;
+        }
+
+        int twicen1 = 2 * n1;
+        int halfn2 = n2 / 2;
+        float[] tmp = new float[halfn2];
+        boolean[] isRowDone = new boolean[twicen1];
+
+        int j = 1;
+        do
+        {
+            int o = j,
+                m = j;
+
+            System.arraycopy(data, offset + halfn2 * m, tmp, 0, halfn2);
+
+            isRowDone[m] = true;
+
+            m = (m < n1 ? 2 * m : 2 * (m - n1) + 1);
+
+            while (m != j)
+            {
+                isRowDone[m] = true;
+
+                System.arraycopy(data, offset + halfn2 * m, data, offset + halfn2 * o, halfn2);
+
+                o = m;
+                m = (m < n1 ? 2 * m : 2 * (m - n1) + 1);
+            }
+
+            System.arraycopy(tmp, 0, data, offset + halfn2 * o, halfn2);
+
+            while (isRowDone[j])
+            {
+                j++;
+            }
+        } while (j < twicen1 - 1);
+    }
+
+    // Permute the rows of matrix to correct order, to make the n1 x n2 matrix twice as wide (n1/2 x 2*n2)
+    private static void permuteToDoubleWidth(float[] data, int offset, int n1, int n2)
+    {
+        if (n1 < 4)
+        {
+            return;
+        }
+
+        int halfn1 = n1 / 2;
+        float[] tmp = new float[n2];
+        boolean[] isRowDone = new boolean[n1];
+
+        int j = 1;
+        do
+        {
+            int o = j,
+                m = j;
+
+            System.arraycopy(data, offset + n2 * m, tmp, 0, n2);
+
+            isRowDone[m] = true;
+
+            m = ((m & 1) != 0 ? m / 2 + halfn1 : m / 2);
+
+            while (m != j)
+            {
+                isRowDone[m] = true;
+
+                System.arraycopy(data, offset + n2 * m, data, offset + n2 * o, n2);
+
+                o = m;
+                m = ((m & 1) != 0 ? m / 2 + halfn1 : m / 2);
+            }
+
+            System.arraycopy(tmp, 0, data, offset + n2 * o, n2);
+
+            while (isRowDone[j])
+            {
+                j++;
+            }
+        } while (j < n1 - 1);
+    }
+}
Index: src/main/java/org/apfloat/internal/FloatMediumConvolutionStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatMediumConvolutionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatMediumConvolutionStrategy.java	(revision 0)
@@ -0,0 +1,125 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ConvolutionStrategy;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.DataStorage;
+
+/**
+ * Medium-length convolution strategy.
+ * Performs a simple O(n<sup>2</sup>) multiplication when the size of one operand is relatively short.
+ *
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class FloatMediumConvolutionStrategy
+    extends FloatBaseMath
+    implements ConvolutionStrategy
+{
+    // Implementation notes:
+    // - Assumes that the operands have been already truncated to match resultSize (the resultSize argument is ignored)
+    // - This class probably shouldn't be converted to a single class using generics because there is some performance impact
+
+    /**
+     * Creates a convolution strategy using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public FloatMediumConvolutionStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public DataStorage convolute(DataStorage x, DataStorage y, long resultSize)
+        throws ApfloatRuntimeException
+    {
+        DataStorage shortStorage, longStorage;
+
+        if (x.getSize() > y.getSize())
+        {
+            shortStorage = y;
+            longStorage = x;
+        }
+        else
+        {
+            shortStorage = x;
+            longStorage = y;
+        }
+
+        long shortSize = shortStorage.getSize(),
+             longSize = longStorage.getSize(),
+             size = shortSize + longSize;
+
+        if (shortSize > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Too long shorter number, size = " + shortSize);
+        }
+
+        final int bufferSize = (int) shortSize;
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        DataStorage resultStorage = dataStorageBuilder.createDataStorage(size * 4);
+        resultStorage.setSize(size);
+
+        DataStorage.Iterator src = longStorage.iterator(DataStorage.READ, longSize, 0),
+                             dst = resultStorage.iterator(DataStorage.WRITE, size, 0),
+                             tmpDst = new DataStorage.Iterator()                        // Cyclic iterator
+                             {
+                                 public void next()
+                                 {
+                                     this.position++;
+                                     this.position = (this.position == bufferSize ? 0 : this.position);
+                                 }
+
+                                 public float getFloat()
+                                 {
+                                     return this.buffer[this.position];
+                                 }
+
+                                 public void setFloat(float value)
+                                 {
+                                     this.buffer[this.position] = value;
+                                 }
+
+                                 private static final long serialVersionUID = 1L;
+
+                                 private float[] buffer = new float[bufferSize];
+                                 private int position = 0;
+                             };
+
+        for (long i = 0; i < longSize; i++)
+        {
+            DataStorage.Iterator tmpSrc = shortStorage.iterator(DataStorage.READ, shortSize, 0);        // Sub-optimal: this could be cyclic also
+
+            float factor = src.getFloat(),          // Get one word of source data
+                    carry = baseMultiplyAdd(tmpSrc, tmpDst, factor, 0, tmpDst, shortSize),
+                    result = tmpDst.getFloat();       // Least significant word of the result
+
+            dst.setFloat(result);     // Store one word of result
+
+            tmpDst.setFloat(carry);   // Set carry from calculation as new last word in cyclic buffer
+
+            tmpDst.next();              // Cycle buffer; current first word becomes last
+            src.next();
+            dst.next();
+        }
+
+        // Exhaust last words from temporary cyclic buffer and store them to result data
+        for (int i = 0; i < bufferSize; i++)
+        {
+            float result = tmpDst.getFloat();
+            dst.setFloat(result);
+
+            tmpDst.next();
+            dst.next();
+        }
+
+        return resultStorage;
+    }
+
+    private static final long serialVersionUID = -6697305140738370764L;
+}
Index: src/main/java/org/apfloat/internal/FloatMemoryArrayAccess.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatMemoryArrayAccess.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatMemoryArrayAccess.java	(revision 0)
@@ -0,0 +1,54 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Array access class based on a <code>float[]</code>.
+ *
+ * @version 1.6.3
+ * @author Mikko Tommila
+ */
+
+public class FloatMemoryArrayAccess
+    extends ArrayAccess
+{
+    /**
+     * Create an array access.<p>
+     *
+     * @param data The underlying array.
+     * @param offset The offset of the access segment within the array.
+     * @param length The access segment.
+     */
+
+    public FloatMemoryArrayAccess(float[] data, int offset, int length)
+    {
+        super(offset, length);
+        this.data = data;
+    }
+
+    public ArrayAccess subsequence(int offset, int length)
+    {
+        return new FloatMemoryArrayAccess(this.data, getOffset() + offset, length);
+    }
+
+    public Object getData()
+    {
+        return this.data;
+    }
+
+    public float[] getFloatData()
+    {
+        return this.data;
+    }
+
+    public void close()
+        throws ApfloatRuntimeException
+    {
+        this.data = null;       // Might have an impact on garbage collection
+    }
+
+    private static final long serialVersionUID = 7704133670961317045L;
+
+    private float[] data;
+}
Index: src/main/java/org/apfloat/internal/FloatMemoryDataStorage.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatMemoryDataStorage.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatMemoryDataStorage.java	(revision 0)
@@ -0,0 +1,287 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Memory based data storage implementation for the <code>float</code>
+ * element type.
+ *
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class FloatMemoryDataStorage
+    extends DataStorage
+{
+    /**
+     * Default constructor.
+     */
+
+    public FloatMemoryDataStorage()
+    {
+        this.data = new float[0];
+    }
+
+    /**
+     * Subsequence constructor.
+     *
+     * @param floatMemoryDataStorage The originating data storage.
+     * @param offset The subsequence starting position.
+     * @param length The subsequence length.
+     */
+
+    protected FloatMemoryDataStorage(FloatMemoryDataStorage floatMemoryDataStorage, long offset, long length)
+    {
+        super(floatMemoryDataStorage, offset, length);
+        this.data = floatMemoryDataStorage.data;
+    }
+
+    public boolean isCached()
+    {
+        return true;
+    }
+
+    protected DataStorage implSubsequence(long offset, long length)
+        throws ApfloatRuntimeException
+    {
+        return new FloatMemoryDataStorage(this, offset + getOffset(), length);
+    }
+
+    protected void implCopyFrom(DataStorage dataStorage, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (size > 0);
+        assert (!isReadOnly());
+        assert (!isSubsequenced());
+
+        if (size > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Size too big for memory array: " + size);
+        }
+
+        if (dataStorage == this)
+        {
+            setSize(size);
+            return;
+        }
+
+        this.data = new float[(int) size];
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        int readSize = (int) Math.min(size, dataStorage.getSize()),
+            position = 0,
+            bufferSize = ctx.getBlockSize() / 4;
+
+        while (readSize > 0)
+        {
+            int length = (int) Math.min(bufferSize, readSize);
+
+            ArrayAccess arrayAccess = dataStorage.getArray(READ, position, length);
+            System.arraycopy(arrayAccess.getFloatData(), arrayAccess.getOffset(), this.data, position, length);
+            arrayAccess.close();
+
+            readSize -= length;
+            position += length;
+       }
+    }
+
+    protected long implGetSize()
+    {
+        return this.data.length;
+    }
+
+    protected void implSetSize(long size)
+        throws ApfloatRuntimeException
+    {
+        assert (size > 0);
+        assert (!isReadOnly());
+        assert (!isSubsequenced());
+
+        if (size == this.data.length)
+        {
+            return;
+        }
+
+        if (size > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Size too big for memory array: " + size);
+        }
+
+        int newSize = (int) size;
+
+        float[] newData = new float[newSize];
+        System.arraycopy(this.data, 0, newData, 0, Math.min(this.data.length, newSize));
+        this.data = newData;
+    }
+
+    protected ArrayAccess implGetArray(int mode, long offset, int length)
+        throws ApfloatRuntimeException
+    {
+        return new FloatMemoryArrayAccess(this.data, (int) (offset + getOffset()), length);
+    }
+
+    protected ArrayAccess implGetArray(int mode, int startColumn, int columns, int rows)
+        throws ApfloatRuntimeException
+    {
+        throw new ApfloatInternalException("Method not implemented - would be sub-optimal; change the apfloat configuration settings");
+    }
+
+    protected ArrayAccess implGetTransposedArray(int mode, int startColumn, int columns, int rows)
+        throws ApfloatRuntimeException
+    {
+        throw new ApfloatInternalException("Method not implemented - would be sub-optimal; change the apfloat configuration settings");
+    }
+
+    private class ReadWriteIterator
+        extends AbstractIterator
+    {
+        public ReadWriteIterator(long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            this(READ_WRITE, startPosition, endPosition);
+        }
+
+        protected ReadWriteIterator(int mode, long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            super(mode, startPosition, endPosition);
+
+            this.data = FloatMemoryDataStorage.this.data;
+
+            this.position = (int) getPosition() + (int) getOffset();
+            this.length = (int) getLength();
+        }
+
+        public boolean hasNext()
+        {
+            return (this.length > 0);
+        }
+
+        public void next()
+            throws IllegalStateException
+        {
+            checkLength();
+            this.position += getIncrement();
+            this.length--;
+        }
+
+        public float getFloat()
+            throws IllegalStateException
+        {
+            checkLength();
+            return this.data[this.position];
+        }
+
+        public void setFloat(float value)
+            throws IllegalStateException
+        {
+            checkLength();
+            this.data[this.position] = value;
+        }
+
+        public <T> T get(Class<T> type)
+            throws UnsupportedOperationException, IllegalStateException
+        {
+            if (!(type.equals(Float.TYPE)))
+            {
+                throw new UnsupportedOperationException("Unsupported data type " + type.getCanonicalName() + ", the only supported type is float");
+            }
+            @SuppressWarnings("unchecked")
+            T value = (T) (Float) getFloat();
+            return value;
+        }
+
+        public <T> void set(Class<T> type, T value)
+            throws UnsupportedOperationException, IllegalArgumentException, IllegalStateException
+        {
+            if (!(type.equals(Float.TYPE)))
+            {
+                throw new UnsupportedOperationException("Unsupported data type " + type.getCanonicalName() + ", the only supported type is float");
+            }
+            if (!(value instanceof Float))
+            {
+                throw new IllegalArgumentException("Unsupported value type " + value.getClass().getCanonicalName() + ", the only supported type is Float");
+            }
+            setFloat((Float) value);
+        }
+
+        protected void checkLength()
+            throws IllegalStateException
+        {
+            if (this.length == 0)
+            {
+                throw new IllegalStateException("At the end of iterator");
+            }
+        }
+
+        private static final long serialVersionUID = -5979620684548284607L;
+
+        private float[] data;
+        private int position,
+                    length;
+    }
+
+    private class ReadOnlyIterator
+        extends ReadWriteIterator
+    {
+        public ReadOnlyIterator(long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            super(READ, startPosition, endPosition);
+        }
+
+        public void setFloat(float value)
+            throws IllegalStateException
+        {
+            throw new IllegalStateException("Not a writable iterator");
+        }
+
+        private static final long serialVersionUID = -6693429125989500778L;
+    }
+
+    private class WriteOnlyIterator
+        extends ReadWriteIterator
+    {
+        public WriteOnlyIterator(long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            super(WRITE, startPosition, endPosition);
+        }
+
+        public float getFloat()
+            throws IllegalStateException
+        {
+            throw new IllegalStateException("Not a readable iterator");
+        }
+
+        private static final long serialVersionUID = -5251200289176969505L;
+    }
+
+    public Iterator iterator(int mode, long startPosition, long endPosition)
+        throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+    {
+        Iterator iterator;
+        switch (mode & READ_WRITE)
+        {
+            case READ:
+                iterator = new ReadOnlyIterator(startPosition, endPosition);
+                break;
+            case WRITE:
+                iterator = new WriteOnlyIterator(startPosition, endPosition);
+                break;
+            case READ_WRITE:
+                iterator = new ReadWriteIterator(startPosition, endPosition);
+                break;
+            default:
+                throw new IllegalArgumentException("Illegal mode: " + mode);
+        }
+        return iterator;
+    }
+
+    private static final long serialVersionUID = -862001153825924236L;
+
+    private float[] data;
+}
Index: src/main/java/org/apfloat/internal/FloatModConstants.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatModConstants.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatModConstants.java	(revision 0)
@@ -0,0 +1,42 @@
+package org.apfloat.internal;
+
+/**
+ * Constants needed for various modular arithmetic operations for the <code>float</code> type.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public interface FloatModConstants
+{
+    /**
+     * Moduli to be used in number theoretic transforms.
+     * Allows transform lengths upto 3*2<sup>17</sup>.
+     */
+
+    public static final float MODULUS[] = { 16515073.0f, 14942209.0f, 14155777.0f };
+
+    /**
+     * Primitive roots for the corresponding moduli.
+     */
+
+    public static final float PRIMITIVE_ROOT[] = { 5.0f, 11.0f, 7.0f };
+
+    /**
+     * Maximum transform length for the moduli.
+     */
+
+    public static final long MAX_TRANSFORM_LENGTH = 393216;
+
+    /**
+     * Maximum bits in a power-of-two base that fits in a <code>float</code>.
+     */
+
+    public static final int MAX_POWER_OF_TWO_BITS = 24;
+
+    /**
+     * Maximum power-of-two base that fits in a <code>float</code>.
+     */
+
+    public static final float MAX_POWER_OF_TWO_BASE = (float) (1 << MAX_POWER_OF_TWO_BITS);
+}
Index: src/main/java/org/apfloat/internal/FloatModMath.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatModMath.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatModMath.java	(revision 0)
@@ -0,0 +1,159 @@
+package org.apfloat.internal;
+
+/**
+ * Modulo arithmetic functions for <code>float</code> data.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public class FloatModMath
+    extends FloatElementaryModMath
+{
+    /**
+     * Default constructor.
+     */
+
+    public FloatModMath()
+    {
+    }
+
+    /**
+     * Create a table of powers of n:th root of unity.
+     *
+     * @param w The n:th root of unity modulo the current modulus.
+     * @param n The table length (= transform length).
+     *
+     * @return Table of <code>table[i]=w<sup>i</sup> mod m</code>, i = 0, ..., n-1.
+     */
+
+    public final float[] createWTable(float w, int n)
+    {
+        float[] wTable = new float[n];
+        float wTemp = 1;
+
+        for (int i = 0; i < n; i++)
+        {
+            wTable[i] = wTemp;
+            wTemp = modMultiply(wTemp, w);
+        }
+
+        return wTable;
+    }
+
+    /**
+     * Get forward n:th root of unity. This is <code>w</code>.<p>
+     *
+     * Assumes that the modulus is prime.
+     *
+     * @param primitiveRoot Primitive root of the modulus.
+     * @param n The transform length.
+     *
+     * @return Forward n:th root of unity.
+     */
+
+    public float getForwardNthRoot(float primitiveRoot, long n)
+    {
+        return modPow(primitiveRoot, getModulus() - 1 - (getModulus() - 1) / (float) n);
+    }
+
+    /**
+     * Get inverse n:th root of unity. This is <code>w<sup>-1</sup></code>.<p>
+     *
+     * Assumes that the modulus is prime.
+     *
+     * @param primitiveRoot Primitive root of the modulus.
+     * @param n The transform length.
+     *
+     * @return Inverse n:th root of unity.
+     */
+
+    public float getInverseNthRoot(float primitiveRoot, long n)
+    {
+        return modPow(primitiveRoot, (getModulus() - 1) / (float) n);
+    }
+
+    /**
+     * Modular inverse, that is <code>1 / a</code>. Assumes that the modulus is prime.
+     *
+     * @param a The operand.
+     *
+     * @return <code>a<sup>-1</sup> mod m</code>.
+     */
+
+    public final float modInverse(float a)
+    {
+        return modPow(a, getModulus() - 2);
+    }
+
+    /**
+     * Modular division. Assumes that the modulus is prime.
+     *
+     * @param a The dividend.
+     * @param b The divisor.
+     *
+     * @return <code>a*b<sup>-1</sup> mod m</code>.
+     */
+
+    public final float modDivide(float a, float b)
+    {
+        return modMultiply(a, modInverse(b));
+    }
+
+    /**
+     * Modular negation.
+     *
+     * @param a The argument.
+     *
+     * @return <code>-a mod m</code>.
+     */
+
+    public final float negate(float a)
+    {
+        return (a == 0 ? 0 : getModulus() - a);
+    }
+
+    /**
+     * Modular power. Assumes that the modulus is prime.
+     *
+     * @param a The base.
+     * @param n The exponent.
+     *
+     * @return <code>a<sup>n</sup> mod m</code>.
+     */
+
+    public final float modPow(float a, float n)
+    {
+        assert (a != 0 || n != 0);
+
+        if (n == 0)
+        {
+            return 1;
+        }
+        else if (n < 0)
+        {
+            return modPow(a, getModulus() - 1 + n);
+        }
+
+        long exponent = (long) n;
+
+        while ((exponent & 1) == 0)
+        {
+            a = modMultiply(a, a);
+            exponent >>= 1;
+        }
+
+        float r = a;
+
+        while ((exponent >>= 1) > 0)
+        {
+            a = modMultiply(a, a);
+            if ((exponent & 1) != 0)
+            {
+                r = modMultiply(r, a);
+            }
+        }
+
+        return r;
+    }
+}
Index: src/main/java/org/apfloat/internal/FloatNTTBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatNTTBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatNTTBuilder.java	(revision 0)
@@ -0,0 +1,66 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.NTTStrategy;
+import org.apfloat.spi.NTTStepStrategy;
+import org.apfloat.spi.Factor3NTTStepStrategy;
+import org.apfloat.spi.NTTConvolutionStepStrategy;
+
+/**
+ * Creates Number Theoretic Transforms for the
+ * <code>float</code> type.
+ *
+ * @see FloatTableFNTStrategy
+ * @see SixStepFNTStrategy
+ * @see TwoPassFNTStrategy
+ * @see Factor3NTTStrategy
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class FloatNTTBuilder
+    extends AbstractNTTBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public FloatNTTBuilder()
+    {
+    }
+
+    public NTTStepStrategy createNTTSteps()
+    {
+        return new FloatNTTStepStrategy();
+    }
+
+    public NTTConvolutionStepStrategy createNTTConvolutionSteps()
+    {
+        return new FloatNTTConvolutionStepStrategy();
+    }
+
+    public Factor3NTTStepStrategy createFactor3NTTSteps()
+    {
+        return new FloatFactor3NTTStepStrategy();
+    }
+
+    protected NTTStrategy createSimpleFNTStrategy()
+    {
+        return new FloatTableFNTStrategy();
+    }
+
+    protected NTTStrategy createSixStepFNTStrategy()
+    {
+        return new SixStepFNTStrategy();
+    }
+
+    protected NTTStrategy createTwoPassFNTStrategy()
+    {
+        return new TwoPassFNTStrategy();
+    }
+
+    protected NTTStrategy createFactor3NTTStrategy(NTTStrategy nttStrategy)
+    {
+        return new Factor3NTTStrategy(nttStrategy);
+    }
+}
Index: src/main/java/org/apfloat/internal/FloatNTTConvolutionStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatNTTConvolutionStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatNTTConvolutionStepStrategy.java	(revision 0)
@@ -0,0 +1,186 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.NTTConvolutionStepStrategy;
+import org.apfloat.spi.DataStorage;
+import static org.apfloat.internal.FloatModConstants.*;
+
+/**
+ * Steps of a three-NTT convolution for the <code>float</code> type.
+ * This class implements the details of the element-by-element multiplication
+ * and element-by-element squaring of the transformed elements.<p>
+ *
+ * The in-place multiplication and squaring of the data elements is done
+ * using a parallel algorithm, if the data fits in memory.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class FloatNTTConvolutionStepStrategy
+    extends FloatModMath
+    implements NTTConvolutionStepStrategy, Parallelizable
+{
+    // Runnable for multiplying elements in place
+    private class MultiplyInPlaceRunnable
+        implements Runnable
+    {
+        public MultiplyInPlaceRunnable(DataStorage sourceAndDestination, DataStorage source, long offset, long length)
+        {
+            this.sourceAndDestination = sourceAndDestination;
+            this.source = source;
+            this.offset = offset;
+            this.length = length;
+        }
+
+        public void run()
+        {
+            DataStorage.Iterator dest = this.sourceAndDestination.iterator(DataStorage.READ_WRITE, this.offset, this.offset + this.length),
+                                 src = this.source.iterator(DataStorage.READ, this.offset, this.offset + this.length);
+
+            while (this.length > 0)
+            {
+                dest.setFloat(modMultiply(dest.getFloat(), src.getFloat()));
+
+                dest.next();
+                src.next();
+                this.length--;
+            }
+        }
+
+        private DataStorage sourceAndDestination,
+                            source;
+        private long offset,
+                     length;
+    }
+
+    // Runnable for squaring elements in place
+    private class SquareInPlaceRunnable
+        implements Runnable
+    {
+        public SquareInPlaceRunnable(DataStorage sourceAndDestination, long offset, long length)
+        {
+            this.sourceAndDestination = sourceAndDestination;
+            this.offset = offset;
+            this.length = length;
+        }
+
+        public void run()
+        {
+            DataStorage.Iterator iterator = this.sourceAndDestination.iterator(DataStorage.READ_WRITE, this.offset, this.offset + this.length);
+
+            while (this.length > 0)
+            {
+                float value = iterator.getFloat();
+                iterator.setFloat(modMultiply(value, value));
+
+                iterator.next();
+                this.length--;
+            }
+        }
+
+        private DataStorage sourceAndDestination;
+        private long offset,
+                     length;
+    }
+
+    /**
+     * Default constructor.
+     */
+
+    public FloatNTTConvolutionStepStrategy()
+    {
+    }
+
+    public void multiplyInPlace(DataStorage sourceAndDestination, DataStorage source, int modulus)
+        throws ApfloatRuntimeException
+    {
+        assert (sourceAndDestination != source);
+
+        long size = sourceAndDestination.getSize();
+
+        ParallelRunnable parallelRunnable = createMultiplyInPlaceParallelRunnable(sourceAndDestination, source, modulus);
+
+        if (size <= Integer.MAX_VALUE &&                                        // Only if the size fits in an integer, but with memory arrays it should
+            sourceAndDestination.isCached() && source.isCached())               // Only if the data storage supports efficient parallel random access
+        {
+            ParallelRunner.runParallel(parallelRunnable);
+        }
+        else
+        {
+            parallelRunnable.run();                                             // Just run in current thread without parallelization
+        }
+    }
+
+    public void squareInPlace(DataStorage sourceAndDestination, int modulus)
+        throws ApfloatRuntimeException
+    {
+        long size = sourceAndDestination.getSize();
+
+        ParallelRunnable parallelRunnable = createSquareInPlaceParallelRunnable(sourceAndDestination, modulus);
+
+        if (size <= Integer.MAX_VALUE &&                                    // Only if the size fits in an integer, but with memory arrays it should
+            sourceAndDestination.isCached())                                // Only if the data storage supports efficient parallel random access
+        {
+            ParallelRunner.runParallel(parallelRunnable);
+        }
+        else
+        {
+            parallelRunnable.run();                                         // Just run in current thread without parallelization
+        }
+    }
+
+    /**
+     * Create a ParallelRunnable for multiplying the elements in-place.
+     *
+     * @param sourceAndDestination The first source data storage, which is also the destination.
+     * @param source The second source data storage.
+     * @param modulus Which modulus to use (0, 1, 2)
+     *
+     * @return An object suitable for multiplying the elements in parallel.
+     */
+
+    protected ParallelRunnable createMultiplyInPlaceParallelRunnable(final DataStorage sourceAndDestination, final DataStorage source, int modulus)
+    {
+        final long size = sourceAndDestination.getSize();
+
+        setModulus(MODULUS[modulus]);
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(size)
+        {
+            public Runnable getRunnable(long offset, long length)
+            {
+                return new MultiplyInPlaceRunnable(sourceAndDestination, source, offset, length);
+            }
+        };
+        return parallelRunnable;
+    }
+
+    /**
+     * Create a ParallelRunnable for squaring the elements in-place.
+     *
+     * @param sourceAndDestination The source data storage, which is also the destination.
+     * @param modulus Which modulus to use (0, 1, 2)
+     *
+     * @return An object suitable for squaring the elements in parallel.
+     */
+
+    protected ParallelRunnable createSquareInPlaceParallelRunnable(final DataStorage sourceAndDestination, int modulus)
+    {
+        final long size = sourceAndDestination.getSize();
+
+        setModulus(MODULUS[modulus]);
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(size)
+        {
+            public Runnable getRunnable(long offset, long length)
+            {
+                return new SquareInPlaceRunnable(sourceAndDestination, offset, length);
+            }
+        };
+        return parallelRunnable;
+    }
+}
Index: src/main/java/org/apfloat/internal/FloatNTTStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatNTTStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatNTTStepStrategy.java	(revision 0)
@@ -0,0 +1,210 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ArrayAccess;
+import org.apfloat.spi.NTTStepStrategy;
+import static org.apfloat.internal.FloatModConstants.*;
+
+/**
+ * Common methods to calculate Fast Number Theoretic Transforms
+ * in parallel using multiple threads.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class FloatNTTStepStrategy
+    extends FloatTableFNT
+    implements NTTStepStrategy, Parallelizable
+{
+    // Runnable for calculating the row transforms in parallel
+    private class TableFNTRunnable
+        implements Runnable
+    {
+        public TableFNTRunnable(int length, boolean isInverse, ArrayAccess arrayAccess, float[] wTable, int[] permutationTable)
+        {
+            this.length = length;               // Transform length
+            this.isInverse = isInverse;
+            this.arrayAccess = arrayAccess;
+            this.wTable = wTable;
+            this.permutationTable = permutationTable;
+        }
+
+        public void run()
+        {
+            int maxI = this.arrayAccess.getLength();
+
+            for (int i = 0; i < maxI; i += this.length)
+            {
+                ArrayAccess arrayAccess = this.arrayAccess.subsequence(i, this.length);
+
+                if (this.isInverse)
+                {
+                    inverseTableFNT(arrayAccess, this.wTable, this.permutationTable);
+                }
+                else
+                {
+                    tableFNT(arrayAccess, this.wTable, this.permutationTable);
+                }
+            }
+        }
+
+        private int length;
+        private boolean isInverse;
+        private ArrayAccess arrayAccess;
+        private float[] wTable;
+        private int[] permutationTable;
+    }
+
+    // Runnable for multiplying elements in the matrix
+    private class MultiplyRunnable
+        implements Runnable
+    {
+        public MultiplyRunnable(ArrayAccess arrayAccess, int startRow, int startColumn, int rows, int columns, float w, float scaleFactor)
+        {
+            this.arrayAccess = arrayAccess;
+            this.startRow = startRow;
+            this.startColumn = startColumn;
+            this.rows = rows;
+            this.columns = columns;
+            this.w = w;
+            this.scaleFactor = scaleFactor;
+        }
+
+        public void run()
+        {
+            float[] data = this.arrayAccess.getFloatData();
+            int position = this.arrayAccess.getOffset();
+            float rowFactor = modPow(this.w, (float) this.startRow);
+            float columnFactor = modPow(this.w, (float) this.startColumn);
+            float rowStartFactor = modMultiply(this.scaleFactor, modPow(rowFactor, (float) this.startColumn));
+
+            for (int i = 0; i < this.rows; i++)
+            {
+                float factor = rowStartFactor;
+
+                for (int j = 0; j < this.columns; j++, position++)
+                {
+                    data[position] = modMultiply(data[position], factor);
+                    factor = modMultiply(factor, rowFactor);
+                }
+
+                rowFactor = modMultiply(rowFactor, this.w);
+                rowStartFactor = modMultiply(rowStartFactor, columnFactor);
+            }
+         }
+
+        private ArrayAccess arrayAccess;
+        private int startRow;
+        private int startColumn;
+        private int rows;
+        private int columns;
+        private float w;
+        private float scaleFactor;
+    }
+
+    /**
+     * Default constructor.
+     */
+
+    public FloatNTTStepStrategy()
+    {
+    }
+
+    public void multiplyElements(ArrayAccess arrayAccess, int startRow, int startColumn, int rows, int columns, long length, long totalTransformLength, boolean isInverse, int modulus)
+        throws ApfloatRuntimeException
+    {
+        ParallelRunnable parallelRunnable = createMultiplyElementsParallelRunnable(arrayAccess, startRow, startColumn, rows, columns, length, totalTransformLength, isInverse, modulus);
+
+        ParallelRunner.runParallel(parallelRunnable);
+    }
+
+    public void transformRows(ArrayAccess arrayAccess, int length, int count, boolean isInverse, boolean permute, int modulus)
+        throws ApfloatRuntimeException
+    {
+        ParallelRunnable parallelRunnable = createTransformRowsParallelRunnable(arrayAccess, length, count, isInverse, permute, modulus);
+
+        ParallelRunner.runParallel(parallelRunnable);
+    }
+
+    public long getMaxTransformLength()
+    {
+        return MAX_TRANSFORM_LENGTH;
+    }
+
+    /**
+     * Create a ParallelRunnable object for multiplying the elements of the matrix.
+     *
+     * @param arrayAccess The memory array to multiply.
+     * @param startRow Which row in the whole matrix the starting row in the <code>arrayAccess</code> is.
+     * @param startColumn Which column in the whole matrix the starting column in the <code>arrayAccess</code> is.
+     * @param rows The number of rows in the <code>arrayAccess</code> to multiply.
+     * @param columns The number of columns in the matrix (= n<sub>2</sub>).
+     * @param length The length of data in the matrix being transformed.
+     * @param totalTransformLength The total transform length, for the scaling factor. Used only for the inverse case.
+     * @param isInverse If the multiplication is done for the inverse transform or not.
+     * @param modulus Index of the modulus.
+     *
+     * @return An object suitable for multiplying the elements of the matrix in parallel.
+     */
+
+    protected ParallelRunnable createMultiplyElementsParallelRunnable(final ArrayAccess arrayAccess, final int startRow, final int startColumn, final int rows, final int columns, long length, long totalTransformLength, boolean isInverse, int modulus)
+        throws ApfloatRuntimeException
+    {
+        setModulus(MODULUS[modulus]);
+        final float w = (isInverse ?
+                           getInverseNthRoot(PRIMITIVE_ROOT[modulus], length) :
+                           getForwardNthRoot(PRIMITIVE_ROOT[modulus], length));
+        final float scaleFactor = (isInverse ?
+                                     modDivide((float) 1, (float) totalTransformLength) :
+                                     (float) 1);
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(rows)
+        {
+            public Runnable getRunnable(int strideStartRow, int strideRows)
+            {
+                ArrayAccess subArrayAccess = arrayAccess.subsequence(strideStartRow * columns, strideRows * columns);
+                return new MultiplyRunnable(subArrayAccess, startRow + strideStartRow, startColumn, strideRows, columns, w, scaleFactor);
+            }
+        };
+
+        return parallelRunnable;
+    }
+
+    /**
+     * Create a ParallelRunnable object for transforming the rows of the matrix.
+     *
+     * @param arrayAccess The memory array to split to rows and to transform.
+     * @param length Length of one transform (one row).
+     * @param count Number of rows.
+     * @param isInverse <code>true</code> if an inverse transform is performed, <code>false</code> if a forward transform is performed.
+     * @param permute If permutation should be done.
+     * @param modulus Index of the modulus.
+     *
+     * @return An object suitable for transforming the rows of the matrix in parallel.
+     */
+
+    protected ParallelRunnable createTransformRowsParallelRunnable(final ArrayAccess arrayAccess, final int length, final int count, final boolean isInverse, boolean permute, int modulus)
+        throws ApfloatRuntimeException
+    {
+        setModulus(MODULUS[modulus]);
+        final float[] wTable = (isInverse ?
+                                  FloatWTables.getInverseWTable(modulus, length) :
+                                  FloatWTables.getWTable(modulus, length));
+        final int[] permutationTable = (permute ? Scramble.createScrambleTable(length) : null);
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(count)
+        {
+            public Runnable getRunnable(int startIndex, int strideCount)
+            {
+                ArrayAccess subArrayAccess = arrayAccess.subsequence(startIndex * length, strideCount * length);
+                return new TableFNTRunnable(length, isInverse, subArrayAccess, wTable, permutationTable);
+            }
+        };
+
+        return parallelRunnable;
+    }
+}
Index: src/main/java/org/apfloat/internal/FloatRadixConstants.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatRadixConstants.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatRadixConstants.java	(revision 0)
@@ -0,0 +1,36 @@
+package org.apfloat.internal;
+
+/**
+ * Constants related to different radixes for the <code>float</code> data type.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public interface FloatRadixConstants
+{
+    /**
+     * Bases for radixes 2, ..., 36. The base is the radix to the maximum power
+     * so that the base is less than all moduli used.
+     */
+
+    public static final float BASE[] = { (float) -1L, (float) -1L, (float) 8388608L, (float) 4782969L, (float) 4194304L, (float) 9765625L, (float) 10077696L, (float) 5764801L, (float) 2097152L, (float) 4782969L, (float) 10000000L, (float) 1771561L, (float) 2985984L, (float) 4826809L, (float) 7529536L, (float) 11390625L, (float) 1048576L, (float) 1419857L, (float) 1889568L, (float) 2476099L, (float) 3200000L, (float) 4084101L, (float) 5153632L, (float) 6436343L, (float) 7962624L, (float) 9765625L, (float) 11881376L, (float) 531441L, (float) 614656L, (float) 707281L, (float) 810000L, (float) 923521L, (float) 1048576L, (float) 1185921L, (float) 1336336L, (float) 1500625L, (float) 1679616L };
+
+    /**
+     * The power of the radix in each base.
+     */
+
+    public static final int BASE_DIGITS[] = { -1, -1, 23, 14, 11, 10, 9, 8, 7, 7, 7, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
+
+    /**
+     * The minimum number in each radix to have the specified amount of digits.
+     */
+
+    public static final float MINIMUM_FOR_DIGITS[][] = { null, null, { (float) 1L, (float) 2L, (float) 4L, (float) 8L, (float) 16L, (float) 32L, (float) 64L, (float) 128L, (float) 256L, (float) 512L, (float) 1024L, (float) 2048L, (float) 4096L, (float) 8192L, (float) 16384L, (float) 32768L, (float) 65536L, (float) 131072L, (float) 262144L, (float) 524288L, (float) 1048576L, (float) 2097152L, (float) 4194304L }, { (float) 1L, (float) 3L, (float) 9L, (float) 27L, (float) 81L, (float) 243L, (float) 729L, (float) 2187L, (float) 6561L, (float) 19683L, (float) 59049L, (float) 177147L, (float) 531441L, (float) 1594323L }, { (float) 1L, (float) 4L, (float) 16L, (float) 64L, (float) 256L, (float) 1024L, (float) 4096L, (float) 16384L, (float) 65536L, (float) 262144L, (float) 1048576L }, { (float) 1L, (float) 5L, (float) 25L, (float) 125L, (float) 625L, (float) 3125L, (float) 15625L, (float) 78125L, (float) 390625L, (float) 1953125L }, { (float) 1L, (float) 6L, (float) 36L, (float) 216L, (float) 1296L, (float) 7776L, (float) 46656L, (float) 279936L, (float) 1679616L }, { (float) 1L, (float) 7L, (float) 49L, (float) 343L, (float) 2401L, (float) 16807L, (float) 117649L, (float) 823543L }, { (float) 1L, (float) 8L, (float) 64L, (float) 512L, (float) 4096L, (float) 32768L, (float) 262144L }, { (float) 1L, (float) 9L, (float) 81L, (float) 729L, (float) 6561L, (float) 59049L, (float) 531441L }, { (float) 1L, (float) 10L, (float) 100L, (float) 1000L, (float) 10000L, (float) 100000L, (float) 1000000L }, { (float) 1L, (float) 11L, (float) 121L, (float) 1331L, (float) 14641L, (float) 161051L }, { (float) 1L, (float) 12L, (float) 144L, (float) 1728L, (float) 20736L, (float) 248832L }, { (float) 1L, (float) 13L, (float) 169L, (float) 2197L, (float) 28561L, (float) 371293L }, { (float) 1L, (float) 14L, (float) 196L, (float) 2744L, (float) 38416L, (float) 537824L }, { (float) 1L, (float) 15L, (float) 225L, (float) 3375L, (float) 50625L, (float) 759375L }, { (float) 1L, (float) 16L, (float) 256L, (float) 4096L, (float) 65536L }, { (float) 1L, (float) 17L, (float) 289L, (float) 4913L, (float) 83521L }, { (float) 1L, (float) 18L, (float) 324L, (float) 5832L, (float) 104976L }, { (float) 1L, (float) 19L, (float) 361L, (float) 6859L, (float) 130321L }, { (float) 1L, (float) 20L, (float) 400L, (float) 8000L, (float) 160000L }, { (float) 1L, (float) 21L, (float) 441L, (float) 9261L, (float) 194481L }, { (float) 1L, (float) 22L, (float) 484L, (float) 10648L, (float) 234256L }, { (float) 1L, (float) 23L, (float) 529L, (float) 12167L, (float) 279841L }, { (float) 1L, (float) 24L, (float) 576L, (float) 13824L, (float) 331776L }, { (float) 1L, (float) 25L, (float) 625L, (float) 15625L, (float) 390625L }, { (float) 1L, (float) 26L, (float) 676L, (float) 17576L, (float) 456976L }, { (float) 1L, (float) 27L, (float) 729L, (float) 19683L }, { (float) 1L, (float) 28L, (float) 784L, (float) 21952L }, { (float) 1L, (float) 29L, (float) 841L, (float) 24389L }, { (float) 1L, (float) 30L, (float) 900L, (float) 27000L }, { (float) 1L, (float) 31L, (float) 961L, (float) 29791L }, { (float) 1L, (float) 32L, (float) 1024L, (float) 32768L }, { (float) 1L, (float) 33L, (float) 1089L, (float) 35937L }, { (float) 1L, (float) 34L, (float) 1156L, (float) 39304L }, { (float) 1L, (float) 35L, (float) 1225L, (float) 42875L }, { (float) 1L, (float) 36L, (float) 1296L, (float) 46656L } };
+
+    /**
+     * Maximum allowed exponent for each radix.
+     */
+
+    public static final long MAX_EXPONENT[] = { -1L, -1L, 401016175515425029L, 658812288346769694L, 838488366986797794L, 922337203685477574L, 1024819115206086194L, 1152921504606846969L, 1317624576693539395L, 1317624576693539395L, 1317624576693539395L, 1537228672809129295L, 1537228672809129295L, 1537228672809129295L, 1537228672809129295L, 1537228672809129295L, 1844674407370955155L, 1844674407370955155L, 1844674407370955155L, 1844674407370955155L, 1844674407370955155L, 1844674407370955155L, 1844674407370955155L, 1844674407370955155L, 1844674407370955155L, 1844674407370955155L, 1844674407370955155L, 2305843009213693945L, 2305843009213693945L, 2305843009213693945L, 2305843009213693945L, 2305843009213693945L, 2305843009213693945L, 2305843009213693945L, 2305843009213693945L, 2305843009213693945L, 2305843009213693945L };
+}
Index: src/main/java/org/apfloat/internal/FloatScramble.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatScramble.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatScramble.java	(revision 0)
@@ -0,0 +1,38 @@
+package org.apfloat.internal;
+
+/**
+ * Functions to perform bit-reverse ordering of <code>float</code> data.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public class FloatScramble
+{
+    private FloatScramble()
+    {
+    }
+
+    /**
+     * Permute the data in the table to bit-reversed order.<p>
+     *
+     * The permutation table argument should contain pairs of indexes
+     * that indicate array elements whose contents are swapped.
+     *
+     * @param data The array to permute.
+     * @param offset The offset within the array to permute.
+     * @param permutationTable Table of indexes indicating, which elements in the <code>data</code> are to be swapped.
+     */
+
+    public static void scramble(float[] data, int offset, int[] permutationTable)
+    {
+        for (int k = 0; k < permutationTable.length; k += 2)
+        {
+            int i = offset + permutationTable[k],
+                j = offset + permutationTable[k + 1];
+            float tmp = data[i];
+            data[i] = data[j];
+            data[j] = tmp;
+        }
+    }
+}
Index: src/main/java/org/apfloat/internal/FloatShortConvolutionStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatShortConvolutionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatShortConvolutionStrategy.java	(revision 0)
@@ -0,0 +1,77 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ConvolutionStrategy;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Short convolution strategy.
+ * Performs a simple multiplication when the size of one operand is 1.
+ *
+ * @version 1.1
+ * @author Mikko Tommila
+ */
+
+public class FloatShortConvolutionStrategy
+    extends FloatBaseMath
+    implements ConvolutionStrategy
+{
+    // Implementation notes:
+    // - Assumes that the operands have been already truncated to match resultSize (the resultSize argument is ignored)
+    // - This class shouldn't be converted to a single class using generics because the performance impact is noticeable
+
+    /**
+     * Creates a convolution strategy using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public FloatShortConvolutionStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public DataStorage convolute(DataStorage x, DataStorage y, long resultSize)
+        throws ApfloatRuntimeException
+    {
+        DataStorage shortStorage, longStorage, resultStorage;
+
+        if (x.getSize() > 1)
+        {
+            shortStorage = y;
+            longStorage = x;
+        }
+        else
+        {
+            shortStorage = x;
+            longStorage = y;
+        }
+
+        assert (shortStorage.getSize() == 1);
+
+        long size = longStorage.getSize() + 1;
+
+        ArrayAccess arrayAccess = shortStorage.getArray(DataStorage.READ, 0, 1);
+        float factor = arrayAccess.getFloatData()[arrayAccess.getOffset()];
+        arrayAccess.close();
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        resultStorage = dataStorageBuilder.createDataStorage(size * 4);
+        resultStorage.setSize(size);
+
+        DataStorage.Iterator src = longStorage.iterator(DataStorage.READ, size - 1, 0),
+                             dst = resultStorage.iterator(DataStorage.WRITE, size, 0);
+
+        float carry = baseMultiplyAdd(src, null, factor, 0, dst, size - 1);
+        dst.setFloat(carry);
+        dst.close();
+
+        return resultStorage;
+    }
+
+    private static final long serialVersionUID = 3839614758362699756L;
+}
Index: src/main/java/org/apfloat/internal/FloatTableFNT.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatTableFNT.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatTableFNT.java	(revision 0)
@@ -0,0 +1,159 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Fast Number Theoretic Transform that uses lookup tables
+ * for powers of n:th root of unity and permutation indexes.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class FloatTableFNT
+    extends FloatModMath
+{
+    /**
+     * Default constructor.
+     */
+
+    public FloatTableFNT()
+    {
+    }
+
+    /**
+     * Forward (Sande-Tukey) fast Number Theoretic Transform.
+     * Data length must be a power of two.
+     *
+     * @param arrayAccess The data array to transform.
+     * @param wTable Table of powers of n:th root of unity <code>w</code> modulo the current modulus.
+     * @param permutationTable Table of permutation indexes, or <code>null</code> if the data should not be permuted.
+     */
+
+    public void tableFNT(ArrayAccess arrayAccess, float[] wTable, int[] permutationTable)
+        throws ApfloatRuntimeException
+    {
+        int nn, offset, istep, mmax, r;
+        float[] data;
+
+        data   = arrayAccess.getFloatData();
+        offset = arrayAccess.getOffset();
+        nn     = arrayAccess.getLength();
+
+        assert (nn == (nn & -nn));
+
+        if (nn < 2)
+        {
+            return;
+        }
+
+        r = 1;
+        mmax = nn >> 1;
+        while (mmax > 0)
+        {
+            istep = mmax << 1;
+
+            // Optimize first step when wr = 1
+
+            for (int i = offset; i < offset + nn; i += istep)
+            {
+                int j = i + mmax;
+                float a = data[i];
+                float b = data[j];
+                data[i] = modAdd(a, b);
+                data[j] = modSubtract(a, b);
+            }
+
+            int t = r;
+
+            for (int m = 1; m < mmax; m++)
+            {
+                for (int i = offset + m; i < offset + nn; i += istep)
+                {
+                    int j = i + mmax;
+                    float a = data[i];
+                    float b = data[j];
+                    data[i] = modAdd(a, b);
+                    data[j] = modMultiply(wTable[t], modSubtract(a, b));
+                }
+                t += r;
+            }
+            r <<= 1;
+            mmax >>= 1;
+        }
+
+        if (permutationTable != null)
+        {
+            FloatScramble.scramble(data, offset, permutationTable);
+        }
+    }
+
+    /**
+     * Inverse (Cooley-Tukey) fast Number Theoretic Transform.
+     * Data length must be a power of two.
+     *
+     * @param arrayAccess The data array to transform.
+     * @param wTable Table of powers of n:th root of unity <code>w</code> modulo the current modulus.
+     * @param permutationTable Table of permutation indexes, or <code>null</code> if the data should not be permuted.
+     */
+
+    public void inverseTableFNT(ArrayAccess arrayAccess, float[] wTable, int[] permutationTable)
+        throws ApfloatRuntimeException
+    {
+        int nn, offset, istep, mmax, r;
+        float[] data;
+
+        data   = arrayAccess.getFloatData();
+        offset = arrayAccess.getOffset();
+        nn     = arrayAccess.getLength();
+
+        assert (nn == (nn & -nn));
+
+        if (nn < 2)
+        {
+            return;
+        }
+
+        if (permutationTable != null)
+        {
+            FloatScramble.scramble(data, offset, permutationTable);
+        }
+
+        r = nn;
+        mmax = 1;
+        while (nn > mmax)
+        {
+            istep = mmax << 1;
+            r >>= 1;
+
+            // Optimize first step when w = 1
+
+            for (int i = offset; i < offset + nn; i += istep)
+            {
+                int j = i + mmax;
+                float wTemp = data[j];
+                data[j] = modSubtract(data[i], wTemp);
+                data[i] = modAdd(data[i], wTemp);
+            }
+
+            int t = r;
+
+            for (int m = 1; m < mmax; m++)
+            {
+                for (int i = offset + m; i < offset + nn; i += istep)
+                {
+                    int j = i + mmax;
+                    float wTemp = modMultiply(wTable[t], data[j]);
+                    data[j] = modSubtract(data[i], wTemp);
+                    data[i] = modAdd(data[i], wTemp);
+                }
+                t += r;
+            }
+            mmax = istep;
+        }
+    }
+}
Index: src/main/java/org/apfloat/internal/FloatTableFNTStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatTableFNTStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatTableFNTStrategy.java	(revision 0)
@@ -0,0 +1,100 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.NTTStrategy;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+import org.apfloat.spi.Util;
+import static org.apfloat.internal.FloatModConstants.*;
+
+/**
+ * Fast Number Theoretic Transform strategy that uses lookup tables
+ * for powers of n:th root of unity and permutation indexes.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class FloatTableFNTStrategy
+    extends FloatTableFNT
+    implements NTTStrategy
+{
+    /**
+     * Default constructor.
+     */
+
+    public FloatTableFNTStrategy()
+    {
+    }
+
+    public void transform(DataStorage dataStorage, int modulus)
+        throws ApfloatRuntimeException
+    {
+        long length = dataStorage.getSize();            // Transform length n
+
+        if (length > MAX_TRANSFORM_LENGTH)
+        {
+            throw new TransformLengthExceededException("Maximum transform length exceeded: " + length + " > " + MAX_TRANSFORM_LENGTH);
+        }
+        else if (length > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Maximum array length exceeded: " + length);
+        }
+
+        setModulus(MODULUS[modulus]);                                       // Modulus
+        float[] wTable = FloatWTables.getWTable(modulus, (int) length);
+
+        ArrayAccess arrayAccess = dataStorage.getArray(DataStorage.READ_WRITE, 0, (int) length);
+
+        tableFNT(arrayAccess, wTable, null);
+
+        arrayAccess.close();
+    }
+
+    public void inverseTransform(DataStorage dataStorage, int modulus, long totalTransformLength)
+        throws ApfloatRuntimeException
+    {
+        long length = dataStorage.getSize();            // Transform length n
+
+        if (Math.max(length, totalTransformLength) > MAX_TRANSFORM_LENGTH)
+        {
+            throw new TransformLengthExceededException("Maximum transform length exceeded: " + Math.max(length, totalTransformLength) + " > " + MAX_TRANSFORM_LENGTH);
+        }
+        else if (length > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Maximum array length exceeded: " + length);
+        }
+
+        setModulus(MODULUS[modulus]);                                       // Modulus
+        float[] wTable = FloatWTables.getInverseWTable(modulus, (int) length);
+
+        ArrayAccess arrayAccess = dataStorage.getArray(DataStorage.READ_WRITE, 0, (int) length);
+
+        inverseTableFNT(arrayAccess, wTable, null);
+
+        divideElements(arrayAccess, (float) totalTransformLength);
+
+        arrayAccess.close();
+    }
+
+    public long getTransformLength(long size)
+    {
+        return Util.round2up(size);
+    }
+
+    private void divideElements(ArrayAccess arrayAccess, float divisor)
+        throws ApfloatRuntimeException
+    {
+        float inverseFactor = modDivide((float) 1, divisor);
+        float[] data = arrayAccess.getFloatData();
+        int length = arrayAccess.getLength(),
+            offset = arrayAccess.getOffset();
+
+        for (int i = 0; i < length; i++)
+        {
+            data[i + offset] = modMultiply(data[i + offset], inverseFactor);
+        }
+    }
+}
Index: src/main/java/org/apfloat/internal/FloatWTables.java
===================================================================
--- src/main/java/org/apfloat/internal/FloatWTables.java	(revision 0)
+++ src/main/java/org/apfloat/internal/FloatWTables.java	(revision 0)
@@ -0,0 +1,86 @@
+package org.apfloat.internal;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.ConcurrentMap;
+
+import org.apfloat.internal.FloatModMath;
+import static org.apfloat.internal.FloatModConstants.*;
+
+/**
+ * Helper class for generating and caching tables of powers of the n:th root of unity.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class FloatWTables
+    extends FloatModMath
+{
+    private FloatWTables()
+    {
+        // Default constructor
+    }
+
+    /**
+     * Get a table of powers of n:th root of unity.
+     *
+     * @param modulus The index of the modulus to be used.
+     * @param length The length of the table to be returned, i.e. n.
+     *
+     * @return The table of powers of the n:th root of unity.
+     */
+
+    public static float[] getWTable(int modulus, int length)
+    {
+        return getWTable(modulus, length, false);
+    }
+
+    /**
+     * Get a table of inverses of powers of n:th root of unity.
+     *
+     * @param modulus The index of the modulus to be used.
+     * @param length The length of the table to be returned, i.e. n.
+     *
+     * @return The table of inverses of powers of the n:th root of unity.
+     */
+
+    public static float[] getInverseWTable(int modulus, int length)
+    {
+        return getWTable(modulus, length, true);
+    }
+
+    private static float[] getWTable(int modulus, int length, boolean isInverse)
+    {
+        List<Integer> key = Arrays.asList(isInverse ? 1 : 0, modulus, length);
+        float[] wTable = FloatWTables.cache.get(key);
+        // Do not synchronize, multiple threads may do this at the same time, but only one gets to put the value in the cache
+        if (wTable == null)
+        {
+            FloatModMath instance = getInstance(modulus);
+            float w = (isInverse ?
+                         instance.getInverseNthRoot(PRIMITIVE_ROOT[modulus], length) :  // Inverse n:th root
+                         instance.getForwardNthRoot(PRIMITIVE_ROOT[modulus], length));  // Forward n:th root
+            wTable = instance.createWTable(w, length);
+            // Check if another thread already put the wTable in the cache; if so then use it
+            float[] value = FloatWTables.cache.putIfAbsent(key, wTable);
+            if (value != null)
+            {
+                // Another thread did put the value in the cache so use it
+                wTable = value;
+            }
+        }
+        return wTable;
+    }
+
+    private static FloatModMath getInstance(int modulus)
+    {
+        FloatModMath instance = new FloatModMath();
+        instance.setModulus(MODULUS[modulus]);
+        return instance;
+    }
+
+    // With inverses, three moduli and lengths being powers of two, the theoretical maximum map size is 2 * 3 * 30 = 180 entries
+    private static ConcurrentMap<List<Integer>, float[]> cache = new ConcurrentSoftHashMap<List<Integer>, float[]>();
+}
Index: src/main/java/org/apfloat/internal/ImplementationMismatchException.java
===================================================================
--- src/main/java/org/apfloat/internal/ImplementationMismatchException.java	(revision 0)
+++ src/main/java/org/apfloat/internal/ImplementationMismatchException.java	(revision 0)
@@ -0,0 +1,47 @@
+package org.apfloat.internal;
+
+/**
+ * Exception indicating a different implementation of the apfloat SPI
+ * being used in two operands of a calculation.<p>
+ *
+ * @since 1.5
+ * @version 1.5
+ * @author Mikko Tommila
+ */
+
+public class ImplementationMismatchException
+    extends ApfloatInternalException
+{
+    /**
+     * Constructs a new apfloat implementation mismatch exception with an empty detail message.
+     */
+
+    public ImplementationMismatchException()
+    {
+    }
+
+    /**
+     * Constructs a new apfloat implementation mismatch exception with the specified detail message.
+     *
+     * @param message The detail message.
+     */
+
+    public ImplementationMismatchException(String message)
+    {
+        super(message);
+    }
+
+    /**
+     * Constructs a new apfloat implementation mismatch exception with the specified detail message and cause.
+     *
+     * @param message The detail message.
+     * @param cause Originating cause of the exception.
+     */
+
+    public ImplementationMismatchException(String message, Throwable cause)
+    {
+        super(message, cause);
+    }
+
+    private static final long serialVersionUID = -7022924635011038776L;
+}
Index: src/main/java/org/apfloat/internal/IntAdditionBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/IntAdditionBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntAdditionBuilder.java	(revision 0)
@@ -0,0 +1,30 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.AdditionBuilder;
+import org.apfloat.spi.AdditionStrategy;
+
+/**
+ * Creates additions for the specified radix and the <code>int</code> element type.<p>
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class IntAdditionBuilder
+    implements AdditionBuilder<Integer>
+{
+    /**
+     * Default constructor.
+     */
+
+    public IntAdditionBuilder()
+    {
+    }
+
+    public AdditionStrategy<Integer> createAddition(int radix)
+    {
+        AdditionStrategy<Integer> additionStrategy = new IntAdditionStrategy(radix);
+        return additionStrategy;
+    }
+}
Index: src/main/java/org/apfloat/internal/IntAdditionStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/IntAdditionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntAdditionStrategy.java	(revision 0)
@@ -0,0 +1,59 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.AdditionStrategy;
+import org.apfloat.spi.DataStorage.Iterator;
+
+/**
+ * Basic addition strategy for the <code>int</code> element type.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+public class IntAdditionStrategy
+    extends IntBaseMath
+    implements AdditionStrategy<Integer>
+{
+    /**
+     * Creates an addition strategy using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public IntAdditionStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public Integer add(Iterator src1, Iterator src2, Integer carry, Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        return baseAdd(src1, src2, carry, dst, size);
+    }
+
+    public Integer subtract(Iterator src1, Iterator src2, Integer carry, Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        return baseSubtract(src1, src2, carry, dst, size);
+    }
+
+    public Integer multiplyAdd(Iterator src1, Iterator src2, Integer src3, Integer carry, Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        return baseMultiplyAdd(src1, src2, src3, carry, dst, size);
+    }
+
+    public Integer divide(Iterator src1, Integer src2, Integer carry, Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        return baseDivide(src1, src2, carry, dst, size);
+    }
+
+    public Integer zero()
+    {
+        return (int) 0;
+    }
+
+    private static final long serialVersionUID = -6156689494629604331L;
+}
Index: src/main/java/org/apfloat/internal/IntApfloatBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/IntApfloatBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntApfloatBuilder.java	(revision 0)
@@ -0,0 +1,52 @@
+package org.apfloat.internal;
+
+import java.io.PushbackReader;
+import java.io.IOException;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ApfloatBuilder;
+import org.apfloat.spi.ApfloatImpl;
+
+/**
+ * Builder class for building {@link ApfloatImpl} implementations with the
+ * <code>int</code> data element type.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public class IntApfloatBuilder
+    implements ApfloatBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public IntApfloatBuilder()
+    {
+    }
+
+    public ApfloatImpl createApfloat(String value, long precision, int radix, boolean isInteger)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        return new IntApfloatImpl(value, precision, radix, isInteger);
+    }
+
+    public ApfloatImpl createApfloat(long value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        return new IntApfloatImpl(value, precision, radix);
+    }
+
+    public ApfloatImpl createApfloat(double value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        return new IntApfloatImpl(value, precision, radix);
+    }
+
+    public ApfloatImpl createApfloat(PushbackReader in, long precision, int radix, boolean isInteger)
+        throws IOException, NumberFormatException, ApfloatRuntimeException
+    {
+        return new IntApfloatImpl(in, precision, radix, isInteger);
+    }
+}
Index: src/main/java/org/apfloat/internal/IntApfloatImpl.java
===================================================================
--- src/main/java/org/apfloat/internal/IntApfloatImpl.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntApfloatImpl.java	(revision 0)
@@ -0,0 +1,2449 @@
+package org.apfloat.internal;
+
+import java.io.ObjectInputStream;
+import java.io.PushbackReader;
+import java.io.Writer;
+import java.io.StringWriter;
+import java.io.IOException;
+
+import org.apfloat.Apfloat;
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.InfiniteExpansionException;
+import org.apfloat.OverflowException;
+import org.apfloat.spi.ApfloatImpl;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+import org.apfloat.spi.AdditionBuilder;
+import org.apfloat.spi.AdditionStrategy;
+import org.apfloat.spi.ConvolutionBuilder;
+import org.apfloat.spi.ConvolutionStrategy;
+import org.apfloat.spi.Util;
+import static org.apfloat.spi.RadixConstants.*;
+import static org.apfloat.internal.IntRadixConstants.*;
+
+/**
+ * Immutable apfloat implementation class for the
+ * <code>int</code> data element type.<p>
+ *
+ * The associated {@link DataStorage} is assumed to be immutable also.
+ * This way performance can be improved by sharing the data storage between
+ * different <code>ApfloatImpl</code>'s and by only varying the
+ * <code>ApfloatImpl</code> specific fields, like sign, precision and exponent.<p>
+ *
+ * This implementation doesn't necessarily store any extra digits for added
+ * precision, so the last digit of any operation may be inaccurate.
+ *
+ * @version 1.8.2
+ * @author Mikko Tommila
+ */
+
+public class IntApfloatImpl
+    extends IntBaseMath
+    implements ApfloatImpl
+{
+    // Implementation notes:
+    // - The dataStorage must never contain leading zeros or trailing zeros
+    // - If precision is reduced then the dataStorage can contain trailing zeros (physically in the middle)
+    // - The dataStorage should not be unnecessarily subsequenced if precision is reduced e.g. to allow autoconvolution
+    // - Precision is in digits but exponent is in base units
+    private IntApfloatImpl(int sign, long precision, long exponent, DataStorage dataStorage, int radix)
+    {
+        super(radix);
+
+        assert (sign == 0 || sign == -1 || sign == 1);
+        assert (precision > 0);
+        assert (sign != 0 || precision == Apfloat.INFINITE);
+        assert (sign != 0 || exponent == 0);
+        assert (sign != 0 || dataStorage == null);
+        assert (sign == 0 || dataStorage != null);
+        assert (exponent <= MAX_EXPONENT[radix] && exponent >= -MAX_EXPONENT[radix]);
+        assert (dataStorage == null || dataStorage.isReadOnly());
+
+        this.sign = sign;
+        this.precision = precision;
+        this.exponent = exponent;
+        this.dataStorage = dataStorage;
+        this.radix = radix;
+    }
+
+    /**
+     * Create a new <code>IntApfloatImpl</code> instance from a String.
+     *
+     * @param value The string to be parsed to a number.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     * @param isInteger Specifies if the number to be parsed from the string is to be treated as an integer or not.
+     *
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public IntApfloatImpl(String value, long precision, int radix, boolean isInteger)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        super(checkRadix(radix));
+
+        assert (precision == Apfloat.DEFAULT || precision > 0);
+
+        this.radix = radix;
+
+        // Default sign if not specified
+        this.sign = 1;
+
+        int startIndex = -1,
+            pointIndex = -1,
+            expIndex = -1,
+            leadingZeros = 0,
+            trailingZeros = 0,
+            digitSize = 0;
+
+        // Scan through the string looking for various things
+        for (int i = 0; i < value.length(); i++)
+        {
+            char c = value.charAt(i);
+            int digit = Character.digit(c, radix);
+
+            // Note that checking for a valid digit takes place before checking for e or E in the string
+            if (digit == -1)
+            {
+                if (i == 0 && (c == '-' || c == '+'))
+                {
+                    // Get sign
+                    this.sign = (c == '-' ? -1 : 1);
+                }
+                else if (!isInteger && c == '.' && pointIndex == -1)
+                {
+                    // Mark decimal point location
+                    pointIndex = digitSize;
+                }
+                else if (!isInteger && (c == 'e' || c == 'E') && expIndex == -1)
+                {
+                    // Mark index after which the exponent is specified
+                    expIndex = i;
+                    break;
+                }
+                else
+                {
+                    throw new NumberFormatException("Invalid character: " + c + " at position " + i);
+                }
+            }
+            else
+            {
+                if (leadingZeros == digitSize && digit == 0)
+                {
+                    // Increase number of leading zeros
+                    leadingZeros++;
+                }
+                else if (startIndex == -1)
+                {
+                    // Mark index where the significant digits start
+                    startIndex = i;
+                }
+
+                // Increase number of digits
+                digitSize++;
+
+                if (digit == 0)
+                {
+                    // Increase number of trailing zeros
+                    trailingZeros++;
+                }
+                else
+                {
+                    // Reset number of trailing zeros
+                    trailingZeros = 0;
+                }
+            }
+        }
+
+        // Check if no digits were specified
+        if (digitSize == 0)
+        {
+            throw new NumberFormatException("No digits");
+        }
+
+        // Check if this number is zero
+        if (startIndex == -1)
+        {
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Default precision is number of significant digits, if not specified
+        if (precision == Apfloat.DEFAULT)
+        {
+            assert (!isInteger);
+            precision = digitSize - leadingZeros;
+        }
+        this.precision = precision;
+
+        // Size of integer part
+        int integerSize = (pointIndex >= 0 ? pointIndex : digitSize) - leadingZeros;
+
+        // Read exponent as specified in string
+        if (expIndex >= 0)
+        {
+            // Thanks to Charles Oliver Nutter for finding this bug
+            String expString = value.substring(expIndex + 1);
+            if (expString.startsWith("+"))
+            {
+                expString = expString.substring(1);
+            }
+
+            try
+            {
+                this.exponent = Long.parseLong(expString);
+            }
+            catch (NumberFormatException nfe)
+            {
+                throw new NumberFormatException("Invalid exponent: " + expString);
+            }
+        }
+        else
+        {
+            this.exponent = 0;
+        }
+
+        // Do not allow the exponent to be too close to the limits (MIN_VALUE, MAX_VALUE), leave some slack
+        int slack = BASE_DIGITS[radix];
+
+        // Check for overflow in exponent, roughly
+        if (integerSize >= -slack && this.exponent >= Long.MAX_VALUE - integerSize - slack)
+        {
+            throw new NumberFormatException("Exponent overflow");
+        }
+        else if (integerSize <= slack && this.exponent <= Long.MIN_VALUE - integerSize + slack)
+        {
+            // Underflow
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Adjust exponent by decimal point location
+        this.exponent += integerSize;
+
+        // Exponent rounded towards positive infinity to base unit
+        long baseExp = (this.exponent + (this.exponent > 0 ? BASE_DIGITS[radix] - 1 : 0)) / BASE_DIGITS[radix];
+
+        // Check for overflow in exponent as represented in base units
+        if (baseExp > MAX_EXPONENT[this.radix])
+        {
+            throw new OverflowException("Overflow");
+        }
+        else if (baseExp < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Leading zeros in first base unit
+        int digitsInBase = (int) (baseExp * BASE_DIGITS[radix] - this.exponent);
+
+        // The stored exponent is really the one per base unit
+        this.exponent = baseExp;
+
+        // Remove leading and trailing zeros from size
+        digitSize -= leadingZeros + trailingZeros;
+
+        // Limit number of significant digits by specified precision
+        digitSize = (int) Math.min(digitSize, precision);
+
+        // Needed storage size in ints
+        int size = (int) getBasePrecision(digitSize, BASE_DIGITS[radix] - digitsInBase);
+
+        this.dataStorage = createDataStorage(size);
+        this.dataStorage.setSize(size);
+
+        // Base unit that is constructed and stored to an element of the data storage
+        int word = 0;
+
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.WRITE, 0, size);
+
+        // Set the data
+        for (int i = startIndex; digitSize > 0; i++)
+        {
+            char c = value.charAt(i);
+            if (c == '.')
+            {
+                continue;
+            }
+
+            int digit = Character.digit(c, radix);
+            word *= (int) radix;
+            word += (int) digit;
+
+            if (digitSize == 1)
+            {
+                // Last digit
+                while (digitsInBase < BASE_DIGITS[radix] - 1)
+                {
+                    // Fill last word with trailing zeros
+                    word *= (int) radix;
+                    digitsInBase++;
+                }
+            }
+
+            if (++digitsInBase == BASE_DIGITS[radix])
+            {
+                // Word is full, write word
+                digitsInBase = 0;
+                iterator.setInt(word);
+                iterator.next();
+                word = 0;
+            }
+
+            digitSize--;
+        }
+
+        assert (!iterator.hasNext());
+
+        this.dataStorage.setReadOnly();
+    }
+
+    /**
+     * Create a new <code>IntApfloatImpl</code> instance from a <code>long</code>.
+     *
+     * @param value The value of the number.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     *
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public IntApfloatImpl(long value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        super(checkRadix(radix));
+
+        assert (precision > 0);
+
+        this.radix = radix;
+
+        // Faster to set now than calculate later
+        this.isOne = (value == 1 ? 1 : 0);
+
+        if (value > 0)
+        {
+            this.sign = 1;
+            value = -value;         // Calculate here as negative to handle 0x8000000000000000
+        }
+        else if (value < 0)
+        {
+            this.sign = -1;
+        }
+        else
+        {
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        this.precision = precision;
+
+        int size;
+        int[] data = new int[MAX_LONG_SIZE];
+        long longBase = (long) BASE[radix];
+
+        if (-longBase < value)
+        {
+            size = 1;                               // Nonzero
+            data[MAX_LONG_SIZE - 1] = (int) -value;
+        }
+        else
+        {
+            for (size = 0; value != 0; size++)
+            {
+                long newValue = value / longBase;
+                data[MAX_LONG_SIZE - 1 - size] = (int) (newValue * longBase - value);   // Negated here
+                value = newValue;
+            }
+        }
+
+        this.exponent = size;
+
+        this.initialDigits = getDigits(data[MAX_LONG_SIZE - size]);
+
+        // Check if precision in ints is less than size; truncate size if so
+        long basePrecision = getBasePrecision(precision, this.initialDigits);
+        if (basePrecision < size)
+        {
+            size = (int) basePrecision;
+        }
+
+        // Remove trailing zeros from data
+        while (data[MAX_LONG_SIZE - 1 - (int) this.exponent + size] == 0)
+        {
+            size--;
+        }
+
+        this.dataStorage = createDataStorage(size);
+        this.dataStorage.setSize(size);
+
+        ArrayAccess arrayAccess = this.dataStorage.getArray(DataStorage.WRITE, 0, size);
+        System.arraycopy(data, MAX_LONG_SIZE - (int) this.exponent, arrayAccess.getData(), arrayAccess.getOffset(), size);
+        arrayAccess.close();
+
+        this.dataStorage.setReadOnly();
+    }
+
+    /**
+     * Create a new <code>IntApfloatImpl</code> instance from a <code>double</code>.
+     *
+     * @param value The value of the number.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     *
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public IntApfloatImpl(double value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        super(checkRadix(radix));
+
+        if (Double.isInfinite(value) || Double.isNaN(value))
+        {
+            throw new NumberFormatException(value + " is not a valid number");
+        }
+
+        this.radix = radix;
+
+        if (value > 0)
+        {
+            this.sign = 1;
+        }
+        else if (value < 0)
+        {
+            this.sign = -1;
+            value = -value;
+        }
+        else
+        {
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        this.precision = precision;
+
+        int size;
+        int[] data = new int[MAX_DOUBLE_SIZE];
+        double doubleBase = (double) BASE[radix];
+
+        this.exponent = (long) Math.floor(Math.log(value) / Math.log(doubleBase));
+        // Avoid overflow in intermediate value
+        if (this.exponent > 0)
+        {
+            value *= Math.pow(doubleBase, (double) -this.exponent);
+        }
+        else if (this.exponent < 0)
+        {
+            value *= Math.pow(doubleBase, (double) (-this.exponent - MAX_DOUBLE_SIZE));
+            value *= Math.pow(doubleBase, (double) MAX_DOUBLE_SIZE);
+        }
+        this.exponent++;
+
+        if (value < 1.0)
+        {
+            // Round-off error in case the input was very close but just under the base, e.g. 9.999999999999996E-10
+            value = 1.0;
+        }
+
+        for (size = 0; size < MAX_DOUBLE_SIZE && value > 0.0; size++)
+        {
+            double tmp = Math.floor(value);
+
+            assert (tmp <= doubleBase);
+
+            if (tmp == doubleBase)
+            {
+                // Round-off error e.g. in case of the number being exactly 1/radix
+                tmp -= 1.0;
+            }
+
+            data[size] = (int) tmp;
+            value -= tmp;
+            value *= doubleBase;
+        }
+
+        this.initialDigits = getDigits(data[0]);
+
+        // Check if precision in ints is less than size; truncate size if so
+        long basePrecision = getBasePrecision(precision, this.initialDigits);
+        if (basePrecision < size)
+        {
+            size = (int) basePrecision;
+        }
+
+        // Remove trailing zeros from data
+        while (data[size - 1] == 0)
+        {
+            size--;
+        }
+
+        this.dataStorage = createDataStorage(size);
+        this.dataStorage.setSize(size);
+
+        ArrayAccess arrayAccess = this.dataStorage.getArray(DataStorage.WRITE, 0, size);
+        System.arraycopy(data, 0, arrayAccess.getData(), arrayAccess.getOffset(), size);
+        arrayAccess.close();
+
+        this.dataStorage.setReadOnly();
+    }
+
+    private static long readExponent(PushbackReader in)
+        throws IOException, NumberFormatException
+    {
+        StringBuilder buffer = new StringBuilder(20);
+        int input;
+
+        for (long i = 0; (input = in.read()) != -1; i++)
+        {
+            char c = (char) input;
+            int digit = Character.digit(c, 10);         // Exponent is always in base 10
+
+            if (i == 0 && c == '-' ||
+                digit != -1)
+            {
+                buffer.append(c);
+            }
+            else
+            {
+                // Stop at first invalid character and put it back
+                in.unread(input);
+                break;
+            }
+        }
+
+        return Long.parseLong(buffer.toString());
+    }
+
+    /**
+     * Create a new <code>IntApfloatImpl</code> instance reading from a stream.<p>
+     *
+     * Implementation note: this constructor calls the <code>in</code> stream's
+     * single-character <code>read()</code> method. If the underlying stream doesn't
+     * explicitly implement this method in some efficient way, but simply inherits it
+     * from the <code>Reader</code> base class, performance will suffer as the default
+     * <code>Reader</code> method creates a <code>new char[1]</code> on every call to
+     * <code>read()</code>.
+     *
+     * @param in The stream to read from.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     * @param isInteger Specifies if the number to be parsed from the stream is to be treated as an integer or not.
+     *
+     * @exception java.io.IOException If an I/O error occurs accessing the stream.
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public IntApfloatImpl(PushbackReader in, long precision, int radix, boolean isInteger)
+        throws IOException, NumberFormatException, ApfloatRuntimeException
+    {
+        super(checkRadix(radix));
+
+        assert (precision == Apfloat.DEFAULT || precision > 0);
+
+        this.radix = radix;
+
+        // Default sign if not specified
+        this.sign = 1;
+
+        // Allocate a maximum memory block, since we don't know how much data to expect
+        ApfloatContext ctx = ApfloatContext.getContext();
+        long initialSize = ctx.getMemoryThreshold() / 4,
+             previousAllocatedSize = 0,
+             allocatedSize = initialSize;
+        this.dataStorage = createDataStorage(initialSize);
+        this.dataStorage.setSize(initialSize);
+
+        // Base unit that is constructed and stored to an element of the data storage
+        int word = 0;
+
+        // Number of digits stored in word
+        int digitsInBase = 0;
+
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.WRITE, previousAllocatedSize, allocatedSize);
+
+        int input;
+        long actualSize = 0,
+             startIndex = -1,
+             pointIndex = -1,
+             leadingZeros = 0,
+             trailingZeros = 0,
+             digitSize = 0;
+
+        // Scan through the string looking for various things
+        for (long i = 0; (input = in.read()) != -1; i++)
+        {
+            char c = (char) input;
+            int digit = Character.digit(c, radix);
+
+            // Note that checking for a valid digit takes place before checking for e or E in the string
+            if (digit == -1)
+            {
+                if (i == 0 && (c == '-' || c == '+'))
+                {
+                    // Get sign
+                    this.sign = (c == '-' ? -1 : 1);
+                }
+                else if (!isInteger && c == '.' && pointIndex == -1)
+                {
+                    // Mark decimal point location
+                    pointIndex = digitSize;
+                }
+                else if (!isInteger && digitSize > 0 && (c == 'e' || c == 'E'))
+                {
+                    // Read the exponent and stop
+                    this.exponent = readExponent(in);
+                    break;
+                }
+                else
+                {
+                    // Stop at first invalid character and put it back
+                    in.unread(input);
+                    break;
+                }
+            }
+            else
+            {
+                if (leadingZeros == digitSize && digit == 0)
+                {
+                    // Increase number of leading zeros
+                    leadingZeros++;
+                }
+                else
+                {
+                    if (startIndex == -1)
+                    {
+                        // Mark index where the significant digits start
+                        startIndex = i;
+                    }
+
+                    // Set the data
+                    word *= (int) radix;
+                    word += (int) digit;
+
+                    // Reallocate storage if needed; done here to prepare storing last (partial) word
+                    if (actualSize == allocatedSize)
+                    {
+                        if (actualSize == initialSize)
+                        {
+                            // Maximum memory block size exceeded; prepare to allocate anything
+                            DataStorage dataStorage = createDataStorage(Long.MAX_VALUE / 4);
+                            dataStorage.copyFrom(this.dataStorage, actualSize);
+                            this.dataStorage = dataStorage;
+                        }
+                        previousAllocatedSize = allocatedSize;
+                        allocatedSize += getBlockSize();
+                        this.dataStorage.setSize(allocatedSize);
+                        iterator.close();
+                        iterator = this.dataStorage.iterator(DataStorage.WRITE, previousAllocatedSize, allocatedSize);
+                    }
+
+                    if (++digitsInBase == BASE_DIGITS[radix])
+                    {
+                        // Word is full, write word
+                        digitsInBase = 0;
+                        iterator.setInt(word);
+                        iterator.next();
+                        word = 0;
+                        actualSize++;
+                    }
+                }
+
+                // Increase number of digits
+                digitSize++;
+
+                if (digit == 0)
+                {
+                    // Increase number of trailing zeros
+                    trailingZeros++;
+                }
+                else
+                {
+                    // Reset number of trailing zeros
+                    trailingZeros = 0;
+                }
+            }
+        }
+
+        // Check if no digits were specified
+        if (digitSize == 0)
+        {
+            throw new NumberFormatException("No digits");
+        }
+
+        // Check if this number is zero
+        if (startIndex == -1)
+        {
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Handle last word
+        if (digitsInBase > 0 && word != 0)
+        {
+            // Last digit
+            while (digitsInBase < BASE_DIGITS[radix])
+            {
+                // Fill last word with trailing zeros
+                word *= (int) radix;
+                digitsInBase++;
+            }
+
+            // Write word
+            iterator.setInt(word);
+            actualSize++;
+        }
+
+        iterator.close();
+
+        // Default precision is number of significant digits, if not specified
+        if (precision == Apfloat.DEFAULT)
+        {
+            assert (!isInteger);
+            precision = digitSize - leadingZeros;
+        }
+        this.precision = precision;
+
+        // Size of integer part
+        long integerSize = (pointIndex >= 0 ? pointIndex : digitSize) - leadingZeros;
+
+        // Do not allow the exponent to be too close to the limits (MIN_VALUE, MAX_VALUE), leave some slack
+        int slack = BASE_DIGITS[radix];
+
+        // Check for overflow in exponent, roughly
+        if (integerSize >= -slack && this.exponent >= Long.MAX_VALUE - integerSize - slack)
+        {
+            throw new NumberFormatException("Exponent overflow");
+        }
+        else if (integerSize <= slack && this.exponent <= Long.MIN_VALUE - integerSize + slack)
+        {
+            // Underflow
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Adjust exponent by decimal point location
+        this.exponent += integerSize;
+
+        // Exponent rounded towards negative infinity to base unit
+        long baseExp = (this.exponent - (this.exponent < 0 ? BASE_DIGITS[radix] - 1 : 0)) / BASE_DIGITS[radix];
+
+        // Check for overflow in exponent as represented in base units
+        if (baseExp > MAX_EXPONENT[this.radix])
+        {
+            throw new OverflowException("Overflow");
+        }
+        else if (baseExp < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // How much the data needs to be shifted
+        int bias = (int) (this.exponent - baseExp * BASE_DIGITS[radix]);
+
+        // The stored exponent is really the one per base unit
+        this.exponent = baseExp;
+
+        // Remove leading and trailing zeros from size
+        digitSize -= leadingZeros + trailingZeros;
+
+        // Limit number of significant digits by specified precision
+        digitSize = Math.min(digitSize, precision);
+
+        // Needed storage size in ints
+        actualSize = (digitSize + BASE_DIGITS[radix] - 1) / BASE_DIGITS[radix];
+
+        // Truncate allocated space to actually used amount
+        this.dataStorage.setSize(actualSize);
+
+        this.dataStorage.setReadOnly();
+
+        if (bias != 0)
+        {
+            // Shift by bias
+            long factor = 1;
+
+            for (int i = 0; i < bias; i++)
+            {
+                factor *= radix;
+            }
+
+            IntApfloatImpl tmp = (IntApfloatImpl) multiply(new IntApfloatImpl(factor, Apfloat.INFINITE, radix));
+
+            this.exponent = tmp.exponent;
+            this.dataStorage = tmp.dataStorage;
+            this.initialDigits = UNDEFINED;     // Needs to be reset
+        }
+    }
+
+    // Returns number of trailing zeros before specified index
+    private static long getTrailingZeros(DataStorage dataStorage, long index)
+        throws ApfloatRuntimeException
+    {
+        long count = 0;
+
+        DataStorage.Iterator iterator = dataStorage.iterator(DataStorage.READ, index, 0);
+
+        while (iterator.hasNext())
+        {
+            if (iterator.getInt() != 0)
+            {
+                iterator.close();
+                break;
+            }
+
+            iterator.next();
+            count++;
+        }
+
+        return count;
+    }
+
+    // Returns number of leading zeros starting from specified index
+    private static long getLeadingZeros(DataStorage dataStorage, long index)
+        throws ApfloatRuntimeException
+    {
+        long count = 0;
+
+        DataStorage.Iterator iterator = dataStorage.iterator(DataStorage.READ, index, dataStorage.getSize());
+
+        while (iterator.hasNext())
+        {
+            if (iterator.getInt() != 0)
+            {
+                iterator.close();
+                break;
+            }
+
+            iterator.next();
+            count++;
+        }
+
+        return count;
+    }
+
+    public ApfloatImpl addOrSubtract(ApfloatImpl x, boolean subtract)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof IntApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        IntApfloatImpl that = (IntApfloatImpl) x;
+
+        if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot use numbers with different radixes: " + this.radix + " and " + that.radix);
+        }
+
+        assert (this.sign != 0);
+        assert (that.sign != 0);
+
+        int realThatSign = (subtract ? -that.sign : that.sign);
+        boolean reallySubtract = (this.sign != realThatSign);
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        AdditionBuilder<Integer> additionBuilder = ctx.getBuilderFactory().getAdditionBuilder(Integer.TYPE);
+        AdditionStrategy<Integer> additionStrategy = additionBuilder.createAddition(this.radix);
+
+        int sign;
+        long exponent,
+             precision;
+        DataStorage dataStorage;
+
+        if (this == that)
+        {
+            if (reallySubtract)
+            {
+                // x - x = 0
+
+                return zero();
+            }
+            else
+            {
+                // x + x = 2 * x
+
+                sign = this.sign;
+                exponent = this.exponent;
+                precision = this.precision;
+                long size = getSize() + 1;
+
+                dataStorage = createDataStorage(size);
+                dataStorage.setSize(size);
+
+                DataStorage.Iterator src1 = this.dataStorage.iterator(DataStorage.READ, size - 1, 0),
+                                     src2 = this.dataStorage.iterator(DataStorage.READ, size - 1, 0),   // Sub-optimal: could be the same
+                                     dst = dataStorage.iterator(DataStorage.WRITE, size, 0);
+
+                int carry = additionStrategy.add(src1, src2, (int) 0, dst, size - 1);
+
+                dst.setInt(carry);
+                dst.close();
+
+                size -= getTrailingZeros(dataStorage, size);
+
+                // Check if carry occurred
+                int carrySize = (int) carry,
+                    leadingZeros = 1 - carrySize;
+
+                dataStorage = dataStorage.subsequence(leadingZeros, size - leadingZeros);
+                exponent += carrySize;
+
+                if (this.exponent == MAX_EXPONENT[this.radix] && carrySize > 0)
+                {
+                    throw new OverflowException("Overflow");
+                }
+
+                if (precision != Apfloat.INFINITE &&
+                    (carrySize > 0 || getInitialDigits(dataStorage) > getInitialDigits()))
+                {
+                    // Carry overflow for most significant digit; number of significant digits increases by one
+                    precision++;
+                }
+            }
+        }
+        else
+        {
+            // Now this != that
+
+            int comparison;
+            if (scale() > that.scale())
+            {
+                comparison = 1;
+            }
+            else if (scale() < that.scale())
+            {
+                comparison = -1;
+            }
+            else if (reallySubtract)
+            {
+                comparison = compareMantissaTo(that);           // Might be sub-optimal, but a more efficient algorithm would be complicated
+            }
+            else
+            {
+                comparison = 1;                                 // Add equally big numbers; arbitrarily choose one
+            }
+
+            IntApfloatImpl big,
+                               small;
+
+            if (comparison > 0)
+            {
+                big = this;
+                small = that;
+                sign = this.sign;
+            }
+            else if (comparison < 0)
+            {
+                big = that;
+                small = this;
+                sign = realThatSign;
+            }
+            else
+            {
+                // x - x = 0
+                return zero();
+            }
+
+            long scaleDifference = big.scale() - small.scale(),
+                 exponentDifference,
+                 size,
+                 bigSize,
+                 smallSize;
+
+            if (scaleDifference < 0)
+            {
+                // Small number is completely insignificantly small compared to big
+                precision = big.precision;
+                exponent = big.exponent;
+                bigSize = big.getSize();
+                smallSize = 0;
+                size = bigSize;
+                exponentDifference = bigSize;
+            }
+            else
+            {
+                precision = Math.min(big.precision, Util.ifFinite(small.precision, scaleDifference + small.precision)); // Detects overflow also
+                long basePrecision = Math.min(MAX_EXPONENT[this.radix], getBasePrecision(precision, big.getInitialDigits()));
+                exponent = big.exponent;
+
+                exponentDifference = big.exponent - small.exponent;
+                size = Math.min(basePrecision, Math.max(big.getSize(), exponentDifference + small.getSize()));
+                bigSize = Math.min(size, big.getSize());
+                smallSize = Math.max(0, Math.min(size - exponentDifference, small.getSize()));
+            }
+
+            long dstSize = size + 1;                    // One extra word for carry overflow
+            dataStorage = createDataStorage(dstSize);
+            dataStorage.setSize(dstSize);
+
+            DataStorage.Iterator src1 = big.dataStorage.iterator(DataStorage.READ, bigSize, 0),
+                                 src2 = small.dataStorage.iterator(DataStorage.READ, smallSize, 0),
+                                 dst = dataStorage.iterator(DataStorage.WRITE, dstSize, 0);
+
+            int carry = 0;
+
+            // big:       XXXXXXXX               XXXX
+            // small:         XXXXXXXX        or         XXXX
+            // This part:         XXXX                   XXXX
+            if (size > bigSize)
+            {
+                long blockSize = Math.min(size - bigSize, smallSize);
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(null, src2, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(null, src2, carry, dst, blockSize);
+                }
+            }
+            // big:        XXXXXXXXXXXX
+            // small:          XXXX
+            // This part:          XXXX
+            else if (size > exponentDifference + smallSize)
+            {
+                long blockSize = size - exponentDifference - smallSize;
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(src1, null, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(src1, null, carry, dst, blockSize);
+                }
+            }
+            // big:        XXXX
+            // small:              XXXX
+            // This part:      XXXX
+            if (exponentDifference > bigSize)
+            {
+                long blockSize = exponentDifference - bigSize;
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(null, null, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(null, null, carry, dst, blockSize);
+                }
+            }
+            // big:        XXXXXXXX               XXXXXXXXXXXX
+            // small:          XXXXXXXX        or     XXXX
+            // This part:      XXXX                   XXXX
+            else if (bigSize > exponentDifference)
+            {
+                long blockSize = Math.min(bigSize - exponentDifference, smallSize);
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(src1, src2, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(src1, src2, carry, dst, blockSize);
+                }
+            }
+            // big:        XXXXXXXX               XXXXXXXXXXXX           XXXX
+            // small:          XXXXXXXX        or     XXXX            or         XXXX
+            // This part:  XXXX                   XXXX                   XXXX
+            if (exponentDifference > 0)
+            {
+                long blockSize = Math.min(bigSize, exponentDifference);
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(src1, null, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(src1, null, carry, dst, blockSize);
+                }
+            }
+
+            // Set most significant word
+            dst.setInt(carry);
+            dst.close();
+
+            long leadingZeros;
+
+            if (reallySubtract)
+            {
+                // Get denormalization
+                leadingZeros = getLeadingZeros(dataStorage, 0);
+
+                assert (leadingZeros <= size);
+            }
+            else
+            {
+                // Check if carry occurred up to and including most significant word
+                leadingZeros = (carry == 0 ? 1 : 0);
+
+                if (this.exponent == MAX_EXPONENT[this.radix] && leadingZeros == 0)
+                {
+                    throw new OverflowException("Overflow");
+                }
+            }
+
+            dstSize -= getTrailingZeros(dataStorage, dstSize);
+
+            dataStorage = dataStorage.subsequence(leadingZeros, dstSize - leadingZeros);
+            exponent += 1 - leadingZeros;
+
+            if (exponent < -MAX_EXPONENT[this.radix])
+            {
+                // Underflow
+                return zero();
+            }
+
+            if (precision != Apfloat.INFINITE)
+            {
+                // If scale of number changes, the number of significant digits changes accordingly
+                long scaleChange = (1 - leadingZeros) * BASE_DIGITS[this.radix] + getInitialDigits(dataStorage) - big.getInitialDigits();
+                if (-scaleChange >= precision)
+                {
+                    // All significant digits were lost anyway, due to trailing garbage digits
+                    return zero();
+                }
+                precision += scaleChange;
+                precision = (precision <= 0 ? Apfloat.INFINITE : precision);    // Detect overflow
+            }
+        }
+
+        dataStorage.setReadOnly();
+
+        return new IntApfloatImpl(sign, precision, exponent, dataStorage, this.radix);
+    }
+
+    public ApfloatImpl multiply(ApfloatImpl x)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof IntApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        IntApfloatImpl that = (IntApfloatImpl) x;
+
+        if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot multiply numbers with different radixes: " + this.radix + " and " + that.radix);
+        }
+
+        int sign = this.sign * that.sign;
+
+        if (sign == 0)
+        {
+            return zero();
+        }
+
+        long exponent = this.exponent + that.exponent;
+
+        if (exponent > MAX_EXPONENT[this.radix])
+        {
+            throw new OverflowException("Overflow");
+        }
+        else if (exponent < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            return zero();
+        }
+
+        long precision = Math.min(this.precision, that.precision),
+             basePrecision = getBasePrecision(precision, 0),            // Round up
+             thisSize = getSize(),
+             thatSize = that.getSize(),
+             size = Math.min(Util.ifFinite(basePrecision, basePrecision + 1), thisSize + thatSize),     // Reserve one extra word for carry
+             thisDataSize = Math.min(thisSize, basePrecision),
+             thatDataSize = Math.min(thatSize, basePrecision);
+
+        DataStorage thisDataStorage = this.dataStorage.subsequence(0, thisDataSize),
+                    thatDataStorage = (this.dataStorage == that.dataStorage ?
+                                       thisDataStorage :                                                // Enable auto-convolution
+                                       that.dataStorage.subsequence(0, thatDataSize));
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        ConvolutionBuilder convolutionBuilder = ctx.getBuilderFactory().getConvolutionBuilder();
+        ConvolutionStrategy convolutionStrategy = convolutionBuilder.createConvolution(this.radix, thisDataSize, thatDataSize, size);
+
+        // Possibly sub-optimal: could look up trailing zeros of the subsequences
+        DataStorage dataStorage = convolutionStrategy.convolute(thisDataStorage, thatDataStorage, size);
+
+        // Check if carry occurred up to and including most significant word
+        int leadingZeros = (getMostSignificantWord(dataStorage) == 0 ? 1 : 0);
+
+        exponent -= leadingZeros;
+
+        if (exponent < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            return zero();
+        }
+
+        size -= leadingZeros;
+        dataStorage = dataStorage.subsequence(leadingZeros, size);
+
+        size = Math.min(size, getBasePrecision(precision, getInitialDigits(dataStorage)));
+        size -= getTrailingZeros(dataStorage, size);
+
+        dataStorage = dataStorage.subsequence(0, size);
+
+        dataStorage.setReadOnly();
+
+        return new IntApfloatImpl(sign, precision, exponent, dataStorage, this.radix);
+    }
+
+    public boolean isShort()
+        throws ApfloatRuntimeException
+    {
+        return (this.sign == 0 || getSize() == 1);
+    }
+
+    public ApfloatImpl divideShort(ApfloatImpl x)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof IntApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        IntApfloatImpl that = (IntApfloatImpl) x;
+
+        if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot divide numbers with different radixes: " + this.radix + " and " + that.radix);
+        }
+
+        assert (this.sign != 0);
+        assert (that.sign != 0);
+
+        int sign = this.sign * that.sign;
+
+        long exponent = this.exponent - that.exponent + 1;
+
+        if (exponent > MAX_EXPONENT[this.radix])
+        {
+            throw new OverflowException("Overflow");
+        }
+        else if (exponent < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            return zero();
+        }
+
+        long precision = Math.min(this.precision, that.precision),
+             basePrecision = getBasePrecision(),
+             thisDataSize = Math.min(getSize(), basePrecision);
+
+        DataStorage dataStorage;
+
+        int divisor = getMostSignificantWord(that.dataStorage);
+
+        if (divisor == (int) 1)
+        {
+            long size = thisDataSize - getTrailingZeros(this.dataStorage, thisDataSize);
+
+            dataStorage = this.dataStorage.subsequence(0, size);
+        }
+        else
+        {
+            ApfloatContext ctx = ApfloatContext.getContext();
+            AdditionBuilder<Integer> additionBuilder = ctx.getBuilderFactory().getAdditionBuilder(Integer.TYPE);
+            AdditionStrategy<Integer> additionStrategy = additionBuilder.createAddition(this.radix);
+
+            long size;
+            int carry;
+
+            // Check for finite or infinite result sequence
+            int dividend = divisor;
+
+            // Check that the factorization of the divisor consists entirely of factors of the base
+            // E.g. if base is 10=2*5 then the divisor should be 2^n*5^m
+            for (int i = 0; i < RADIX_FACTORS[this.radix].length; i++)
+            {
+                int factor = RADIX_FACTORS[this.radix][i],
+                        quotient;
+
+                // Keep dividing by factor as long as dividend % factor == 0
+                // that is remove factors of the base from the divisor
+                while ((dividend - factor * (quotient = (int) (long) (dividend / factor))) == 0)
+                {
+                    dividend = quotient;
+                }
+            }
+
+            // Check if the divisor was factored all the way to one by just dividing by factors of the base
+            if (dividend != (int) 1)
+            {
+                // Divisor does not contain only factors of the base; infinite nonzero sequence
+
+                if (basePrecision == Apfloat.INFINITE)
+                {
+                    throw new InfiniteExpansionException("Cannot perform inexact division to infinite precision");
+                }
+
+                size = basePrecision;
+            }
+            else
+            {
+                // Divisor contains only factors of the base; calculate maximum sequence length
+                carry = (int) 1;
+                DataStorage.Iterator dummy = new DataStorage.Iterator()
+                {
+                    public void setInt(int value) {}
+                    public void next() {}
+                    private static final long serialVersionUID = 1L;
+                };
+                long sequenceSize;
+                for (sequenceSize = 0; carry != 0; sequenceSize++)
+                {
+                    carry = additionStrategy.divide(null, divisor, carry, dummy, 1);
+                }
+
+                size = Math.min(basePrecision, thisDataSize + sequenceSize);
+            }
+
+            // One extra word for result in case the initial word becomes zero; to avoid loss of precision
+            size++;
+
+            dataStorage = createDataStorage(size);
+            dataStorage.setSize(size);
+
+            DataStorage.Iterator src = this.dataStorage.iterator(DataStorage.READ, 0, thisDataSize),
+                                 dst = dataStorage.iterator(DataStorage.WRITE, 0, size);
+
+            // Perform actual division
+            carry = additionStrategy.divide(src, divisor, (int) 0, dst, thisDataSize);
+
+            // Produce the trailing sequence of digits due to inexact division
+            carry = additionStrategy.divide(null, divisor, carry, dst, size - thisDataSize);
+
+            size -= getTrailingZeros(dataStorage, size);
+
+            // Check if initial word of result is zero
+            int leadingZeros = (getMostSignificantWord() < divisor ? 1 : 0);
+
+            dataStorage = dataStorage.subsequence(leadingZeros, size - leadingZeros);
+            exponent -= leadingZeros;
+
+            if (exponent < -MAX_EXPONENT[this.radix])
+            {
+                // Underflow
+                return zero();
+            }
+
+            dataStorage.setReadOnly();
+        }
+
+        return new IntApfloatImpl(sign, precision, exponent, dataStorage, this.radix);
+    }
+
+    public ApfloatImpl absFloor()
+        throws ApfloatRuntimeException
+    {
+        if (this.sign == 0 ||
+            this.exponent >= this.dataStorage.getSize())        // Is integer already, with no extra hidden trailing digits
+        {
+            return precision(Apfloat.INFINITE);
+        }
+        else if (this.exponent <= 0)                            // Is less than one in absolute value
+        {
+            return zero();
+        }
+
+        long size = this.exponent;                              // Size of integer part, now that this.dataStorage.getSize() > this.exponent
+        size -= getTrailingZeros(this.dataStorage, size);
+
+        DataStorage dataStorage = this.dataStorage.subsequence(0, size);
+
+        ApfloatImpl apfloatImpl = new IntApfloatImpl(this.sign, Apfloat.INFINITE, this.exponent, dataStorage, this.radix);
+
+        return apfloatImpl;
+    }
+
+    public ApfloatImpl absCeil()
+        throws ApfloatRuntimeException
+    {
+        if (this.sign == 0)
+        {
+            return this;
+        }
+
+        long exponent;
+        DataStorage dataStorage;
+        DataStorage.Iterator iterator = null;
+
+        if (this.exponent <= 0)
+        {
+            // Number is < 1 but > 0; result is one
+            int size = 1;
+            dataStorage = createDataStorage(size);
+            dataStorage.setSize(size);
+            ArrayAccess arrayAccess = dataStorage.getArray(DataStorage.WRITE, 0, size);
+            arrayAccess.getIntData()[arrayAccess.getOffset()] = (int) 1;
+            arrayAccess.close();
+
+            exponent = 1;
+        }
+        else if (getSize() <= this.exponent ||          // Check if the fractional part is nonzero
+                 findMismatch(iterator = getZeroPaddedIterator(this.exponent, getSize()), ZERO_ITERATOR, getSize() - this.exponent) < 0)
+        {
+            // Fractional part is zero; the result is the number itself (to infinite precision)
+            long size = Math.min(this.dataStorage.getSize(), this.exponent);
+            size -= getTrailingZeros(this.dataStorage, size);
+            dataStorage = this.dataStorage.subsequence(0, size);        // Ensure truncation
+
+            exponent = this.exponent;
+        }
+        else
+        {
+            // Fractional part is nonzero; round up
+
+            ApfloatContext ctx = ApfloatContext.getContext();
+            AdditionBuilder<Integer> additionBuilder = ctx.getBuilderFactory().getAdditionBuilder(Integer.TYPE);
+            AdditionStrategy<Integer> additionStrategy = additionBuilder.createAddition(this.radix);
+
+            long size = this.exponent;                  // Size of integer part
+            dataStorage = createDataStorage(size + 1);     // Reserve room for carry overflow
+            dataStorage.setSize(size + 1);
+            DataStorage.Iterator src = this.dataStorage.iterator(DataStorage.READ, size, 0),
+                                 dst = dataStorage.iterator(DataStorage.WRITE, size + 1, 0);
+            int carry = additionStrategy.add(src, null, (int) 1, dst, size);     // Add carry
+            dst.setInt(carry);                      // Set leading int as overflow carry
+            src.close();
+            dst.close();
+            int carrySize = (int) carry;                // For adjusting size, if carry did overflow or not
+            size -= getTrailingZeros(dataStorage, size + 1);
+            dataStorage = dataStorage.subsequence(1 - carrySize, size + carrySize);
+
+            exponent = this.exponent + carrySize;
+        }
+
+        if (iterator != null)
+        {
+            iterator.close();
+        }
+
+        dataStorage.setReadOnly();
+
+        ApfloatImpl apfloatImpl = new IntApfloatImpl(this.sign, Apfloat.INFINITE, exponent, dataStorage, this.radix);
+
+        return apfloatImpl;
+    }
+
+    public ApfloatImpl frac()
+        throws ApfloatRuntimeException
+    {
+        if (this.sign == 0 ||
+            this.exponent <= 0)                                 // Is less than one in absolute value already
+        {
+            return this;
+        }
+        if (this.exponent >= getSize())                         // Is an integer, fractional part is zero
+        {
+            return zero();
+        }
+
+        long size = this.dataStorage.getSize() - this.exponent; // Size of fractional part, now that getSize() > this.exponent
+        long leadingZeros = getLeadingZeros(this.dataStorage, this.exponent);
+        if (this.exponent + leadingZeros >= getSize())
+        {
+            // All significant digits were lost, only trailing garbage digits
+            return zero();
+        }
+
+        DataStorage dataStorage = this.dataStorage.subsequence(this.exponent + leadingZeros, size - leadingZeros);
+
+        long precision;
+        if (this.precision != Apfloat.INFINITE)
+        {
+            // Precision is reduced as the integer part is omitted, plus any leading zeros
+            precision = this.precision - getInitialDigits() - (this.exponent + leadingZeros) * BASE_DIGITS[this.radix] + getInitialDigits(dataStorage);
+            if (precision <= 0)
+            {
+                // All significant digits were lost anyway, only trailing garbage digits
+                return zero();
+            }
+        }
+        else
+        {
+            precision = Apfloat.INFINITE;
+        }
+
+        long exponent = -leadingZeros;
+
+        ApfloatImpl apfloatImpl = new IntApfloatImpl(this.sign, precision, exponent, dataStorage, this.radix);
+
+        return apfloatImpl;
+    }
+
+    private ApfloatImpl zero()
+    {
+        return new IntApfloatImpl(0, Apfloat.INFINITE, 0, null, this.radix);
+    }
+
+    public int radix()
+    {
+        return this.radix;
+    }
+
+    public long precision()
+    {
+        return this.precision;
+    }
+
+    public long size()
+        throws ApfloatRuntimeException
+    {
+        assert (this.dataStorage != null);
+
+        if (this.size == 0)
+        {
+            // Writes and reads of volatile long values are always atomic so multiple threads can read and write this at the same time
+            this.size = getInitialDigits() + (getSize() - 1) * BASE_DIGITS[this.radix] - getLeastZeros();
+        }
+
+        return this.size;
+    }
+
+    // Get number of trailing zeros
+    private long getLeastZeros()
+        throws ApfloatRuntimeException
+    {
+        if (this.leastZeros == UNDEFINED)
+        {
+            // Cache the value
+            // NOTE: This is not synchronized; it's OK if multiple threads set this at the same time
+            // Writes and reads of volatile long values are always atomic so multiple threads can read and write this at the same time
+            long index = getSize() - 1;
+            int word = getWord(index);
+            word = getLeastSignificantWord(index, word);
+
+            long leastZeros = 0;
+            if (word == 0)
+            {
+                // Usually the last word is nonzero but in case precision was later changed, it might be zero
+                long trailingZeros = getTrailingZeros(this.dataStorage, index) + 1;
+                index -= trailingZeros;
+                word = getWord(index);
+                word = getLeastSignificantWord(index, word);
+
+                leastZeros += trailingZeros * BASE_DIGITS[this.radix];
+            }
+
+            assert (word != 0);
+
+            while (word % this.radix == 0)
+            {
+                leastZeros++;
+                word /= this.radix;
+            }
+            this.leastZeros = leastZeros;
+        }
+
+        return this.leastZeros;
+    }
+
+    public ApfloatImpl precision(long precision)
+    {
+        if (this.sign == 0 || precision == this.precision)
+        {
+            return this;
+        }
+        else
+        {
+            return new IntApfloatImpl(this.sign, precision, this.exponent, this.dataStorage, this.radix);
+        }
+    }
+
+    public long scale()
+        throws ApfloatRuntimeException
+    {
+        assert (this.dataStorage != null);
+
+        return (this.exponent - 1) * BASE_DIGITS[this.radix] + getInitialDigits();
+    }
+
+    public int signum()
+    {
+        return this.sign;
+    }
+
+    public ApfloatImpl negate()
+        throws ApfloatRuntimeException
+    {
+        return new IntApfloatImpl(-this.sign, this.precision, this.exponent, this.dataStorage, this.radix);
+    }
+
+    public double doubleValue()
+    {
+        if (this.sign == 0)
+        {
+            return 0.0;
+        }
+
+        double value = 0.0,
+               doubleBase = (double) BASE[this.radix];
+
+        int size = (int) Math.min(MAX_DOUBLE_SIZE, getSize());
+
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.READ, size, 0);
+
+        while (iterator.hasNext())
+        {
+            value += (double) iterator.getInt();
+            value /= doubleBase;
+            iterator.next();
+        }
+
+        // If the end result fits in a double, any intermediate calculation must not overflow
+        // Note that 1/BASE <= value < 1
+        if (this.exponent > 0)
+        {
+            return this.sign * value * Math.pow((double) BASE[this.radix], (double) (this.exponent - 1)) * BASE[this.radix];
+        }
+        else
+        {
+            return this.sign * value * Math.pow((double) BASE[this.radix], (double) this.exponent);
+        }
+    }
+
+    public long longValue()
+    {
+        if (this.sign == 0 || this.exponent <= 0)
+        {
+            return 0;
+        }
+        else if (this.exponent > MAX_LONG_SIZE)
+        {
+            // Overflow for sure
+            return (this.sign > 0 ? Long.MAX_VALUE : Long.MIN_VALUE);
+        }
+
+        long value = 0,
+             longBase = (long) BASE[this.radix],
+             maxPrevious = Long.MIN_VALUE / longBase;
+
+        // Number of words in integer part of the number
+        int size = (int) Math.min(this.exponent, getSize());
+
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.READ, 0, size);
+
+        for (int i = 0; i < (int) this.exponent; i++)
+        {
+            if (value < maxPrevious)
+            {
+                // Overflow
+                value = 0;
+                iterator.close();
+                break;
+            }
+            value *= longBase;
+            if (i < size)
+            {
+                value -= (long) iterator.getInt();      // Calculate value negated to handle 0x8000000000000000
+                iterator.next();
+            }
+        }
+
+        if (value == Long.MIN_VALUE || value >= 0)
+        {
+            // Overflow
+            return (this.sign > 0 ? Long.MAX_VALUE : Long.MIN_VALUE);
+        }
+        else
+        {
+            return -this.sign * value;
+        }
+    }
+
+    // If this ApfloatImpl is equal to 1
+    public boolean isOne()
+        throws ApfloatRuntimeException
+    {
+        if (this.isOne == UNDEFINED)
+        {
+            // Cache the value
+            // NOTE: This is not synchronized; it's OK if multiple threads set this at the same time
+            this.isOne = (this.sign == 1 && this.exponent == 1 && getSize() == 1 && getMostSignificantWord() == (int) 1 ? 1 : 0);
+        }
+
+        return (this.isOne == 1);
+    }
+
+    public long equalDigits(ApfloatImpl x)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof IntApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        IntApfloatImpl that = (IntApfloatImpl) x;
+
+        if (this.sign == 0 && that.sign == 0)           // Both are zero
+        {
+            return Apfloat.INFINITE;
+        }
+        else if (this.sign != that.sign)                // No match
+        {
+            return 0;
+        }
+        else if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot compare values with different radixes: " + this.radix + " and " + that.radix);
+        }
+
+        long thisScale = scale(),
+             thatScale = that.scale(),
+             minScale = Math.min(thisScale, thatScale),
+             maxScale = Math.max(thisScale, thatScale);
+
+        if (maxScale - 1 > minScale)                    // No match
+        {
+            return 0;
+        }
+
+        // Need to compare mantissas
+        long thisSize = getSize(),
+             thatSize = that.getSize(),
+             size = Math.max(thisSize, thatSize);
+        DataStorage.Iterator thisIterator = getZeroPaddedIterator(0, thisSize),
+                             thatIterator = that.getZeroPaddedIterator(0, thatSize);
+
+        long index,
+             result = Math.min(this.precision, that.precision);         // If mantissas are identical
+        int lastMatchingDigits = -1;                                    // Will be used for deferred comparison hanging in last word, e.g. this = 1.000000000, that = 0.999999999
+        int carry,
+                base = BASE[this.radix];
+
+        if (this.exponent > that.exponent)
+        {
+            // Possible case this = 1.0000000, that = 0.9999999
+            int value = thisIterator.getInt();                  // Check first word
+
+            if (value != (int) 1)
+            {
+                // No match
+                thisIterator.close();
+                thatIterator.close();
+
+                return 0;
+            }
+
+            carry = base;
+            thisIterator.next();
+        }
+        else if (this.exponent < that.exponent)
+        {
+            // Possible case this = 0.9999999, that = 1.0000000
+            int value = thatIterator.getInt();                  // Check first word
+
+            if (value != (int) 1)
+            {
+                // No match
+                thisIterator.close();
+                thatIterator.close();
+
+                return 0;
+            }
+
+            carry = -base;
+            thatIterator.next();
+        }
+        else
+        {
+            // Trivial case, e.g. this = 111234, that = 111567
+            carry = 0;
+        }
+
+        // Calculate this - that, stopping at first difference
+        for (index = 0; index < size; index++)
+        {
+            int value = thisIterator.getInt() - thatIterator.getInt() + carry;
+
+            if (value == 0)
+            {
+                // Trivial case; words are equal
+                carry = 0;
+            }
+            else if (Math.abs(value) > (int) 1)
+            {
+                // Mismatch found
+                if (Math.abs(value) >= base)
+                {
+                    // Deferred comparison, e.g. this = 1.0000000002, that = 0.9999999991
+                    lastMatchingDigits = -1;
+                }
+                else
+                {
+                    // Any trivial cases and e.g. this = 1.0000000001, that = 0.9999999992
+                    lastMatchingDigits = BASE_DIGITS[this.radix] - getDigits(Math.abs(value));
+                }
+
+                break;
+            }
+            else if (value == (int) 1)
+            {
+                // Case this = 1.0000000..., that = 0.9999999...
+                carry = base;
+            }
+            else if (value == (int) -1)
+            {
+                // Case this = 0.9999999..., that = 1.0000000...
+                carry = -base;
+            }
+
+            thisIterator.next();
+            thatIterator.next();
+        }
+
+        if (index < size || carry != 0)                 // Mismatch found
+        {
+            long initialMatchingDigits = (this.exponent == that.exponent ?
+                                          Math.min(getInitialDigits(), that.getInitialDigits()) :       // Normal case, e.g. this = 10, that = 5
+                                          BASE_DIGITS[this.radix]);                                     // Special case, e.g. this = 1.0, that = 0.9
+
+            // Note that this works even if index == 0
+            long middleMatchingDigits = (index - 1) * BASE_DIGITS[this.radix];                          // This is correct even if exponents are different
+
+            // Limit by available precision
+            result = Math.min(result, initialMatchingDigits + middleMatchingDigits + lastMatchingDigits);
+
+            // Handle some cases e.g. 0.15 vs. 0.04
+            result = Math.max(result, 0);
+        }
+
+        thisIterator.close();
+        thatIterator.close();
+
+        return result;
+    }
+
+    public int compareTo(ApfloatImpl x)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof IntApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        IntApfloatImpl that = (IntApfloatImpl) x;
+
+        if (this.sign == 0 && that.sign == 0)
+        {
+            return 0;
+        }
+        else if (this.sign < that.sign)                 // Now we know that not both are zero
+        {
+            return -1;
+        }
+        else if (this.sign > that.sign)
+        {
+            return 1;
+        }
+        else if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot compare values with different radixes: " + this.radix + " and " + that.radix);
+        }
+        else if (scale() < that.scale())                // Now we know that both have same sign (which is not zero)
+        {
+            return -this.sign;
+        }
+        else if (scale() > that.scale())
+        {
+            return this.sign;
+        }
+
+        // Need to compare mantissas
+        return this.sign * compareMantissaTo(that);
+    }
+
+    // Returns an iterator for this number's data storage from start to end,
+    // least significant word is correctly truncated with getLeastSignificantWord(),
+    // after that the iterator returns zeros only
+    private DataStorage.Iterator getZeroPaddedIterator(final long start, final long end)
+        throws ApfloatRuntimeException
+    {
+        final DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.READ, start, end);
+
+        return new DataStorage.Iterator()
+        {
+            public int getInt()
+                throws ApfloatRuntimeException
+            {
+                int value;
+
+                if (this.index < end)
+                {
+                    value = iterator.getInt();
+                    if (this.index == end - 1)
+                    {
+                        value = getLeastSignificantWord(this.index, value);
+                    }
+                }
+                else
+                {
+                    value = 0;
+                }
+
+                return value;
+            }
+
+            public void next()
+                throws ApfloatRuntimeException
+            {
+                if (this.index < end)
+                {
+                    iterator.next();
+                    this.index++;
+                }
+            }
+
+            public void close()
+                throws ApfloatRuntimeException
+            {
+                iterator.close();
+            }
+
+            private static final long serialVersionUID = 1L;
+
+            private long index = start;
+        };
+    }
+
+    // Compare absolute values of mantissas
+    private int compareMantissaTo(IntApfloatImpl that)
+        throws ApfloatRuntimeException
+    {
+        long thisSize = getSize(),
+             thatSize = that.getSize(),
+             size = Math.max(thisSize, thatSize);
+        DataStorage.Iterator thisIterator = getZeroPaddedIterator(0, thisSize),
+                             thatIterator = that.getZeroPaddedIterator(0, thatSize);
+        int result = 0;
+
+        long index = findMismatch(thisIterator, thatIterator, size);
+
+        if (index >= 0)                 // Mismatch found
+        {
+            int thisValue = thisIterator.getInt(),
+                    thatValue = thatIterator.getInt();
+
+            if (thisValue < thatValue)
+            {
+                result = -1;
+            }
+            else if (thisValue > thatValue)
+            {
+                result = 1;
+            }
+        }
+
+        thisIterator.close();
+        thatIterator.close();
+
+        return result;
+    }
+
+    // Returns index of first mismatching int, or -1 if mantissas are equal
+    // Iterators are left to point to the mismatching words
+    private long findMismatch(DataStorage.Iterator thisIterator, DataStorage.Iterator thatIterator, long size)
+        throws ApfloatRuntimeException
+    {
+        for (long index = 0; index < size; index++)
+        {
+            int thisValue = thisIterator.getInt(),
+                    thatValue = thatIterator.getInt();
+
+            if (thisValue != thatValue)
+            {
+                return index;
+            }
+
+            thisIterator.next();
+            thatIterator.next();
+        }
+
+        // All searched words matched exactly
+        return -1;
+    }
+
+    // Truncate insignificant digits from the last int of the number
+    private int getLeastSignificantWord(long index, int word)
+        throws ApfloatRuntimeException
+    {
+        if (this.precision == Apfloat.INFINITE)
+        {
+            return word;
+        }
+
+        // Total digits including the specified index
+        long digits = getInitialDigits() + index * BASE_DIGITS[this.radix];
+
+        if (this.precision >= digits)
+        {
+            return word;
+        }
+
+        // Assert that the second array access will not be out of bounds
+        int divisor = MINIMUM_FOR_DIGITS[this.radix][(int) (digits - this.precision)];
+
+        return (int) (long) (word / divisor) * divisor;
+    }
+
+    /**
+     * Compares this object to the specified object.
+     *
+     * @param obj The object to compare with.
+     *
+     * @return <code>true</code> if the objects are equal; <code>false</code> otherwise.
+     */
+
+    public boolean equals(Object obj)
+    {
+        if (!(obj instanceof ApfloatImpl))
+        {
+            return false;
+        }
+
+        ApfloatImpl thatImpl = (ApfloatImpl) obj;
+
+        // Special comparisons against Apfloat.ZERO and Apfloat.ONE work regardless of radix or implementation class
+        if (signum() == 0 && thatImpl.signum() == 0)
+        {
+            return true;
+        }
+        else if (isOne() && thatImpl.isOne())
+        {
+            return true;
+        }
+
+        if (!(obj instanceof IntApfloatImpl))
+        {
+            return false;
+        }
+
+        IntApfloatImpl that = (IntApfloatImpl) obj;
+
+        if (this.radix != that.radix)
+        {
+            // Limitation: cannot compare values with different radixes
+            return false;
+        }
+        else if (this.sign != that.sign ||
+                 this.exponent != that.exponent)
+        {
+            return false;
+        }
+        else
+        {
+            // Need to compare mantissas
+            return compareMantissaTo(that) == 0;
+        }
+    }
+
+    public int hashCode()
+    {
+        if (this.hashCode == 0)
+        {
+            // Cache the value
+            // NOTE: This is not synchronized; it's OK if multiple threads set this at the same time
+            int hashCode = 1 + this.sign + (int) this.exponent + (int) (this.exponent >>> 32);
+
+            if (this.dataStorage != null)
+            {
+                long size = getSize();
+
+                // Scan through log(size) scattered words in the mantissa
+                for (long i = 0; i < size; i = i + i + 1)
+                {
+                    int word = getWord(i);
+
+                    if (i == size - 1)
+                    {
+                        word = getLeastSignificantWord(i, word);
+                    }
+
+                    long element = (long) word;
+                    hashCode += (int) element + (int) (element >>> 32);
+                }
+            }
+
+            this.hashCode = hashCode;
+        }
+
+        return this.hashCode;
+    }
+
+    public String toString(boolean pretty)
+        throws ApfloatRuntimeException
+    {
+        if (this.sign == 0)
+        {
+            return "0";
+        }
+
+        long size = getSize() * BASE_DIGITS[this.radix],    // This is a rounded up value
+             length;
+        if (pretty)
+        {
+             long scale = scale();
+             if (scale <= 0)
+             {
+                 length = 2 - scale + size;         // Format is 0.xxxx or 0.0000xxx
+             }
+             else if (size > scale)
+             {
+                 length = 1 + size;                 // Format is x.xxx
+             }
+             else
+             {
+                 length = scale;                    // Format is xxxx or xxxx0000
+             }
+             length += (this.sign < 0 ? 1 : 0);     // Room for minus sign
+        }
+        else
+        {
+            length = size + 24;     // Sign, "0.", "e", exponent sign and 19 digits of exponent
+        }
+
+        if (length > Integer.MAX_VALUE || length < 0)           // Detect overflow
+        {
+            throw new ApfloatInternalException("Number is too large to fit in a String");
+        }
+
+        StringWriter writer = new StringWriter((int) length);
+
+        try
+        {
+            writeTo(writer, pretty);
+        }
+        catch (IOException ioe)
+        {
+            throw new ApfloatInternalException("Unexpected I/O error writing to StringWriter", ioe);
+        }
+
+        String value = writer.toString();
+
+        assert (value.length() <= length);      // Postcondition to ensure performance
+
+        return value;
+    }
+
+    private static void writeZeros(Writer out, long count)
+        throws IOException
+    {
+        for (long i = 0; i < count; i++)
+        {
+            out.write('0');
+        }
+    }
+
+    public void writeTo(Writer out, boolean pretty)
+        throws IOException, ApfloatRuntimeException
+    {
+        if (this.sign == 0)
+        {
+            out.write('0');
+            return;
+        }
+
+        if (this.sign < 0)
+        {
+            out.write('-');
+        }
+
+        long integerDigits,                 // Number of digits to write before the decimal point
+             exponent;                      // Exponent to print
+
+        if (pretty)
+        {
+            if (this.exponent <= 0)
+            {
+                out.write("0.");            // Output is 0.xxxx
+                writeZeros(out, -scale());  // Print leading zeros after decimal point before first nonzero digit
+                integerDigits = -1;         // Decimal point is already written
+            }
+            else
+            {
+                integerDigits = scale();    // Decimal point location
+            }
+            exponent = 0;                   // Do not print exponent
+        }
+        else
+        {
+            integerDigits = 1;              // Always write as x.xxxey
+            exponent = scale() - 1;         // Print exponent
+        }
+
+        boolean leftPadZeros = false;       // If the written base unit should be left-padded with zeros
+        long size = getSize(),
+             digitsToWrite = Math.min(this.precision, getInitialDigits() + (size - 1) * BASE_DIGITS[this.radix]),
+             digitsWritten = 0,
+             trailingZeros = 0;
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.READ, 0, size);
+        char[] buffer = new char[BASE_DIGITS[this.radix]];
+
+        while (size > 0)
+        {
+            int start = (leftPadZeros ? 0 : BASE_DIGITS[this.radix] - getInitialDigits()),
+                digits = (int) Math.min(digitsToWrite, BASE_DIGITS[this.radix] - start);
+
+            formatWord(buffer, iterator.getInt());
+
+            for (int i = 0; i < digits; i++)
+            {
+                int c = buffer[start + i];
+                if (c == '0')
+                {
+                    trailingZeros++;
+                    digitsToWrite--;
+                }
+                else
+                {
+                    while (trailingZeros > 0)
+                    {
+                        if (digitsWritten == integerDigits)
+                        {
+                            out.write('.');
+                        }
+                        out.write('0');
+                        digitsWritten++;
+                        trailingZeros--;
+                    }
+                    if (digitsWritten == integerDigits)
+                    {
+                        out.write('.');
+                    }
+                    out.write(c);
+                    digitsWritten++;
+                    digitsToWrite--;
+                }
+            }
+            leftPadZeros = true;                        // Always pad with zeros after first word
+
+            iterator.next();
+            size--;
+        }
+
+        if (!pretty && exponent != 0)
+        {
+            out.write("e" + exponent);
+        }
+
+        writeZeros(out, integerDigits - digitsWritten); // If format is xxxx0000
+    }
+
+    private void formatWord(char[] buffer, int word)
+    {
+        int position = BASE_DIGITS[this.radix];
+        while (position > 0 && word > 0)
+        {
+            int newWord = (int) (long) (word / this.radix);
+            int digit = (int) (word -  newWord * this.radix);
+            word = newWord;
+            position--;
+            buffer[position] = Character.forDigit(digit, this.radix);
+        }
+
+        // Left pad zeros
+        while (position > 0)
+        {
+            position--;
+            buffer[position] = '0';
+        }
+    }
+
+    // Effective size, in ints
+    private long getSize()
+        throws ApfloatRuntimeException
+    {
+        assert (this.dataStorage != null);
+
+        return Math.min(getBasePrecision(),
+                        this.dataStorage.getSize());
+    }
+
+    private static int checkRadix(int radix)
+        throws NumberFormatException
+    {
+        if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)
+        {
+            throw new NumberFormatException("Invalid radix " + radix + "; radix must be between " + Character.MIN_RADIX + " and " + Character.MAX_RADIX);
+        }
+
+        return radix;
+    }
+
+    // Get the most significant word of this number
+    private int getMostSignificantWord()
+        throws ApfloatRuntimeException
+    {
+        return getMostSignificantWord(this.dataStorage);
+    }
+
+    // Get the most significant word of the specified data storage
+    private static int getMostSignificantWord(DataStorage dataStorage)
+        throws ApfloatRuntimeException
+    {
+        int msw;
+
+        ArrayAccess arrayAccess = dataStorage.getArray(DataStorage.READ, 0, 1);
+        msw = arrayAccess.getIntData()[arrayAccess.getOffset()];
+        arrayAccess.close();
+
+        return msw;
+    }
+
+    // Get number of digits in the most significant word
+    private int getInitialDigits()
+        throws ApfloatRuntimeException
+    {
+        if (this.initialDigits == UNDEFINED)
+        {
+            // Cache the value
+            // NOTE: This is not synchronized; it's OK if multiple threads set this at the same time
+            this.initialDigits = getDigits(getMostSignificantWord());
+        }
+
+        return this.initialDigits;
+    }
+
+    // Get number of digits in the most significant word of specified data
+    private int getInitialDigits(DataStorage dataStorage)
+        throws ApfloatRuntimeException
+    {
+        return getDigits(getMostSignificantWord(dataStorage));
+    }
+
+    // Gets the number of digits in the specified int and this number's radix
+    private int getDigits(int x)
+    {
+        assert (x > 0);
+
+        int[] minimums = MINIMUM_FOR_DIGITS[this.radix];
+        int i = minimums.length;
+
+        while (x < minimums[--i])
+        {
+        }
+
+        return i + 1;
+    }
+
+    // Gets the precision in ints
+    private long getBasePrecision()
+        throws ApfloatRuntimeException
+    {
+        return getBasePrecision(this.precision, getInitialDigits());
+    }
+
+    // Gets the precision in ints, based on specified precision (in digits),
+    // number of digits in most significant word and this number's radix
+    private long getBasePrecision(long precision, int mswDigits)
+    {
+        if (precision == Apfloat.INFINITE)
+        {
+            return Apfloat.INFINITE;
+        }
+        else
+        {
+            return (precision + BASE_DIGITS[this.radix] - mswDigits - 1) / BASE_DIGITS[this.radix] + 1;
+        }
+    }
+
+    private int getWord(long index)
+    {
+        ArrayAccess arrayAccess = this.dataStorage.getArray(DataStorage.READ, index, 1);
+        int word = arrayAccess.getIntData()[arrayAccess.getOffset()];
+        arrayAccess.close();
+
+        return word;
+    }
+
+    private void readObject(ObjectInputStream in)
+        throws IOException, ClassNotFoundException
+    {
+        this.leastZeros = UNDEFINED;
+        this.isOne = UNDEFINED;
+        in.defaultReadObject();
+    }
+
+    // Gets a new data storage for specified size
+    private static DataStorage createDataStorage(long size)
+        throws ApfloatRuntimeException
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        return dataStorageBuilder.createDataStorage(size * 4);
+    }
+
+    // Gets I/O block size in ints
+    private static int getBlockSize()
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        return ctx.getBlockSize() / 4;
+    }
+
+    private static final DataStorage.Iterator ZERO_ITERATOR =
+    new DataStorage.Iterator()
+    {
+        public int getInt() { return 0; }
+        public void next() { }
+        private static final long serialVersionUID = 1L;
+    };
+
+    private static final long serialVersionUID = -3759805150008433996L;
+
+    private static final int UNDEFINED = 0x80000000;
+    private static final int MAX_LONG_SIZE = 4;
+    private static final int MAX_DOUBLE_SIZE = 4;
+
+    private int sign;
+    private long precision;
+    private long exponent;
+    private DataStorage dataStorage;
+    private int radix;
+    private int hashCode = 0;
+    private int initialDigits = UNDEFINED;
+    private int isOne = UNDEFINED;
+    private volatile long leastZeros = UNDEFINED;
+    private volatile long size = 0;
+}
Index: src/main/java/org/apfloat/internal/IntBaseMath.java
===================================================================
--- src/main/java/org/apfloat/internal/IntBaseMath.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntBaseMath.java	(revision 0)
@@ -0,0 +1,211 @@
+package org.apfloat.internal;
+
+import java.io.Serializable;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+import static org.apfloat.internal.IntRadixConstants.*;
+
+/**
+ * Mathematical operations on numbers in a base.
+ * Implementation for the <code>int</code> type.
+ *
+ * @version 1.8.2
+ * @author Mikko Tommila
+ */
+
+public class IntBaseMath
+    implements Serializable
+{
+    /**
+     * Creates a base math using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public IntBaseMath(int radix)
+    {
+        this.radix = radix;
+    }
+
+    /**
+     * Addition in some base. Adds the data words
+     * of <code>src1</code> and <code>src2</code> and stores the result to
+     * <code>dst</code>. <code>src2</code> may be <code>null</code>, in
+     * which case it is ignored (only the carry is propagated).<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] + src2[i]</code>.
+     *
+     * @param src1 First source data sequence. Can be <code>null</code>, in which case it's ignored.
+     * @param src2 Second source data sequence. Can be <code>null</code>, in which case it's ignored.
+     * @param carry Input carry bit. This is added to the first (rightmost) word in the accessed sequence.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Overflow carry bit. Propagated carry bit from the addition of the last (leftmost) word in the accessed sequence.
+     */
+
+    public int baseAdd(DataStorage.Iterator src1, DataStorage.Iterator src2, int carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (src1 == null || src1 != src2);
+
+        boolean sameDst = (src1 == dst || src2 == dst);
+        int base = BASE[this.radix];
+
+        for (long i = 0; i < size; i++)
+        {
+            int result = (src1 == null ? 0 : src1.getInt()) + carry +
+                         (src2 == null ? 0 : src2.getInt());
+
+            carry = (result >= base | result < 0 ? 1 : 0);      // Detect overflow (optimization: | is often faster than || here)
+            result -= (result >= base | result < 0 ? base : 0);
+
+            dst.setInt(result);
+
+            if (src1 != null) src1.next();
+            if (src2 != null) src2.next();
+            if (!sameDst) dst.next();
+        }
+
+        return carry;
+    }
+
+    /**
+     * Subtraction in some base. Subtracts the data words
+     * of <code>src1</code> and <code>src2</code> and stores the result to
+     * <code>dst</code>. <code>src1</code> and <code>src2</code> may be
+     * <code>null</code>, in which case they are ignored (the values are assumed
+     * to be zero and only the carry is propagated).<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] - src2[i]</code>.
+     *
+     * @param src1 First source data sequence. Can be <code>null</code>, in which case the input values are assumed to be zero.
+     * @param src2 Second source data sequence. Can be <code>null</code>, in which case it's ignored, or can be the same as <code>dst</code>.
+     * @param carry Input carry bit. This is subtracted from the first (rightmost) word in the accessed sequence.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Overflow carry bit. Propagated carry bit from the subtraction of the last (leftmost) word in the accessed sequence. The value is <code>1</code> if the carry is set, and <code>0</code> otherwise.
+     */
+
+    public int baseSubtract(DataStorage.Iterator src1, DataStorage.Iterator src2, int carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (src1 == null || src1 != src2);
+        assert (src2 != dst);
+
+        int base = BASE[this.radix];
+
+        for (long i = 0; i < size; i++)
+        {
+            int result = (src1 == null ? 0 : src1.getInt()) - carry -
+                         (src2 == null ? 0 : src2.getInt());
+
+            carry = (result < 0 ? 1 : 0);
+            result += (result < 0 ? base : 0);
+
+            dst.setInt(result);
+
+            if (src1 != null && src1 != dst) src1.next();
+            if (src2 != null) src2.next();
+            dst.next();
+        }
+
+        return carry;
+    }
+
+    /**
+     * Multiplication and addition in some base. Multiplies the data words
+     * of <code>src1</code> by <code>src3</code> and adds the result to the
+     * words in <code>src2</code>, and stores the result to <code>dst</code>.
+     * <code>src2</code> may be <code>null</code>, in which case it is ignored
+     * (the values are assumed to be zero).<p>
+     *
+     * Assumes that the result from the addition doesn't overflow the upper
+     * result word (to larger than the base). This is the case e.g. when using
+     * this method to perform an arbitrary precision multiplication.<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] * src3 + src2[i]</code>.
+     *
+     * @param src1 First source data sequence.
+     * @param src2 Second source data sequence. Can be <code>null</code>, in which case it's ignored, or can be the same as <code>dst</code>.
+     * @param src3 Multiplicand. All elements of <code>src1</code> are multiplied by this value.
+     * @param carry Input carry word. This is added to the first (rightmost) word in the accessed sequence.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Overflow carry word. Propagated carry word from the multiplication and addition of the last (leftmost) word in the accessed sequence.
+     */
+
+    public int baseMultiplyAdd(DataStorage.Iterator src1, DataStorage.Iterator src2, int src3, int carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (src1 != src2);
+        assert (src1 != dst);
+
+        int base = BASE[this.radix];
+
+        for (long i = 0; i < size; i++)
+        {
+            long tmp = (long) src1.getInt() * (long) src3 +
+                       (src2 == null ? 0 : src2.getInt()) + carry;
+
+            carry = (int) (tmp / base);
+
+            dst.setInt((int) tmp - carry * base);       // = tmp % base
+
+            src1.next();
+            if (src2 != null && src2 != dst) src2.next();
+            dst.next();
+        }
+
+        return carry;
+    }
+
+    /**
+     * Division in some base. Divides the data words
+     * of <code>src1</code> by <code>src2</code> and stores the result to
+     * <code>dst</code>. <code>src1</code> may be <code>null</code>,
+     * in which case it is ignored (the values are assumed to be
+     * zero and only the carry division is propagated).<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] / src2</code>.
+     *
+     * @param src1 First source data sequence. Can be <code>null</code>, in which case the input values are assumed to be zero.
+     * @param src2 Divisor. All elements of <code>src1</code> are divided by this value.
+     * @param carry Input carry word. Used as the upper word for the division of the first input element. This should be the remainder word returned from the previous block processed.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Remainder word of the propagated division of the last (rightmost) word in the accessed sequence.
+     */
+
+    public int baseDivide(DataStorage.Iterator src1, int src2, int carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (src1 != dst);
+
+        int base = BASE[this.radix];
+
+        for (long i = 0; i < size; i++)
+        {
+            long tmp = (long) carry * (long) base +
+                       (src1 == null ? 0 : src1.getInt());
+            int result = (int) (tmp / src2);
+
+            carry = (int) tmp - result * src2;      // = tmp % src2
+
+            dst.setInt(result);
+
+            if (src1 != null) src1.next();
+            dst.next();
+        }
+
+        return carry;
+    }
+
+    private static final long serialVersionUID = 2173589976837534455L;
+
+    private int radix;
+}
Index: src/main/java/org/apfloat/internal/IntBuilderFactory.java
===================================================================
--- src/main/java/org/apfloat/internal/IntBuilderFactory.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntBuilderFactory.java	(revision 0)
@@ -0,0 +1,119 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+
+import org.apfloat.spi.AdditionBuilder;
+import org.apfloat.spi.BuilderFactory;
+import org.apfloat.spi.ApfloatBuilder;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.ConvolutionBuilder;
+import org.apfloat.spi.NTTBuilder;
+import org.apfloat.spi.MatrixBuilder;
+import org.apfloat.spi.CarryCRTBuilder;
+
+/**
+ * Factory class for getting instances of the various builder classes needed
+ * to build an <code>ApfloatImpl</code> with the <code>int</code> data element type.
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class IntBuilderFactory
+    implements BuilderFactory
+{
+    /**
+     * Default constructor.
+     */
+
+    public IntBuilderFactory()
+    {
+    }
+
+    public ApfloatBuilder getApfloatBuilder()
+    {
+        return IntBuilderFactory.apfloatBuilder;
+    }
+
+    public DataStorageBuilder getDataStorageBuilder()
+    {
+        return IntBuilderFactory.dataStorageBuilder;
+    }
+
+    public <T> AdditionBuilder<T> getAdditionBuilder(Class<T> elementType)
+        throws IllegalArgumentException
+    {
+        if (!Integer.TYPE.equals(elementType))
+        {
+           throw new IllegalArgumentException("Unsupported element type: " + elementType);
+        }
+        @SuppressWarnings("unchecked")
+        AdditionBuilder<T> additionBuilder = (AdditionBuilder<T>) IntBuilderFactory.additionBuilder;
+        return additionBuilder;
+    }
+
+    public ConvolutionBuilder getConvolutionBuilder()
+    {
+        return IntBuilderFactory.convolutionBuilder;
+    }
+
+    public NTTBuilder getNTTBuilder()
+    {
+        return IntBuilderFactory.nttBuilder;
+    }
+
+    public MatrixBuilder getMatrixBuilder()
+    {
+        return IntBuilderFactory.matrixBuilder;
+    }
+
+    public <T> CarryCRTBuilder<T> getCarryCRTBuilder(Class<T> elementArrayType)
+        throws IllegalArgumentException
+    {
+        if (!int[].class.equals(elementArrayType))
+        {
+           throw new IllegalArgumentException("Unsupported element array type: " + elementArrayType);
+        }
+        @SuppressWarnings("unchecked")
+        CarryCRTBuilder<T> carryCRTBuilder = (CarryCRTBuilder<T>) IntBuilderFactory.carryCRTBuilder;
+        return carryCRTBuilder;
+    }
+
+    public Class<?> getElementType()
+    {
+        return Integer.TYPE;
+    }
+
+    public Class<?> getElementArrayType()
+    {
+        return int[].class;
+    }
+
+    public int getElementSize()
+    {
+        return 4;
+    }
+
+    public void shutdown()
+        throws ApfloatRuntimeException
+    {
+        DiskDataStorage.cleanUp();
+    }
+
+    public void gc()
+        throws ApfloatRuntimeException
+    {
+        System.gc();
+        System.gc();
+        System.runFinalization();
+        DiskDataStorage.gc();
+    }
+
+    private static ApfloatBuilder apfloatBuilder = new IntApfloatBuilder();
+    private static DataStorageBuilder dataStorageBuilder = new IntDataStorageBuilder();
+    private static AdditionBuilder<Integer> additionBuilder = new IntAdditionBuilder();
+    private static ConvolutionBuilder convolutionBuilder = new IntConvolutionBuilder();
+    private static NTTBuilder nttBuilder = new IntNTTBuilder();
+    private static MatrixBuilder matrixBuilder = new IntMatrixBuilder();
+    private static CarryCRTBuilder<int[]> carryCRTBuilder = new IntCarryCRTBuilder();
+}
Index: src/main/java/org/apfloat/internal/IntCRTMath.java
===================================================================
--- src/main/java/org/apfloat/internal/IntCRTMath.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntCRTMath.java	(revision 0)
@@ -0,0 +1,172 @@
+package org.apfloat.internal;
+
+import static org.apfloat.internal.IntModConstants.*;
+import static org.apfloat.internal.IntRadixConstants.*;
+
+/**
+ * Basic arithmetic for calculating the Chinese Remainder
+ * Theorem. Works for the <code>int</code> type.
+ *
+ * @version 1.6
+ * @author Mikko Tommila
+ */
+
+public class IntCRTMath
+    extends IntBaseMath
+{
+    /**
+     * Creates a carry-CRT math using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public IntCRTMath(int radix)
+    {
+        super(radix);
+        this.base = BASE[radix];
+    }
+
+    /**
+     * Multiplies two words by one word to produce a result of three words.
+     * Most significant word is stored first.
+     *
+     * @param src Source array, first multiplicand.
+     * @param factor Second multiplicand.
+     * @param dst Destination array.
+     */
+
+    public final void multiply(int[] src, int factor, int[] dst)
+    {
+        long tmp = (long) src[1] * (long) factor;
+        int carry = (int) (tmp >>> MAX_POWER_OF_TWO_BITS);
+
+        dst[2] = (int) tmp & BASE_MASK;     // = tmp % MAX_POWER_OF_TWO_BASE
+
+        tmp = (long) src[0] * (long) factor + carry;
+        carry = (int) (tmp >>> MAX_POWER_OF_TWO_BITS);
+
+        dst[1] = (int) tmp & BASE_MASK;     // = tmp % MAX_POWER_OF_TWO_BASE
+
+        dst[0] = carry;
+    }
+
+    /**
+     * Compares three words. Most significant word is stored first.
+     *
+     * @param src1 First operand.
+     * @param src2 Second operand.
+     *
+     * @return Less than zero if <code>src1 &lt; src2</code>, greater than zero if <code>src1 &gt; src2</code> and zero if <code>src1 == src2</code>.
+     */
+
+    public final int compare(int[] src1, int[] src2)
+    {
+        int result = src1[0] - src2[0];
+
+        if (result != 0)
+        {
+            return result;
+        }
+
+        result = src1[1] - src2[1];
+
+        if (result != 0)
+        {
+            return result;
+        }
+
+        return src1[2] - src2[2];
+    }
+
+    /**
+     * Adds three words. Most significant word is stored first.
+     *
+     * @param src First operand.
+     * @param srcDst Second operand, and destination of the operation.
+     *
+     * @return Overflow carry bit.
+     */
+
+    public final int add(int[] src, int[] srcDst)
+    {
+        int result = srcDst[2] + src[2],
+            carry = (result < 0 ? 1 : 0);
+        result = (result < 0 ? result - MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[2] = result;
+
+        result = srcDst[1] + src[1] + carry;
+        carry = (result < 0 ? 1 : 0);
+        result = (result < 0 ? result - MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[1] = result;
+
+        result = srcDst[0] + src[0] + carry;
+        carry = (result < 0 ? 1 : 0);
+        result = (result < 0 ? result - MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[0] = result;
+
+        return carry;
+    }
+
+    /**
+     * Subtracts three words. Most significant word is stored first.
+     *
+     * @param src First operand.
+     * @param srcDst Second operand, and destination of the operation.
+     */
+
+    public final void subtract(int[] src, int[] srcDst)
+    {
+        int result = srcDst[2] - src[2],
+            carry = (result < 0 ? 1 : 0);
+        result = (result < 0 ? result + MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[2] = result;
+
+        result = srcDst[1] - src[1] - carry;
+        carry = (result < 0 ? 1 : 0);
+        result = (result < 0 ? result + MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[1] = result;
+
+        result = srcDst[0] - src[0] - carry;
+        // carry = (result < 0 ? 1 : 0);
+        result = (result < 0 ? result + MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[0] = result;
+    }
+
+    /**
+     * Divides three words by the base to produce two words. Most significant word is stored first.
+     *
+     * @param srcDst Source and destination of the operation.
+     *
+     * @return Remainder of the division.
+     */
+
+    public final int divide(int[] srcDst)
+    {
+        long tmp = ((long) srcDst[0] << MAX_POWER_OF_TWO_BITS) + srcDst[1];
+        int result = (int) (tmp / this.base),
+            carry = (int) tmp - result * this.base;     // = tmp % this.base
+
+        srcDst[0] = 0;
+        srcDst[1] = result;
+
+        tmp = ((long) carry << MAX_POWER_OF_TWO_BITS) + srcDst[2];
+        result = (int) (tmp / this.base);
+        carry = (int) tmp - result * this.base;         // = tmp % this.base
+
+        srcDst[2] = result;
+
+        return carry;
+    }
+
+    private static final long serialVersionUID = 6698972116690441263L;
+
+    private static final int BASE_MASK = (1 << MAX_POWER_OF_TWO_BITS) - 1;
+
+    private int base;
+}
Index: src/main/java/org/apfloat/internal/IntCarryCRTBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/IntCarryCRTBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntCarryCRTBuilder.java	(revision 0)
@@ -0,0 +1,36 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.CarryCRTBuilder;
+import org.apfloat.spi.CarryCRTStrategy;
+import org.apfloat.spi.CarryCRTStepStrategy;
+
+/**
+ * Creates carry-CRT related objects, for the
+ * <code>int</code> type.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class IntCarryCRTBuilder
+    implements CarryCRTBuilder<int[]>
+{
+    /**
+     * Default constructor.
+     */
+
+    public IntCarryCRTBuilder()
+    {
+    }
+
+    public CarryCRTStrategy createCarryCRT(int radix)
+    {
+        return new StepCarryCRTStrategy(radix);
+    }
+
+    public CarryCRTStepStrategy<int[]> createCarryCRTSteps(int radix)
+    {
+        return new IntCarryCRTStepStrategy(radix);
+    }
+}
Index: src/main/java/org/apfloat/internal/IntCarryCRTStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/IntCarryCRTStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntCarryCRTStepStrategy.java	(revision 0)
@@ -0,0 +1,293 @@
+package org.apfloat.internal;
+
+import java.math.BigInteger;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.CarryCRTStepStrategy;
+import org.apfloat.spi.DataStorage;
+import static org.apfloat.internal.IntModConstants.*;
+
+/**
+ * Class for performing the final steps of a three-modulus
+ * Number Theoretic Transform based convolution. Works for the
+ * <code>int</code> type.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class IntCarryCRTStepStrategy
+    extends IntCRTMath
+    implements CarryCRTStepStrategy<int[]>
+{
+    /**
+     * Creates a carry-CRT steps object using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public IntCarryCRTStepStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public int[] crt(DataStorage resultMod0, DataStorage resultMod1, DataStorage resultMod2, DataStorage dataStorage, long size, long resultSize, long offset, long length)
+        throws ApfloatRuntimeException
+    {
+        long skipSize = (offset == 0 ? size - resultSize + 1: 0);   // For the first block, ignore the first 1-3 elements
+        long lastSize = (offset + length == size ? 1: 0);           // For the last block, add 1 element
+        long nonLastSize = 1 - lastSize;                            // For the other than last blocks, move 1 element
+        long subResultSize = length - skipSize + lastSize;
+
+        long subStart = size - offset,
+             subEnd = subStart - length,
+             subResultStart = size - offset - length + nonLastSize + subResultSize,
+             subResultEnd = subResultStart - subResultSize;
+
+        DataStorage.Iterator src0 = resultMod0.iterator(DataStorage.READ, subStart, subEnd),
+                             src1 = resultMod1.iterator(DataStorage.READ, subStart, subEnd),
+                             src2 = resultMod2.iterator(DataStorage.READ, subStart, subEnd),
+                             dst = dataStorage.iterator(DataStorage.WRITE, subResultStart, subResultEnd);
+
+        int[] carryResult = new int[3],
+                  sum = new int[3],
+                  tmp = new int[3];
+
+        // Preliminary carry-CRT calculation (happens in parallel in multiple blocks)
+        for (long i = 0; i < length; i++)
+        {
+            int y0 = MATH_MOD_0.modMultiply(T0, src0.getInt()),
+                    y1 = MATH_MOD_1.modMultiply(T1, src1.getInt()),
+                    y2 = MATH_MOD_2.modMultiply(T2, src2.getInt());
+
+            multiply(M12, y0, sum);
+            multiply(M02, y1, tmp);
+
+            if (add(tmp, sum) != 0 ||
+                compare(sum, M012) >= 0)
+            {
+                subtract(M012, sum);
+            }
+
+            multiply(M01, y2, tmp);
+
+            if (add(tmp, sum) != 0 ||
+                compare(sum, M012) >= 0)
+            {
+                subtract(M012, sum);
+            }
+
+            add(sum, carryResult);
+
+            int result = divide(carryResult);
+
+            // In the first block, ignore the first element (it's zero in full precision calculations)
+            // and possibly one or two more in limited precision calculations
+            if (i >= skipSize)
+            {
+                dst.setInt(result);
+                dst.next();
+            }
+
+            src0.next();
+            src1.next();
+            src2.next();
+        }
+
+        // Calculate the last words (in base math)
+        int result0 = divide(carryResult);
+        int result1 = carryResult[2];
+
+        assert (carryResult[0] == 0);
+        assert (carryResult[1] == 0);
+
+        // Last block has one extra element (corresponding to the one skipped in the first block)
+        if (subResultSize == length - skipSize + 1)
+        {
+            dst.setInt(result0);
+            dst.close();
+
+            result0 = result1;
+            assert (result1 == 0);
+        }
+
+        int[] results = { result1, result0 };
+
+        return results;
+    }
+
+    public int[] carry(DataStorage dataStorage, long size, long resultSize, long offset, long length, int[] results, int[] previousResults)
+        throws ApfloatRuntimeException
+    {
+        long skipSize = (offset == 0 ? size - resultSize + 1: 0);   // For the first block, ignore the first 1-3 elements
+        long lastSize = (offset + length == size ? 1: 0);           // For the last block, add 1 element
+        long nonLastSize = 1 - lastSize;                            // For the other than last blocks, move 1 element
+        long subResultSize = length - skipSize + lastSize;
+
+        long subResultStart = size - offset - length + nonLastSize + subResultSize,
+             subResultEnd = subResultStart - subResultSize;
+
+        // Get iterators for the previous block carries, and dst, padded with this block's carries
+        // Note that size could be 1 but carries size is 2
+        DataStorage.Iterator src = arrayIterator(previousResults);
+        DataStorage.Iterator dst = compositeIterator(dataStorage.iterator(DataStorage.READ_WRITE, subResultStart, subResultEnd), subResultSize, arrayIterator(results));
+
+        // Propagate base addition through dst, and this block's carries
+        int carry = baseAdd(dst, src, 0, dst, previousResults.length);
+        carry = baseCarry(dst, carry, subResultSize);
+        dst.close();                                                    // Iterator likely was not iterated to end
+
+        assert (carry == 0);
+
+        return results;
+    }
+
+    private int baseCarry(DataStorage.Iterator srcDst, int carry, long size)
+        throws ApfloatRuntimeException
+    {
+        for (long i = 0; i < size && carry > 0; i++)
+        {
+            carry = baseAdd(srcDst, null, carry, srcDst, 1);
+        }
+
+        return carry;
+    }
+
+    // Wrap an array in a simple reverse-order iterator, padded with zeros
+    private static DataStorage.Iterator arrayIterator(final int[] data)
+    {
+        return new DataStorage.Iterator()
+        {
+            public boolean hasNext()
+            {
+                return true;
+            }
+
+            public void next()
+            {
+                this.position--;
+            }
+
+            public int getInt()
+            {
+                assert (this.position >= 0);
+                return data[this.position];
+            }
+
+            public void setInt(int value)
+            {
+                assert (this.position >= 0);
+                data[this.position] = value;
+            }
+
+            private static final long serialVersionUID = 1L;
+
+            private int position = data.length - 1;
+        };
+    }
+
+    // Composite iterator, made by concatenating two iterators
+    private static DataStorage.Iterator compositeIterator(final DataStorage.Iterator iterator1, final long size, final DataStorage.Iterator iterator2)
+    {
+        return new DataStorage.Iterator()
+        {
+            public boolean hasNext()
+            {
+                return (this.position < size ? iterator1.hasNext() : iterator2.hasNext());
+            }
+
+            public void next()
+                throws ApfloatRuntimeException
+            {
+                (this.position < size ? iterator1 : iterator2).next();
+                this.position++;
+            }
+
+            public int getInt()
+                throws ApfloatRuntimeException
+            {
+                return (this.position < size ? iterator1 : iterator2).getInt();
+            }
+
+            public void setInt(int value)
+                throws ApfloatRuntimeException
+            {
+                (this.position < size ? iterator1 : iterator2).setInt(value);
+            }
+
+            public void close()
+                throws ApfloatRuntimeException
+            {
+                (this.position < size ? iterator1 : iterator2).close();
+            }
+
+            private static final long serialVersionUID = 1L;
+
+            private long position;
+        };
+    }
+
+    private static final long serialVersionUID = 7666237487091579201L;
+
+    private static final IntModMath MATH_MOD_0,
+                                        MATH_MOD_1,
+                                        MATH_MOD_2;
+    private static final int T0,
+                                 T1,
+                                 T2;
+    private static final int[] M01,
+                                   M02,
+                                   M12,
+                                   M012;
+
+    static
+    {
+        MATH_MOD_0 = new IntModMath();
+        MATH_MOD_1 = new IntModMath();
+        MATH_MOD_2 = new IntModMath();
+
+        MATH_MOD_0.setModulus(MODULUS[0]);
+        MATH_MOD_1.setModulus(MODULUS[1]);
+        MATH_MOD_2.setModulus(MODULUS[2]);
+
+        // Probably sub-optimal, but it's a one-time operation
+
+        BigInteger base = BigInteger.valueOf(Math.abs((long) MAX_POWER_OF_TWO_BASE)),   // In int case the base is 0x80000000
+                   m0 = BigInteger.valueOf((long) MODULUS[0]),
+                   m1 = BigInteger.valueOf((long) MODULUS[1]),
+                   m2 = BigInteger.valueOf((long) MODULUS[2]),
+                   m01 = m0.multiply(m1),
+                   m02 = m0.multiply(m2),
+                   m12 = m1.multiply(m2);
+
+        T0 = m12.modInverse(m0).intValue();
+        T1 = m02.modInverse(m1).intValue();
+        T2 = m01.modInverse(m2).intValue();
+
+        M01 = new int[2];
+        M02 = new int[2];
+        M12 = new int[2];
+        M012 = new int[3];
+
+        BigInteger[] qr = m01.divideAndRemainder(base);
+        M01[0] = qr[0].intValue();
+        M01[1] = qr[1].intValue();
+
+        qr = m02.divideAndRemainder(base);
+        M02[0] = qr[0].intValue();
+        M02[1] = qr[1].intValue();
+
+        qr = m12.divideAndRemainder(base);
+        M12[0] = qr[0].intValue();
+        M12[1] = qr[1].intValue();
+
+        qr = m0.multiply(m12).divideAndRemainder(base);
+        M012[2] = qr[1].intValue();
+        qr = qr[0].divideAndRemainder(base);
+        M012[0] = qr[0].intValue();
+        M012[1] = qr[1].intValue();
+    }
+}
Index: src/main/java/org/apfloat/internal/IntConstants.java
===================================================================
--- src/main/java/org/apfloat/internal/IntConstants.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntConstants.java	(revision 0)
@@ -0,0 +1,24 @@
+package org.apfloat.internal;
+
+/**
+ * Constants needed for various algorithms for the <code>int</code> type.
+ *
+ * @since 1.4
+ * @version 1.4
+ * @author Mikko Tommila
+ */
+
+public interface IntConstants
+{
+    /**
+     * Relative cost of Karatsuba multiplication.
+     */
+
+    public static final float KARATSUBA_COST_FACTOR = 4.8f;
+
+    /**
+     * Relative cost of NTT multiplication.
+     */
+
+    public static final float NTT_COST_FACTOR = 4.1f;
+}
Index: src/main/java/org/apfloat/internal/IntConvolutionBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/IntConvolutionBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntConvolutionBuilder.java	(revision 0)
@@ -0,0 +1,65 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.ConvolutionStrategy;
+import org.apfloat.spi.NTTStrategy;
+import static org.apfloat.internal.IntConstants.*;
+
+/**
+ * Creates convolutions of suitable type for the <code>int</code> type.<p>
+ *
+ * @see IntShortConvolutionStrategy
+ * @see IntMediumConvolutionStrategy
+ * @see IntKaratsubaConvolutionStrategy
+ * @see ThreeNTTConvolutionStrategy
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class IntConvolutionBuilder
+    extends AbstractConvolutionBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public IntConvolutionBuilder()
+    {
+    }
+
+    protected int getKaratsubaCutoffPoint()
+    {
+        return IntKaratsubaConvolutionStrategy.CUTOFF_POINT;
+    }
+
+    protected float getKaratsubaCostFactor()
+    {
+        return KARATSUBA_COST_FACTOR;
+    }
+
+    protected float getNTTCostFactor()
+    {
+        return NTT_COST_FACTOR;
+    }
+
+    protected ConvolutionStrategy createShortConvolutionStrategy(int radix)
+    {
+        return new IntShortConvolutionStrategy(radix);
+    }
+
+    protected ConvolutionStrategy createMediumConvolutionStrategy(int radix)
+    {
+        return new IntMediumConvolutionStrategy(radix);
+    }
+
+    protected ConvolutionStrategy createKaratsubaConvolutionStrategy(int radix)
+    {
+        return new IntKaratsubaConvolutionStrategy(radix);
+    }
+
+
+    protected ConvolutionStrategy createThreeNTTConvolutionStrategy(int radix, NTTStrategy nttStrategy)
+    {
+        return new ParallelThreeNTTConvolutionStrategy(radix, nttStrategy);
+    }
+}
Index: src/main/java/org/apfloat/internal/IntDataStorageBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/IntDataStorageBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntDataStorageBuilder.java	(revision 0)
@@ -0,0 +1,49 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+
+/**
+ * Default data storage creation strategy for the <code>int</code> data type.
+ *
+ * @see IntMemoryDataStorage
+ * @see IntDiskDataStorage
+ *
+ * @version 1.8.2
+ * @author Mikko Tommila
+ */
+
+public class IntDataStorageBuilder
+    extends AbstractDataStorageBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public IntDataStorageBuilder()
+    {
+    }
+
+    protected long getMaxCachedSize()
+    {
+        return (long) 4 * Integer.MAX_VALUE;
+    }
+
+    protected DataStorage createCachedDataStorage()
+        throws ApfloatRuntimeException
+    {
+        return new IntMemoryDataStorage();
+    }
+
+    protected DataStorage createNonCachedDataStorage()
+        throws ApfloatRuntimeException
+    {
+        return new IntDiskDataStorage();
+    }
+
+    protected boolean isCached(DataStorage dataStorage)
+        throws ApfloatRuntimeException
+    {
+        return (dataStorage instanceof IntMemoryDataStorage);
+    }
+}
Index: src/main/java/org/apfloat/internal/IntDiskDataStorage.java
===================================================================
--- src/main/java/org/apfloat/internal/IntDiskDataStorage.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntDiskDataStorage.java	(revision 0)
@@ -0,0 +1,333 @@
+package org.apfloat.internal;
+
+import java.nio.ByteBuffer;
+import java.nio.IntBuffer;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.channels.WritableByteChannel;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Disk-based data storage for the <code>int</code> element type.
+ *
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class IntDiskDataStorage
+    extends DiskDataStorage
+{
+    /**
+     * Default constructor.
+     */
+
+    public IntDiskDataStorage()
+        throws ApfloatRuntimeException
+    {
+    }
+
+    /**
+     * Subsequence constructor.
+     *
+     * @param intDiskDataStorage The originating data storage.
+     * @param offset The subsequence starting position.
+     * @param length The subsequence length.
+     */
+
+    protected IntDiskDataStorage(IntDiskDataStorage intDiskDataStorage, long offset, long length)
+    {
+        super(intDiskDataStorage, offset, length);
+    }
+
+    protected DataStorage implSubsequence(long offset, long length)
+        throws ApfloatRuntimeException
+    {
+        return new IntDiskDataStorage(this, offset + getOffset(), length);
+    }
+
+    private class IntDiskArrayAccess
+        extends IntMemoryArrayAccess
+    {
+        // fileOffset is absolute position in file
+        public IntDiskArrayAccess(int mode, long fileOffset, int length)
+            throws ApfloatRuntimeException
+        {
+            super(new int[length], 0, length);
+            this.mode = mode;
+            this.fileOffset = fileOffset;
+
+            if ((mode & READ) != 0)
+            {
+                final int[] array = getIntData();
+                WritableByteChannel out = new WritableByteChannel()
+                {
+                    public int write(ByteBuffer buffer)
+                    {
+                        IntBuffer src = buffer.asIntBuffer();
+                        int readLength = src.remaining();
+
+                        src.get(array, this.readPosition, readLength);
+
+                        this.readPosition += readLength;
+                        buffer.position(buffer.position() + readLength * 4);
+
+                        return readLength * 4;
+                    }
+
+                    public void close() {}
+                    public boolean isOpen() { return true; }
+
+                    private int readPosition = 0;
+                };
+
+                transferTo(out, fileOffset * 4, (long) length * 4);
+            }
+        }
+
+        public void close()
+            throws ApfloatRuntimeException
+        {
+            if ((this.mode & WRITE) != 0 && getData() != null)
+            {
+                final int[] array = getIntData();
+                ReadableByteChannel in = new ReadableByteChannel()
+                {
+                    public int read(ByteBuffer buffer)
+                    {
+                        IntBuffer dst = buffer.asIntBuffer();
+                        int writeLength = dst.remaining();
+
+                        dst.put(array, this.writePosition, writeLength);
+
+                        this.writePosition += writeLength;
+                        buffer.position(buffer.position() + writeLength * 4);
+
+                        return writeLength * 4;
+                    }
+
+                    public void close() {}
+                    public boolean isOpen() { return true; }
+
+                    private int writePosition = 0;
+                };
+
+                transferFrom(in, this.fileOffset * 4, (long) array.length * 4);
+            }
+
+            super.close();
+        }
+
+        private static final long serialVersionUID = -88509093904437138L;
+
+        private int mode;
+        private long fileOffset;
+    }
+
+    protected ArrayAccess implGetArray(int mode, long offset, int length)
+        throws ApfloatRuntimeException
+    {
+        return new IntDiskArrayAccess(mode, getOffset() + offset, length);
+    }
+
+    protected ArrayAccess createArrayAccess(int mode, int startColumn, int columns, int rows)
+    {
+        return new MemoryArrayAccess(mode, new int[columns * rows], startColumn, columns, rows);
+    }
+
+    protected ArrayAccess createTransposedArrayAccess(int mode, int startColumn, int columns, int rows)
+    {
+        return new TransposedMemoryArrayAccess(mode, new int[columns * rows], startColumn, columns, rows);
+    }
+
+    private class MemoryArrayAccess
+        extends IntMemoryArrayAccess
+    {
+        public MemoryArrayAccess(int mode, int[] data, int startColumn, int columns, int rows)
+        {
+            super(data, 0, data.length);
+            this.mode = mode;
+            this.startColumn = startColumn;
+            this.columns = columns;
+            this.rows = rows;
+        }
+
+        public void close()
+            throws ApfloatRuntimeException
+        {
+            if ((this.mode & WRITE) != 0 && getData() != null)
+            {
+                setArray(this, this.startColumn, this.columns, this.rows);
+            }
+            super.close();
+        }
+
+        private static final long serialVersionUID = 7690849230285450035L;
+
+        private int mode,
+                    startColumn,
+                    columns,
+                    rows;
+    }
+
+    private class TransposedMemoryArrayAccess
+        extends IntMemoryArrayAccess
+    {
+        public TransposedMemoryArrayAccess(int mode, int[] data, int startColumn, int columns, int rows)
+        {
+            super(data, 0, data.length);
+            this.mode = mode;
+            this.startColumn = startColumn;
+            this.columns = columns;
+            this.rows = rows;
+        }
+
+        public void close()
+            throws ApfloatRuntimeException
+        {
+            if ((this.mode & WRITE) != 0 && getData() != null)
+            {
+                setTransposedArray(this, this.startColumn, this.columns, this.rows);
+            }
+            super.close();
+        }
+
+        private static final long serialVersionUID = 2990517367865486151L;
+
+        private int mode,
+                    startColumn,
+                    columns,
+                    rows;
+    }
+
+    private class BlockIterator
+        extends AbstractIterator
+    {
+        public BlockIterator(int mode, long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            super(mode, startPosition, endPosition);
+            this.arrayAccess = null;
+            this.remaining = 0;
+        }
+
+        public void next()
+            throws IllegalStateException, ApfloatRuntimeException
+        {
+            checkLength();
+
+            assert (this.remaining > 0);
+
+            checkAvailable();
+
+            this.offset += getIncrement();
+            this.remaining--;
+
+            if (this.remaining == 0)
+            {
+                close();
+            }
+
+            super.next();
+        }
+
+        public int getInt()
+            throws IllegalStateException, ApfloatRuntimeException
+        {
+            checkGet();
+            checkAvailable();
+            return this.data[this.offset];
+        }
+
+        public void setInt(int value)
+            throws IllegalStateException, ApfloatRuntimeException
+        {
+            checkSet();
+            checkAvailable();
+            this.data[this.offset] = value;
+        }
+
+        public <T> T get(Class<T> type)
+            throws UnsupportedOperationException, IllegalStateException
+        {
+            if (!(type.equals(Integer.TYPE)))
+            {
+                throw new UnsupportedOperationException("Unsupported data type " + type.getCanonicalName() + ", the only supported type is int");
+            }
+            @SuppressWarnings("unchecked")
+            T value = (T) (Integer) getInt();
+            return value;
+        }
+
+        public <T> void set(Class<T> type, T value)
+            throws UnsupportedOperationException, IllegalArgumentException, IllegalStateException
+        {
+            if (!(type.equals(Integer.TYPE)))
+            {
+                throw new UnsupportedOperationException("Unsupported data type " + type.getCanonicalName() + ", the only supported type is int");
+            }
+            if (!(value instanceof Integer))
+            {
+                throw new IllegalArgumentException("Unsupported value type " + value.getClass().getCanonicalName() + ", the only supported type is Integer");
+            }
+            setInt((Integer) value);
+        }
+
+        /**
+         * Closes the iterator. This needs to be called only if the
+         * iterator is not iterated to the end.
+         */
+
+        public void close()
+            throws ApfloatRuntimeException
+        {
+            if (this.arrayAccess != null)
+            {
+                this.data = null;
+                this.arrayAccess.close();
+                this.arrayAccess = null;
+            }
+        }
+
+        private void checkAvailable()
+            throws ApfloatRuntimeException
+        {
+            if (this.arrayAccess == null)
+            {
+                boolean isForward = (getIncrement() > 0);
+                int length = (int) Math.min(getLength(), getBlockSize() / 4);
+                long offset = (isForward ? getPosition() : getPosition() - length + 1);
+
+                this.arrayAccess = getArray(getMode(), offset, length);
+                this.data = this.arrayAccess.getIntData();
+                this.offset = this.arrayAccess.getOffset() + (isForward ? 0 : length - 1);
+                this.remaining = length;
+            }
+        }
+
+        private static final long serialVersionUID = 4187202582650284101L;
+
+        private ArrayAccess arrayAccess;
+        private int[] data;
+        private int offset,
+                    remaining;
+    }
+
+    public Iterator iterator(int mode, long startPosition, long endPosition)
+        throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+    {
+        if ((mode & READ_WRITE) == 0)
+        {
+            throw new IllegalArgumentException("Illegal mode: " + mode);
+        }
+        return new BlockIterator(mode, startPosition, endPosition);
+    }
+
+    protected int getUnitSize()
+    {
+        return 4;
+    }
+
+    private static final long serialVersionUID = -1540087135754114721L;
+}
Index: src/main/java/org/apfloat/internal/IntElementaryModMath.java
===================================================================
--- src/main/java/org/apfloat/internal/IntElementaryModMath.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntElementaryModMath.java	(revision 0)
@@ -0,0 +1,141 @@
+package org.apfloat.internal;
+
+/**
+ * Elementary modulo arithmetic functions for <code>int</code> data.<p>
+ *
+ * Modular addition and subtraction are trivial, when the modulus is less
+ * than 2<sup>31</sup> and overflow can be detected easily.<p>
+ *
+ * Modular multiplication is more complicated, and since it is usually
+ * the single most time consuming operation in the whole program execution,
+ * the very core of the Number Theoretic Transform (NTT), it should be
+ * carefully optimized.<p>
+ *
+ * The obvious (but not very efficient) algorithm for multiplying two
+ * <code>int</code>s and taking the remainder is<p>
+ *
+ * <code>(int) ((long) a * b % modulus)</code><p>
+ *
+ * The first observation is that since the modulus is practically
+ * constant, it should be more efficient to calculate (once) the inverse
+ * of the modulus, and then subsequently multiply by the inverse modulus
+ * instead of dividing by the modulus.<p>
+ *
+ * The second observation is that to get the remainder of the division,
+ * we don't necessarily need the actual result of the division (we just
+ * want the remainder). So, we should discard the topmost 32 bits of the
+ * full 64-bit result whenever possible, to save a few operations.<p>
+ *
+ * The basic approach is to get some approximation of <code>a * b / modulus</code>.
+ * The approximation should be within +1 or -1 of the correct result. Then
+ * calculate <code>a * b - approximateDivision * modulus</code> to get
+ * the remainder. This calculation needs to use only the lowest 32 bits. As
+ * the modulus is less than 2<sup>31</sup> it is easy to detect the case
+ * when the approximate division was off by one (and the remainder is
+ * <code>&#177;modulus</code> off).<p>
+ *
+ * There are different algorithms to calculate the approximate division
+ * <code>a * b / modulus</code>. This implementation simply converts all
+ * the operands to <code>double</code> and performs the mulciplications.
+ * This requires that converting between integer types and floating point
+ * types is efficient. On some platforms this may not be true; in that
+ * case it can be more efficient to perform the multiplications using
+ * 64-bit integer arithmetic.<p>
+ *
+ * To simplify the operations, we calculate the inverse modulus as
+ * <code>1.0 / (modulus + 0.5)</code>. Since the modulus is assumed to be
+ * prime, and a <code>double</code> has more bits for precision than an
+ * <code>int</code>, the approximate result of <code>a * b / modulus</code>
+ * will always be either correct or one too small (but never one too big).
+ *
+ * @version 1.0.2
+ * @author Mikko Tommila
+ */
+
+public class IntElementaryModMath
+{
+    /**
+     * Default constructor.
+     */
+
+    public IntElementaryModMath()
+    {
+    }
+
+    /**
+     * Modular multiplication.
+     *
+     * @param a First operand.
+     * @param b Second operand.
+     *
+     * @return <code>a * b % modulus</code>
+     */
+
+    public final int modMultiply(int a, int b)
+    {
+        int r1 = a * b - (int) (this.inverseModulus * (double) a * (double) b) * this.modulus,
+            r2 = r1 - this.modulus;
+
+        return (r2 < 0 ? r1 : r2);
+    }
+
+    /**
+     * Modular addition.
+     *
+     * @param a First operand.
+     * @param b Second operand.
+     *
+     * @return <code>(a + b) % modulus</code>
+     */
+
+    public final int modAdd(int a, int b)
+    {
+        int r1 = a + b,
+            r2 = r1 - this.modulus;
+
+        return (r2 < 0 ? r1 : r2);
+    }
+
+    /**
+     * Modular subtraction. The result is always &gt;= 0.
+     *
+     * @param a First operand.
+     * @param b Second operand.
+     *
+     * @return <code>(a - b + modulus) % modulus</code>
+     */
+
+    public final int modSubtract(int a, int b)
+    {
+        int r1 = a - b,
+            r2 = r1 + this.modulus;
+
+        return (r1 < 0 ? r2 : r1);
+    }
+
+    /**
+     * Get the modulus.
+     *
+     * @return The modulus.
+     */
+
+    public final int getModulus()
+    {
+        return this.modulus;
+    }
+
+    /**
+     * Set the modulus.
+     *
+     * @param modulus The modulus.
+     */
+
+    public final void setModulus(int modulus)
+    {
+        this.inverseModulus = 1.0 / (modulus + 0.5);    // Round down
+        this.modulus = modulus;
+    }
+
+    private int modulus;
+    private double inverseModulus;
+}
Index: src/main/java/org/apfloat/internal/IntFactor3NTTStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/IntFactor3NTTStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntFactor3NTTStepStrategy.java	(revision 0)
@@ -0,0 +1,180 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.Factor3NTTStepStrategy;
+import org.apfloat.spi.DataStorage;
+import static org.apfloat.internal.IntModConstants.*;
+
+/**
+ * Steps for the factor-3 NTT.<p>
+ *
+ * The transform is done using a parallel algorithm, if the data fits in memory.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class IntFactor3NTTStepStrategy
+    extends IntModMath
+    implements Factor3NTTStepStrategy, Parallelizable
+{
+    // Runnable for transforming the columns in a factor-3 transform
+    private class ColumnTransformRunnable
+        implements Runnable
+    {
+        public ColumnTransformRunnable(DataStorage dataStorage0, DataStorage dataStorage1, DataStorage dataStorage2, long startColumn, long columns, int w, int ww, int w1, int w2, boolean isInverse)
+        {
+            this.dataStorage0 = dataStorage0;
+            this.dataStorage1 = dataStorage1;
+            this.dataStorage2 = dataStorage2;
+            this.startColumn = startColumn;
+            this.columns = columns;
+            this.w = w;
+            this.ww = ww;
+            this.w1 = w1;
+            this.w2 = w2;
+            this.isInverse = isInverse;
+        }
+
+        public void run()
+        {
+            int tmp1 = modPow(this.w, (int) this.startColumn),
+                    tmp2 = modPow(this.ww, (int) this.startColumn);
+
+            DataStorage.Iterator iterator0 = this.dataStorage0.iterator(DataStorage.READ_WRITE, this.startColumn, this.startColumn + this.columns),
+                                 iterator1 = this.dataStorage1.iterator(DataStorage.READ_WRITE, this.startColumn, this.startColumn + this.columns),
+                                 iterator2 = this.dataStorage2.iterator(DataStorage.READ_WRITE, this.startColumn, this.startColumn + this.columns);
+
+            for (long i = 0; i < this.columns; i++)
+            {
+                // 3-point WFTA on the corresponding array elements
+
+                int x0 = iterator0.getInt(),
+                        x1 = iterator1.getInt(),
+                        x2 = iterator2.getInt(),
+                        t;
+
+                if (this.isInverse)
+                {
+                    // Multiply before transform
+                    x1 = modMultiply(x1, tmp1);
+                    x2 = modMultiply(x2, tmp2);
+                }
+
+                // Transform columns
+                t = modAdd(x1, x2);
+                x2 = modSubtract(x1, x2);
+                x0 = modAdd(x0, t);
+                t = modMultiply(t, this.w1);
+                x2 = modMultiply(x2, this.w2);
+                t = modAdd(t, x0);
+                x1 = modAdd(t, x2);
+                x2 = modSubtract(t, x2);
+
+                if (!this.isInverse)
+                {
+                    // Multiply after transform
+                    x1 = modMultiply(x1, tmp1);
+                    x2 = modMultiply(x2, tmp2);
+                }
+
+                iterator0.setInt(x0);
+                iterator1.setInt(x1);
+                iterator2.setInt(x2);
+
+                iterator0.next();
+                iterator1.next();
+                iterator2.next();
+
+                tmp1 = modMultiply(tmp1, this.w);
+                tmp2 = modMultiply(tmp2, this.ww);
+            }
+        }
+
+        private DataStorage dataStorage0;
+        private DataStorage dataStorage1;
+        private DataStorage dataStorage2;
+        private long startColumn;
+        private long columns;
+        private int w;
+        private int ww;
+        private int w1;
+        private int w2;
+        private boolean isInverse;
+    }
+
+    /**
+     * Default constructor.
+     */
+
+    public IntFactor3NTTStepStrategy()
+    {
+    }
+
+    public void transformColumns(DataStorage dataStorage0, DataStorage dataStorage1, DataStorage dataStorage2, long startColumn, long columns, long power2length, long length, boolean isInverse, int modulus)
+        throws ApfloatRuntimeException
+    {
+        // Transform length is three times a power of two
+        assert (length == 3 * power2length);
+
+        ParallelRunnable parallelRunnable = createColumnTransformParallelRunnable(dataStorage0, dataStorage1, dataStorage2, startColumn, columns, power2length, length, isInverse, modulus);
+
+        if (columns <= Integer.MAX_VALUE &&                                     // Only if the size fits in an integer, but with memory arrays it should
+            dataStorage0.isCached() &&                                          // Only if the data storage supports efficient parallel random access
+            dataStorage1.isCached() &&
+            dataStorage2.isCached())
+        {
+            ParallelRunner.runParallel(parallelRunnable);
+        }
+        else
+        {
+            parallelRunnable.run();                                             // Just run in current thread without parallelization
+        }
+    }
+
+    public long getMaxTransformLength()
+    {
+        return MAX_TRANSFORM_LENGTH;
+    }
+
+    /**
+     * Create a ParallelRunnable object for transforming the columns of the matrix
+     * using a 3-point NTT transform.
+     *
+     * @param dataStorage0 The data of the first column.
+     * @param dataStorage1 The data of the second column.
+     * @param dataStorage2 The data of the third column.
+     * @param startColumn The starting element index in the data storages to transform.
+     * @param columns How many columns to transform.
+     * @param power2length Length of the column transform.
+     * @param length Length of total transform (three times the length of one column).
+     * @param isInverse <code>true</code> if an inverse transform is performed, <code>false</code> if a forward transform is performed.
+     * @param modulus Index of the modulus.
+     *
+     * @return A suitable object for performing the 3-point transforms in parallel.
+     */
+
+    protected ParallelRunnable createColumnTransformParallelRunnable(final DataStorage dataStorage0, final DataStorage dataStorage1, final DataStorage dataStorage2, final long startColumn, final long columns, long power2length, long length, final boolean isInverse, int modulus)
+    {
+        setModulus(MODULUS[modulus]);                                             // Modulus
+        final int w = (isInverse ?
+                           getInverseNthRoot(PRIMITIVE_ROOT[modulus], length) :
+                           getForwardNthRoot(PRIMITIVE_ROOT[modulus], length)),   // Forward/inverse n:th root
+                      w3 = modPow(w, (int) power2length),                     // Forward/inverse 3rd root
+                      ww = modMultiply(w, w),
+                      w1 = negate(modDivide((int) 3, (int) 2)),
+                      w2 = modAdd(w3, modDivide((int) 1, (int) 2));
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(columns)
+        {
+            public Runnable getRunnable(long strideStartColumn, long strideColumns)
+            {
+                return new ColumnTransformRunnable(dataStorage0, dataStorage1, dataStorage2, startColumn + strideStartColumn, strideColumns, w, ww, w1, w2, isInverse);
+            }
+        };
+        return parallelRunnable;
+    }
+}
Index: src/main/java/org/apfloat/internal/IntKaratsubaConvolutionStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/IntKaratsubaConvolutionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntKaratsubaConvolutionStrategy.java	(revision 0)
@@ -0,0 +1,242 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.DataStorage;
+
+/**
+ * Convolution strategy using the Karatsuba algorithm.
+ * The complexity of the algorithm is O(n<sup>log(3)/log(2)</sup>) as
+ * the operands are split to two and multiplied using three multiplications
+ * (and five additions / subtractions). This splitting is done recursively
+ * until some cut-off point where the basic O(n<sup>2</sup>) algorithm is
+ * applied. The Karatsuba algorithm is faster than the basic O(n<sup>2</sup>)
+ * multiplication algorithm for medium size numbers larger than some certain
+ * size. For very large numbers, the transform-based convolution algorithms
+ * are faster.
+ *
+ * @since 1.4
+ * @version 1.4
+ * @author Mikko Tommila
+ */
+
+public class IntKaratsubaConvolutionStrategy
+    extends IntMediumConvolutionStrategy
+{
+    /**
+     * Cut-off point for Karatsuba / basic convolution.<p>
+     *
+     * Convolutions where the shorter number is at most this long
+     * are calculated using the basic O(n<sup>2</sup>) algorithm
+     * i.e. <code>super.convolute()</code>.
+     */
+
+    public static final int CUTOFF_POINT = 15;
+
+    /**
+     * Creates a convolution strategy using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public IntKaratsubaConvolutionStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public DataStorage convolute(DataStorage x, DataStorage y, long resultSize)
+        throws ApfloatRuntimeException
+    {
+        if (Math.min(x.getSize(), y.getSize()) <= CUTOFF_POINT)
+        {
+            // The numbers are too short for Karatsuba to have any advantage, fall back to O(n^2) algorithm
+            return super.convolute(x, y, resultSize);
+        }
+
+        DataStorage shortStorage, longStorage;
+
+        if (x.getSize() > y.getSize())
+        {
+            shortStorage = y;
+            longStorage = x;
+        }
+        else
+        {
+            shortStorage = x;
+            longStorage = y;
+        }
+
+        long shortSize = shortStorage.getSize(),
+             longSize = longStorage.getSize(),
+             size = shortSize + longSize,
+             halfSize = longSize + 1 >> 1,      // Split point for recursion, round up
+             x1size = longSize - halfSize,
+             x2size = halfSize,
+             y1size = shortSize - halfSize;     // y2size = halfSize
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        DataStorage resultStorage = dataStorageBuilder.createDataStorage(size * 4);
+        resultStorage.setSize(size);
+
+        if (y1size <= 0)
+        {
+            // The shorter number is half of the longer number or less, use simplified algorithm
+            DataStorage.Iterator dst = resultStorage.iterator(DataStorage.WRITE, size, 0),
+                                 src1 = null;
+            int carry = 0;
+            long i = longSize,
+                 xSize;
+
+            // Calculate sub-results in blocks of size shortSize
+            do
+            {
+                xSize = Math.min(i, shortSize);
+                x = longStorage.subsequence(i - xSize, xSize);
+                y = shortStorage;
+
+                // Calculate sub-convolutions recursively
+                DataStorage a = convolute(x, y, xSize + shortSize);
+
+                assert (a.getSize() == xSize + shortSize);
+
+                // Add the sub-results together
+                DataStorage.Iterator src2 = a.iterator(DataStorage.READ, xSize + shortSize, 0);
+
+                carry = baseAdd(src1, src2, carry, dst, shortSize);
+
+                src1 = src2;
+                i -= shortSize;
+            } while (i > 0);
+
+            // Propagate carry through the last sub-result and store to result data
+            carry = baseAdd(src1, null, carry, dst, xSize);
+
+            assert (carry == 0);
+        }
+        else
+        {
+            // The numbers are roughly equal size (shorter is more than half of the longer), use Karatsuba algorithm
+            DataStorage x1 = longStorage.subsequence(0, x1size),
+                        x2 = longStorage.subsequence(x1size, x2size),
+                        y1 = shortStorage.subsequence(0, y1size),
+                        y2 = shortStorage.subsequence(y1size, halfSize);
+
+            // Calculate a = x1 + x2
+            DataStorage a = add(x1, x2);
+
+            // Calculate b = y1 + y2
+            DataStorage b = add(y1, y2);
+
+            // Calculate sub-convolutions recursively
+            DataStorage c = convolute(a, b, a.getSize() + b.getSize());
+            a = convolute(x1, y1, x1size + y1size);
+            b = convolute(x2, y2, 2 * halfSize);
+
+            // Calculate c = c - a - b
+            subtract(c, a);
+            subtract(c, b);
+
+            long cSize = c.getSize(),
+                 c1size = cSize - halfSize;
+
+            if (c1size > x1size + y1size)
+            {
+                // We know that the top one or two words of c are zero
+                // Omit them to avoid later having c1size > x1size + y1size
+                long zeros = c1size - x1size - y1size;
+                assert (isZero(c, 0));
+                assert (zeros == 1 || isZero(c, 1));
+                assert (zeros <= 2);
+                cSize -= zeros;
+                c1size -= zeros;
+                c = c.subsequence(zeros, cSize);
+            }
+
+            assert (a.getSize() == x1size + y1size);
+            assert (b.getSize() == 2 * halfSize);
+            assert (cSize >= 2 * halfSize && cSize <= 2 * halfSize + 2);
+            assert (c1size <= x1size + y1size);
+
+            // Add the sub-results a + b + c together
+            DataStorage.Iterator src1 = a.iterator(DataStorage.READ, x1size + y1size, 0),
+                                 src2 = b.iterator(DataStorage.READ, 2 * halfSize, 0),
+                                 src3 = c.iterator(DataStorage.READ, cSize, 0),
+                                 dst = resultStorage.iterator(DataStorage.WRITE, size, 0);
+
+            int carry = 0;
+            carry = baseAdd(src2, null, carry, dst, halfSize);
+            carry = baseAdd(src2, src3, carry, dst, halfSize);
+            carry = baseAdd(src1, src3, carry, dst, c1size);
+            carry = baseAdd(src1, null, carry, dst, x1size + y1size - c1size);
+
+            assert (carry == 0);
+        }
+
+        return resultStorage;
+    }
+
+    // Return x1 + x2
+    private DataStorage add(DataStorage x1, DataStorage x2)
+    {
+        long x1size = x1.getSize(),
+             x2size = x2.getSize();
+
+        assert (x1size <= x2size);
+
+        long size = x2size + 1;
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        DataStorage resultStorage = dataStorageBuilder.createDataStorage(size * 4);
+        resultStorage.setSize(size);
+
+        // Calculate x1 + x2
+        DataStorage.Iterator src1 = x1.iterator(DataStorage.READ, x1size, 0),
+                             src2 = x2.iterator(DataStorage.READ, x2size, 0),
+                             dst = resultStorage.iterator(DataStorage.WRITE, size, 0);
+
+        int carry = 0;
+        carry = baseAdd(src1, src2, carry, dst, x1size);
+        carry = baseAdd(src2, null, carry, dst, x2size - x1size);
+        baseAdd(null, null, carry, dst, 1);         // Set carry digit to the top word
+        if (carry == 0)
+        {
+            resultStorage = resultStorage.subsequence(1, size - 1);     // Omit zero top word
+        }
+
+        return resultStorage;
+    }
+
+    // x1 -= x2
+    private void subtract(DataStorage x1, DataStorage x2)
+    {
+        long x1size = x1.getSize(),
+             x2size = x2.getSize();
+
+        assert (x1size >= x2size);
+
+        DataStorage.Iterator src1 = x1.iterator(DataStorage.READ_WRITE, x1size, 0),
+                             src2 = x2.iterator(DataStorage.READ, x2size, 0),
+                             dst = src1;
+
+        int carry = 0;
+        carry = baseSubtract(src1, src2, carry, dst, x2size);
+        carry = baseSubtract(src1, null, carry, dst, x1size - x2size);
+
+        assert (carry == 0);
+    }
+
+    private boolean isZero(DataStorage x, long index)
+    {
+        DataStorage.Iterator i = x.iterator(DataStorage.READ, index, index + 1);
+
+        int data = i.getInt();
+        i.next();
+
+        return data == 0;
+    }
+
+    private static final long serialVersionUID = -4939884744147374897L;
+}
Index: src/main/java/org/apfloat/internal/IntMatrixBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/IntMatrixBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntMatrixBuilder.java	(revision 0)
@@ -0,0 +1,32 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.MatrixBuilder;
+import org.apfloat.spi.MatrixStrategy;
+
+/**
+ * Creates matrix operations objects, for the
+ * <code>int</code> type.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class IntMatrixBuilder
+    implements MatrixBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public IntMatrixBuilder()
+    {
+    }
+
+    public MatrixStrategy createMatrix()
+    {
+        return IntMatrixBuilder.matrixStrategy;
+    }
+
+    private static MatrixStrategy matrixStrategy = new IntMatrixStrategy();
+}
Index: src/main/java/org/apfloat/internal/IntMatrixStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/IntMatrixStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntMatrixStrategy.java	(revision 0)
@@ -0,0 +1,442 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.MatrixStrategy;
+import org.apfloat.spi.ArrayAccess;
+import org.apfloat.spi.Util;
+
+/**
+ * Optimized matrix transposition methods for the <code>int</code> type.
+ * The matrix transposition algorithm isn't parallelized.<p>
+ *
+ * While the matrix transposition algorithm could easily be parallelized,
+ * on an SMP machine it does not make any sense. If the matrix doesn't fit
+ * in any processor specific cache then the memory (or higher level
+ * shared cache) bandwidth becomes a bottleneck in the algorithm. Matrix
+ * transposition is in principle a very simple algorithm - it doesn't do
+ * anything else than move data from one place to another. If shared memory
+ * is the bottleneck, then the algorithm isn't any faster if the data is being
+ * moved around by one thread or by multiple threads in parallel.<p>
+ *
+ * If the data fits in a processor specific cache, then the algorithm could
+ * theoretically be made faster with parallelization. To make the parallelization
+ * effective however, the data would have to be set up in some kind of a NUMA
+ * way. For example, each processor core would hold an equal section of
+ * the data in the processor cache. Then the algorithm could be made faster
+ * as each processor core could quickly transpose blocks of data that are in the
+ * processor cache, and then exchange blocks with other processor cores via the
+ * slower higher level shared cache or main memory.<p>
+ *
+ * This approach doesn't work well in practice however, at least not in a Java
+ * program. The reason is that there are no guarantees where the data is when
+ * the algorithm starts (in which processor core caches), and further there are
+ * no guarantees of any processor affinity for the threads that are executing
+ * in parallel. Different processor cores could be executing the transposition
+ * of different sections of the data at any moment, depending on how the
+ * operating system (and the JVM) schedule thread execution. And more often
+ * than not, the operating system isn't smart enough to apply any such processor
+ * affinity for the threads.<p>
+ *
+ * An additional problem for any NUMA based attempt is that the data array would
+ * have to be aligned on a cache line (e.g. 64 or 128 bytes), to prevent
+ * cache contention at the edges of each data section. But a JVM makes no such
+ * guarantees about memory alignment. And since pointers do not exist in Java,
+ * manually aligning memory addresses isn't possible.<p>
+ *
+ * Considering all of the above, the parallel algorithm doesn't in practice work
+ * any faster than the single-thread algorithm, as the algorithm is bound by the
+ * memory bandwidth (or shared cache bandwidth). In some cases parallelization
+ * can even make the execution slower due to increased cache contention.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class IntMatrixStrategy
+    implements MatrixStrategy
+{
+    /**
+     * Default constructor.
+     */
+
+    public IntMatrixStrategy()
+    {
+    }
+
+    /**
+     * Transpose a n<sub>1</sub> x n<sub>2</sub> matrix.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two.
+     * Additionally, one of these must be true:<p>
+     *
+     * n<sub>1</sub> = n<sub>2</sub><br>
+     * n<sub>1</sub> = 2*n<sub>2</sub><br>
+     * n<sub>2</sub> = 2*n<sub>1</sub><br>
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be transposed.
+     * @param n1 Number of rows in the matrix.
+     * @param n2 Number of columns in the matrix.
+     */
+
+    public void transpose(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException
+    {
+        int[] data = arrayAccess.getIntData();
+        int offset = arrayAccess.getOffset();
+
+        if (n1 != (n1 & -n1) ||
+            n2 != (n2 & -n2) ||
+            n1 <= 0 || n2 <= 0)
+        {
+            throw new ApfloatInternalException("Matrix size must be a power of two, not " + n1 + " x " + n2);
+        }
+        if (n1 == n2)
+        {
+            // Simply transpose
+
+            transposeSquare(data, offset, n1, n1);
+        }
+        else if (n2 == 2 * n1)
+        {
+            // First transpose two n1 x n1 blocks
+            transposeSquare(data, offset, n1, n2);
+            transposeSquare(data, offset + n1, n1, n2);
+
+            // Then permute the rows to correct order
+            permuteToHalfWidth(data, offset, n1, n2);
+        }
+        else if (n1 == 2 * n2)
+        {
+            // First permute the rows to correct order
+            permuteToDoubleWidth(data, offset, n1, n2);
+
+            // Then transpose two n2 x n2 blocks
+            transposeSquare(data, offset, n2, n1);
+            transposeSquare(data, offset + n2, n2, n1);
+        }
+        else
+        {
+            throw new ApfloatInternalException("Must be n1 = n2, n1 = 2*n2 or n2 = 2*n1; matrix is " + n1 + " x " + n2);
+        }
+    }
+
+    /**
+     * Transpose a square n<sub>1</sub> x n<sub>1</sub> block of n<sub>1</sub> x n<sub>2</sub> matrix.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two,
+     * and n<sub>1</sub> &lt;= n<sub>2</sub>.
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be transposed.
+     * @param n1 Number of rows and columns in the block to be transposed.
+     * @param n2 Number of columns in the matrix.
+     */
+
+    public void transposeSquare(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException
+    {
+        transposeSquare(arrayAccess.getIntData(), arrayAccess.getOffset(), n1, n2);
+    }
+
+    /**
+     * Permute the rows of the n<sub>1</sub> x n<sub>2</sub> matrix so that it is shaped like a
+     * n<sub>1</sub>/2 x 2*n<sub>2</sub> matrix. Logically, the matrix is split in half, and the
+     * lower half is moved to the right side of the upper half.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two,
+     * and n<sub>1</sub> &gt;= 2.<p>
+     *
+     * E.g. if the matrix layout is originally as follows:
+     * <table style="width:100px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix before">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td>
+     *   </tr>
+     *   <tr>
+     *     <td>4</td><td>5</td><td>6</td><td>7</td>
+     *   </tr>
+     *   <tr>
+     *     <td>8</td><td>9</td><td>10</td><td>11</td>
+     *   </tr>
+     *   <tr>
+     *     <td>12</td><td>13</td><td>14</td><td>15</td>
+     *   </tr>
+     * </table>
+     * <p>
+     *
+     * Then after this method it is as follows:
+     * <table style="width:200px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix after">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td><td>8</td><td>9</td><td>10</td><td>11</td>
+     *   </tr>
+     *   <tr>
+     *     <td>4</td><td>5</td><td>6</td><td>7</td><td>12</td><td>13</td><td>14</td><td>15</td>
+     *   </tr>
+     * </table>
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be permuted.
+     * @param n1 Number of rows in the matrix.
+     * @param n2 Number of columns in the matrix.
+     *
+     * @since 1.7.0
+     */
+
+    public void permuteToDoubleWidth(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException
+    {
+        if (n1 != (n1 & -n1) ||
+            n2 != (n2 & -n2) ||
+            n1 <= 0 || n2 <= 0)
+        {
+            throw new ApfloatInternalException("Matrix size must be a power of two, not " + n1 + " x " + n2);
+        }
+        if (n1 < 2)
+        {
+            throw new ApfloatInternalException("Matrix height must be at least 2.");
+        }
+        permuteToDoubleWidth(arrayAccess.getIntData(), arrayAccess.getOffset(), n1, n2);
+    }
+
+    /**
+     * Permute the rows of the n<sub>1</sub> x n<sub>2</sub> matrix so that it is shaped like a
+     * 2*n<sub>1</sub> x n<sub>2</sub>/2 matrix. Logically, the matrix is split in half, and the
+     * right half is moved below the left half.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two.
+     *
+     * E.g. if the matrix layout is originally as follows:
+     * <table style="width:200px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix before">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td>
+     *   </tr>
+     *   <tr>
+     *     <td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td>
+     *   </tr>
+     * </table>
+     * <p>
+     *
+     * Then after this method it is as follows:
+     * <table style="width:100px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix after">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td>
+     *   </tr>
+     *   <tr>
+     *     <td>8</td><td>9</td><td>10</td><td>11</td>
+     *   </tr>
+     *   <tr>
+     *     <td>4</td><td>5</td><td>6</td><td>7</td>
+     *   </tr>
+     *   <tr>
+     *     <td>12</td><td>13</td><td>14</td><td>15</td>
+     *   </tr>
+     * </table>
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be permuted.
+     * @param n1 Number of rows in the matrix.
+     * @param n2 Number of columns in the matrix.
+     *
+     * @since 1.7.0
+     */
+
+    public void permuteToHalfWidth(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException
+    {
+        if (n1 != (n1 & -n1) ||
+            n2 != (n2 & -n2) ||
+            n1 <= 0 || n2 <= 0)
+        {
+            throw new ApfloatInternalException("Matrix size must be a power of two, not " + n1 + " x " + n2);
+        }
+        permuteToHalfWidth(arrayAccess.getIntData(), arrayAccess.getOffset(), n1, n2);
+    }
+
+    // Move a b x b block from source to dest
+    private static void moveBlock(int[] source, int sourceOffset, int sourceWidth, int[] dest, int destOffset, int destWidth, int b)
+    {
+        for (int i = 0; i < b; i++)
+        {
+            System.arraycopy(source, sourceOffset, dest, destOffset, b);
+
+            destOffset += destWidth;
+            sourceOffset += sourceWidth;
+        }
+    }
+
+    // Transpose two b x b blocks of matrix with specified width
+    // data based on offset1 is accessed in columns, data based on offset2 in rows
+    private static void transpose2blocks(int[] data, int offset1, int offset2, int width, int b)
+    {
+        for (int i = 0, position1 = offset2; i < b; i++, position1 += width)
+        {
+            for (int j = 0, position2 = offset1 + i; j < b; j++, position2 += width)
+            {
+                int tmp = data[position1 + j];
+                data[position1 + j] = data[position2];
+                data[position2] = tmp;
+            }
+        }
+    }
+
+    // Transpose a b x b block of matrix with specified width
+    private static void transposeBlock(int[] data, int offset, int width, int b)
+    {
+        for (int i = 0, position1 = offset; i < b; i++, position1 += width)
+        {
+            for (int j = i + 1, position2 = offset + j * width + i; j < b; j++, position2 += width)
+            {
+                int tmp = data[position1 + j];
+                data[position1 + j] = data[position2];
+                data[position2] = tmp;
+            }
+        }
+    }
+
+    // Transpose a square n1 x n1 block of n1 x n2 matrix in b x b blocks
+    private static void transposeSquare(int[] data, int offset, int n1, int n2)
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        int cacheBurstBlockSize = Util.round2down(ctx.getCacheBurst() / 8),   // Cache burst in ints
+            cacheBlockSize = Util.sqrt4down(ctx.getCacheL1Size() / 8),        // Transpose block size b that fits in processor L1 cache
+            cacheTreshold = Util.round2down(ctx.getCacheL2Size() / 8);        // Size of matrix that fits in L2 cache
+
+        if (n1 <= cacheBurstBlockSize || n1 <= cacheBlockSize)
+        {
+            // Whole matrix fits in L1 cache
+
+            transposeBlock(data, offset, n2, n1);
+        }
+        else if (n1 * n2 <= cacheTreshold)
+        {
+            // Whole matrix fits in L2 cache (but not in L1 cache)
+            // Sometimes the first algorithm (the block above) is faster, if your L2 cache is very fast
+
+            int b = cacheBurstBlockSize;
+
+            for (int i = 0, position1 = offset; i < n1; i += b, position1 += b * n2)
+            {
+                transposeBlock(data, position1 + i, n2, b);
+
+                for (int j = i + b, position2 = offset + j * n2 + i; j < n1; j += b, position2 += b * n2)
+                {
+                    transpose2blocks(data, position1 + j, position2, n2, b);
+                }
+            }
+        }
+        else
+        {
+            // Whole matrix doesn't fit in L2 cache
+            // This algorithm works fastest if L1 cache size is set correctly
+
+            int b = cacheBlockSize;
+
+            int[] tmp1 = new int[b * b],
+                      tmp2 = new int[b * b];
+
+            for (int i = 0, position1 = offset; i < n1; i += b, position1 += b * n2)
+            {
+                moveBlock(data, position1 + i, n2, tmp1, 0, b, b);
+                transposeBlock(tmp1, 0, b, b);
+                moveBlock(tmp1, 0, b, data, position1 + i, n2, b);
+
+                for (int j = i + b, position2 = offset + j * n2 + i; j < n1; j += b, position2 += b * n2)
+                {
+                    moveBlock(data, position1 + j, n2, tmp1, 0, b, b);
+                    transposeBlock(tmp1, 0, b, b);
+
+                    moveBlock(data, position2, n2, tmp2, 0, b, b);
+                    transposeBlock(tmp2, 0, b, b);
+
+                    moveBlock(tmp2, 0, b, data, position1 + j, n2, b);
+                    moveBlock(tmp1, 0, b, data, position2, n2, b);
+                }
+            }
+        }
+    }
+
+    // Permute the rows of matrix to correct order, to make the n1 x n2 matrix half as wide (2*n1 x n2/2)
+    private static void permuteToHalfWidth(int[] data, int offset, int n1, int n2)
+    {
+        if (n1 < 2)
+        {
+            return;
+        }
+
+        int twicen1 = 2 * n1;
+        int halfn2 = n2 / 2;
+        int[] tmp = new int[halfn2];
+        boolean[] isRowDone = new boolean[twicen1];
+
+        int j = 1;
+        do
+        {
+            int o = j,
+                m = j;
+
+            System.arraycopy(data, offset + halfn2 * m, tmp, 0, halfn2);
+
+            isRowDone[m] = true;
+
+            m = (m < n1 ? 2 * m : 2 * (m - n1) + 1);
+
+            while (m != j)
+            {
+                isRowDone[m] = true;
+
+                System.arraycopy(data, offset + halfn2 * m, data, offset + halfn2 * o, halfn2);
+
+                o = m;
+                m = (m < n1 ? 2 * m : 2 * (m - n1) + 1);
+            }
+
+            System.arraycopy(tmp, 0, data, offset + halfn2 * o, halfn2);
+
+            while (isRowDone[j])
+            {
+                j++;
+            }
+        } while (j < twicen1 - 1);
+    }
+
+    // Permute the rows of matrix to correct order, to make the n1 x n2 matrix twice as wide (n1/2 x 2*n2)
+    private static void permuteToDoubleWidth(int[] data, int offset, int n1, int n2)
+    {
+        if (n1 < 4)
+        {
+            return;
+        }
+
+        int halfn1 = n1 / 2;
+        int[] tmp = new int[n2];
+        boolean[] isRowDone = new boolean[n1];
+
+        int j = 1;
+        do
+        {
+            int o = j,
+                m = j;
+
+            System.arraycopy(data, offset + n2 * m, tmp, 0, n2);
+
+            isRowDone[m] = true;
+
+            m = ((m & 1) != 0 ? m / 2 + halfn1 : m / 2);
+
+            while (m != j)
+            {
+                isRowDone[m] = true;
+
+                System.arraycopy(data, offset + n2 * m, data, offset + n2 * o, n2);
+
+                o = m;
+                m = ((m & 1) != 0 ? m / 2 + halfn1 : m / 2);
+            }
+
+            System.arraycopy(tmp, 0, data, offset + n2 * o, n2);
+
+            while (isRowDone[j])
+            {
+                j++;
+            }
+        } while (j < n1 - 1);
+    }
+}
Index: src/main/java/org/apfloat/internal/IntMediumConvolutionStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/IntMediumConvolutionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntMediumConvolutionStrategy.java	(revision 0)
@@ -0,0 +1,125 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ConvolutionStrategy;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.DataStorage;
+
+/**
+ * Medium-length convolution strategy.
+ * Performs a simple O(n<sup>2</sup>) multiplication when the size of one operand is relatively short.
+ *
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class IntMediumConvolutionStrategy
+    extends IntBaseMath
+    implements ConvolutionStrategy
+{
+    // Implementation notes:
+    // - Assumes that the operands have been already truncated to match resultSize (the resultSize argument is ignored)
+    // - This class probably shouldn't be converted to a single class using generics because there is some performance impact
+
+    /**
+     * Creates a convolution strategy using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public IntMediumConvolutionStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public DataStorage convolute(DataStorage x, DataStorage y, long resultSize)
+        throws ApfloatRuntimeException
+    {
+        DataStorage shortStorage, longStorage;
+
+        if (x.getSize() > y.getSize())
+        {
+            shortStorage = y;
+            longStorage = x;
+        }
+        else
+        {
+            shortStorage = x;
+            longStorage = y;
+        }
+
+        long shortSize = shortStorage.getSize(),
+             longSize = longStorage.getSize(),
+             size = shortSize + longSize;
+
+        if (shortSize > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Too long shorter number, size = " + shortSize);
+        }
+
+        final int bufferSize = (int) shortSize;
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        DataStorage resultStorage = dataStorageBuilder.createDataStorage(size * 4);
+        resultStorage.setSize(size);
+
+        DataStorage.Iterator src = longStorage.iterator(DataStorage.READ, longSize, 0),
+                             dst = resultStorage.iterator(DataStorage.WRITE, size, 0),
+                             tmpDst = new DataStorage.Iterator()                        // Cyclic iterator
+                             {
+                                 public void next()
+                                 {
+                                     this.position++;
+                                     this.position = (this.position == bufferSize ? 0 : this.position);
+                                 }
+
+                                 public int getInt()
+                                 {
+                                     return this.buffer[this.position];
+                                 }
+
+                                 public void setInt(int value)
+                                 {
+                                     this.buffer[this.position] = value;
+                                 }
+
+                                 private static final long serialVersionUID = 1L;
+
+                                 private int[] buffer = new int[bufferSize];
+                                 private int position = 0;
+                             };
+
+        for (long i = 0; i < longSize; i++)
+        {
+            DataStorage.Iterator tmpSrc = shortStorage.iterator(DataStorage.READ, shortSize, 0);        // Sub-optimal: this could be cyclic also
+
+            int factor = src.getInt(),          // Get one word of source data
+                    carry = baseMultiplyAdd(tmpSrc, tmpDst, factor, 0, tmpDst, shortSize),
+                    result = tmpDst.getInt();       // Least significant word of the result
+
+            dst.setInt(result);     // Store one word of result
+
+            tmpDst.setInt(carry);   // Set carry from calculation as new last word in cyclic buffer
+
+            tmpDst.next();              // Cycle buffer; current first word becomes last
+            src.next();
+            dst.next();
+        }
+
+        // Exhaust last words from temporary cyclic buffer and store them to result data
+        for (int i = 0; i < bufferSize; i++)
+        {
+            int result = tmpDst.getInt();
+            dst.setInt(result);
+
+            tmpDst.next();
+            dst.next();
+        }
+
+        return resultStorage;
+    }
+
+    private static final long serialVersionUID = -1339358141859224649L;
+}
Index: src/main/java/org/apfloat/internal/IntMemoryArrayAccess.java
===================================================================
--- src/main/java/org/apfloat/internal/IntMemoryArrayAccess.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntMemoryArrayAccess.java	(revision 0)
@@ -0,0 +1,54 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Array access class based on a <code>int[]</code>.
+ *
+ * @version 1.6.3
+ * @author Mikko Tommila
+ */
+
+public class IntMemoryArrayAccess
+    extends ArrayAccess
+{
+    /**
+     * Create an array access.<p>
+     *
+     * @param data The underlying array.
+     * @param offset The offset of the access segment within the array.
+     * @param length The access segment.
+     */
+
+    public IntMemoryArrayAccess(int[] data, int offset, int length)
+    {
+        super(offset, length);
+        this.data = data;
+    }
+
+    public ArrayAccess subsequence(int offset, int length)
+    {
+        return new IntMemoryArrayAccess(this.data, getOffset() + offset, length);
+    }
+
+    public Object getData()
+    {
+        return this.data;
+    }
+
+    public int[] getIntData()
+    {
+        return this.data;
+    }
+
+    public void close()
+        throws ApfloatRuntimeException
+    {
+        this.data = null;       // Might have an impact on garbage collection
+    }
+
+    private static final long serialVersionUID = -1137159053668908693L;
+
+    private int[] data;
+}
Index: src/main/java/org/apfloat/internal/IntMemoryDataStorage.java
===================================================================
--- src/main/java/org/apfloat/internal/IntMemoryDataStorage.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntMemoryDataStorage.java	(revision 0)
@@ -0,0 +1,287 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Memory based data storage implementation for the <code>int</code>
+ * element type.
+ *
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class IntMemoryDataStorage
+    extends DataStorage
+{
+    /**
+     * Default constructor.
+     */
+
+    public IntMemoryDataStorage()
+    {
+        this.data = new int[0];
+    }
+
+    /**
+     * Subsequence constructor.
+     *
+     * @param intMemoryDataStorage The originating data storage.
+     * @param offset The subsequence starting position.
+     * @param length The subsequence length.
+     */
+
+    protected IntMemoryDataStorage(IntMemoryDataStorage intMemoryDataStorage, long offset, long length)
+    {
+        super(intMemoryDataStorage, offset, length);
+        this.data = intMemoryDataStorage.data;
+    }
+
+    public boolean isCached()
+    {
+        return true;
+    }
+
+    protected DataStorage implSubsequence(long offset, long length)
+        throws ApfloatRuntimeException
+    {
+        return new IntMemoryDataStorage(this, offset + getOffset(), length);
+    }
+
+    protected void implCopyFrom(DataStorage dataStorage, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (size > 0);
+        assert (!isReadOnly());
+        assert (!isSubsequenced());
+
+        if (size > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Size too big for memory array: " + size);
+        }
+
+        if (dataStorage == this)
+        {
+            setSize(size);
+            return;
+        }
+
+        this.data = new int[(int) size];
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        int readSize = (int) Math.min(size, dataStorage.getSize()),
+            position = 0,
+            bufferSize = ctx.getBlockSize() / 4;
+
+        while (readSize > 0)
+        {
+            int length = (int) Math.min(bufferSize, readSize);
+
+            ArrayAccess arrayAccess = dataStorage.getArray(READ, position, length);
+            System.arraycopy(arrayAccess.getIntData(), arrayAccess.getOffset(), this.data, position, length);
+            arrayAccess.close();
+
+            readSize -= length;
+            position += length;
+       }
+    }
+
+    protected long implGetSize()
+    {
+        return this.data.length;
+    }
+
+    protected void implSetSize(long size)
+        throws ApfloatRuntimeException
+    {
+        assert (size > 0);
+        assert (!isReadOnly());
+        assert (!isSubsequenced());
+
+        if (size == this.data.length)
+        {
+            return;
+        }
+
+        if (size > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Size too big for memory array: " + size);
+        }
+
+        int newSize = (int) size;
+
+        int[] newData = new int[newSize];
+        System.arraycopy(this.data, 0, newData, 0, Math.min(this.data.length, newSize));
+        this.data = newData;
+    }
+
+    protected ArrayAccess implGetArray(int mode, long offset, int length)
+        throws ApfloatRuntimeException
+    {
+        return new IntMemoryArrayAccess(this.data, (int) (offset + getOffset()), length);
+    }
+
+    protected ArrayAccess implGetArray(int mode, int startColumn, int columns, int rows)
+        throws ApfloatRuntimeException
+    {
+        throw new ApfloatInternalException("Method not implemented - would be sub-optimal; change the apfloat configuration settings");
+    }
+
+    protected ArrayAccess implGetTransposedArray(int mode, int startColumn, int columns, int rows)
+        throws ApfloatRuntimeException
+    {
+        throw new ApfloatInternalException("Method not implemented - would be sub-optimal; change the apfloat configuration settings");
+    }
+
+    private class ReadWriteIterator
+        extends AbstractIterator
+    {
+        public ReadWriteIterator(long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            this(READ_WRITE, startPosition, endPosition);
+        }
+
+        protected ReadWriteIterator(int mode, long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            super(mode, startPosition, endPosition);
+
+            this.data = IntMemoryDataStorage.this.data;
+
+            this.position = (int) getPosition() + (int) getOffset();
+            this.length = (int) getLength();
+        }
+
+        public boolean hasNext()
+        {
+            return (this.length > 0);
+        }
+
+        public void next()
+            throws IllegalStateException
+        {
+            checkLength();
+            this.position += getIncrement();
+            this.length--;
+        }
+
+        public int getInt()
+            throws IllegalStateException
+        {
+            checkLength();
+            return this.data[this.position];
+        }
+
+        public void setInt(int value)
+            throws IllegalStateException
+        {
+            checkLength();
+            this.data[this.position] = value;
+        }
+
+        public <T> T get(Class<T> type)
+            throws UnsupportedOperationException, IllegalStateException
+        {
+            if (!(type.equals(Integer.TYPE)))
+            {
+                throw new UnsupportedOperationException("Unsupported data type " + type.getCanonicalName() + ", the only supported type is int");
+            }
+            @SuppressWarnings("unchecked")
+            T value = (T) (Integer) getInt();
+            return value;
+        }
+
+        public <T> void set(Class<T> type, T value)
+            throws UnsupportedOperationException, IllegalArgumentException, IllegalStateException
+        {
+            if (!(type.equals(Integer.TYPE)))
+            {
+                throw new UnsupportedOperationException("Unsupported data type " + type.getCanonicalName() + ", the only supported type is int");
+            }
+            if (!(value instanceof Integer))
+            {
+                throw new IllegalArgumentException("Unsupported value type " + value.getClass().getCanonicalName() + ", the only supported type is Integer");
+            }
+            setInt((Integer) value);
+        }
+
+        protected void checkLength()
+            throws IllegalStateException
+        {
+            if (this.length == 0)
+            {
+                throw new IllegalStateException("At the end of iterator");
+            }
+        }
+
+        private static final long serialVersionUID = 6881950853858664947L;
+
+        private int[] data;
+        private int position,
+                    length;
+    }
+
+    private class ReadOnlyIterator
+        extends ReadWriteIterator
+    {
+        public ReadOnlyIterator(long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            super(READ, startPosition, endPosition);
+        }
+
+        public void setInt(int value)
+            throws IllegalStateException
+        {
+            throw new IllegalStateException("Not a writable iterator");
+        }
+
+        private static final long serialVersionUID = -6709295918596292159L;
+    }
+
+    private class WriteOnlyIterator
+        extends ReadWriteIterator
+    {
+        public WriteOnlyIterator(long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            super(WRITE, startPosition, endPosition);
+        }
+
+        public int getInt()
+            throws IllegalStateException
+        {
+            throw new IllegalStateException("Not a readable iterator");
+        }
+
+        private static final long serialVersionUID = 2753806793669098570L;
+    }
+
+    public Iterator iterator(int mode, long startPosition, long endPosition)
+        throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+    {
+        Iterator iterator;
+        switch (mode & READ_WRITE)
+        {
+            case READ:
+                iterator = new ReadOnlyIterator(startPosition, endPosition);
+                break;
+            case WRITE:
+                iterator = new WriteOnlyIterator(startPosition, endPosition);
+                break;
+            case READ_WRITE:
+                iterator = new ReadWriteIterator(startPosition, endPosition);
+                break;
+            default:
+                throw new IllegalArgumentException("Illegal mode: " + mode);
+        }
+        return iterator;
+    }
+
+    private static final long serialVersionUID = 4034264499027294039L;
+
+    private int[] data;
+}
Index: src/main/java/org/apfloat/internal/IntModConstants.java
===================================================================
--- src/main/java/org/apfloat/internal/IntModConstants.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntModConstants.java	(revision 0)
@@ -0,0 +1,42 @@
+package org.apfloat.internal;
+
+/**
+ * Constants needed for various modular arithmetic operations for the <code>int</code> type.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public interface IntModConstants
+{
+    /**
+     * Moduli to be used in number theoretic transforms.
+     * Allows transform lengths upto 3*2<sup>24</sup>.
+     */
+
+    public static final int MODULUS[] = { 2113929217, 2013265921, 1811939329 };
+
+    /**
+     * Primitive roots for the corresponding moduli.
+     */
+
+    public static final int PRIMITIVE_ROOT[] = { 5, 31, 13 };
+
+    /**
+     * Maximum transform length for the moduli.
+     */
+
+    public static final long MAX_TRANSFORM_LENGTH = 50331648;
+
+    /**
+     * Maximum bits in a power-of-two base that fits in an <code>int</code>.
+     */
+
+    public static final int MAX_POWER_OF_TWO_BITS = 31;
+
+    /**
+     * Maximum power-of-two base that fits in an <code>int</code>.
+     */
+
+    public static final int MAX_POWER_OF_TWO_BASE = 1 << MAX_POWER_OF_TWO_BITS;
+}
Index: src/main/java/org/apfloat/internal/IntModMath.java
===================================================================
--- src/main/java/org/apfloat/internal/IntModMath.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntModMath.java	(revision 0)
@@ -0,0 +1,159 @@
+package org.apfloat.internal;
+
+/**
+ * Modulo arithmetic functions for <code>int</code> data.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public class IntModMath
+    extends IntElementaryModMath
+{
+    /**
+     * Default constructor.
+     */
+
+    public IntModMath()
+    {
+    }
+
+    /**
+     * Create a table of powers of n:th root of unity.
+     *
+     * @param w The n:th root of unity modulo the current modulus.
+     * @param n The table length (= transform length).
+     *
+     * @return Table of <code>table[i]=w<sup>i</sup> mod m</code>, i = 0, ..., n-1.
+     */
+
+    public final int[] createWTable(int w, int n)
+    {
+        int[] wTable = new int[n];
+        int wTemp = 1;
+
+        for (int i = 0; i < n; i++)
+        {
+            wTable[i] = wTemp;
+            wTemp = modMultiply(wTemp, w);
+        }
+
+        return wTable;
+    }
+
+    /**
+     * Get forward n:th root of unity. This is <code>w</code>.<p>
+     *
+     * Assumes that the modulus is prime.
+     *
+     * @param primitiveRoot Primitive root of the modulus.
+     * @param n The transform length.
+     *
+     * @return Forward n:th root of unity.
+     */
+
+    public int getForwardNthRoot(int primitiveRoot, long n)
+    {
+        return modPow(primitiveRoot, getModulus() - 1 - (getModulus() - 1) / (int) n);
+    }
+
+    /**
+     * Get inverse n:th root of unity. This is <code>w<sup>-1</sup></code>.<p>
+     *
+     * Assumes that the modulus is prime.
+     *
+     * @param primitiveRoot Primitive root of the modulus.
+     * @param n The transform length.
+     *
+     * @return Inverse n:th root of unity.
+     */
+
+    public int getInverseNthRoot(int primitiveRoot, long n)
+    {
+        return modPow(primitiveRoot, (getModulus() - 1) / (int) n);
+    }
+
+    /**
+     * Modular inverse, that is <code>1 / a</code>. Assumes that the modulus is prime.
+     *
+     * @param a The operand.
+     *
+     * @return <code>a<sup>-1</sup> mod m</code>.
+     */
+
+    public final int modInverse(int a)
+    {
+        return modPow(a, getModulus() - 2);
+    }
+
+    /**
+     * Modular division. Assumes that the modulus is prime.
+     *
+     * @param a The dividend.
+     * @param b The divisor.
+     *
+     * @return <code>a*b<sup>-1</sup> mod m</code>.
+     */
+
+    public final int modDivide(int a, int b)
+    {
+        return modMultiply(a, modInverse(b));
+    }
+
+    /**
+     * Modular negation.
+     *
+     * @param a The argument.
+     *
+     * @return <code>-a mod m</code>.
+     */
+
+    public final int negate(int a)
+    {
+        return (a == 0 ? 0 : getModulus() - a);
+    }
+
+    /**
+     * Modular power. Assumes that the modulus is prime.
+     *
+     * @param a The base.
+     * @param n The exponent.
+     *
+     * @return <code>a<sup>n</sup> mod m</code>.
+     */
+
+    public final int modPow(int a, int n)
+    {
+        assert (a != 0 || n != 0);
+
+        if (n == 0)
+        {
+            return 1;
+        }
+        else if (n < 0)
+        {
+            return modPow(a, getModulus() - 1 + n);
+        }
+
+        long exponent = (long) n;
+
+        while ((exponent & 1) == 0)
+        {
+            a = modMultiply(a, a);
+            exponent >>= 1;
+        }
+
+        int r = a;
+
+        while ((exponent >>= 1) > 0)
+        {
+            a = modMultiply(a, a);
+            if ((exponent & 1) != 0)
+            {
+                r = modMultiply(r, a);
+            }
+        }
+
+        return r;
+    }
+}
Index: src/main/java/org/apfloat/internal/IntNTTBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/IntNTTBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntNTTBuilder.java	(revision 0)
@@ -0,0 +1,66 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.NTTStrategy;
+import org.apfloat.spi.NTTStepStrategy;
+import org.apfloat.spi.Factor3NTTStepStrategy;
+import org.apfloat.spi.NTTConvolutionStepStrategy;
+
+/**
+ * Creates Number Theoretic Transforms for the
+ * <code>int</code> type.
+ *
+ * @see IntTableFNTStrategy
+ * @see SixStepFNTStrategy
+ * @see TwoPassFNTStrategy
+ * @see Factor3NTTStrategy
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class IntNTTBuilder
+    extends AbstractNTTBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public IntNTTBuilder()
+    {
+    }
+
+    public NTTStepStrategy createNTTSteps()
+    {
+        return new IntNTTStepStrategy();
+    }
+
+    public NTTConvolutionStepStrategy createNTTConvolutionSteps()
+    {
+        return new IntNTTConvolutionStepStrategy();
+    }
+
+    public Factor3NTTStepStrategy createFactor3NTTSteps()
+    {
+        return new IntFactor3NTTStepStrategy();
+    }
+
+    protected NTTStrategy createSimpleFNTStrategy()
+    {
+        return new IntTableFNTStrategy();
+    }
+
+    protected NTTStrategy createSixStepFNTStrategy()
+    {
+        return new SixStepFNTStrategy();
+    }
+
+    protected NTTStrategy createTwoPassFNTStrategy()
+    {
+        return new TwoPassFNTStrategy();
+    }
+
+    protected NTTStrategy createFactor3NTTStrategy(NTTStrategy nttStrategy)
+    {
+        return new Factor3NTTStrategy(nttStrategy);
+    }
+}
Index: src/main/java/org/apfloat/internal/IntNTTConvolutionStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/IntNTTConvolutionStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntNTTConvolutionStepStrategy.java	(revision 0)
@@ -0,0 +1,186 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.NTTConvolutionStepStrategy;
+import org.apfloat.spi.DataStorage;
+import static org.apfloat.internal.IntModConstants.*;
+
+/**
+ * Steps of a three-NTT convolution for the <code>int</code> type.
+ * This class implements the details of the element-by-element multiplication
+ * and element-by-element squaring of the transformed elements.<p>
+ *
+ * The in-place multiplication and squaring of the data elements is done
+ * using a parallel algorithm, if the data fits in memory.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class IntNTTConvolutionStepStrategy
+    extends IntModMath
+    implements NTTConvolutionStepStrategy, Parallelizable
+{
+    // Runnable for multiplying elements in place
+    private class MultiplyInPlaceRunnable
+        implements Runnable
+    {
+        public MultiplyInPlaceRunnable(DataStorage sourceAndDestination, DataStorage source, long offset, long length)
+        {
+            this.sourceAndDestination = sourceAndDestination;
+            this.source = source;
+            this.offset = offset;
+            this.length = length;
+        }
+
+        public void run()
+        {
+            DataStorage.Iterator dest = this.sourceAndDestination.iterator(DataStorage.READ_WRITE, this.offset, this.offset + this.length),
+                                 src = this.source.iterator(DataStorage.READ, this.offset, this.offset + this.length);
+
+            while (this.length > 0)
+            {
+                dest.setInt(modMultiply(dest.getInt(), src.getInt()));
+
+                dest.next();
+                src.next();
+                this.length--;
+            }
+        }
+
+        private DataStorage sourceAndDestination,
+                            source;
+        private long offset,
+                     length;
+    }
+
+    // Runnable for squaring elements in place
+    private class SquareInPlaceRunnable
+        implements Runnable
+    {
+        public SquareInPlaceRunnable(DataStorage sourceAndDestination, long offset, long length)
+        {
+            this.sourceAndDestination = sourceAndDestination;
+            this.offset = offset;
+            this.length = length;
+        }
+
+        public void run()
+        {
+            DataStorage.Iterator iterator = this.sourceAndDestination.iterator(DataStorage.READ_WRITE, this.offset, this.offset + this.length);
+
+            while (this.length > 0)
+            {
+                int value = iterator.getInt();
+                iterator.setInt(modMultiply(value, value));
+
+                iterator.next();
+                this.length--;
+            }
+        }
+
+        private DataStorage sourceAndDestination;
+        private long offset,
+                     length;
+    }
+
+    /**
+     * Default constructor.
+     */
+
+    public IntNTTConvolutionStepStrategy()
+    {
+    }
+
+    public void multiplyInPlace(DataStorage sourceAndDestination, DataStorage source, int modulus)
+        throws ApfloatRuntimeException
+    {
+        assert (sourceAndDestination != source);
+
+        long size = sourceAndDestination.getSize();
+
+        ParallelRunnable parallelRunnable = createMultiplyInPlaceParallelRunnable(sourceAndDestination, source, modulus);
+
+        if (size <= Integer.MAX_VALUE &&                                        // Only if the size fits in an integer, but with memory arrays it should
+            sourceAndDestination.isCached() && source.isCached())               // Only if the data storage supports efficient parallel random access
+        {
+            ParallelRunner.runParallel(parallelRunnable);
+        }
+        else
+        {
+            parallelRunnable.run();                                             // Just run in current thread without parallelization
+        }
+    }
+
+    public void squareInPlace(DataStorage sourceAndDestination, int modulus)
+        throws ApfloatRuntimeException
+    {
+        long size = sourceAndDestination.getSize();
+
+        ParallelRunnable parallelRunnable = createSquareInPlaceParallelRunnable(sourceAndDestination, modulus);
+
+        if (size <= Integer.MAX_VALUE &&                                    // Only if the size fits in an integer, but with memory arrays it should
+            sourceAndDestination.isCached())                                // Only if the data storage supports efficient parallel random access
+        {
+            ParallelRunner.runParallel(parallelRunnable);
+        }
+        else
+        {
+            parallelRunnable.run();                                         // Just run in current thread without parallelization
+        }
+    }
+
+    /**
+     * Create a ParallelRunnable for multiplying the elements in-place.
+     *
+     * @param sourceAndDestination The first source data storage, which is also the destination.
+     * @param source The second source data storage.
+     * @param modulus Which modulus to use (0, 1, 2)
+     *
+     * @return An object suitable for multiplying the elements in parallel.
+     */
+
+    protected ParallelRunnable createMultiplyInPlaceParallelRunnable(final DataStorage sourceAndDestination, final DataStorage source, int modulus)
+    {
+        final long size = sourceAndDestination.getSize();
+
+        setModulus(MODULUS[modulus]);
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(size)
+        {
+            public Runnable getRunnable(long offset, long length)
+            {
+                return new MultiplyInPlaceRunnable(sourceAndDestination, source, offset, length);
+            }
+        };
+        return parallelRunnable;
+    }
+
+    /**
+     * Create a ParallelRunnable for squaring the elements in-place.
+     *
+     * @param sourceAndDestination The source data storage, which is also the destination.
+     * @param modulus Which modulus to use (0, 1, 2)
+     *
+     * @return An object suitable for squaring the elements in parallel.
+     */
+
+    protected ParallelRunnable createSquareInPlaceParallelRunnable(final DataStorage sourceAndDestination, int modulus)
+    {
+        final long size = sourceAndDestination.getSize();
+
+        setModulus(MODULUS[modulus]);
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(size)
+        {
+            public Runnable getRunnable(long offset, long length)
+            {
+                return new SquareInPlaceRunnable(sourceAndDestination, offset, length);
+            }
+        };
+        return parallelRunnable;
+    }
+}
Index: src/main/java/org/apfloat/internal/IntNTTStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/IntNTTStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntNTTStepStrategy.java	(revision 0)
@@ -0,0 +1,210 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ArrayAccess;
+import org.apfloat.spi.NTTStepStrategy;
+import static org.apfloat.internal.IntModConstants.*;
+
+/**
+ * Common methods to calculate Fast Number Theoretic Transforms
+ * in parallel using multiple threads.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class IntNTTStepStrategy
+    extends IntTableFNT
+    implements NTTStepStrategy, Parallelizable
+{
+    // Runnable for calculating the row transforms in parallel
+    private class TableFNTRunnable
+        implements Runnable
+    {
+        public TableFNTRunnable(int length, boolean isInverse, ArrayAccess arrayAccess, int[] wTable, int[] permutationTable)
+        {
+            this.length = length;               // Transform length
+            this.isInverse = isInverse;
+            this.arrayAccess = arrayAccess;
+            this.wTable = wTable;
+            this.permutationTable = permutationTable;
+        }
+
+        public void run()
+        {
+            int maxI = this.arrayAccess.getLength();
+
+            for (int i = 0; i < maxI; i += this.length)
+            {
+                ArrayAccess arrayAccess = this.arrayAccess.subsequence(i, this.length);
+
+                if (this.isInverse)
+                {
+                    inverseTableFNT(arrayAccess, this.wTable, this.permutationTable);
+                }
+                else
+                {
+                    tableFNT(arrayAccess, this.wTable, this.permutationTable);
+                }
+            }
+        }
+
+        private int length;
+        private boolean isInverse;
+        private ArrayAccess arrayAccess;
+        private int[] wTable;
+        private int[] permutationTable;
+    }
+
+    // Runnable for multiplying elements in the matrix
+    private class MultiplyRunnable
+        implements Runnable
+    {
+        public MultiplyRunnable(ArrayAccess arrayAccess, int startRow, int startColumn, int rows, int columns, int w, int scaleFactor)
+        {
+            this.arrayAccess = arrayAccess;
+            this.startRow = startRow;
+            this.startColumn = startColumn;
+            this.rows = rows;
+            this.columns = columns;
+            this.w = w;
+            this.scaleFactor = scaleFactor;
+        }
+
+        public void run()
+        {
+            int[] data = this.arrayAccess.getIntData();
+            int position = this.arrayAccess.getOffset();
+            int rowFactor = modPow(this.w, (int) this.startRow);
+            int columnFactor = modPow(this.w, (int) this.startColumn);
+            int rowStartFactor = modMultiply(this.scaleFactor, modPow(rowFactor, (int) this.startColumn));
+
+            for (int i = 0; i < this.rows; i++)
+            {
+                int factor = rowStartFactor;
+
+                for (int j = 0; j < this.columns; j++, position++)
+                {
+                    data[position] = modMultiply(data[position], factor);
+                    factor = modMultiply(factor, rowFactor);
+                }
+
+                rowFactor = modMultiply(rowFactor, this.w);
+                rowStartFactor = modMultiply(rowStartFactor, columnFactor);
+            }
+         }
+
+        private ArrayAccess arrayAccess;
+        private int startRow;
+        private int startColumn;
+        private int rows;
+        private int columns;
+        private int w;
+        private int scaleFactor;
+    }
+
+    /**
+     * Default constructor.
+     */
+
+    public IntNTTStepStrategy()
+    {
+    }
+
+    public void multiplyElements(ArrayAccess arrayAccess, int startRow, int startColumn, int rows, int columns, long length, long totalTransformLength, boolean isInverse, int modulus)
+        throws ApfloatRuntimeException
+    {
+        ParallelRunnable parallelRunnable = createMultiplyElementsParallelRunnable(arrayAccess, startRow, startColumn, rows, columns, length, totalTransformLength, isInverse, modulus);
+
+        ParallelRunner.runParallel(parallelRunnable);
+    }
+
+    public void transformRows(ArrayAccess arrayAccess, int length, int count, boolean isInverse, boolean permute, int modulus)
+        throws ApfloatRuntimeException
+    {
+        ParallelRunnable parallelRunnable = createTransformRowsParallelRunnable(arrayAccess, length, count, isInverse, permute, modulus);
+
+        ParallelRunner.runParallel(parallelRunnable);
+    }
+
+    public long getMaxTransformLength()
+    {
+        return MAX_TRANSFORM_LENGTH;
+    }
+
+    /**
+     * Create a ParallelRunnable object for multiplying the elements of the matrix.
+     *
+     * @param arrayAccess The memory array to multiply.
+     * @param startRow Which row in the whole matrix the starting row in the <code>arrayAccess</code> is.
+     * @param startColumn Which column in the whole matrix the starting column in the <code>arrayAccess</code> is.
+     * @param rows The number of rows in the <code>arrayAccess</code> to multiply.
+     * @param columns The number of columns in the matrix (= n<sub>2</sub>).
+     * @param length The length of data in the matrix being transformed.
+     * @param totalTransformLength The total transform length, for the scaling factor. Used only for the inverse case.
+     * @param isInverse If the multiplication is done for the inverse transform or not.
+     * @param modulus Index of the modulus.
+     *
+     * @return An object suitable for multiplying the elements of the matrix in parallel.
+     */
+
+    protected ParallelRunnable createMultiplyElementsParallelRunnable(final ArrayAccess arrayAccess, final int startRow, final int startColumn, final int rows, final int columns, long length, long totalTransformLength, boolean isInverse, int modulus)
+        throws ApfloatRuntimeException
+    {
+        setModulus(MODULUS[modulus]);
+        final int w = (isInverse ?
+                           getInverseNthRoot(PRIMITIVE_ROOT[modulus], length) :
+                           getForwardNthRoot(PRIMITIVE_ROOT[modulus], length));
+        final int scaleFactor = (isInverse ?
+                                     modDivide((int) 1, (int) totalTransformLength) :
+                                     (int) 1);
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(rows)
+        {
+            public Runnable getRunnable(int strideStartRow, int strideRows)
+            {
+                ArrayAccess subArrayAccess = arrayAccess.subsequence(strideStartRow * columns, strideRows * columns);
+                return new MultiplyRunnable(subArrayAccess, startRow + strideStartRow, startColumn, strideRows, columns, w, scaleFactor);
+            }
+        };
+
+        return parallelRunnable;
+    }
+
+    /**
+     * Create a ParallelRunnable object for transforming the rows of the matrix.
+     *
+     * @param arrayAccess The memory array to split to rows and to transform.
+     * @param length Length of one transform (one row).
+     * @param count Number of rows.
+     * @param isInverse <code>true</code> if an inverse transform is performed, <code>false</code> if a forward transform is performed.
+     * @param permute If permutation should be done.
+     * @param modulus Index of the modulus.
+     *
+     * @return An object suitable for transforming the rows of the matrix in parallel.
+     */
+
+    protected ParallelRunnable createTransformRowsParallelRunnable(final ArrayAccess arrayAccess, final int length, final int count, final boolean isInverse, boolean permute, int modulus)
+        throws ApfloatRuntimeException
+    {
+        setModulus(MODULUS[modulus]);
+        final int[] wTable = (isInverse ?
+                                  IntWTables.getInverseWTable(modulus, length) :
+                                  IntWTables.getWTable(modulus, length));
+        final int[] permutationTable = (permute ? Scramble.createScrambleTable(length) : null);
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(count)
+        {
+            public Runnable getRunnable(int startIndex, int strideCount)
+            {
+                ArrayAccess subArrayAccess = arrayAccess.subsequence(startIndex * length, strideCount * length);
+                return new TableFNTRunnable(length, isInverse, subArrayAccess, wTable, permutationTable);
+            }
+        };
+
+        return parallelRunnable;
+    }
+}
Index: src/main/java/org/apfloat/internal/IntRadixConstants.java
===================================================================
--- src/main/java/org/apfloat/internal/IntRadixConstants.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntRadixConstants.java	(revision 0)
@@ -0,0 +1,36 @@
+package org.apfloat.internal;
+
+/**
+ * Constants related to different radixes for the <code>int</code> data type.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public interface IntRadixConstants
+{
+    /**
+     * Bases for radixes 2, ..., 36. The base is the radix to the maximum power
+     * so that the base is less than all moduli used.
+     */
+
+    public static final int BASE[] = { (int) -1L, (int) -1L, (int) 1073741824L, (int) 1162261467L, (int) 1073741824L, (int) 1220703125L, (int) 362797056L, (int) 282475249L, (int) 1073741824L, (int) 387420489L, (int) 1000000000L, (int) 214358881L, (int) 429981696L, (int) 815730721L, (int) 1475789056L, (int) 170859375L, (int) 268435456L, (int) 410338673L, (int) 612220032L, (int) 893871739L, (int) 1280000000L, (int) 1801088541L, (int) 113379904L, (int) 148035889L, (int) 191102976L, (int) 244140625L, (int) 308915776L, (int) 387420489L, (int) 481890304L, (int) 594823321L, (int) 729000000L, (int) 887503681L, (int) 1073741824L, (int) 1291467969L, (int) 1544804416L, (int) 52521875L, (int) 60466176L };
+
+    /**
+     * The power of the radix in each base.
+     */
+
+    public static final int BASE_DIGITS[] = { -1, -1, 30, 19, 15, 13, 11, 10, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5 };
+
+    /**
+     * The minimum number in each radix to have the specified amount of digits.
+     */
+
+    public static final int MINIMUM_FOR_DIGITS[][] = { null, null, { (int) 1L, (int) 2L, (int) 4L, (int) 8L, (int) 16L, (int) 32L, (int) 64L, (int) 128L, (int) 256L, (int) 512L, (int) 1024L, (int) 2048L, (int) 4096L, (int) 8192L, (int) 16384L, (int) 32768L, (int) 65536L, (int) 131072L, (int) 262144L, (int) 524288L, (int) 1048576L, (int) 2097152L, (int) 4194304L, (int) 8388608L, (int) 16777216L, (int) 33554432L, (int) 67108864L, (int) 134217728L, (int) 268435456L, (int) 536870912L }, { (int) 1L, (int) 3L, (int) 9L, (int) 27L, (int) 81L, (int) 243L, (int) 729L, (int) 2187L, (int) 6561L, (int) 19683L, (int) 59049L, (int) 177147L, (int) 531441L, (int) 1594323L, (int) 4782969L, (int) 14348907L, (int) 43046721L, (int) 129140163L, (int) 387420489L }, { (int) 1L, (int) 4L, (int) 16L, (int) 64L, (int) 256L, (int) 1024L, (int) 4096L, (int) 16384L, (int) 65536L, (int) 262144L, (int) 1048576L, (int) 4194304L, (int) 16777216L, (int) 67108864L, (int) 268435456L }, { (int) 1L, (int) 5L, (int) 25L, (int) 125L, (int) 625L, (int) 3125L, (int) 15625L, (int) 78125L, (int) 390625L, (int) 1953125L, (int) 9765625L, (int) 48828125L, (int) 244140625L }, { (int) 1L, (int) 6L, (int) 36L, (int) 216L, (int) 1296L, (int) 7776L, (int) 46656L, (int) 279936L, (int) 1679616L, (int) 10077696L, (int) 60466176L }, { (int) 1L, (int) 7L, (int) 49L, (int) 343L, (int) 2401L, (int) 16807L, (int) 117649L, (int) 823543L, (int) 5764801L, (int) 40353607L }, { (int) 1L, (int) 8L, (int) 64L, (int) 512L, (int) 4096L, (int) 32768L, (int) 262144L, (int) 2097152L, (int) 16777216L, (int) 134217728L }, { (int) 1L, (int) 9L, (int) 81L, (int) 729L, (int) 6561L, (int) 59049L, (int) 531441L, (int) 4782969L, (int) 43046721L }, { (int) 1L, (int) 10L, (int) 100L, (int) 1000L, (int) 10000L, (int) 100000L, (int) 1000000L, (int) 10000000L, (int) 100000000L }, { (int) 1L, (int) 11L, (int) 121L, (int) 1331L, (int) 14641L, (int) 161051L, (int) 1771561L, (int) 19487171L }, { (int) 1L, (int) 12L, (int) 144L, (int) 1728L, (int) 20736L, (int) 248832L, (int) 2985984L, (int) 35831808L }, { (int) 1L, (int) 13L, (int) 169L, (int) 2197L, (int) 28561L, (int) 371293L, (int) 4826809L, (int) 62748517L }, { (int) 1L, (int) 14L, (int) 196L, (int) 2744L, (int) 38416L, (int) 537824L, (int) 7529536L, (int) 105413504L }, { (int) 1L, (int) 15L, (int) 225L, (int) 3375L, (int) 50625L, (int) 759375L, (int) 11390625L }, { (int) 1L, (int) 16L, (int) 256L, (int) 4096L, (int) 65536L, (int) 1048576L, (int) 16777216L }, { (int) 1L, (int) 17L, (int) 289L, (int) 4913L, (int) 83521L, (int) 1419857L, (int) 24137569L }, { (int) 1L, (int) 18L, (int) 324L, (int) 5832L, (int) 104976L, (int) 1889568L, (int) 34012224L }, { (int) 1L, (int) 19L, (int) 361L, (int) 6859L, (int) 130321L, (int) 2476099L, (int) 47045881L }, { (int) 1L, (int) 20L, (int) 400L, (int) 8000L, (int) 160000L, (int) 3200000L, (int) 64000000L }, { (int) 1L, (int) 21L, (int) 441L, (int) 9261L, (int) 194481L, (int) 4084101L, (int) 85766121L }, { (int) 1L, (int) 22L, (int) 484L, (int) 10648L, (int) 234256L, (int) 5153632L }, { (int) 1L, (int) 23L, (int) 529L, (int) 12167L, (int) 279841L, (int) 6436343L }, { (int) 1L, (int) 24L, (int) 576L, (int) 13824L, (int) 331776L, (int) 7962624L }, { (int) 1L, (int) 25L, (int) 625L, (int) 15625L, (int) 390625L, (int) 9765625L }, { (int) 1L, (int) 26L, (int) 676L, (int) 17576L, (int) 456976L, (int) 11881376L }, { (int) 1L, (int) 27L, (int) 729L, (int) 19683L, (int) 531441L, (int) 14348907L }, { (int) 1L, (int) 28L, (int) 784L, (int) 21952L, (int) 614656L, (int) 17210368L }, { (int) 1L, (int) 29L, (int) 841L, (int) 24389L, (int) 707281L, (int) 20511149L }, { (int) 1L, (int) 30L, (int) 900L, (int) 27000L, (int) 810000L, (int) 24300000L }, { (int) 1L, (int) 31L, (int) 961L, (int) 29791L, (int) 923521L, (int) 28629151L }, { (int) 1L, (int) 32L, (int) 1024L, (int) 32768L, (int) 1048576L, (int) 33554432L }, { (int) 1L, (int) 33L, (int) 1089L, (int) 35937L, (int) 1185921L, (int) 39135393L }, { (int) 1L, (int) 34L, (int) 1156L, (int) 39304L, (int) 1336336L, (int) 45435424L }, { (int) 1L, (int) 35L, (int) 1225L, (int) 42875L, (int) 1500625L }, { (int) 1L, (int) 36L, (int) 1296L, (int) 46656L, (int) 1679616L } };
+
+    /**
+     * Maximum allowed exponent for each radix.
+     */
+
+    public static final long MAX_EXPONENT[] = { -1L, -1L, 307445734561825854L, 485440633518672404L, 614891469123651714L, 709490156681136594L, 838488366986797794L, 922337203685477574L, 922337203685477574L, 1024819115206086194L, 1024819115206086194L, 1152921504606846969L, 1152921504606846969L, 1152921504606846969L, 1152921504606846969L, 1317624576693539395L, 1317624576693539395L, 1317624576693539395L, 1317624576693539395L, 1317624576693539395L, 1317624576693539395L, 1317624576693539395L, 1537228672809129295L, 1537228672809129295L, 1537228672809129295L, 1537228672809129295L, 1537228672809129295L, 1537228672809129295L, 1537228672809129295L, 1537228672809129295L, 1537228672809129295L, 1537228672809129295L, 1537228672809129295L, 1537228672809129295L, 1537228672809129295L, 1844674407370955155L, 1844674407370955155L };
+}
Index: src/main/java/org/apfloat/internal/IntScramble.java
===================================================================
--- src/main/java/org/apfloat/internal/IntScramble.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntScramble.java	(revision 0)
@@ -0,0 +1,38 @@
+package org.apfloat.internal;
+
+/**
+ * Functions to perform bit-reverse ordering of <code>int</code> data.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public class IntScramble
+{
+    private IntScramble()
+    {
+    }
+
+    /**
+     * Permute the data in the table to bit-reversed order.<p>
+     *
+     * The permutation table argument should contain pairs of indexes
+     * that indicate array elements whose contents are swapped.
+     *
+     * @param data The array to permute.
+     * @param offset The offset within the array to permute.
+     * @param permutationTable Table of indexes indicating, which elements in the <code>data</code> are to be swapped.
+     */
+
+    public static void scramble(int[] data, int offset, int[] permutationTable)
+    {
+        for (int k = 0; k < permutationTable.length; k += 2)
+        {
+            int i = offset + permutationTable[k],
+                j = offset + permutationTable[k + 1];
+            int tmp = data[i];
+            data[i] = data[j];
+            data[j] = tmp;
+        }
+    }
+}
Index: src/main/java/org/apfloat/internal/IntShortConvolutionStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/IntShortConvolutionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntShortConvolutionStrategy.java	(revision 0)
@@ -0,0 +1,77 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ConvolutionStrategy;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Short convolution strategy.
+ * Performs a simple multiplication when the size of one operand is 1.
+ *
+ * @version 1.1
+ * @author Mikko Tommila
+ */
+
+public class IntShortConvolutionStrategy
+    extends IntBaseMath
+    implements ConvolutionStrategy
+{
+    // Implementation notes:
+    // - Assumes that the operands have been already truncated to match resultSize (the resultSize argument is ignored)
+    // - This class shouldn't be converted to a single class using generics because the performance impact is noticeable
+
+    /**
+     * Creates a convolution strategy using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public IntShortConvolutionStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public DataStorage convolute(DataStorage x, DataStorage y, long resultSize)
+        throws ApfloatRuntimeException
+    {
+        DataStorage shortStorage, longStorage, resultStorage;
+
+        if (x.getSize() > 1)
+        {
+            shortStorage = y;
+            longStorage = x;
+        }
+        else
+        {
+            shortStorage = x;
+            longStorage = y;
+        }
+
+        assert (shortStorage.getSize() == 1);
+
+        long size = longStorage.getSize() + 1;
+
+        ArrayAccess arrayAccess = shortStorage.getArray(DataStorage.READ, 0, 1);
+        int factor = arrayAccess.getIntData()[arrayAccess.getOffset()];
+        arrayAccess.close();
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        resultStorage = dataStorageBuilder.createDataStorage(size * 4);
+        resultStorage.setSize(size);
+
+        DataStorage.Iterator src = longStorage.iterator(DataStorage.READ, size - 1, 0),
+                             dst = resultStorage.iterator(DataStorage.WRITE, size, 0);
+
+        int carry = baseMultiplyAdd(src, null, factor, 0, dst, size - 1);
+        dst.setInt(carry);
+        dst.close();
+
+        return resultStorage;
+    }
+
+    private static final long serialVersionUID = 7238463434254768541L;
+}
Index: src/main/java/org/apfloat/internal/IntTableFNT.java
===================================================================
--- src/main/java/org/apfloat/internal/IntTableFNT.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntTableFNT.java	(revision 0)
@@ -0,0 +1,159 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Fast Number Theoretic Transform that uses lookup tables
+ * for powers of n:th root of unity and permutation indexes.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class IntTableFNT
+    extends IntModMath
+{
+    /**
+     * Default constructor.
+     */
+
+    public IntTableFNT()
+    {
+    }
+
+    /**
+     * Forward (Sande-Tukey) fast Number Theoretic Transform.
+     * Data length must be a power of two.
+     *
+     * @param arrayAccess The data array to transform.
+     * @param wTable Table of powers of n:th root of unity <code>w</code> modulo the current modulus.
+     * @param permutationTable Table of permutation indexes, or <code>null</code> if the data should not be permuted.
+     */
+
+    public void tableFNT(ArrayAccess arrayAccess, int[] wTable, int[] permutationTable)
+        throws ApfloatRuntimeException
+    {
+        int nn, offset, istep, mmax, r;
+        int[] data;
+
+        data   = arrayAccess.getIntData();
+        offset = arrayAccess.getOffset();
+        nn     = arrayAccess.getLength();
+
+        assert (nn == (nn & -nn));
+
+        if (nn < 2)
+        {
+            return;
+        }
+
+        r = 1;
+        mmax = nn >> 1;
+        while (mmax > 0)
+        {
+            istep = mmax << 1;
+
+            // Optimize first step when wr = 1
+
+            for (int i = offset; i < offset + nn; i += istep)
+            {
+                int j = i + mmax;
+                int a = data[i];
+                int b = data[j];
+                data[i] = modAdd(a, b);
+                data[j] = modSubtract(a, b);
+            }
+
+            int t = r;
+
+            for (int m = 1; m < mmax; m++)
+            {
+                for (int i = offset + m; i < offset + nn; i += istep)
+                {
+                    int j = i + mmax;
+                    int a = data[i];
+                    int b = data[j];
+                    data[i] = modAdd(a, b);
+                    data[j] = modMultiply(wTable[t], modSubtract(a, b));
+                }
+                t += r;
+            }
+            r <<= 1;
+            mmax >>= 1;
+        }
+
+        if (permutationTable != null)
+        {
+            IntScramble.scramble(data, offset, permutationTable);
+        }
+    }
+
+    /**
+     * Inverse (Cooley-Tukey) fast Number Theoretic Transform.
+     * Data length must be a power of two.
+     *
+     * @param arrayAccess The data array to transform.
+     * @param wTable Table of powers of n:th root of unity <code>w</code> modulo the current modulus.
+     * @param permutationTable Table of permutation indexes, or <code>null</code> if the data should not be permuted.
+     */
+
+    public void inverseTableFNT(ArrayAccess arrayAccess, int[] wTable, int[] permutationTable)
+        throws ApfloatRuntimeException
+    {
+        int nn, offset, istep, mmax, r;
+        int[] data;
+
+        data   = arrayAccess.getIntData();
+        offset = arrayAccess.getOffset();
+        nn     = arrayAccess.getLength();
+
+        assert (nn == (nn & -nn));
+
+        if (nn < 2)
+        {
+            return;
+        }
+
+        if (permutationTable != null)
+        {
+            IntScramble.scramble(data, offset, permutationTable);
+        }
+
+        r = nn;
+        mmax = 1;
+        while (nn > mmax)
+        {
+            istep = mmax << 1;
+            r >>= 1;
+
+            // Optimize first step when w = 1
+
+            for (int i = offset; i < offset + nn; i += istep)
+            {
+                int j = i + mmax;
+                int wTemp = data[j];
+                data[j] = modSubtract(data[i], wTemp);
+                data[i] = modAdd(data[i], wTemp);
+            }
+
+            int t = r;
+
+            for (int m = 1; m < mmax; m++)
+            {
+                for (int i = offset + m; i < offset + nn; i += istep)
+                {
+                    int j = i + mmax;
+                    int wTemp = modMultiply(wTable[t], data[j]);
+                    data[j] = modSubtract(data[i], wTemp);
+                    data[i] = modAdd(data[i], wTemp);
+                }
+                t += r;
+            }
+            mmax = istep;
+        }
+    }
+}
Index: src/main/java/org/apfloat/internal/IntTableFNTStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/IntTableFNTStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntTableFNTStrategy.java	(revision 0)
@@ -0,0 +1,100 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.NTTStrategy;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+import org.apfloat.spi.Util;
+import static org.apfloat.internal.IntModConstants.*;
+
+/**
+ * Fast Number Theoretic Transform strategy that uses lookup tables
+ * for powers of n:th root of unity and permutation indexes.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class IntTableFNTStrategy
+    extends IntTableFNT
+    implements NTTStrategy
+{
+    /**
+     * Default constructor.
+     */
+
+    public IntTableFNTStrategy()
+    {
+    }
+
+    public void transform(DataStorage dataStorage, int modulus)
+        throws ApfloatRuntimeException
+    {
+        long length = dataStorage.getSize();            // Transform length n
+
+        if (length > MAX_TRANSFORM_LENGTH)
+        {
+            throw new TransformLengthExceededException("Maximum transform length exceeded: " + length + " > " + MAX_TRANSFORM_LENGTH);
+        }
+        else if (length > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Maximum array length exceeded: " + length);
+        }
+
+        setModulus(MODULUS[modulus]);                                       // Modulus
+        int[] wTable = IntWTables.getWTable(modulus, (int) length);
+
+        ArrayAccess arrayAccess = dataStorage.getArray(DataStorage.READ_WRITE, 0, (int) length);
+
+        tableFNT(arrayAccess, wTable, null);
+
+        arrayAccess.close();
+    }
+
+    public void inverseTransform(DataStorage dataStorage, int modulus, long totalTransformLength)
+        throws ApfloatRuntimeException
+    {
+        long length = dataStorage.getSize();            // Transform length n
+
+        if (Math.max(length, totalTransformLength) > MAX_TRANSFORM_LENGTH)
+        {
+            throw new TransformLengthExceededException("Maximum transform length exceeded: " + Math.max(length, totalTransformLength) + " > " + MAX_TRANSFORM_LENGTH);
+        }
+        else if (length > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Maximum array length exceeded: " + length);
+        }
+
+        setModulus(MODULUS[modulus]);                                       // Modulus
+        int[] wTable = IntWTables.getInverseWTable(modulus, (int) length);
+
+        ArrayAccess arrayAccess = dataStorage.getArray(DataStorage.READ_WRITE, 0, (int) length);
+
+        inverseTableFNT(arrayAccess, wTable, null);
+
+        divideElements(arrayAccess, (int) totalTransformLength);
+
+        arrayAccess.close();
+    }
+
+    public long getTransformLength(long size)
+    {
+        return Util.round2up(size);
+    }
+
+    private void divideElements(ArrayAccess arrayAccess, int divisor)
+        throws ApfloatRuntimeException
+    {
+        int inverseFactor = modDivide((int) 1, divisor);
+        int[] data = arrayAccess.getIntData();
+        int length = arrayAccess.getLength(),
+            offset = arrayAccess.getOffset();
+
+        for (int i = 0; i < length; i++)
+        {
+            data[i + offset] = modMultiply(data[i + offset], inverseFactor);
+        }
+    }
+}
Index: src/main/java/org/apfloat/internal/IntWTables.java
===================================================================
--- src/main/java/org/apfloat/internal/IntWTables.java	(revision 0)
+++ src/main/java/org/apfloat/internal/IntWTables.java	(revision 0)
@@ -0,0 +1,86 @@
+package org.apfloat.internal;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.ConcurrentMap;
+
+import org.apfloat.internal.IntModMath;
+import static org.apfloat.internal.IntModConstants.*;
+
+/**
+ * Helper class for generating and caching tables of powers of the n:th root of unity.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class IntWTables
+    extends IntModMath
+{
+    private IntWTables()
+    {
+        // Default constructor
+    }
+
+    /**
+     * Get a table of powers of n:th root of unity.
+     *
+     * @param modulus The index of the modulus to be used.
+     * @param length The length of the table to be returned, i.e. n.
+     *
+     * @return The table of powers of the n:th root of unity.
+     */
+
+    public static int[] getWTable(int modulus, int length)
+    {
+        return getWTable(modulus, length, false);
+    }
+
+    /**
+     * Get a table of inverses of powers of n:th root of unity.
+     *
+     * @param modulus The index of the modulus to be used.
+     * @param length The length of the table to be returned, i.e. n.
+     *
+     * @return The table of inverses of powers of the n:th root of unity.
+     */
+
+    public static int[] getInverseWTable(int modulus, int length)
+    {
+        return getWTable(modulus, length, true);
+    }
+
+    private static int[] getWTable(int modulus, int length, boolean isInverse)
+    {
+        List<Integer> key = Arrays.asList(isInverse ? 1 : 0, modulus, length);
+        int[] wTable = IntWTables.cache.get(key);
+        // Do not synchronize, multiple threads may do this at the same time, but only one gets to put the value in the cache
+        if (wTable == null)
+        {
+            IntModMath instance = getInstance(modulus);
+            int w = (isInverse ?
+                         instance.getInverseNthRoot(PRIMITIVE_ROOT[modulus], length) :  // Inverse n:th root
+                         instance.getForwardNthRoot(PRIMITIVE_ROOT[modulus], length));  // Forward n:th root
+            wTable = instance.createWTable(w, length);
+            // Check if another thread already put the wTable in the cache; if so then use it
+            int[] value = IntWTables.cache.putIfAbsent(key, wTable);
+            if (value != null)
+            {
+                // Another thread did put the value in the cache so use it
+                wTable = value;
+            }
+        }
+        return wTable;
+    }
+
+    private static IntModMath getInstance(int modulus)
+    {
+        IntModMath instance = new IntModMath();
+        instance.setModulus(MODULUS[modulus]);
+        return instance;
+    }
+
+    // With inverses, three moduli and lengths being powers of two, the theoretical maximum map size is 2 * 3 * 30 = 180 entries
+    private static ConcurrentMap<List<Integer>, int[]> cache = new ConcurrentSoftHashMap<List<Integer>, int[]>();
+}
Index: src/main/java/org/apfloat/internal/LongAdditionBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/LongAdditionBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongAdditionBuilder.java	(revision 0)
@@ -0,0 +1,30 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.AdditionBuilder;
+import org.apfloat.spi.AdditionStrategy;
+
+/**
+ * Creates additions for the specified radix and the <code>long</code> element type.<p>
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class LongAdditionBuilder
+    implements AdditionBuilder<Long>
+{
+    /**
+     * Default constructor.
+     */
+
+    public LongAdditionBuilder()
+    {
+    }
+
+    public AdditionStrategy<Long> createAddition(int radix)
+    {
+        AdditionStrategy<Long> additionStrategy = new LongAdditionStrategy(radix);
+        return additionStrategy;
+    }
+}
Index: src/main/java/org/apfloat/internal/LongAdditionStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/LongAdditionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongAdditionStrategy.java	(revision 0)
@@ -0,0 +1,59 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.AdditionStrategy;
+import org.apfloat.spi.DataStorage.Iterator;
+
+/**
+ * Basic addition strategy for the <code>long</code> element type.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+public class LongAdditionStrategy
+    extends LongBaseMath
+    implements AdditionStrategy<Long>
+{
+    /**
+     * Creates an addition strategy using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public LongAdditionStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public Long add(Iterator src1, Iterator src2, Long carry, Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        return baseAdd(src1, src2, carry, dst, size);
+    }
+
+    public Long subtract(Iterator src1, Iterator src2, Long carry, Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        return baseSubtract(src1, src2, carry, dst, size);
+    }
+
+    public Long multiplyAdd(Iterator src1, Iterator src2, Long src3, Long carry, Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        return baseMultiplyAdd(src1, src2, src3, carry, dst, size);
+    }
+
+    public Long divide(Iterator src1, Long src2, Long carry, Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        return baseDivide(src1, src2, carry, dst, size);
+    }
+
+    public Long zero()
+    {
+        return (long) 0;
+    }
+
+    private static final long serialVersionUID = 4128390142053847289L;
+}
Index: src/main/java/org/apfloat/internal/LongApfloatBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/LongApfloatBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongApfloatBuilder.java	(revision 0)
@@ -0,0 +1,52 @@
+package org.apfloat.internal;
+
+import java.io.PushbackReader;
+import java.io.IOException;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ApfloatBuilder;
+import org.apfloat.spi.ApfloatImpl;
+
+/**
+ * Builder class for building {@link ApfloatImpl} implementations with the
+ * <code>long</code> data element type.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public class LongApfloatBuilder
+    implements ApfloatBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public LongApfloatBuilder()
+    {
+    }
+
+    public ApfloatImpl createApfloat(String value, long precision, int radix, boolean isInteger)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        return new LongApfloatImpl(value, precision, radix, isInteger);
+    }
+
+    public ApfloatImpl createApfloat(long value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        return new LongApfloatImpl(value, precision, radix);
+    }
+
+    public ApfloatImpl createApfloat(double value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        return new LongApfloatImpl(value, precision, radix);
+    }
+
+    public ApfloatImpl createApfloat(PushbackReader in, long precision, int radix, boolean isInteger)
+        throws IOException, NumberFormatException, ApfloatRuntimeException
+    {
+        return new LongApfloatImpl(in, precision, radix, isInteger);
+    }
+}
Index: src/main/java/org/apfloat/internal/LongApfloatImpl.java
===================================================================
--- src/main/java/org/apfloat/internal/LongApfloatImpl.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongApfloatImpl.java	(revision 0)
@@ -0,0 +1,2449 @@
+package org.apfloat.internal;
+
+import java.io.ObjectInputStream;
+import java.io.PushbackReader;
+import java.io.Writer;
+import java.io.StringWriter;
+import java.io.IOException;
+
+import org.apfloat.Apfloat;
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.InfiniteExpansionException;
+import org.apfloat.OverflowException;
+import org.apfloat.spi.ApfloatImpl;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+import org.apfloat.spi.AdditionBuilder;
+import org.apfloat.spi.AdditionStrategy;
+import org.apfloat.spi.ConvolutionBuilder;
+import org.apfloat.spi.ConvolutionStrategy;
+import org.apfloat.spi.Util;
+import static org.apfloat.spi.RadixConstants.*;
+import static org.apfloat.internal.LongRadixConstants.*;
+
+/**
+ * Immutable apfloat implementation class for the
+ * <code>long</code> data element type.<p>
+ *
+ * The associated {@link DataStorage} is assumed to be immutable also.
+ * This way performance can be improved by sharing the data storage between
+ * different <code>ApfloatImpl</code>'s and by only varying the
+ * <code>ApfloatImpl</code> specific fields, like sign, precision and exponent.<p>
+ *
+ * This implementation doesn't necessarily store any extra digits for added
+ * precision, so the last digit of any operation may be inaccurate.
+ *
+ * @version 1.8.2
+ * @author Mikko Tommila
+ */
+
+public class LongApfloatImpl
+    extends LongBaseMath
+    implements ApfloatImpl
+{
+    // Implementation notes:
+    // - The dataStorage must never contain leading zeros or trailing zeros
+    // - If precision is reduced then the dataStorage can contain trailing zeros (physically in the middle)
+    // - The dataStorage should not be unnecessarily subsequenced if precision is reduced e.g. to allow autoconvolution
+    // - Precision is in digits but exponent is in base units
+    private LongApfloatImpl(int sign, long precision, long exponent, DataStorage dataStorage, int radix)
+    {
+        super(radix);
+
+        assert (sign == 0 || sign == -1 || sign == 1);
+        assert (precision > 0);
+        assert (sign != 0 || precision == Apfloat.INFINITE);
+        assert (sign != 0 || exponent == 0);
+        assert (sign != 0 || dataStorage == null);
+        assert (sign == 0 || dataStorage != null);
+        assert (exponent <= MAX_EXPONENT[radix] && exponent >= -MAX_EXPONENT[radix]);
+        assert (dataStorage == null || dataStorage.isReadOnly());
+
+        this.sign = sign;
+        this.precision = precision;
+        this.exponent = exponent;
+        this.dataStorage = dataStorage;
+        this.radix = radix;
+    }
+
+    /**
+     * Create a new <code>LongApfloatImpl</code> instance from a String.
+     *
+     * @param value The string to be parsed to a number.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     * @param isInteger Specifies if the number to be parsed from the string is to be treated as an integer or not.
+     *
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public LongApfloatImpl(String value, long precision, int radix, boolean isInteger)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        super(checkRadix(radix));
+
+        assert (precision == Apfloat.DEFAULT || precision > 0);
+
+        this.radix = radix;
+
+        // Default sign if not specified
+        this.sign = 1;
+
+        int startIndex = -1,
+            pointIndex = -1,
+            expIndex = -1,
+            leadingZeros = 0,
+            trailingZeros = 0,
+            digitSize = 0;
+
+        // Scan through the string looking for various things
+        for (int i = 0; i < value.length(); i++)
+        {
+            char c = value.charAt(i);
+            int digit = Character.digit(c, radix);
+
+            // Note that checking for a valid digit takes place before checking for e or E in the string
+            if (digit == -1)
+            {
+                if (i == 0 && (c == '-' || c == '+'))
+                {
+                    // Get sign
+                    this.sign = (c == '-' ? -1 : 1);
+                }
+                else if (!isInteger && c == '.' && pointIndex == -1)
+                {
+                    // Mark decimal point location
+                    pointIndex = digitSize;
+                }
+                else if (!isInteger && (c == 'e' || c == 'E') && expIndex == -1)
+                {
+                    // Mark index after which the exponent is specified
+                    expIndex = i;
+                    break;
+                }
+                else
+                {
+                    throw new NumberFormatException("Invalid character: " + c + " at position " + i);
+                }
+            }
+            else
+            {
+                if (leadingZeros == digitSize && digit == 0)
+                {
+                    // Increase number of leading zeros
+                    leadingZeros++;
+                }
+                else if (startIndex == -1)
+                {
+                    // Mark index where the significant digits start
+                    startIndex = i;
+                }
+
+                // Increase number of digits
+                digitSize++;
+
+                if (digit == 0)
+                {
+                    // Increase number of trailing zeros
+                    trailingZeros++;
+                }
+                else
+                {
+                    // Reset number of trailing zeros
+                    trailingZeros = 0;
+                }
+            }
+        }
+
+        // Check if no digits were specified
+        if (digitSize == 0)
+        {
+            throw new NumberFormatException("No digits");
+        }
+
+        // Check if this number is zero
+        if (startIndex == -1)
+        {
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Default precision is number of significant digits, if not specified
+        if (precision == Apfloat.DEFAULT)
+        {
+            assert (!isInteger);
+            precision = digitSize - leadingZeros;
+        }
+        this.precision = precision;
+
+        // Size of integer part
+        int integerSize = (pointIndex >= 0 ? pointIndex : digitSize) - leadingZeros;
+
+        // Read exponent as specified in string
+        if (expIndex >= 0)
+        {
+            // Thanks to Charles Oliver Nutter for finding this bug
+            String expString = value.substring(expIndex + 1);
+            if (expString.startsWith("+"))
+            {
+                expString = expString.substring(1);
+            }
+
+            try
+            {
+                this.exponent = Long.parseLong(expString);
+            }
+            catch (NumberFormatException nfe)
+            {
+                throw new NumberFormatException("Invalid exponent: " + expString);
+            }
+        }
+        else
+        {
+            this.exponent = 0;
+        }
+
+        // Do not allow the exponent to be too close to the limits (MIN_VALUE, MAX_VALUE), leave some slack
+        int slack = BASE_DIGITS[radix];
+
+        // Check for overflow in exponent, roughly
+        if (integerSize >= -slack && this.exponent >= Long.MAX_VALUE - integerSize - slack)
+        {
+            throw new NumberFormatException("Exponent overflow");
+        }
+        else if (integerSize <= slack && this.exponent <= Long.MIN_VALUE - integerSize + slack)
+        {
+            // Underflow
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Adjust exponent by decimal point location
+        this.exponent += integerSize;
+
+        // Exponent rounded towards positive infinity to base unit
+        long baseExp = (this.exponent + (this.exponent > 0 ? BASE_DIGITS[radix] - 1 : 0)) / BASE_DIGITS[radix];
+
+        // Check for overflow in exponent as represented in base units
+        if (baseExp > MAX_EXPONENT[this.radix])
+        {
+            throw new OverflowException("Overflow");
+        }
+        else if (baseExp < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Leading zeros in first base unit
+        int digitsInBase = (int) (baseExp * BASE_DIGITS[radix] - this.exponent);
+
+        // The stored exponent is really the one per base unit
+        this.exponent = baseExp;
+
+        // Remove leading and trailing zeros from size
+        digitSize -= leadingZeros + trailingZeros;
+
+        // Limit number of significant digits by specified precision
+        digitSize = (int) Math.min(digitSize, precision);
+
+        // Needed storage size in longs
+        int size = (int) getBasePrecision(digitSize, BASE_DIGITS[radix] - digitsInBase);
+
+        this.dataStorage = createDataStorage(size);
+        this.dataStorage.setSize(size);
+
+        // Base unit that is constructed and stored to an element of the data storage
+        long word = 0;
+
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.WRITE, 0, size);
+
+        // Set the data
+        for (int i = startIndex; digitSize > 0; i++)
+        {
+            char c = value.charAt(i);
+            if (c == '.')
+            {
+                continue;
+            }
+
+            int digit = Character.digit(c, radix);
+            word *= (long) radix;
+            word += (long) digit;
+
+            if (digitSize == 1)
+            {
+                // Last digit
+                while (digitsInBase < BASE_DIGITS[radix] - 1)
+                {
+                    // Fill last word with trailing zeros
+                    word *= (long) radix;
+                    digitsInBase++;
+                }
+            }
+
+            if (++digitsInBase == BASE_DIGITS[radix])
+            {
+                // Word is full, write word
+                digitsInBase = 0;
+                iterator.setLong(word);
+                iterator.next();
+                word = 0;
+            }
+
+            digitSize--;
+        }
+
+        assert (!iterator.hasNext());
+
+        this.dataStorage.setReadOnly();
+    }
+
+    /**
+     * Create a new <code>LongApfloatImpl</code> instance from a <code>long</code>.
+     *
+     * @param value The value of the number.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     *
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public LongApfloatImpl(long value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        super(checkRadix(radix));
+
+        assert (precision > 0);
+
+        this.radix = radix;
+
+        // Faster to set now than calculate later
+        this.isOne = (value == 1 ? 1 : 0);
+
+        if (value > 0)
+        {
+            this.sign = 1;
+            value = -value;         // Calculate here as negative to handle 0x8000000000000000
+        }
+        else if (value < 0)
+        {
+            this.sign = -1;
+        }
+        else
+        {
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        this.precision = precision;
+
+        int size;
+        long[] data = new long[MAX_LONG_SIZE];
+        long longBase = (long) BASE[radix];
+
+        if (-longBase < value)
+        {
+            size = 1;                               // Nonzero
+            data[MAX_LONG_SIZE - 1] = (long) -value;
+        }
+        else
+        {
+            for (size = 0; value != 0; size++)
+            {
+                long newValue = value / longBase;
+                data[MAX_LONG_SIZE - 1 - size] = (long) (newValue * longBase - value);   // Negated here
+                value = newValue;
+            }
+        }
+
+        this.exponent = size;
+
+        this.initialDigits = getDigits(data[MAX_LONG_SIZE - size]);
+
+        // Check if precision in longs is less than size; truncate size if so
+        long basePrecision = getBasePrecision(precision, this.initialDigits);
+        if (basePrecision < size)
+        {
+            size = (int) basePrecision;
+        }
+
+        // Remove trailing zeros from data
+        while (data[MAX_LONG_SIZE - 1 - (int) this.exponent + size] == 0)
+        {
+            size--;
+        }
+
+        this.dataStorage = createDataStorage(size);
+        this.dataStorage.setSize(size);
+
+        ArrayAccess arrayAccess = this.dataStorage.getArray(DataStorage.WRITE, 0, size);
+        System.arraycopy(data, MAX_LONG_SIZE - (int) this.exponent, arrayAccess.getData(), arrayAccess.getOffset(), size);
+        arrayAccess.close();
+
+        this.dataStorage.setReadOnly();
+    }
+
+    /**
+     * Create a new <code>LongApfloatImpl</code> instance from a <code>double</code>.
+     *
+     * @param value The value of the number.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     *
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public LongApfloatImpl(double value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException
+    {
+        super(checkRadix(radix));
+
+        if (Double.isInfinite(value) || Double.isNaN(value))
+        {
+            throw new NumberFormatException(value + " is not a valid number");
+        }
+
+        this.radix = radix;
+
+        if (value > 0)
+        {
+            this.sign = 1;
+        }
+        else if (value < 0)
+        {
+            this.sign = -1;
+            value = -value;
+        }
+        else
+        {
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        this.precision = precision;
+
+        int size;
+        long[] data = new long[MAX_DOUBLE_SIZE];
+        double doubleBase = (double) BASE[radix];
+
+        this.exponent = (long) Math.floor(Math.log(value) / Math.log(doubleBase));
+        // Avoid overflow in intermediate value
+        if (this.exponent > 0)
+        {
+            value *= Math.pow(doubleBase, (double) -this.exponent);
+        }
+        else if (this.exponent < 0)
+        {
+            value *= Math.pow(doubleBase, (double) (-this.exponent - MAX_DOUBLE_SIZE));
+            value *= Math.pow(doubleBase, (double) MAX_DOUBLE_SIZE);
+        }
+        this.exponent++;
+
+        if (value < 1.0)
+        {
+            // Round-off error in case the input was very close but just under the base, e.g. 9.999999999999996E-10
+            value = 1.0;
+        }
+
+        for (size = 0; size < MAX_DOUBLE_SIZE && value > 0.0; size++)
+        {
+            double tmp = Math.floor(value);
+
+            assert (tmp <= doubleBase);
+
+            if (tmp == doubleBase)
+            {
+                // Round-off error e.g. in case of the number being exactly 1/radix
+                tmp -= 1.0;
+            }
+
+            data[size] = (long) tmp;
+            value -= tmp;
+            value *= doubleBase;
+        }
+
+        this.initialDigits = getDigits(data[0]);
+
+        // Check if precision in longs is less than size; truncate size if so
+        long basePrecision = getBasePrecision(precision, this.initialDigits);
+        if (basePrecision < size)
+        {
+            size = (int) basePrecision;
+        }
+
+        // Remove trailing zeros from data
+        while (data[size - 1] == 0)
+        {
+            size--;
+        }
+
+        this.dataStorage = createDataStorage(size);
+        this.dataStorage.setSize(size);
+
+        ArrayAccess arrayAccess = this.dataStorage.getArray(DataStorage.WRITE, 0, size);
+        System.arraycopy(data, 0, arrayAccess.getData(), arrayAccess.getOffset(), size);
+        arrayAccess.close();
+
+        this.dataStorage.setReadOnly();
+    }
+
+    private static long readExponent(PushbackReader in)
+        throws IOException, NumberFormatException
+    {
+        StringBuilder buffer = new StringBuilder(20);
+        int input;
+
+        for (long i = 0; (input = in.read()) != -1; i++)
+        {
+            char c = (char) input;
+            int digit = Character.digit(c, 10);         // Exponent is always in base 10
+
+            if (i == 0 && c == '-' ||
+                digit != -1)
+            {
+                buffer.append(c);
+            }
+            else
+            {
+                // Stop at first invalid character and put it back
+                in.unread(input);
+                break;
+            }
+        }
+
+        return Long.parseLong(buffer.toString());
+    }
+
+    /**
+     * Create a new <code>LongApfloatImpl</code> instance reading from a stream.<p>
+     *
+     * Implementation note: this constructor calls the <code>in</code> stream's
+     * single-character <code>read()</code> method. If the underlying stream doesn't
+     * explicitly implement this method in some efficient way, but simply inherits it
+     * from the <code>Reader</code> base class, performance will suffer as the default
+     * <code>Reader</code> method creates a <code>new char[1]</code> on every call to
+     * <code>read()</code>.
+     *
+     * @param in The stream to read from.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     * @param isInteger Specifies if the number to be parsed from the stream is to be treated as an integer or not.
+     *
+     * @exception java.io.IOException If an I/O error occurs accessing the stream.
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public LongApfloatImpl(PushbackReader in, long precision, int radix, boolean isInteger)
+        throws IOException, NumberFormatException, ApfloatRuntimeException
+    {
+        super(checkRadix(radix));
+
+        assert (precision == Apfloat.DEFAULT || precision > 0);
+
+        this.radix = radix;
+
+        // Default sign if not specified
+        this.sign = 1;
+
+        // Allocate a maximum memory block, since we don't know how much data to expect
+        ApfloatContext ctx = ApfloatContext.getContext();
+        long initialSize = ctx.getMemoryThreshold() / 8,
+             previousAllocatedSize = 0,
+             allocatedSize = initialSize;
+        this.dataStorage = createDataStorage(initialSize);
+        this.dataStorage.setSize(initialSize);
+
+        // Base unit that is constructed and stored to an element of the data storage
+        long word = 0;
+
+        // Number of digits stored in word
+        int digitsInBase = 0;
+
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.WRITE, previousAllocatedSize, allocatedSize);
+
+        int input;
+        long actualSize = 0,
+             startIndex = -1,
+             pointIndex = -1,
+             leadingZeros = 0,
+             trailingZeros = 0,
+             digitSize = 0;
+
+        // Scan through the string looking for various things
+        for (long i = 0; (input = in.read()) != -1; i++)
+        {
+            char c = (char) input;
+            int digit = Character.digit(c, radix);
+
+            // Note that checking for a valid digit takes place before checking for e or E in the string
+            if (digit == -1)
+            {
+                if (i == 0 && (c == '-' || c == '+'))
+                {
+                    // Get sign
+                    this.sign = (c == '-' ? -1 : 1);
+                }
+                else if (!isInteger && c == '.' && pointIndex == -1)
+                {
+                    // Mark decimal point location
+                    pointIndex = digitSize;
+                }
+                else if (!isInteger && digitSize > 0 && (c == 'e' || c == 'E'))
+                {
+                    // Read the exponent and stop
+                    this.exponent = readExponent(in);
+                    break;
+                }
+                else
+                {
+                    // Stop at first invalid character and put it back
+                    in.unread(input);
+                    break;
+                }
+            }
+            else
+            {
+                if (leadingZeros == digitSize && digit == 0)
+                {
+                    // Increase number of leading zeros
+                    leadingZeros++;
+                }
+                else
+                {
+                    if (startIndex == -1)
+                    {
+                        // Mark index where the significant digits start
+                        startIndex = i;
+                    }
+
+                    // Set the data
+                    word *= (long) radix;
+                    word += (long) digit;
+
+                    // Reallocate storage if needed; done here to prepare storing last (partial) word
+                    if (actualSize == allocatedSize)
+                    {
+                        if (actualSize == initialSize)
+                        {
+                            // Maximum memory block size exceeded; prepare to allocate anything
+                            DataStorage dataStorage = createDataStorage(Long.MAX_VALUE / 8);
+                            dataStorage.copyFrom(this.dataStorage, actualSize);
+                            this.dataStorage = dataStorage;
+                        }
+                        previousAllocatedSize = allocatedSize;
+                        allocatedSize += getBlockSize();
+                        this.dataStorage.setSize(allocatedSize);
+                        iterator.close();
+                        iterator = this.dataStorage.iterator(DataStorage.WRITE, previousAllocatedSize, allocatedSize);
+                    }
+
+                    if (++digitsInBase == BASE_DIGITS[radix])
+                    {
+                        // Word is full, write word
+                        digitsInBase = 0;
+                        iterator.setLong(word);
+                        iterator.next();
+                        word = 0;
+                        actualSize++;
+                    }
+                }
+
+                // Increase number of digits
+                digitSize++;
+
+                if (digit == 0)
+                {
+                    // Increase number of trailing zeros
+                    trailingZeros++;
+                }
+                else
+                {
+                    // Reset number of trailing zeros
+                    trailingZeros = 0;
+                }
+            }
+        }
+
+        // Check if no digits were specified
+        if (digitSize == 0)
+        {
+            throw new NumberFormatException("No digits");
+        }
+
+        // Check if this number is zero
+        if (startIndex == -1)
+        {
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Handle last word
+        if (digitsInBase > 0 && word != 0)
+        {
+            // Last digit
+            while (digitsInBase < BASE_DIGITS[radix])
+            {
+                // Fill last word with trailing zeros
+                word *= (long) radix;
+                digitsInBase++;
+            }
+
+            // Write word
+            iterator.setLong(word);
+            actualSize++;
+        }
+
+        iterator.close();
+
+        // Default precision is number of significant digits, if not specified
+        if (precision == Apfloat.DEFAULT)
+        {
+            assert (!isInteger);
+            precision = digitSize - leadingZeros;
+        }
+        this.precision = precision;
+
+        // Size of integer part
+        long integerSize = (pointIndex >= 0 ? pointIndex : digitSize) - leadingZeros;
+
+        // Do not allow the exponent to be too close to the limits (MIN_VALUE, MAX_VALUE), leave some slack
+        int slack = BASE_DIGITS[radix];
+
+        // Check for overflow in exponent, roughly
+        if (integerSize >= -slack && this.exponent >= Long.MAX_VALUE - integerSize - slack)
+        {
+            throw new NumberFormatException("Exponent overflow");
+        }
+        else if (integerSize <= slack && this.exponent <= Long.MIN_VALUE - integerSize + slack)
+        {
+            // Underflow
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // Adjust exponent by decimal point location
+        this.exponent += integerSize;
+
+        // Exponent rounded towards negative infinity to base unit
+        long baseExp = (this.exponent - (this.exponent < 0 ? BASE_DIGITS[radix] - 1 : 0)) / BASE_DIGITS[radix];
+
+        // Check for overflow in exponent as represented in base units
+        if (baseExp > MAX_EXPONENT[this.radix])
+        {
+            throw new OverflowException("Overflow");
+        }
+        else if (baseExp < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            this.sign = 0;
+            this.precision = Apfloat.INFINITE;
+            this.exponent = 0;
+            this.dataStorage = null;
+
+            return;
+        }
+
+        // How much the data needs to be shifted
+        int bias = (int) (this.exponent - baseExp * BASE_DIGITS[radix]);
+
+        // The stored exponent is really the one per base unit
+        this.exponent = baseExp;
+
+        // Remove leading and trailing zeros from size
+        digitSize -= leadingZeros + trailingZeros;
+
+        // Limit number of significant digits by specified precision
+        digitSize = Math.min(digitSize, precision);
+
+        // Needed storage size in longs
+        actualSize = (digitSize + BASE_DIGITS[radix] - 1) / BASE_DIGITS[radix];
+
+        // Truncate allocated space to actually used amount
+        this.dataStorage.setSize(actualSize);
+
+        this.dataStorage.setReadOnly();
+
+        if (bias != 0)
+        {
+            // Shift by bias
+            long factor = 1;
+
+            for (int i = 0; i < bias; i++)
+            {
+                factor *= radix;
+            }
+
+            LongApfloatImpl tmp = (LongApfloatImpl) multiply(new LongApfloatImpl(factor, Apfloat.INFINITE, radix));
+
+            this.exponent = tmp.exponent;
+            this.dataStorage = tmp.dataStorage;
+            this.initialDigits = UNDEFINED;     // Needs to be reset
+        }
+    }
+
+    // Returns number of trailing zeros before specified index
+    private static long getTrailingZeros(DataStorage dataStorage, long index)
+        throws ApfloatRuntimeException
+    {
+        long count = 0;
+
+        DataStorage.Iterator iterator = dataStorage.iterator(DataStorage.READ, index, 0);
+
+        while (iterator.hasNext())
+        {
+            if (iterator.getLong() != 0)
+            {
+                iterator.close();
+                break;
+            }
+
+            iterator.next();
+            count++;
+        }
+
+        return count;
+    }
+
+    // Returns number of leading zeros starting from specified index
+    private static long getLeadingZeros(DataStorage dataStorage, long index)
+        throws ApfloatRuntimeException
+    {
+        long count = 0;
+
+        DataStorage.Iterator iterator = dataStorage.iterator(DataStorage.READ, index, dataStorage.getSize());
+
+        while (iterator.hasNext())
+        {
+            if (iterator.getLong() != 0)
+            {
+                iterator.close();
+                break;
+            }
+
+            iterator.next();
+            count++;
+        }
+
+        return count;
+    }
+
+    public ApfloatImpl addOrSubtract(ApfloatImpl x, boolean subtract)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof LongApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        LongApfloatImpl that = (LongApfloatImpl) x;
+
+        if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot use numbers with different radixes: " + this.radix + " and " + that.radix);
+        }
+
+        assert (this.sign != 0);
+        assert (that.sign != 0);
+
+        int realThatSign = (subtract ? -that.sign : that.sign);
+        boolean reallySubtract = (this.sign != realThatSign);
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        AdditionBuilder<Long> additionBuilder = ctx.getBuilderFactory().getAdditionBuilder(Long.TYPE);
+        AdditionStrategy<Long> additionStrategy = additionBuilder.createAddition(this.radix);
+
+        int sign;
+        long exponent,
+             precision;
+        DataStorage dataStorage;
+
+        if (this == that)
+        {
+            if (reallySubtract)
+            {
+                // x - x = 0
+
+                return zero();
+            }
+            else
+            {
+                // x + x = 2 * x
+
+                sign = this.sign;
+                exponent = this.exponent;
+                precision = this.precision;
+                long size = getSize() + 1;
+
+                dataStorage = createDataStorage(size);
+                dataStorage.setSize(size);
+
+                DataStorage.Iterator src1 = this.dataStorage.iterator(DataStorage.READ, size - 1, 0),
+                                     src2 = this.dataStorage.iterator(DataStorage.READ, size - 1, 0),   // Sub-optimal: could be the same
+                                     dst = dataStorage.iterator(DataStorage.WRITE, size, 0);
+
+                long carry = additionStrategy.add(src1, src2, (long) 0, dst, size - 1);
+
+                dst.setLong(carry);
+                dst.close();
+
+                size -= getTrailingZeros(dataStorage, size);
+
+                // Check if carry occurred
+                int carrySize = (int) carry,
+                    leadingZeros = 1 - carrySize;
+
+                dataStorage = dataStorage.subsequence(leadingZeros, size - leadingZeros);
+                exponent += carrySize;
+
+                if (this.exponent == MAX_EXPONENT[this.radix] && carrySize > 0)
+                {
+                    throw new OverflowException("Overflow");
+                }
+
+                if (precision != Apfloat.INFINITE &&
+                    (carrySize > 0 || getInitialDigits(dataStorage) > getInitialDigits()))
+                {
+                    // Carry overflow for most significant digit; number of significant digits increases by one
+                    precision++;
+                }
+            }
+        }
+        else
+        {
+            // Now this != that
+
+            int comparison;
+            if (scale() > that.scale())
+            {
+                comparison = 1;
+            }
+            else if (scale() < that.scale())
+            {
+                comparison = -1;
+            }
+            else if (reallySubtract)
+            {
+                comparison = compareMantissaTo(that);           // Might be sub-optimal, but a more efficient algorithm would be complicated
+            }
+            else
+            {
+                comparison = 1;                                 // Add equally big numbers; arbitrarily choose one
+            }
+
+            LongApfloatImpl big,
+                               small;
+
+            if (comparison > 0)
+            {
+                big = this;
+                small = that;
+                sign = this.sign;
+            }
+            else if (comparison < 0)
+            {
+                big = that;
+                small = this;
+                sign = realThatSign;
+            }
+            else
+            {
+                // x - x = 0
+                return zero();
+            }
+
+            long scaleDifference = big.scale() - small.scale(),
+                 exponentDifference,
+                 size,
+                 bigSize,
+                 smallSize;
+
+            if (scaleDifference < 0)
+            {
+                // Small number is completely insignificantly small compared to big
+                precision = big.precision;
+                exponent = big.exponent;
+                bigSize = big.getSize();
+                smallSize = 0;
+                size = bigSize;
+                exponentDifference = bigSize;
+            }
+            else
+            {
+                precision = Math.min(big.precision, Util.ifFinite(small.precision, scaleDifference + small.precision)); // Detects overflow also
+                long basePrecision = Math.min(MAX_EXPONENT[this.radix], getBasePrecision(precision, big.getInitialDigits()));
+                exponent = big.exponent;
+
+                exponentDifference = big.exponent - small.exponent;
+                size = Math.min(basePrecision, Math.max(big.getSize(), exponentDifference + small.getSize()));
+                bigSize = Math.min(size, big.getSize());
+                smallSize = Math.max(0, Math.min(size - exponentDifference, small.getSize()));
+            }
+
+            long dstSize = size + 1;                    // One extra word for carry overflow
+            dataStorage = createDataStorage(dstSize);
+            dataStorage.setSize(dstSize);
+
+            DataStorage.Iterator src1 = big.dataStorage.iterator(DataStorage.READ, bigSize, 0),
+                                 src2 = small.dataStorage.iterator(DataStorage.READ, smallSize, 0),
+                                 dst = dataStorage.iterator(DataStorage.WRITE, dstSize, 0);
+
+            long carry = 0;
+
+            // big:       XXXXXXXX               XXXX
+            // small:         XXXXXXXX        or         XXXX
+            // This part:         XXXX                   XXXX
+            if (size > bigSize)
+            {
+                long blockSize = Math.min(size - bigSize, smallSize);
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(null, src2, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(null, src2, carry, dst, blockSize);
+                }
+            }
+            // big:        XXXXXXXXXXXX
+            // small:          XXXX
+            // This part:          XXXX
+            else if (size > exponentDifference + smallSize)
+            {
+                long blockSize = size - exponentDifference - smallSize;
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(src1, null, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(src1, null, carry, dst, blockSize);
+                }
+            }
+            // big:        XXXX
+            // small:              XXXX
+            // This part:      XXXX
+            if (exponentDifference > bigSize)
+            {
+                long blockSize = exponentDifference - bigSize;
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(null, null, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(null, null, carry, dst, blockSize);
+                }
+            }
+            // big:        XXXXXXXX               XXXXXXXXXXXX
+            // small:          XXXXXXXX        or     XXXX
+            // This part:      XXXX                   XXXX
+            else if (bigSize > exponentDifference)
+            {
+                long blockSize = Math.min(bigSize - exponentDifference, smallSize);
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(src1, src2, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(src1, src2, carry, dst, blockSize);
+                }
+            }
+            // big:        XXXXXXXX               XXXXXXXXXXXX           XXXX
+            // small:          XXXXXXXX        or     XXXX            or         XXXX
+            // This part:  XXXX                   XXXX                   XXXX
+            if (exponentDifference > 0)
+            {
+                long blockSize = Math.min(bigSize, exponentDifference);
+                if (reallySubtract)
+                {
+                    carry = additionStrategy.subtract(src1, null, carry, dst, blockSize);
+                }
+                else
+                {
+                    carry = additionStrategy.add(src1, null, carry, dst, blockSize);
+                }
+            }
+
+            // Set most significant word
+            dst.setLong(carry);
+            dst.close();
+
+            long leadingZeros;
+
+            if (reallySubtract)
+            {
+                // Get denormalization
+                leadingZeros = getLeadingZeros(dataStorage, 0);
+
+                assert (leadingZeros <= size);
+            }
+            else
+            {
+                // Check if carry occurred up to and including most significant word
+                leadingZeros = (carry == 0 ? 1 : 0);
+
+                if (this.exponent == MAX_EXPONENT[this.radix] && leadingZeros == 0)
+                {
+                    throw new OverflowException("Overflow");
+                }
+            }
+
+            dstSize -= getTrailingZeros(dataStorage, dstSize);
+
+            dataStorage = dataStorage.subsequence(leadingZeros, dstSize - leadingZeros);
+            exponent += 1 - leadingZeros;
+
+            if (exponent < -MAX_EXPONENT[this.radix])
+            {
+                // Underflow
+                return zero();
+            }
+
+            if (precision != Apfloat.INFINITE)
+            {
+                // If scale of number changes, the number of significant digits changes accordingly
+                long scaleChange = (1 - leadingZeros) * BASE_DIGITS[this.radix] + getInitialDigits(dataStorage) - big.getInitialDigits();
+                if (-scaleChange >= precision)
+                {
+                    // All significant digits were lost anyway, due to trailing garbage digits
+                    return zero();
+                }
+                precision += scaleChange;
+                precision = (precision <= 0 ? Apfloat.INFINITE : precision);    // Detect overflow
+            }
+        }
+
+        dataStorage.setReadOnly();
+
+        return new LongApfloatImpl(sign, precision, exponent, dataStorage, this.radix);
+    }
+
+    public ApfloatImpl multiply(ApfloatImpl x)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof LongApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        LongApfloatImpl that = (LongApfloatImpl) x;
+
+        if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot multiply numbers with different radixes: " + this.radix + " and " + that.radix);
+        }
+
+        int sign = this.sign * that.sign;
+
+        if (sign == 0)
+        {
+            return zero();
+        }
+
+        long exponent = this.exponent + that.exponent;
+
+        if (exponent > MAX_EXPONENT[this.radix])
+        {
+            throw new OverflowException("Overflow");
+        }
+        else if (exponent < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            return zero();
+        }
+
+        long precision = Math.min(this.precision, that.precision),
+             basePrecision = getBasePrecision(precision, 0),            // Round up
+             thisSize = getSize(),
+             thatSize = that.getSize(),
+             size = Math.min(Util.ifFinite(basePrecision, basePrecision + 1), thisSize + thatSize),     // Reserve one extra word for carry
+             thisDataSize = Math.min(thisSize, basePrecision),
+             thatDataSize = Math.min(thatSize, basePrecision);
+
+        DataStorage thisDataStorage = this.dataStorage.subsequence(0, thisDataSize),
+                    thatDataStorage = (this.dataStorage == that.dataStorage ?
+                                       thisDataStorage :                                                // Enable auto-convolution
+                                       that.dataStorage.subsequence(0, thatDataSize));
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        ConvolutionBuilder convolutionBuilder = ctx.getBuilderFactory().getConvolutionBuilder();
+        ConvolutionStrategy convolutionStrategy = convolutionBuilder.createConvolution(this.radix, thisDataSize, thatDataSize, size);
+
+        // Possibly sub-optimal: could look up trailing zeros of the subsequences
+        DataStorage dataStorage = convolutionStrategy.convolute(thisDataStorage, thatDataStorage, size);
+
+        // Check if carry occurred up to and including most significant word
+        int leadingZeros = (getMostSignificantWord(dataStorage) == 0 ? 1 : 0);
+
+        exponent -= leadingZeros;
+
+        if (exponent < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            return zero();
+        }
+
+        size -= leadingZeros;
+        dataStorage = dataStorage.subsequence(leadingZeros, size);
+
+        size = Math.min(size, getBasePrecision(precision, getInitialDigits(dataStorage)));
+        size -= getTrailingZeros(dataStorage, size);
+
+        dataStorage = dataStorage.subsequence(0, size);
+
+        dataStorage.setReadOnly();
+
+        return new LongApfloatImpl(sign, precision, exponent, dataStorage, this.radix);
+    }
+
+    public boolean isShort()
+        throws ApfloatRuntimeException
+    {
+        return (this.sign == 0 || getSize() == 1);
+    }
+
+    public ApfloatImpl divideShort(ApfloatImpl x)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof LongApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        LongApfloatImpl that = (LongApfloatImpl) x;
+
+        if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot divide numbers with different radixes: " + this.radix + " and " + that.radix);
+        }
+
+        assert (this.sign != 0);
+        assert (that.sign != 0);
+
+        int sign = this.sign * that.sign;
+
+        long exponent = this.exponent - that.exponent + 1;
+
+        if (exponent > MAX_EXPONENT[this.radix])
+        {
+            throw new OverflowException("Overflow");
+        }
+        else if (exponent < -MAX_EXPONENT[this.radix])
+        {
+            // Underflow
+            return zero();
+        }
+
+        long precision = Math.min(this.precision, that.precision),
+             basePrecision = getBasePrecision(),
+             thisDataSize = Math.min(getSize(), basePrecision);
+
+        DataStorage dataStorage;
+
+        long divisor = getMostSignificantWord(that.dataStorage);
+
+        if (divisor == (long) 1)
+        {
+            long size = thisDataSize - getTrailingZeros(this.dataStorage, thisDataSize);
+
+            dataStorage = this.dataStorage.subsequence(0, size);
+        }
+        else
+        {
+            ApfloatContext ctx = ApfloatContext.getContext();
+            AdditionBuilder<Long> additionBuilder = ctx.getBuilderFactory().getAdditionBuilder(Long.TYPE);
+            AdditionStrategy<Long> additionStrategy = additionBuilder.createAddition(this.radix);
+
+            long size;
+            long carry;
+
+            // Check for finite or infinite result sequence
+            long dividend = divisor;
+
+            // Check that the factorization of the divisor consists entirely of factors of the base
+            // E.g. if base is 10=2*5 then the divisor should be 2^n*5^m
+            for (int i = 0; i < RADIX_FACTORS[this.radix].length; i++)
+            {
+                long factor = RADIX_FACTORS[this.radix][i],
+                        quotient;
+
+                // Keep dividing by factor as long as dividend % factor == 0
+                // that is remove factors of the base from the divisor
+                while ((dividend - factor * (quotient = (long) (long) (dividend / factor))) == 0)
+                {
+                    dividend = quotient;
+                }
+            }
+
+            // Check if the divisor was factored all the way to one by just dividing by factors of the base
+            if (dividend != (long) 1)
+            {
+                // Divisor does not contain only factors of the base; infinite nonzero sequence
+
+                if (basePrecision == Apfloat.INFINITE)
+                {
+                    throw new InfiniteExpansionException("Cannot perform inexact division to infinite precision");
+                }
+
+                size = basePrecision;
+            }
+            else
+            {
+                // Divisor contains only factors of the base; calculate maximum sequence length
+                carry = (long) 1;
+                DataStorage.Iterator dummy = new DataStorage.Iterator()
+                {
+                    public void setLong(long value) {}
+                    public void next() {}
+                    private static final long serialVersionUID = 1L;
+                };
+                long sequenceSize;
+                for (sequenceSize = 0; carry != 0; sequenceSize++)
+                {
+                    carry = additionStrategy.divide(null, divisor, carry, dummy, 1);
+                }
+
+                size = Math.min(basePrecision, thisDataSize + sequenceSize);
+            }
+
+            // One extra word for result in case the initial word becomes zero; to avoid loss of precision
+            size++;
+
+            dataStorage = createDataStorage(size);
+            dataStorage.setSize(size);
+
+            DataStorage.Iterator src = this.dataStorage.iterator(DataStorage.READ, 0, thisDataSize),
+                                 dst = dataStorage.iterator(DataStorage.WRITE, 0, size);
+
+            // Perform actual division
+            carry = additionStrategy.divide(src, divisor, (long) 0, dst, thisDataSize);
+
+            // Produce the trailing sequence of digits due to inexact division
+            carry = additionStrategy.divide(null, divisor, carry, dst, size - thisDataSize);
+
+            size -= getTrailingZeros(dataStorage, size);
+
+            // Check if initial word of result is zero
+            int leadingZeros = (getMostSignificantWord() < divisor ? 1 : 0);
+
+            dataStorage = dataStorage.subsequence(leadingZeros, size - leadingZeros);
+            exponent -= leadingZeros;
+
+            if (exponent < -MAX_EXPONENT[this.radix])
+            {
+                // Underflow
+                return zero();
+            }
+
+            dataStorage.setReadOnly();
+        }
+
+        return new LongApfloatImpl(sign, precision, exponent, dataStorage, this.radix);
+    }
+
+    public ApfloatImpl absFloor()
+        throws ApfloatRuntimeException
+    {
+        if (this.sign == 0 ||
+            this.exponent >= this.dataStorage.getSize())        // Is integer already, with no extra hidden trailing digits
+        {
+            return precision(Apfloat.INFINITE);
+        }
+        else if (this.exponent <= 0)                            // Is less than one in absolute value
+        {
+            return zero();
+        }
+
+        long size = this.exponent;                              // Size of integer part, now that this.dataStorage.getSize() > this.exponent
+        size -= getTrailingZeros(this.dataStorage, size);
+
+        DataStorage dataStorage = this.dataStorage.subsequence(0, size);
+
+        ApfloatImpl apfloatImpl = new LongApfloatImpl(this.sign, Apfloat.INFINITE, this.exponent, dataStorage, this.radix);
+
+        return apfloatImpl;
+    }
+
+    public ApfloatImpl absCeil()
+        throws ApfloatRuntimeException
+    {
+        if (this.sign == 0)
+        {
+            return this;
+        }
+
+        long exponent;
+        DataStorage dataStorage;
+        DataStorage.Iterator iterator = null;
+
+        if (this.exponent <= 0)
+        {
+            // Number is < 1 but > 0; result is one
+            int size = 1;
+            dataStorage = createDataStorage(size);
+            dataStorage.setSize(size);
+            ArrayAccess arrayAccess = dataStorage.getArray(DataStorage.WRITE, 0, size);
+            arrayAccess.getLongData()[arrayAccess.getOffset()] = (long) 1;
+            arrayAccess.close();
+
+            exponent = 1;
+        }
+        else if (getSize() <= this.exponent ||          // Check if the fractional part is nonzero
+                 findMismatch(iterator = getZeroPaddedIterator(this.exponent, getSize()), ZERO_ITERATOR, getSize() - this.exponent) < 0)
+        {
+            // Fractional part is zero; the result is the number itself (to infinite precision)
+            long size = Math.min(this.dataStorage.getSize(), this.exponent);
+            size -= getTrailingZeros(this.dataStorage, size);
+            dataStorage = this.dataStorage.subsequence(0, size);        // Ensure truncation
+
+            exponent = this.exponent;
+        }
+        else
+        {
+            // Fractional part is nonzero; round up
+
+            ApfloatContext ctx = ApfloatContext.getContext();
+            AdditionBuilder<Long> additionBuilder = ctx.getBuilderFactory().getAdditionBuilder(Long.TYPE);
+            AdditionStrategy<Long> additionStrategy = additionBuilder.createAddition(this.radix);
+
+            long size = this.exponent;                  // Size of integer part
+            dataStorage = createDataStorage(size + 1);     // Reserve room for carry overflow
+            dataStorage.setSize(size + 1);
+            DataStorage.Iterator src = this.dataStorage.iterator(DataStorage.READ, size, 0),
+                                 dst = dataStorage.iterator(DataStorage.WRITE, size + 1, 0);
+            long carry = additionStrategy.add(src, null, (long) 1, dst, size);     // Add carry
+            dst.setLong(carry);                      // Set leading long as overflow carry
+            src.close();
+            dst.close();
+            int carrySize = (int) carry;                // For adjusting size, if carry did overflow or not
+            size -= getTrailingZeros(dataStorage, size + 1);
+            dataStorage = dataStorage.subsequence(1 - carrySize, size + carrySize);
+
+            exponent = this.exponent + carrySize;
+        }
+
+        if (iterator != null)
+        {
+            iterator.close();
+        }
+
+        dataStorage.setReadOnly();
+
+        ApfloatImpl apfloatImpl = new LongApfloatImpl(this.sign, Apfloat.INFINITE, exponent, dataStorage, this.radix);
+
+        return apfloatImpl;
+    }
+
+    public ApfloatImpl frac()
+        throws ApfloatRuntimeException
+    {
+        if (this.sign == 0 ||
+            this.exponent <= 0)                                 // Is less than one in absolute value already
+        {
+            return this;
+        }
+        if (this.exponent >= getSize())                         // Is an integer, fractional part is zero
+        {
+            return zero();
+        }
+
+        long size = this.dataStorage.getSize() - this.exponent; // Size of fractional part, now that getSize() > this.exponent
+        long leadingZeros = getLeadingZeros(this.dataStorage, this.exponent);
+        if (this.exponent + leadingZeros >= getSize())
+        {
+            // All significant digits were lost, only trailing garbage digits
+            return zero();
+        }
+
+        DataStorage dataStorage = this.dataStorage.subsequence(this.exponent + leadingZeros, size - leadingZeros);
+
+        long precision;
+        if (this.precision != Apfloat.INFINITE)
+        {
+            // Precision is reduced as the integer part is omitted, plus any leading zeros
+            precision = this.precision - getInitialDigits() - (this.exponent + leadingZeros) * BASE_DIGITS[this.radix] + getInitialDigits(dataStorage);
+            if (precision <= 0)
+            {
+                // All significant digits were lost anyway, only trailing garbage digits
+                return zero();
+            }
+        }
+        else
+        {
+            precision = Apfloat.INFINITE;
+        }
+
+        long exponent = -leadingZeros;
+
+        ApfloatImpl apfloatImpl = new LongApfloatImpl(this.sign, precision, exponent, dataStorage, this.radix);
+
+        return apfloatImpl;
+    }
+
+    private ApfloatImpl zero()
+    {
+        return new LongApfloatImpl(0, Apfloat.INFINITE, 0, null, this.radix);
+    }
+
+    public int radix()
+    {
+        return this.radix;
+    }
+
+    public long precision()
+    {
+        return this.precision;
+    }
+
+    public long size()
+        throws ApfloatRuntimeException
+    {
+        assert (this.dataStorage != null);
+
+        if (this.size == 0)
+        {
+            // Writes and reads of volatile long values are always atomic so multiple threads can read and write this at the same time
+            this.size = getInitialDigits() + (getSize() - 1) * BASE_DIGITS[this.radix] - getLeastZeros();
+        }
+
+        return this.size;
+    }
+
+    // Get number of trailing zeros
+    private long getLeastZeros()
+        throws ApfloatRuntimeException
+    {
+        if (this.leastZeros == UNDEFINED)
+        {
+            // Cache the value
+            // NOTE: This is not synchronized; it's OK if multiple threads set this at the same time
+            // Writes and reads of volatile long values are always atomic so multiple threads can read and write this at the same time
+            long index = getSize() - 1;
+            long word = getWord(index);
+            word = getLeastSignificantWord(index, word);
+
+            long leastZeros = 0;
+            if (word == 0)
+            {
+                // Usually the last word is nonzero but in case precision was later changed, it might be zero
+                long trailingZeros = getTrailingZeros(this.dataStorage, index) + 1;
+                index -= trailingZeros;
+                word = getWord(index);
+                word = getLeastSignificantWord(index, word);
+
+                leastZeros += trailingZeros * BASE_DIGITS[this.radix];
+            }
+
+            assert (word != 0);
+
+            while (word % this.radix == 0)
+            {
+                leastZeros++;
+                word /= this.radix;
+            }
+            this.leastZeros = leastZeros;
+        }
+
+        return this.leastZeros;
+    }
+
+    public ApfloatImpl precision(long precision)
+    {
+        if (this.sign == 0 || precision == this.precision)
+        {
+            return this;
+        }
+        else
+        {
+            return new LongApfloatImpl(this.sign, precision, this.exponent, this.dataStorage, this.radix);
+        }
+    }
+
+    public long scale()
+        throws ApfloatRuntimeException
+    {
+        assert (this.dataStorage != null);
+
+        return (this.exponent - 1) * BASE_DIGITS[this.radix] + getInitialDigits();
+    }
+
+    public int signum()
+    {
+        return this.sign;
+    }
+
+    public ApfloatImpl negate()
+        throws ApfloatRuntimeException
+    {
+        return new LongApfloatImpl(-this.sign, this.precision, this.exponent, this.dataStorage, this.radix);
+    }
+
+    public double doubleValue()
+    {
+        if (this.sign == 0)
+        {
+            return 0.0;
+        }
+
+        double value = 0.0,
+               doubleBase = (double) BASE[this.radix];
+
+        int size = (int) Math.min(MAX_DOUBLE_SIZE, getSize());
+
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.READ, size, 0);
+
+        while (iterator.hasNext())
+        {
+            value += (double) iterator.getLong();
+            value /= doubleBase;
+            iterator.next();
+        }
+
+        // If the end result fits in a double, any intermediate calculation must not overflow
+        // Note that 1/BASE <= value < 1
+        if (this.exponent > 0)
+        {
+            return this.sign * value * Math.pow((double) BASE[this.radix], (double) (this.exponent - 1)) * BASE[this.radix];
+        }
+        else
+        {
+            return this.sign * value * Math.pow((double) BASE[this.radix], (double) this.exponent);
+        }
+    }
+
+    public long longValue()
+    {
+        if (this.sign == 0 || this.exponent <= 0)
+        {
+            return 0;
+        }
+        else if (this.exponent > MAX_LONG_SIZE)
+        {
+            // Overflow for sure
+            return (this.sign > 0 ? Long.MAX_VALUE : Long.MIN_VALUE);
+        }
+
+        long value = 0,
+             longBase = (long) BASE[this.radix],
+             maxPrevious = Long.MIN_VALUE / longBase;
+
+        // Number of words in integer part of the number
+        int size = (int) Math.min(this.exponent, getSize());
+
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.READ, 0, size);
+
+        for (int i = 0; i < (int) this.exponent; i++)
+        {
+            if (value < maxPrevious)
+            {
+                // Overflow
+                value = 0;
+                iterator.close();
+                break;
+            }
+            value *= longBase;
+            if (i < size)
+            {
+                value -= (long) iterator.getLong();      // Calculate value negated to handle 0x8000000000000000
+                iterator.next();
+            }
+        }
+
+        if (value == Long.MIN_VALUE || value >= 0)
+        {
+            // Overflow
+            return (this.sign > 0 ? Long.MAX_VALUE : Long.MIN_VALUE);
+        }
+        else
+        {
+            return -this.sign * value;
+        }
+    }
+
+    // If this ApfloatImpl is equal to 1
+    public boolean isOne()
+        throws ApfloatRuntimeException
+    {
+        if (this.isOne == UNDEFINED)
+        {
+            // Cache the value
+            // NOTE: This is not synchronized; it's OK if multiple threads set this at the same time
+            this.isOne = (this.sign == 1 && this.exponent == 1 && getSize() == 1 && getMostSignificantWord() == (long) 1 ? 1 : 0);
+        }
+
+        return (this.isOne == 1);
+    }
+
+    public long equalDigits(ApfloatImpl x)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof LongApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        LongApfloatImpl that = (LongApfloatImpl) x;
+
+        if (this.sign == 0 && that.sign == 0)           // Both are zero
+        {
+            return Apfloat.INFINITE;
+        }
+        else if (this.sign != that.sign)                // No match
+        {
+            return 0;
+        }
+        else if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot compare values with different radixes: " + this.radix + " and " + that.radix);
+        }
+
+        long thisScale = scale(),
+             thatScale = that.scale(),
+             minScale = Math.min(thisScale, thatScale),
+             maxScale = Math.max(thisScale, thatScale);
+
+        if (maxScale - 1 > minScale)                    // No match
+        {
+            return 0;
+        }
+
+        // Need to compare mantissas
+        long thisSize = getSize(),
+             thatSize = that.getSize(),
+             size = Math.max(thisSize, thatSize);
+        DataStorage.Iterator thisIterator = getZeroPaddedIterator(0, thisSize),
+                             thatIterator = that.getZeroPaddedIterator(0, thatSize);
+
+        long index,
+             result = Math.min(this.precision, that.precision);         // If mantissas are identical
+        int lastMatchingDigits = -1;                                    // Will be used for deferred comparison hanging in last word, e.g. this = 1.000000000, that = 0.999999999
+        long carry,
+                base = BASE[this.radix];
+
+        if (this.exponent > that.exponent)
+        {
+            // Possible case this = 1.0000000, that = 0.9999999
+            long value = thisIterator.getLong();                  // Check first word
+
+            if (value != (long) 1)
+            {
+                // No match
+                thisIterator.close();
+                thatIterator.close();
+
+                return 0;
+            }
+
+            carry = base;
+            thisIterator.next();
+        }
+        else if (this.exponent < that.exponent)
+        {
+            // Possible case this = 0.9999999, that = 1.0000000
+            long value = thatIterator.getLong();                  // Check first word
+
+            if (value != (long) 1)
+            {
+                // No match
+                thisIterator.close();
+                thatIterator.close();
+
+                return 0;
+            }
+
+            carry = -base;
+            thatIterator.next();
+        }
+        else
+        {
+            // Trivial case, e.g. this = 111234, that = 111567
+            carry = 0;
+        }
+
+        // Calculate this - that, stopping at first difference
+        for (index = 0; index < size; index++)
+        {
+            long value = thisIterator.getLong() - thatIterator.getLong() + carry;
+
+            if (value == 0)
+            {
+                // Trivial case; words are equal
+                carry = 0;
+            }
+            else if (Math.abs(value) > (long) 1)
+            {
+                // Mismatch found
+                if (Math.abs(value) >= base)
+                {
+                    // Deferred comparison, e.g. this = 1.0000000002, that = 0.9999999991
+                    lastMatchingDigits = -1;
+                }
+                else
+                {
+                    // Any trivial cases and e.g. this = 1.0000000001, that = 0.9999999992
+                    lastMatchingDigits = BASE_DIGITS[this.radix] - getDigits(Math.abs(value));
+                }
+
+                break;
+            }
+            else if (value == (long) 1)
+            {
+                // Case this = 1.0000000..., that = 0.9999999...
+                carry = base;
+            }
+            else if (value == (long) -1)
+            {
+                // Case this = 0.9999999..., that = 1.0000000...
+                carry = -base;
+            }
+
+            thisIterator.next();
+            thatIterator.next();
+        }
+
+        if (index < size || carry != 0)                 // Mismatch found
+        {
+            long initialMatchingDigits = (this.exponent == that.exponent ?
+                                          Math.min(getInitialDigits(), that.getInitialDigits()) :       // Normal case, e.g. this = 10, that = 5
+                                          BASE_DIGITS[this.radix]);                                     // Special case, e.g. this = 1.0, that = 0.9
+
+            // Note that this works even if index == 0
+            long middleMatchingDigits = (index - 1) * BASE_DIGITS[this.radix];                          // This is correct even if exponents are different
+
+            // Limit by available precision
+            result = Math.min(result, initialMatchingDigits + middleMatchingDigits + lastMatchingDigits);
+
+            // Handle some cases e.g. 0.15 vs. 0.04
+            result = Math.max(result, 0);
+        }
+
+        thisIterator.close();
+        thatIterator.close();
+
+        return result;
+    }
+
+    public int compareTo(ApfloatImpl x)
+        throws ApfloatRuntimeException
+    {
+        if (!(x instanceof LongApfloatImpl))
+        {
+            throw new ImplementationMismatchException("Wrong operand type: " + x.getClass().getName());
+        }
+
+        LongApfloatImpl that = (LongApfloatImpl) x;
+
+        if (this.sign == 0 && that.sign == 0)
+        {
+            return 0;
+        }
+        else if (this.sign < that.sign)                 // Now we know that not both are zero
+        {
+            return -1;
+        }
+        else if (this.sign > that.sign)
+        {
+            return 1;
+        }
+        else if (this.radix != that.radix)
+        {
+            throw new RadixMismatchException("Cannot compare values with different radixes: " + this.radix + " and " + that.radix);
+        }
+        else if (scale() < that.scale())                // Now we know that both have same sign (which is not zero)
+        {
+            return -this.sign;
+        }
+        else if (scale() > that.scale())
+        {
+            return this.sign;
+        }
+
+        // Need to compare mantissas
+        return this.sign * compareMantissaTo(that);
+    }
+
+    // Returns an iterator for this number's data storage from start to end,
+    // least significant word is correctly truncated with getLeastSignificantWord(),
+    // after that the iterator returns zeros only
+    private DataStorage.Iterator getZeroPaddedIterator(final long start, final long end)
+        throws ApfloatRuntimeException
+    {
+        final DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.READ, start, end);
+
+        return new DataStorage.Iterator()
+        {
+            public long getLong()
+                throws ApfloatRuntimeException
+            {
+                long value;
+
+                if (this.index < end)
+                {
+                    value = iterator.getLong();
+                    if (this.index == end - 1)
+                    {
+                        value = getLeastSignificantWord(this.index, value);
+                    }
+                }
+                else
+                {
+                    value = 0;
+                }
+
+                return value;
+            }
+
+            public void next()
+                throws ApfloatRuntimeException
+            {
+                if (this.index < end)
+                {
+                    iterator.next();
+                    this.index++;
+                }
+            }
+
+            public void close()
+                throws ApfloatRuntimeException
+            {
+                iterator.close();
+            }
+
+            private static final long serialVersionUID = 1L;
+
+            private long index = start;
+        };
+    }
+
+    // Compare absolute values of mantissas
+    private int compareMantissaTo(LongApfloatImpl that)
+        throws ApfloatRuntimeException
+    {
+        long thisSize = getSize(),
+             thatSize = that.getSize(),
+             size = Math.max(thisSize, thatSize);
+        DataStorage.Iterator thisIterator = getZeroPaddedIterator(0, thisSize),
+                             thatIterator = that.getZeroPaddedIterator(0, thatSize);
+        int result = 0;
+
+        long index = findMismatch(thisIterator, thatIterator, size);
+
+        if (index >= 0)                 // Mismatch found
+        {
+            long thisValue = thisIterator.getLong(),
+                    thatValue = thatIterator.getLong();
+
+            if (thisValue < thatValue)
+            {
+                result = -1;
+            }
+            else if (thisValue > thatValue)
+            {
+                result = 1;
+            }
+        }
+
+        thisIterator.close();
+        thatIterator.close();
+
+        return result;
+    }
+
+    // Returns index of first mismatching long, or -1 if mantissas are equal
+    // Iterators are left to point to the mismatching words
+    private long findMismatch(DataStorage.Iterator thisIterator, DataStorage.Iterator thatIterator, long size)
+        throws ApfloatRuntimeException
+    {
+        for (long index = 0; index < size; index++)
+        {
+            long thisValue = thisIterator.getLong(),
+                    thatValue = thatIterator.getLong();
+
+            if (thisValue != thatValue)
+            {
+                return index;
+            }
+
+            thisIterator.next();
+            thatIterator.next();
+        }
+
+        // All searched words matched exactly
+        return -1;
+    }
+
+    // Truncate insignificant digits from the last long of the number
+    private long getLeastSignificantWord(long index, long word)
+        throws ApfloatRuntimeException
+    {
+        if (this.precision == Apfloat.INFINITE)
+        {
+            return word;
+        }
+
+        // Total digits including the specified index
+        long digits = getInitialDigits() + index * BASE_DIGITS[this.radix];
+
+        if (this.precision >= digits)
+        {
+            return word;
+        }
+
+        // Assert that the second array access will not be out of bounds
+        long divisor = MINIMUM_FOR_DIGITS[this.radix][(int) (digits - this.precision)];
+
+        return (long) (long) (word / divisor) * divisor;
+    }
+
+    /**
+     * Compares this object to the specified object.
+     *
+     * @param obj The object to compare with.
+     *
+     * @return <code>true</code> if the objects are equal; <code>false</code> otherwise.
+     */
+
+    public boolean equals(Object obj)
+    {
+        if (!(obj instanceof ApfloatImpl))
+        {
+            return false;
+        }
+
+        ApfloatImpl thatImpl = (ApfloatImpl) obj;
+
+        // Special comparisons against Apfloat.ZERO and Apfloat.ONE work regardless of radix or implementation class
+        if (signum() == 0 && thatImpl.signum() == 0)
+        {
+            return true;
+        }
+        else if (isOne() && thatImpl.isOne())
+        {
+            return true;
+        }
+
+        if (!(obj instanceof LongApfloatImpl))
+        {
+            return false;
+        }
+
+        LongApfloatImpl that = (LongApfloatImpl) obj;
+
+        if (this.radix != that.radix)
+        {
+            // Limitation: cannot compare values with different radixes
+            return false;
+        }
+        else if (this.sign != that.sign ||
+                 this.exponent != that.exponent)
+        {
+            return false;
+        }
+        else
+        {
+            // Need to compare mantissas
+            return compareMantissaTo(that) == 0;
+        }
+    }
+
+    public int hashCode()
+    {
+        if (this.hashCode == 0)
+        {
+            // Cache the value
+            // NOTE: This is not synchronized; it's OK if multiple threads set this at the same time
+            int hashCode = 1 + this.sign + (int) this.exponent + (int) (this.exponent >>> 32);
+
+            if (this.dataStorage != null)
+            {
+                long size = getSize();
+
+                // Scan through log(size) scattered words in the mantissa
+                for (long i = 0; i < size; i = i + i + 1)
+                {
+                    long word = getWord(i);
+
+                    if (i == size - 1)
+                    {
+                        word = getLeastSignificantWord(i, word);
+                    }
+
+                    long element = (long) word;
+                    hashCode += (int) element + (int) (element >>> 32);
+                }
+            }
+
+            this.hashCode = hashCode;
+        }
+
+        return this.hashCode;
+    }
+
+    public String toString(boolean pretty)
+        throws ApfloatRuntimeException
+    {
+        if (this.sign == 0)
+        {
+            return "0";
+        }
+
+        long size = getSize() * BASE_DIGITS[this.radix],    // This is a rounded up value
+             length;
+        if (pretty)
+        {
+             long scale = scale();
+             if (scale <= 0)
+             {
+                 length = 2 - scale + size;         // Format is 0.xxxx or 0.0000xxx
+             }
+             else if (size > scale)
+             {
+                 length = 1 + size;                 // Format is x.xxx
+             }
+             else
+             {
+                 length = scale;                    // Format is xxxx or xxxx0000
+             }
+             length += (this.sign < 0 ? 1 : 0);     // Room for minus sign
+        }
+        else
+        {
+            length = size + 24;     // Sign, "0.", "e", exponent sign and 19 digits of exponent
+        }
+
+        if (length > Integer.MAX_VALUE || length < 0)           // Detect overflow
+        {
+            throw new ApfloatInternalException("Number is too large to fit in a String");
+        }
+
+        StringWriter writer = new StringWriter((int) length);
+
+        try
+        {
+            writeTo(writer, pretty);
+        }
+        catch (IOException ioe)
+        {
+            throw new ApfloatInternalException("Unexpected I/O error writing to StringWriter", ioe);
+        }
+
+        String value = writer.toString();
+
+        assert (value.length() <= length);      // Postcondition to ensure performance
+
+        return value;
+    }
+
+    private static void writeZeros(Writer out, long count)
+        throws IOException
+    {
+        for (long i = 0; i < count; i++)
+        {
+            out.write('0');
+        }
+    }
+
+    public void writeTo(Writer out, boolean pretty)
+        throws IOException, ApfloatRuntimeException
+    {
+        if (this.sign == 0)
+        {
+            out.write('0');
+            return;
+        }
+
+        if (this.sign < 0)
+        {
+            out.write('-');
+        }
+
+        long integerDigits,                 // Number of digits to write before the decimal point
+             exponent;                      // Exponent to print
+
+        if (pretty)
+        {
+            if (this.exponent <= 0)
+            {
+                out.write("0.");            // Output is 0.xxxx
+                writeZeros(out, -scale());  // Print leading zeros after decimal point before first nonzero digit
+                integerDigits = -1;         // Decimal point is already written
+            }
+            else
+            {
+                integerDigits = scale();    // Decimal point location
+            }
+            exponent = 0;                   // Do not print exponent
+        }
+        else
+        {
+            integerDigits = 1;              // Always write as x.xxxey
+            exponent = scale() - 1;         // Print exponent
+        }
+
+        boolean leftPadZeros = false;       // If the written base unit should be left-padded with zeros
+        long size = getSize(),
+             digitsToWrite = Math.min(this.precision, getInitialDigits() + (size - 1) * BASE_DIGITS[this.radix]),
+             digitsWritten = 0,
+             trailingZeros = 0;
+        DataStorage.Iterator iterator = this.dataStorage.iterator(DataStorage.READ, 0, size);
+        char[] buffer = new char[BASE_DIGITS[this.radix]];
+
+        while (size > 0)
+        {
+            int start = (leftPadZeros ? 0 : BASE_DIGITS[this.radix] - getInitialDigits()),
+                digits = (int) Math.min(digitsToWrite, BASE_DIGITS[this.radix] - start);
+
+            formatWord(buffer, iterator.getLong());
+
+            for (int i = 0; i < digits; i++)
+            {
+                int c = buffer[start + i];
+                if (c == '0')
+                {
+                    trailingZeros++;
+                    digitsToWrite--;
+                }
+                else
+                {
+                    while (trailingZeros > 0)
+                    {
+                        if (digitsWritten == integerDigits)
+                        {
+                            out.write('.');
+                        }
+                        out.write('0');
+                        digitsWritten++;
+                        trailingZeros--;
+                    }
+                    if (digitsWritten == integerDigits)
+                    {
+                        out.write('.');
+                    }
+                    out.write(c);
+                    digitsWritten++;
+                    digitsToWrite--;
+                }
+            }
+            leftPadZeros = true;                        // Always pad with zeros after first word
+
+            iterator.next();
+            size--;
+        }
+
+        if (!pretty && exponent != 0)
+        {
+            out.write("e" + exponent);
+        }
+
+        writeZeros(out, integerDigits - digitsWritten); // If format is xxxx0000
+    }
+
+    private void formatWord(char[] buffer, long word)
+    {
+        int position = BASE_DIGITS[this.radix];
+        while (position > 0 && word > 0)
+        {
+            long newWord = (long) (long) (word / this.radix);
+            int digit = (int) (word -  newWord * this.radix);
+            word = newWord;
+            position--;
+            buffer[position] = Character.forDigit(digit, this.radix);
+        }
+
+        // Left pad zeros
+        while (position > 0)
+        {
+            position--;
+            buffer[position] = '0';
+        }
+    }
+
+    // Effective size, in longs
+    private long getSize()
+        throws ApfloatRuntimeException
+    {
+        assert (this.dataStorage != null);
+
+        return Math.min(getBasePrecision(),
+                        this.dataStorage.getSize());
+    }
+
+    private static int checkRadix(int radix)
+        throws NumberFormatException
+    {
+        if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)
+        {
+            throw new NumberFormatException("Invalid radix " + radix + "; radix must be between " + Character.MIN_RADIX + " and " + Character.MAX_RADIX);
+        }
+
+        return radix;
+    }
+
+    // Get the most significant word of this number
+    private long getMostSignificantWord()
+        throws ApfloatRuntimeException
+    {
+        return getMostSignificantWord(this.dataStorage);
+    }
+
+    // Get the most significant word of the specified data storage
+    private static long getMostSignificantWord(DataStorage dataStorage)
+        throws ApfloatRuntimeException
+    {
+        long msw;
+
+        ArrayAccess arrayAccess = dataStorage.getArray(DataStorage.READ, 0, 1);
+        msw = arrayAccess.getLongData()[arrayAccess.getOffset()];
+        arrayAccess.close();
+
+        return msw;
+    }
+
+    // Get number of digits in the most significant word
+    private int getInitialDigits()
+        throws ApfloatRuntimeException
+    {
+        if (this.initialDigits == UNDEFINED)
+        {
+            // Cache the value
+            // NOTE: This is not synchronized; it's OK if multiple threads set this at the same time
+            this.initialDigits = getDigits(getMostSignificantWord());
+        }
+
+        return this.initialDigits;
+    }
+
+    // Get number of digits in the most significant word of specified data
+    private int getInitialDigits(DataStorage dataStorage)
+        throws ApfloatRuntimeException
+    {
+        return getDigits(getMostSignificantWord(dataStorage));
+    }
+
+    // Gets the number of digits in the specified long and this number's radix
+    private int getDigits(long x)
+    {
+        assert (x > 0);
+
+        long[] minimums = MINIMUM_FOR_DIGITS[this.radix];
+        int i = minimums.length;
+
+        while (x < minimums[--i])
+        {
+        }
+
+        return i + 1;
+    }
+
+    // Gets the precision in longs
+    private long getBasePrecision()
+        throws ApfloatRuntimeException
+    {
+        return getBasePrecision(this.precision, getInitialDigits());
+    }
+
+    // Gets the precision in longs, based on specified precision (in digits),
+    // number of digits in most significant word and this number's radix
+    private long getBasePrecision(long precision, int mswDigits)
+    {
+        if (precision == Apfloat.INFINITE)
+        {
+            return Apfloat.INFINITE;
+        }
+        else
+        {
+            return (precision + BASE_DIGITS[this.radix] - mswDigits - 1) / BASE_DIGITS[this.radix] + 1;
+        }
+    }
+
+    private long getWord(long index)
+    {
+        ArrayAccess arrayAccess = this.dataStorage.getArray(DataStorage.READ, index, 1);
+        long word = arrayAccess.getLongData()[arrayAccess.getOffset()];
+        arrayAccess.close();
+
+        return word;
+    }
+
+    private void readObject(ObjectInputStream in)
+        throws IOException, ClassNotFoundException
+    {
+        this.leastZeros = UNDEFINED;
+        this.isOne = UNDEFINED;
+        in.defaultReadObject();
+    }
+
+    // Gets a new data storage for specified size
+    private static DataStorage createDataStorage(long size)
+        throws ApfloatRuntimeException
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        return dataStorageBuilder.createDataStorage(size * 8);
+    }
+
+    // Gets I/O block size in longs
+    private static int getBlockSize()
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        return ctx.getBlockSize() / 8;
+    }
+
+    private static final DataStorage.Iterator ZERO_ITERATOR =
+    new DataStorage.Iterator()
+    {
+        public long getLong() { return 0; }
+        public void next() { }
+        private static final long serialVersionUID = 1L;
+    };
+
+    private static final long serialVersionUID = -2151344673641680085L;
+
+    private static final int UNDEFINED = 0x80000000;
+    private static final int MAX_LONG_SIZE = 4;
+    private static final int MAX_DOUBLE_SIZE = 4;
+
+    private int sign;
+    private long precision;
+    private long exponent;
+    private DataStorage dataStorage;
+    private int radix;
+    private int hashCode = 0;
+    private int initialDigits = UNDEFINED;
+    private int isOne = UNDEFINED;
+    private volatile long leastZeros = UNDEFINED;
+    private volatile long size = 0;
+}
Index: src/main/java/org/apfloat/internal/LongBaseMath.java
===================================================================
--- src/main/java/org/apfloat/internal/LongBaseMath.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongBaseMath.java	(revision 0)
@@ -0,0 +1,243 @@
+package org.apfloat.internal;
+
+import java.io.Serializable;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+import static org.apfloat.internal.LongRadixConstants.*;
+
+/**
+ * Mathematical operations on numbers in a base.
+ * Implementation for the <code>long</code> type.
+ *
+ * @version 1.8.2
+ * @author Mikko Tommila
+ */
+
+public class LongBaseMath
+    implements Serializable
+{
+    /**
+     * Creates a base math using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public LongBaseMath(int radix)
+    {
+        this.radix = radix;
+        this.inverseBase = 1.0 / BASE[radix];
+    }
+
+    /**
+     * Addition in some base. Adds the data words
+     * of <code>src1</code> and <code>src2</code> and stores the result to
+     * <code>dst</code>. <code>src2</code> may be <code>null</code>, in
+     * which case it is ignored (only the carry is propagated).<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] + src2[i]</code>.
+     *
+     * @param src1 First source data sequence. Can be <code>null</code>, in which case it's ignored.
+     * @param src2 Second source data sequence. Can be <code>null</code>, in which case it's ignored.
+     * @param carry Input carry bit. This is added to the first (rightmost) word in the accessed sequence.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Overflow carry bit. Propagated carry bit from the addition of the last (leftmost) word in the accessed sequence.
+     */
+
+    public long baseAdd(DataStorage.Iterator src1, DataStorage.Iterator src2, long carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (src1 == null || src1 != src2);
+
+        boolean sameDst = (src1 == dst || src2 == dst);
+        long base = BASE[this.radix];
+
+        for (long i = 0; i < size; i++)
+        {
+            long result = (src1 == null ? 0 : src1.getLong()) + carry +
+                          (src2 == null ? 0 : src2.getLong());
+
+            carry = (result >= base ? 1 : 0);
+            result -= (result >= base ? base : 0);
+
+            dst.setLong(result);
+
+            if (src1 != null) src1.next();
+            if (src2 != null) src2.next();
+            if (!sameDst) dst.next();
+        }
+
+        return carry;
+    }
+
+    /**
+     * Subtraction in some base. Subtracts the data words
+     * of <code>src1</code> and <code>src2</code> and stores the result to
+     * <code>dst</code>. <code>src1</code> and <code>src2</code> may be
+     * <code>null</code>, in which case they are ignored (the values are assumed
+     * to be zero and only the carry is propagated).<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] - src2[i]</code>.
+     *
+     * @param src1 First source data sequence. Can be <code>null</code>, in which case the input values are assumed to be zero.
+     * @param src2 Second source data sequence. Can be <code>null</code>, in which case it's ignored, or can be the same as <code>dst</code>.
+     * @param carry Input carry bit. This is subtracted from the first (rightmost) word in the accessed sequence.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Overflow carry bit. Propagated carry bit from the subtraction of the last (leftmost) word in the accessed sequence. The value is <code>1</code> if the carry is set, and <code>0</code> otherwise.
+     */
+
+    public long baseSubtract(DataStorage.Iterator src1, DataStorage.Iterator src2, long carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (src1 == null || src1 != src2);
+        assert (src2 != dst);
+
+        long base = BASE[this.radix];
+
+        for (long i = 0; i < size; i++)
+        {
+            long result = (src1 == null ? 0 : src1.getLong()) - carry -
+                          (src2 == null ? 0 : src2.getLong());
+
+            carry = (result < 0 ? 1 : 0);
+            result += (result < 0 ? base : 0);
+
+            dst.setLong(result);
+
+            if (src1 != null && src1 != dst) src1.next();
+            if (src2 != null) src2.next();
+            dst.next();
+        }
+
+        return carry;
+    }
+
+    /**
+     * Multiplication and addition in some base. Multiplies the data words
+     * of <code>src1</code> by <code>src3</code> and adds the result to the
+     * words in <code>src2</code>, and stores the result to <code>dst</code>.
+     * <code>src2</code> may be <code>null</code>, in which case it is ignored
+     * (the values are assumed to be zero).<p>
+     *
+     * Assumes that the result from the addition doesn't overflow the upper
+     * result word (to larger than the base). This is the case e.g. when using
+     * this method to perform an arbitrary precision multiplication.<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] * src3 + src2[i]</code>.
+     *
+     * @param src1 First source data sequence.
+     * @param src2 Second source data sequence. Can be <code>null</code>, in which case it's ignored, or can be the same as <code>dst</code>.
+     * @param src3 Multiplicand. All elements of <code>src1</code> are multiplied by this value.
+     * @param carry Input carry word. This is added to the first (rightmost) word in the accessed sequence.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Overflow carry word. Propagated carry word from the multiplication and addition of the last (leftmost) word in the accessed sequence.
+     */
+
+    public long baseMultiplyAdd(DataStorage.Iterator src1, DataStorage.Iterator src2, long src3, long carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (src1 != src2);
+        assert (src1 != dst);
+
+        long base = BASE[this.radix];
+
+        for (long i = 0; i < size; i++)
+        {
+            long a = src1.getLong(),
+                 b = src3;
+
+            carry += (src2 == null ? 0 : src2.getLong());
+            long tmp = a * b + carry;
+            carry = (long) (((double) a * (double) b + (double) carry) * this.inverseBase);
+            tmp -= carry * base;
+            int tmp2 = (int) ((double) tmp * this.inverseBase);
+            carry += tmp2;
+            tmp -= tmp2 * base;
+
+            carry += (tmp >= base ? 1 : 0);
+            tmp -= (tmp >= base ? base : 0);
+            carry += (tmp >= base ? 1 : 0);
+            tmp -= (tmp >= base ? base : 0);
+
+            carry -= (tmp < 0 ? 1 : 0);
+            tmp += (tmp < 0 ? base : 0);
+            carry -= (tmp < 0 ? 1 : 0);
+            tmp += (tmp < 0 ? base : 0);
+
+            dst.setLong(tmp);                           // = a * b % base
+
+            src1.next();
+            if (src2 != null && src2 != dst) src2.next();
+            dst.next();
+        }
+
+        return carry;
+    }
+
+    /**
+     * Division in some base. Divides the data words
+     * of <code>src1</code> by <code>src2</code> and stores the result to
+     * <code>dst</code>. <code>src1</code> may be <code>null</code>,
+     * in which case it is ignored (the values are assumed to be
+     * zero and only the carry division is propagated).<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] / src2</code>.
+     *
+     * @param src1 First source data sequence. Can be <code>null</code>, in which case the input values are assumed to be zero.
+     * @param src2 Divisor. All elements of <code>src1</code> are divided by this value.
+     * @param carry Input carry word. Used as the upper word for the division of the first input element. This should be the remainder word returned from the previous block processed.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Remainder word of the propagated division of the last (rightmost) word in the accessed sequence.
+     */
+
+    public long baseDivide(DataStorage.Iterator src1, long src2, long carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (src1 != dst);
+
+        long base = BASE[this.radix];
+
+        double inverseDivisor = 1.0 / src2;
+
+        for (long i = 0; i < size; i++)
+        {
+            long a = (src1 == null ? 0 : src1.getLong()),
+                 tmp = carry * base + a,
+                 result = (long) (((double) carry * (double) base + (double) a) * inverseDivisor);
+            carry = tmp - result * src2;
+            int tmp2 = (int) ((double) carry * inverseDivisor);
+            result += tmp2;
+            carry -= tmp2 * src2;
+
+            result += (carry >= src2 ? 1 : 0);
+            carry -= (carry >= src2 ? src2 : 0);
+            result += (carry >= src2 ? 1 : 0);
+            carry -= (carry >= src2 ? src2 : 0);
+
+            result -= (carry < 0 ? 1 : 0);
+            carry += (carry < 0 ? src2 : 0);
+            result -= (carry < 0 ? 1 : 0);
+            carry += (carry < 0 ? src2 : 0);
+
+            dst.setLong(result);                        // = carry * base % src2
+
+            if (src1 != null) src1.next();
+            dst.next();
+        }
+
+        return carry;
+    }
+
+    private static final long serialVersionUID = -6469225916787810664L;
+
+    private int radix;
+    private double inverseBase;
+}
Index: src/main/java/org/apfloat/internal/LongBuilderFactory.java
===================================================================
--- src/main/java/org/apfloat/internal/LongBuilderFactory.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongBuilderFactory.java	(revision 0)
@@ -0,0 +1,119 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+
+import org.apfloat.spi.AdditionBuilder;
+import org.apfloat.spi.BuilderFactory;
+import org.apfloat.spi.ApfloatBuilder;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.ConvolutionBuilder;
+import org.apfloat.spi.NTTBuilder;
+import org.apfloat.spi.MatrixBuilder;
+import org.apfloat.spi.CarryCRTBuilder;
+
+/**
+ * Factory class for getting instances of the various builder classes needed
+ * to build an <code>ApfloatImpl</code> with the <code>long</code> data element type.
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class LongBuilderFactory
+    implements BuilderFactory
+{
+    /**
+     * Default constructor.
+     */
+
+    public LongBuilderFactory()
+    {
+    }
+
+    public ApfloatBuilder getApfloatBuilder()
+    {
+        return LongBuilderFactory.apfloatBuilder;
+    }
+
+    public DataStorageBuilder getDataStorageBuilder()
+    {
+        return LongBuilderFactory.dataStorageBuilder;
+    }
+
+    public <T> AdditionBuilder<T> getAdditionBuilder(Class<T> elementType)
+        throws IllegalArgumentException
+    {
+        if (!Long.TYPE.equals(elementType))
+        {
+           throw new IllegalArgumentException("Unsupported element type: " + elementType);
+        }
+        @SuppressWarnings("unchecked")
+        AdditionBuilder<T> additionBuilder = (AdditionBuilder<T>) LongBuilderFactory.additionBuilder;
+        return additionBuilder;
+    }
+
+    public ConvolutionBuilder getConvolutionBuilder()
+    {
+        return LongBuilderFactory.convolutionBuilder;
+    }
+
+    public NTTBuilder getNTTBuilder()
+    {
+        return LongBuilderFactory.nttBuilder;
+    }
+
+    public MatrixBuilder getMatrixBuilder()
+    {
+        return LongBuilderFactory.matrixBuilder;
+    }
+
+    public <T> CarryCRTBuilder<T> getCarryCRTBuilder(Class<T> elementArrayType)
+        throws IllegalArgumentException
+    {
+        if (!long[].class.equals(elementArrayType))
+        {
+           throw new IllegalArgumentException("Unsupported element array type: " + elementArrayType);
+        }
+        @SuppressWarnings("unchecked")
+        CarryCRTBuilder<T> carryCRTBuilder = (CarryCRTBuilder<T>) LongBuilderFactory.carryCRTBuilder;
+        return carryCRTBuilder;
+    }
+
+    public Class<?> getElementType()
+    {
+        return Long.TYPE;
+    }
+
+    public Class<?> getElementArrayType()
+    {
+        return long[].class;
+    }
+
+    public int getElementSize()
+    {
+        return 8;
+    }
+
+    public void shutdown()
+        throws ApfloatRuntimeException
+    {
+        DiskDataStorage.cleanUp();
+    }
+
+    public void gc()
+        throws ApfloatRuntimeException
+    {
+        System.gc();
+        System.gc();
+        System.runFinalization();
+        DiskDataStorage.gc();
+    }
+
+    private static ApfloatBuilder apfloatBuilder = new LongApfloatBuilder();
+    private static DataStorageBuilder dataStorageBuilder = new LongDataStorageBuilder();
+    private static AdditionBuilder<Long> additionBuilder = new LongAdditionBuilder();
+    private static ConvolutionBuilder convolutionBuilder = new LongConvolutionBuilder();
+    private static NTTBuilder nttBuilder = new LongNTTBuilder();
+    private static MatrixBuilder matrixBuilder = new LongMatrixBuilder();
+    private static CarryCRTBuilder<long[]> carryCRTBuilder = new LongCarryCRTBuilder();
+}
Index: src/main/java/org/apfloat/internal/LongCRTMath.java
===================================================================
--- src/main/java/org/apfloat/internal/LongCRTMath.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongCRTMath.java	(revision 0)
@@ -0,0 +1,225 @@
+package org.apfloat.internal;
+
+import static org.apfloat.internal.LongModConstants.*;
+import static org.apfloat.internal.LongRadixConstants.*;
+
+/**
+ * Basic arithmetic for calculating the Chinese Remainder
+ * Theorem. Works for the <code>long</code> type.
+ *
+ * @version 1.6
+ * @author Mikko Tommila
+ */
+
+public class LongCRTMath
+    extends LongBaseMath
+{
+    /**
+     * Creates a carry-CRT math using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public LongCRTMath(int radix)
+    {
+        super(radix);
+        this.base = BASE[radix];
+        this.inverseBase = 1.0 / BASE[radix];
+    }
+
+    /**
+     * Multiplies two words by one word to produce a result of three words.
+     * Most significant word is stored first.
+     *
+     * @param src Source array, first multiplicand.
+     * @param factor Second multiplicand.
+     * @param dst Destination array.
+     */
+
+    public final void multiply(long[] src, long factor, long[] dst)
+    {
+        long tmp = src[1] * factor,
+             carry = (long) ((double) src[1] * (double) factor * INVERSE_MAX_POWER_OF_TWO_BASE);
+        carry += tmp - (carry << MAX_POWER_OF_TWO_BITS) >> MAX_POWER_OF_TWO_BITS;
+
+        dst[2] = tmp & BASE_MASK;               // = tmp % MAX_POWER_OF_TWO_BASE
+
+        tmp = src[0] * factor + carry;
+        carry = (long) (((double) src[0] * (double) factor + (double) carry) * INVERSE_MAX_POWER_OF_TWO_BASE);
+        carry += tmp - (carry << MAX_POWER_OF_TWO_BITS) >> MAX_POWER_OF_TWO_BITS;
+
+        dst[1] = tmp & BASE_MASK;               // = tmp % MAX_POWER_OF_TWO_BASE
+
+        dst[0] = carry;
+    }
+
+    /**
+     * Compares three words. Most significant word is stored first.
+     *
+     * @param src1 First operand.
+     * @param src2 Second operand.
+     *
+     * @return Less than zero if <code>src1 &lt; src2</code>, greater than zero if <code>src1 &gt; src2</code> and zero if <code>src1 == src2</code>.
+     */
+
+    public final long compare(long[] src1, long[] src2)
+    {
+        long result = src1[0] - src2[0];
+
+        if (result != 0)
+        {
+            return result;
+        }
+
+        result = src1[1] - src2[1];
+
+        if (result != 0)
+        {
+            return result;
+        }
+
+        return src1[2] - src2[2];
+    }
+
+    /**
+     * Adds three words. Most significant word is stored first.
+     *
+     * @param src First operand.
+     * @param srcDst Second operand, and destination of the operation.
+     *
+     * @return Overflow carry bit.
+     */
+
+    public final long add(long[] src, long[] srcDst)
+    {
+        long result = srcDst[2] + src[2],
+             carry = (result >= MAX_POWER_OF_TWO_BASE ? 1 : 0);
+        result = (result >= MAX_POWER_OF_TWO_BASE ? result - MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[2] = result;
+
+        result = srcDst[1] + src[1] + carry;
+        carry = (result >= MAX_POWER_OF_TWO_BASE ? 1 : 0);
+        result = (result >= MAX_POWER_OF_TWO_BASE ? result - MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[1] = result;
+
+        result = srcDst[0] + src[0] + carry;
+        carry = (result >= MAX_POWER_OF_TWO_BASE ? 1 : 0);
+        result = (result >= MAX_POWER_OF_TWO_BASE ? result - MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[0] = result;
+
+        return carry;
+    }
+
+    /**
+     * Subtracts three words. Most significant word is stored first.
+     *
+     * @param src First operand.
+     * @param srcDst Second operand, and destination of the operation.
+     */
+
+    public final void subtract(long[] src, long[] srcDst)
+    {
+        long result = srcDst[2] - src[2],
+             carry = (result < 0 ? 1 : 0);
+        result = (result < 0 ? result + MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[2] = result;
+
+        result = srcDst[1] - src[1] - carry;
+        carry = (result < 0 ? 1 : 0);
+        result = (result < 0 ? result + MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[1] = result;
+
+        result = srcDst[0] - src[0] - carry;
+        // carry = (result < 0 ? 1 : 0);
+        result = (result < 0 ? result + MAX_POWER_OF_TWO_BASE : result);
+
+        srcDst[0] = result;
+    }
+
+    /**
+     * Divides three words by the base to produce two words. Most significant word is stored first.
+     *
+     * @param srcDst Source and destination of the operation.
+     *
+     * @return Remainder of the division.
+     */
+
+    public final long divide(long[] srcDst)
+    {
+        long tmp = (srcDst[0] << MAX_POWER_OF_TWO_BITS) + srcDst[1],
+             result = (long) (((double) srcDst[0] * (double) MAX_POWER_OF_TWO_BASE + (double) srcDst[1]) * this.inverseBase),
+             carry = tmp - result * this.base;          // = tmp % divisor
+        int tmp2 = (int) ((double) carry * this.inverseBase);
+        result += tmp2;
+        carry -= tmp2 * this.base;
+
+        if (carry >= this.base)
+        {
+            carry -= this.base;
+            result++;
+        }
+        if (carry >= this.base)
+        {
+            carry -= this.base;
+            result++;
+        }
+        if (carry < 0)
+        {
+            carry += this.base;
+            result--;
+        }
+        if (carry < 0)
+        {
+            carry += this.base;
+            result--;
+        }
+
+        srcDst[0] = 0;
+        srcDst[1] = result;
+
+        tmp = (carry << MAX_POWER_OF_TWO_BITS) + srcDst[2];
+        result = (long) (((double) carry * (double) MAX_POWER_OF_TWO_BASE + (double) srcDst[2]) * this.inverseBase);
+        carry = tmp - result * this.base;               // = tmp % divisor
+        tmp2 = (int) ((double) carry * this.inverseBase);
+        result += tmp2;
+        carry -= tmp2 * this.base;
+
+        if (carry >= this.base)
+        {
+            carry -= this.base;
+            result++;
+        }
+        if (carry >= this.base)
+        {
+            carry -= this.base;
+            result++;
+        }
+        if (carry < 0)
+        {
+            carry += this.base;
+            result--;
+        }
+        if (carry < 0)
+        {
+            carry += this.base;
+            result--;
+        }
+
+        srcDst[2] = result;
+
+        return carry;
+    }
+
+    private static final long serialVersionUID = 7400961005627736773L;
+
+    private static final long BASE_MASK = (1L << MAX_POWER_OF_TWO_BITS) - 1;
+    private static final double INVERSE_MAX_POWER_OF_TWO_BASE = 1.0 / MAX_POWER_OF_TWO_BASE;
+
+    private long base;
+    private double inverseBase;
+}
Index: src/main/java/org/apfloat/internal/LongCarryCRTBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/LongCarryCRTBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongCarryCRTBuilder.java	(revision 0)
@@ -0,0 +1,36 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.CarryCRTBuilder;
+import org.apfloat.spi.CarryCRTStrategy;
+import org.apfloat.spi.CarryCRTStepStrategy;
+
+/**
+ * Creates carry-CRT related objects, for the
+ * <code>long</code> type.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class LongCarryCRTBuilder
+    implements CarryCRTBuilder<long[]>
+{
+    /**
+     * Default constructor.
+     */
+
+    public LongCarryCRTBuilder()
+    {
+    }
+
+    public CarryCRTStrategy createCarryCRT(int radix)
+    {
+        return new StepCarryCRTStrategy(radix);
+    }
+
+    public CarryCRTStepStrategy<long[]> createCarryCRTSteps(int radix)
+    {
+        return new LongCarryCRTStepStrategy(radix);
+    }
+}
Index: src/main/java/org/apfloat/internal/LongCarryCRTStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/LongCarryCRTStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongCarryCRTStepStrategy.java	(revision 0)
@@ -0,0 +1,293 @@
+package org.apfloat.internal;
+
+import java.math.BigInteger;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.CarryCRTStepStrategy;
+import org.apfloat.spi.DataStorage;
+import static org.apfloat.internal.LongModConstants.*;
+
+/**
+ * Class for performing the final steps of a three-modulus
+ * Number Theoretic Transform based convolution. Works for the
+ * <code>long</code> type.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class LongCarryCRTStepStrategy
+    extends LongCRTMath
+    implements CarryCRTStepStrategy<long[]>
+{
+    /**
+     * Creates a carry-CRT steps object using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public LongCarryCRTStepStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public long[] crt(DataStorage resultMod0, DataStorage resultMod1, DataStorage resultMod2, DataStorage dataStorage, long size, long resultSize, long offset, long length)
+        throws ApfloatRuntimeException
+    {
+        long skipSize = (offset == 0 ? size - resultSize + 1: 0);   // For the first block, ignore the first 1-3 elements
+        long lastSize = (offset + length == size ? 1: 0);           // For the last block, add 1 element
+        long nonLastSize = 1 - lastSize;                            // For the other than last blocks, move 1 element
+        long subResultSize = length - skipSize + lastSize;
+
+        long subStart = size - offset,
+             subEnd = subStart - length,
+             subResultStart = size - offset - length + nonLastSize + subResultSize,
+             subResultEnd = subResultStart - subResultSize;
+
+        DataStorage.Iterator src0 = resultMod0.iterator(DataStorage.READ, subStart, subEnd),
+                             src1 = resultMod1.iterator(DataStorage.READ, subStart, subEnd),
+                             src2 = resultMod2.iterator(DataStorage.READ, subStart, subEnd),
+                             dst = dataStorage.iterator(DataStorage.WRITE, subResultStart, subResultEnd);
+
+        long[] carryResult = new long[3],
+                  sum = new long[3],
+                  tmp = new long[3];
+
+        // Preliminary carry-CRT calculation (happens in parallel in multiple blocks)
+        for (long i = 0; i < length; i++)
+        {
+            long y0 = MATH_MOD_0.modMultiply(T0, src0.getLong()),
+                    y1 = MATH_MOD_1.modMultiply(T1, src1.getLong()),
+                    y2 = MATH_MOD_2.modMultiply(T2, src2.getLong());
+
+            multiply(M12, y0, sum);
+            multiply(M02, y1, tmp);
+
+            if (add(tmp, sum) != 0 ||
+                compare(sum, M012) >= 0)
+            {
+                subtract(M012, sum);
+            }
+
+            multiply(M01, y2, tmp);
+
+            if (add(tmp, sum) != 0 ||
+                compare(sum, M012) >= 0)
+            {
+                subtract(M012, sum);
+            }
+
+            add(sum, carryResult);
+
+            long result = divide(carryResult);
+
+            // In the first block, ignore the first element (it's zero in full precision calculations)
+            // and possibly one or two more in limited precision calculations
+            if (i >= skipSize)
+            {
+                dst.setLong(result);
+                dst.next();
+            }
+
+            src0.next();
+            src1.next();
+            src2.next();
+        }
+
+        // Calculate the last words (in base math)
+        long result0 = divide(carryResult);
+        long result1 = carryResult[2];
+
+        assert (carryResult[0] == 0);
+        assert (carryResult[1] == 0);
+
+        // Last block has one extra element (corresponding to the one skipped in the first block)
+        if (subResultSize == length - skipSize + 1)
+        {
+            dst.setLong(result0);
+            dst.close();
+
+            result0 = result1;
+            assert (result1 == 0);
+        }
+
+        long[] results = { result1, result0 };
+
+        return results;
+    }
+
+    public long[] carry(DataStorage dataStorage, long size, long resultSize, long offset, long length, long[] results, long[] previousResults)
+        throws ApfloatRuntimeException
+    {
+        long skipSize = (offset == 0 ? size - resultSize + 1: 0);   // For the first block, ignore the first 1-3 elements
+        long lastSize = (offset + length == size ? 1: 0);           // For the last block, add 1 element
+        long nonLastSize = 1 - lastSize;                            // For the other than last blocks, move 1 element
+        long subResultSize = length - skipSize + lastSize;
+
+        long subResultStart = size - offset - length + nonLastSize + subResultSize,
+             subResultEnd = subResultStart - subResultSize;
+
+        // Get iterators for the previous block carries, and dst, padded with this block's carries
+        // Note that size could be 1 but carries size is 2
+        DataStorage.Iterator src = arrayIterator(previousResults);
+        DataStorage.Iterator dst = compositeIterator(dataStorage.iterator(DataStorage.READ_WRITE, subResultStart, subResultEnd), subResultSize, arrayIterator(results));
+
+        // Propagate base addition through dst, and this block's carries
+        long carry = baseAdd(dst, src, 0, dst, previousResults.length);
+        carry = baseCarry(dst, carry, subResultSize);
+        dst.close();                                                    // Iterator likely was not iterated to end
+
+        assert (carry == 0);
+
+        return results;
+    }
+
+    private long baseCarry(DataStorage.Iterator srcDst, long carry, long size)
+        throws ApfloatRuntimeException
+    {
+        for (long i = 0; i < size && carry > 0; i++)
+        {
+            carry = baseAdd(srcDst, null, carry, srcDst, 1);
+        }
+
+        return carry;
+    }
+
+    // Wrap an array in a simple reverse-order iterator, padded with zeros
+    private static DataStorage.Iterator arrayIterator(final long[] data)
+    {
+        return new DataStorage.Iterator()
+        {
+            public boolean hasNext()
+            {
+                return true;
+            }
+
+            public void next()
+            {
+                this.position--;
+            }
+
+            public long getLong()
+            {
+                assert (this.position >= 0);
+                return data[this.position];
+            }
+
+            public void setLong(long value)
+            {
+                assert (this.position >= 0);
+                data[this.position] = value;
+            }
+
+            private static final long serialVersionUID = 1L;
+
+            private int position = data.length - 1;
+        };
+    }
+
+    // Composite iterator, made by concatenating two iterators
+    private static DataStorage.Iterator compositeIterator(final DataStorage.Iterator iterator1, final long size, final DataStorage.Iterator iterator2)
+    {
+        return new DataStorage.Iterator()
+        {
+            public boolean hasNext()
+            {
+                return (this.position < size ? iterator1.hasNext() : iterator2.hasNext());
+            }
+
+            public void next()
+                throws ApfloatRuntimeException
+            {
+                (this.position < size ? iterator1 : iterator2).next();
+                this.position++;
+            }
+
+            public long getLong()
+                throws ApfloatRuntimeException
+            {
+                return (this.position < size ? iterator1 : iterator2).getLong();
+            }
+
+            public void setLong(long value)
+                throws ApfloatRuntimeException
+            {
+                (this.position < size ? iterator1 : iterator2).setLong(value);
+            }
+
+            public void close()
+                throws ApfloatRuntimeException
+            {
+                (this.position < size ? iterator1 : iterator2).close();
+            }
+
+            private static final long serialVersionUID = 1L;
+
+            private long position;
+        };
+    }
+
+    private static final long serialVersionUID = -1851512769800204475L;
+
+    private static final LongModMath MATH_MOD_0,
+                                        MATH_MOD_1,
+                                        MATH_MOD_2;
+    private static final long T0,
+                                 T1,
+                                 T2;
+    private static final long[] M01,
+                                   M02,
+                                   M12,
+                                   M012;
+
+    static
+    {
+        MATH_MOD_0 = new LongModMath();
+        MATH_MOD_1 = new LongModMath();
+        MATH_MOD_2 = new LongModMath();
+
+        MATH_MOD_0.setModulus(MODULUS[0]);
+        MATH_MOD_1.setModulus(MODULUS[1]);
+        MATH_MOD_2.setModulus(MODULUS[2]);
+
+        // Probably sub-optimal, but it's a one-time operation
+
+        BigInteger base = BigInteger.valueOf(Math.abs((long) MAX_POWER_OF_TWO_BASE)),   // In int case the base is 0x80000000
+                   m0 = BigInteger.valueOf((long) MODULUS[0]),
+                   m1 = BigInteger.valueOf((long) MODULUS[1]),
+                   m2 = BigInteger.valueOf((long) MODULUS[2]),
+                   m01 = m0.multiply(m1),
+                   m02 = m0.multiply(m2),
+                   m12 = m1.multiply(m2);
+
+        T0 = m12.modInverse(m0).longValue();
+        T1 = m02.modInverse(m1).longValue();
+        T2 = m01.modInverse(m2).longValue();
+
+        M01 = new long[2];
+        M02 = new long[2];
+        M12 = new long[2];
+        M012 = new long[3];
+
+        BigInteger[] qr = m01.divideAndRemainder(base);
+        M01[0] = qr[0].longValue();
+        M01[1] = qr[1].longValue();
+
+        qr = m02.divideAndRemainder(base);
+        M02[0] = qr[0].longValue();
+        M02[1] = qr[1].longValue();
+
+        qr = m12.divideAndRemainder(base);
+        M12[0] = qr[0].longValue();
+        M12[1] = qr[1].longValue();
+
+        qr = m0.multiply(m12).divideAndRemainder(base);
+        M012[2] = qr[1].longValue();
+        qr = qr[0].divideAndRemainder(base);
+        M012[0] = qr[0].longValue();
+        M012[1] = qr[1].longValue();
+    }
+}
Index: src/main/java/org/apfloat/internal/LongConstants.java
===================================================================
--- src/main/java/org/apfloat/internal/LongConstants.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongConstants.java	(revision 0)
@@ -0,0 +1,24 @@
+package org.apfloat.internal;
+
+/**
+ * Constants needed for various algorithms for the <code>long</code> type.
+ *
+ * @since 1.4
+ * @version 1.4
+ * @author Mikko Tommila
+ */
+
+public interface LongConstants
+{
+    /**
+     * Relative cost of Karatsuba multiplication.
+     */
+
+    public static final float KARATSUBA_COST_FACTOR = 4.9f;
+
+    /**
+     * Relative cost of NTT multiplication.
+     */
+
+    public static final float NTT_COST_FACTOR = 8.3f;
+}
Index: src/main/java/org/apfloat/internal/LongConvolutionBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/LongConvolutionBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongConvolutionBuilder.java	(revision 0)
@@ -0,0 +1,65 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.ConvolutionStrategy;
+import org.apfloat.spi.NTTStrategy;
+import static org.apfloat.internal.LongConstants.*;
+
+/**
+ * Creates convolutions of suitable type for the <code>long</code> type.<p>
+ *
+ * @see LongShortConvolutionStrategy
+ * @see LongMediumConvolutionStrategy
+ * @see LongKaratsubaConvolutionStrategy
+ * @see ThreeNTTConvolutionStrategy
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class LongConvolutionBuilder
+    extends AbstractConvolutionBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public LongConvolutionBuilder()
+    {
+    }
+
+    protected int getKaratsubaCutoffPoint()
+    {
+        return LongKaratsubaConvolutionStrategy.CUTOFF_POINT;
+    }
+
+    protected float getKaratsubaCostFactor()
+    {
+        return KARATSUBA_COST_FACTOR;
+    }
+
+    protected float getNTTCostFactor()
+    {
+        return NTT_COST_FACTOR;
+    }
+
+    protected ConvolutionStrategy createShortConvolutionStrategy(int radix)
+    {
+        return new LongShortConvolutionStrategy(radix);
+    }
+
+    protected ConvolutionStrategy createMediumConvolutionStrategy(int radix)
+    {
+        return new LongMediumConvolutionStrategy(radix);
+    }
+
+    protected ConvolutionStrategy createKaratsubaConvolutionStrategy(int radix)
+    {
+        return new LongKaratsubaConvolutionStrategy(radix);
+    }
+
+
+    protected ConvolutionStrategy createThreeNTTConvolutionStrategy(int radix, NTTStrategy nttStrategy)
+    {
+        return new ParallelThreeNTTConvolutionStrategy(radix, nttStrategy);
+    }
+}
Index: src/main/java/org/apfloat/internal/LongDataStorageBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/LongDataStorageBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongDataStorageBuilder.java	(revision 0)
@@ -0,0 +1,49 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+
+/**
+ * Default data storage creation strategy for the <code>long</code> data type.
+ *
+ * @see LongMemoryDataStorage
+ * @see LongDiskDataStorage
+ *
+ * @version 1.8.2
+ * @author Mikko Tommila
+ */
+
+public class LongDataStorageBuilder
+    extends AbstractDataStorageBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public LongDataStorageBuilder()
+    {
+    }
+
+    protected long getMaxCachedSize()
+    {
+        return (long) 8 * Integer.MAX_VALUE;
+    }
+
+    protected DataStorage createCachedDataStorage()
+        throws ApfloatRuntimeException
+    {
+        return new LongMemoryDataStorage();
+    }
+
+    protected DataStorage createNonCachedDataStorage()
+        throws ApfloatRuntimeException
+    {
+        return new LongDiskDataStorage();
+    }
+
+    protected boolean isCached(DataStorage dataStorage)
+        throws ApfloatRuntimeException
+    {
+        return (dataStorage instanceof LongMemoryDataStorage);
+    }
+}
Index: src/main/java/org/apfloat/internal/LongDiskDataStorage.java
===================================================================
--- src/main/java/org/apfloat/internal/LongDiskDataStorage.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongDiskDataStorage.java	(revision 0)
@@ -0,0 +1,333 @@
+package org.apfloat.internal;
+
+import java.nio.ByteBuffer;
+import java.nio.LongBuffer;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.channels.WritableByteChannel;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Disk-based data storage for the <code>long</code> element type.
+ *
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class LongDiskDataStorage
+    extends DiskDataStorage
+{
+    /**
+     * Default constructor.
+     */
+
+    public LongDiskDataStorage()
+        throws ApfloatRuntimeException
+    {
+    }
+
+    /**
+     * Subsequence constructor.
+     *
+     * @param longDiskDataStorage The originating data storage.
+     * @param offset The subsequence starting position.
+     * @param length The subsequence length.
+     */
+
+    protected LongDiskDataStorage(LongDiskDataStorage longDiskDataStorage, long offset, long length)
+    {
+        super(longDiskDataStorage, offset, length);
+    }
+
+    protected DataStorage implSubsequence(long offset, long length)
+        throws ApfloatRuntimeException
+    {
+        return new LongDiskDataStorage(this, offset + getOffset(), length);
+    }
+
+    private class LongDiskArrayAccess
+        extends LongMemoryArrayAccess
+    {
+        // fileOffset is absolute position in file
+        public LongDiskArrayAccess(int mode, long fileOffset, int length)
+            throws ApfloatRuntimeException
+        {
+            super(new long[length], 0, length);
+            this.mode = mode;
+            this.fileOffset = fileOffset;
+
+            if ((mode & READ) != 0)
+            {
+                final long[] array = getLongData();
+                WritableByteChannel out = new WritableByteChannel()
+                {
+                    public int write(ByteBuffer buffer)
+                    {
+                        LongBuffer src = buffer.asLongBuffer();
+                        int readLength = src.remaining();
+
+                        src.get(array, this.readPosition, readLength);
+
+                        this.readPosition += readLength;
+                        buffer.position(buffer.position() + readLength * 8);
+
+                        return readLength * 8;
+                    }
+
+                    public void close() {}
+                    public boolean isOpen() { return true; }
+
+                    private int readPosition = 0;
+                };
+
+                transferTo(out, fileOffset * 8, (long) length * 8);
+            }
+        }
+
+        public void close()
+            throws ApfloatRuntimeException
+        {
+            if ((this.mode & WRITE) != 0 && getData() != null)
+            {
+                final long[] array = getLongData();
+                ReadableByteChannel in = new ReadableByteChannel()
+                {
+                    public int read(ByteBuffer buffer)
+                    {
+                        LongBuffer dst = buffer.asLongBuffer();
+                        int writeLength = dst.remaining();
+
+                        dst.put(array, this.writePosition, writeLength);
+
+                        this.writePosition += writeLength;
+                        buffer.position(buffer.position() + writeLength * 8);
+
+                        return writeLength * 8;
+                    }
+
+                    public void close() {}
+                    public boolean isOpen() { return true; }
+
+                    private int writePosition = 0;
+                };
+
+                transferFrom(in, this.fileOffset * 8, (long) array.length * 8);
+            }
+
+            super.close();
+        }
+
+        private static final long serialVersionUID = -2591640502422276852L;
+
+        private int mode;
+        private long fileOffset;
+    }
+
+    protected ArrayAccess implGetArray(int mode, long offset, int length)
+        throws ApfloatRuntimeException
+    {
+        return new LongDiskArrayAccess(mode, getOffset() + offset, length);
+    }
+
+    protected ArrayAccess createArrayAccess(int mode, int startColumn, int columns, int rows)
+    {
+        return new MemoryArrayAccess(mode, new long[columns * rows], startColumn, columns, rows);
+    }
+
+    protected ArrayAccess createTransposedArrayAccess(int mode, int startColumn, int columns, int rows)
+    {
+        return new TransposedMemoryArrayAccess(mode, new long[columns * rows], startColumn, columns, rows);
+    }
+
+    private class MemoryArrayAccess
+        extends LongMemoryArrayAccess
+    {
+        public MemoryArrayAccess(int mode, long[] data, int startColumn, int columns, int rows)
+        {
+            super(data, 0, data.length);
+            this.mode = mode;
+            this.startColumn = startColumn;
+            this.columns = columns;
+            this.rows = rows;
+        }
+
+        public void close()
+            throws ApfloatRuntimeException
+        {
+            if ((this.mode & WRITE) != 0 && getData() != null)
+            {
+                setArray(this, this.startColumn, this.columns, this.rows);
+            }
+            super.close();
+        }
+
+        private static final long serialVersionUID = -1573539652919953016L;
+
+        private int mode,
+                    startColumn,
+                    columns,
+                    rows;
+    }
+
+    private class TransposedMemoryArrayAccess
+        extends LongMemoryArrayAccess
+    {
+        public TransposedMemoryArrayAccess(int mode, long[] data, int startColumn, int columns, int rows)
+        {
+            super(data, 0, data.length);
+            this.mode = mode;
+            this.startColumn = startColumn;
+            this.columns = columns;
+            this.rows = rows;
+        }
+
+        public void close()
+            throws ApfloatRuntimeException
+        {
+            if ((this.mode & WRITE) != 0 && getData() != null)
+            {
+                setTransposedArray(this, this.startColumn, this.columns, this.rows);
+            }
+            super.close();
+        }
+
+        private static final long serialVersionUID = -455915044370886962L;
+
+        private int mode,
+                    startColumn,
+                    columns,
+                    rows;
+    }
+
+    private class BlockIterator
+        extends AbstractIterator
+    {
+        public BlockIterator(int mode, long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            super(mode, startPosition, endPosition);
+            this.arrayAccess = null;
+            this.remaining = 0;
+        }
+
+        public void next()
+            throws IllegalStateException, ApfloatRuntimeException
+        {
+            checkLength();
+
+            assert (this.remaining > 0);
+
+            checkAvailable();
+
+            this.offset += getIncrement();
+            this.remaining--;
+
+            if (this.remaining == 0)
+            {
+                close();
+            }
+
+            super.next();
+        }
+
+        public long getLong()
+            throws IllegalStateException, ApfloatRuntimeException
+        {
+            checkGet();
+            checkAvailable();
+            return this.data[this.offset];
+        }
+
+        public void setLong(long value)
+            throws IllegalStateException, ApfloatRuntimeException
+        {
+            checkSet();
+            checkAvailable();
+            this.data[this.offset] = value;
+        }
+
+        public <T> T get(Class<T> type)
+            throws UnsupportedOperationException, IllegalStateException
+        {
+            if (!(type.equals(Long.TYPE)))
+            {
+                throw new UnsupportedOperationException("Unsupported data type " + type.getCanonicalName() + ", the only supported type is long");
+            }
+            @SuppressWarnings("unchecked")
+            T value = (T) (Long) getLong();
+            return value;
+        }
+
+        public <T> void set(Class<T> type, T value)
+            throws UnsupportedOperationException, IllegalArgumentException, IllegalStateException
+        {
+            if (!(type.equals(Long.TYPE)))
+            {
+                throw new UnsupportedOperationException("Unsupported data type " + type.getCanonicalName() + ", the only supported type is long");
+            }
+            if (!(value instanceof Long))
+            {
+                throw new IllegalArgumentException("Unsupported value type " + value.getClass().getCanonicalName() + ", the only supported type is Long");
+            }
+            setLong((Long) value);
+        }
+
+        /**
+         * Closes the iterator. This needs to be called only if the
+         * iterator is not iterated to the end.
+         */
+
+        public void close()
+            throws ApfloatRuntimeException
+        {
+            if (this.arrayAccess != null)
+            {
+                this.data = null;
+                this.arrayAccess.close();
+                this.arrayAccess = null;
+            }
+        }
+
+        private void checkAvailable()
+            throws ApfloatRuntimeException
+        {
+            if (this.arrayAccess == null)
+            {
+                boolean isForward = (getIncrement() > 0);
+                int length = (int) Math.min(getLength(), getBlockSize() / 8);
+                long offset = (isForward ? getPosition() : getPosition() - length + 1);
+
+                this.arrayAccess = getArray(getMode(), offset, length);
+                this.data = this.arrayAccess.getLongData();
+                this.offset = this.arrayAccess.getOffset() + (isForward ? 0 : length - 1);
+                this.remaining = length;
+            }
+        }
+
+        private static final long serialVersionUID = -2804905180796718735L;
+
+        private ArrayAccess arrayAccess;
+        private long[] data;
+        private int offset,
+                    remaining;
+    }
+
+    public Iterator iterator(int mode, long startPosition, long endPosition)
+        throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+    {
+        if ((mode & READ_WRITE) == 0)
+        {
+            throw new IllegalArgumentException("Illegal mode: " + mode);
+        }
+        return new BlockIterator(mode, startPosition, endPosition);
+    }
+
+    protected int getUnitSize()
+    {
+        return 8;
+    }
+
+    private static final long serialVersionUID = 4741507089425158620L;
+}
Index: src/main/java/org/apfloat/internal/LongElementaryModMath.java
===================================================================
--- src/main/java/org/apfloat/internal/LongElementaryModMath.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongElementaryModMath.java	(revision 0)
@@ -0,0 +1,146 @@
+package org.apfloat.internal;
+
+/**
+ * Elementary modulo arithmetic functions for <code>long</code> data.<p>
+ *
+ * Modular addition and subtraction are trivial, when the modulus is less
+ * than 2<sup>63</sup> and overflow can be detected easily.<p>
+ *
+ * Modular multiplication is more complicated, and since it is usually
+ * the single most time consuming operation in the whole program execution,
+ * the very core of the Number Theoretic Transform (NTT), it should be
+ * carefully optimized.<p>
+ *
+ * The algorithm for multiplying two <code>long</code>s and taking the
+ * remainder is not entirely obvious. The basic problem is to get the
+ * full 128-bit result of multiplying two 64-bit integers. It would be
+ * possible to do this by splitting the arguments to high and low 32-bit
+ * words and performing four multiplications. The performance of this
+ * solution would be not very good.<p>
+ *
+ * Another approach is to use <code>long</code>s only for getting the lowest
+ * 64 bits of the result. Casting the operands to <code>double</code> and
+ * multiplying as floating-point numbers, we can get the highest (roughly) 52
+ * bits of the result. However since only 116 bits can be acquired this
+ * way, it would be possible to only use 58 bits in each of the multiplication
+ * operands (not the full 64 or 63 bits). Furthermore, round-off errors in
+ * the floating-point multiplications, as allowed by the IEEE specification,
+ * actually prevent getting even 52 of the top bits accurately, and actually
+ * only 57 bits can be used in the multiplication operands. This is the
+ * approach chosen in this implementation.<p>
+ *
+ * The first observation is that since the modulus is practically
+ * constant, it should be more efficient to calculate (once) the inverse
+ * of the modulus, and then subsequently multiply by the inverse modulus
+ * instead of dividing by the modulus.<p>
+ *
+ * The second observation is that to get the remainder of the division,
+ * we don't necessarily need the actual result of the division (we just
+ * want the remainder). So, we should discard the topmost 50 bits of the
+ * full 114-bit result whenever possible, to save a few operations.<p>
+ *
+ * The basic approach is to get an approximation of <code>a * b / modulus</code>
+ * (using floating-point operands, that is <code>double</code>s). The approximation
+ * should be within +1 or -1 of the correct result. We first calculate
+ * <code>a * b - approximateDivision * modulus</code> to get the initial remainder.
+ * This calculation can use the lowest 64 bits only and is done using <code>long</code>s.
+ * It is enough to use a <code>double</code> to do the approximate division, as it eliminates
+ * at least 51 bits from the top of the 114-bit multiplication result, leaving at
+ * most 63 bits in the remainder. The calculation <code>result - approximateDivision * modulus</code>
+ * must then be done once more to reduce the remainder since the original multiplication operands
+ * are only 57-bit numbers. The second reduction reduces the results to the correct value &#177;modulus.
+ * It is then easy to detect the case when the approximate division was off by one (and the
+ * remainder is <code>&#177;modulus</code> off) as the final step of the algorithm.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public class LongElementaryModMath
+{
+    /**
+     * Default constructor.
+     */
+
+    public LongElementaryModMath()
+    {
+    }
+
+    /**
+     * Modular multiplication.
+     *
+     * @param a First operand.
+     * @param b Second operand.
+     *
+     * @return <code>a * b % modulus</code>
+     */
+
+    public final long modMultiply(long a, long b)
+    {
+        long r = a * b - this.modulus * (long) ((double) a * (double) b * this.inverseModulus);
+        r -= this.modulus * (int) ((double) r * this.inverseModulus);
+
+        r = (r >= this.modulus ? r - this.modulus : r);
+        r = (r < 0 ? r + this.modulus : r);
+
+        return r;
+    }
+
+    /**
+     * Modular addition.
+     *
+     * @param a First operand.
+     * @param b Second operand.
+     *
+     * @return <code>(a + b) % modulus</code>
+     */
+
+    public final long modAdd(long a, long b)
+    {
+        long r = a + b;
+
+        return (r >= this.modulus ? r - this.modulus : r);
+    }
+
+    /**
+     * Modular subtraction. The result is always &gt;= 0.
+     *
+     * @param a First operand.
+     * @param b Second operand.
+     *
+     * @return <code>(a - b + modulus) % modulus</code>
+     */
+
+    public final long modSubtract(long a, long b)
+    {
+        long r = a - b;
+
+        return (r < 0 ? r + this.modulus : r);
+    }
+
+    /**
+     * Get the modulus.
+     *
+     * @return The modulus.
+     */
+
+    public final long getModulus()
+    {
+        return this.modulus;
+    }
+
+    /**
+     * Set the modulus.
+     *
+     * @param modulus The modulus.
+     */
+
+    public final void setModulus(long modulus)
+    {
+        this.inverseModulus = 1.0 / modulus;
+        this.modulus = modulus;
+    }
+
+    private long modulus;
+    private double inverseModulus;
+}
Index: src/main/java/org/apfloat/internal/LongFactor3NTTStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/LongFactor3NTTStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongFactor3NTTStepStrategy.java	(revision 0)
@@ -0,0 +1,180 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.Factor3NTTStepStrategy;
+import org.apfloat.spi.DataStorage;
+import static org.apfloat.internal.LongModConstants.*;
+
+/**
+ * Steps for the factor-3 NTT.<p>
+ *
+ * The transform is done using a parallel algorithm, if the data fits in memory.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class LongFactor3NTTStepStrategy
+    extends LongModMath
+    implements Factor3NTTStepStrategy, Parallelizable
+{
+    // Runnable for transforming the columns in a factor-3 transform
+    private class ColumnTransformRunnable
+        implements Runnable
+    {
+        public ColumnTransformRunnable(DataStorage dataStorage0, DataStorage dataStorage1, DataStorage dataStorage2, long startColumn, long columns, long w, long ww, long w1, long w2, boolean isInverse)
+        {
+            this.dataStorage0 = dataStorage0;
+            this.dataStorage1 = dataStorage1;
+            this.dataStorage2 = dataStorage2;
+            this.startColumn = startColumn;
+            this.columns = columns;
+            this.w = w;
+            this.ww = ww;
+            this.w1 = w1;
+            this.w2 = w2;
+            this.isInverse = isInverse;
+        }
+
+        public void run()
+        {
+            long tmp1 = modPow(this.w, (long) this.startColumn),
+                    tmp2 = modPow(this.ww, (long) this.startColumn);
+
+            DataStorage.Iterator iterator0 = this.dataStorage0.iterator(DataStorage.READ_WRITE, this.startColumn, this.startColumn + this.columns),
+                                 iterator1 = this.dataStorage1.iterator(DataStorage.READ_WRITE, this.startColumn, this.startColumn + this.columns),
+                                 iterator2 = this.dataStorage2.iterator(DataStorage.READ_WRITE, this.startColumn, this.startColumn + this.columns);
+
+            for (long i = 0; i < this.columns; i++)
+            {
+                // 3-point WFTA on the corresponding array elements
+
+                long x0 = iterator0.getLong(),
+                        x1 = iterator1.getLong(),
+                        x2 = iterator2.getLong(),
+                        t;
+
+                if (this.isInverse)
+                {
+                    // Multiply before transform
+                    x1 = modMultiply(x1, tmp1);
+                    x2 = modMultiply(x2, tmp2);
+                }
+
+                // Transform columns
+                t = modAdd(x1, x2);
+                x2 = modSubtract(x1, x2);
+                x0 = modAdd(x0, t);
+                t = modMultiply(t, this.w1);
+                x2 = modMultiply(x2, this.w2);
+                t = modAdd(t, x0);
+                x1 = modAdd(t, x2);
+                x2 = modSubtract(t, x2);
+
+                if (!this.isInverse)
+                {
+                    // Multiply after transform
+                    x1 = modMultiply(x1, tmp1);
+                    x2 = modMultiply(x2, tmp2);
+                }
+
+                iterator0.setLong(x0);
+                iterator1.setLong(x1);
+                iterator2.setLong(x2);
+
+                iterator0.next();
+                iterator1.next();
+                iterator2.next();
+
+                tmp1 = modMultiply(tmp1, this.w);
+                tmp2 = modMultiply(tmp2, this.ww);
+            }
+        }
+
+        private DataStorage dataStorage0;
+        private DataStorage dataStorage1;
+        private DataStorage dataStorage2;
+        private long startColumn;
+        private long columns;
+        private long w;
+        private long ww;
+        private long w1;
+        private long w2;
+        private boolean isInverse;
+    }
+
+    /**
+     * Default constructor.
+     */
+
+    public LongFactor3NTTStepStrategy()
+    {
+    }
+
+    public void transformColumns(DataStorage dataStorage0, DataStorage dataStorage1, DataStorage dataStorage2, long startColumn, long columns, long power2length, long length, boolean isInverse, int modulus)
+        throws ApfloatRuntimeException
+    {
+        // Transform length is three times a power of two
+        assert (length == 3 * power2length);
+
+        ParallelRunnable parallelRunnable = createColumnTransformParallelRunnable(dataStorage0, dataStorage1, dataStorage2, startColumn, columns, power2length, length, isInverse, modulus);
+
+        if (columns <= Integer.MAX_VALUE &&                                     // Only if the size fits in an integer, but with memory arrays it should
+            dataStorage0.isCached() &&                                          // Only if the data storage supports efficient parallel random access
+            dataStorage1.isCached() &&
+            dataStorage2.isCached())
+        {
+            ParallelRunner.runParallel(parallelRunnable);
+        }
+        else
+        {
+            parallelRunnable.run();                                             // Just run in current thread without parallelization
+        }
+    }
+
+    public long getMaxTransformLength()
+    {
+        return MAX_TRANSFORM_LENGTH;
+    }
+
+    /**
+     * Create a ParallelRunnable object for transforming the columns of the matrix
+     * using a 3-point NTT transform.
+     *
+     * @param dataStorage0 The data of the first column.
+     * @param dataStorage1 The data of the second column.
+     * @param dataStorage2 The data of the third column.
+     * @param startColumn The starting element index in the data storages to transform.
+     * @param columns How many columns to transform.
+     * @param power2length Length of the column transform.
+     * @param length Length of total transform (three times the length of one column).
+     * @param isInverse <code>true</code> if an inverse transform is performed, <code>false</code> if a forward transform is performed.
+     * @param modulus Index of the modulus.
+     *
+     * @return A suitable object for performing the 3-point transforms in parallel.
+     */
+
+    protected ParallelRunnable createColumnTransformParallelRunnable(final DataStorage dataStorage0, final DataStorage dataStorage1, final DataStorage dataStorage2, final long startColumn, final long columns, long power2length, long length, final boolean isInverse, int modulus)
+    {
+        setModulus(MODULUS[modulus]);                                             // Modulus
+        final long w = (isInverse ?
+                           getInverseNthRoot(PRIMITIVE_ROOT[modulus], length) :
+                           getForwardNthRoot(PRIMITIVE_ROOT[modulus], length)),   // Forward/inverse n:th root
+                      w3 = modPow(w, (long) power2length),                     // Forward/inverse 3rd root
+                      ww = modMultiply(w, w),
+                      w1 = negate(modDivide((long) 3, (long) 2)),
+                      w2 = modAdd(w3, modDivide((long) 1, (long) 2));
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(columns)
+        {
+            public Runnable getRunnable(long strideStartColumn, long strideColumns)
+            {
+                return new ColumnTransformRunnable(dataStorage0, dataStorage1, dataStorage2, startColumn + strideStartColumn, strideColumns, w, ww, w1, w2, isInverse);
+            }
+        };
+        return parallelRunnable;
+    }
+}
Index: src/main/java/org/apfloat/internal/LongKaratsubaConvolutionStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/LongKaratsubaConvolutionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongKaratsubaConvolutionStrategy.java	(revision 0)
@@ -0,0 +1,242 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.DataStorage;
+
+/**
+ * Convolution strategy using the Karatsuba algorithm.
+ * The complexity of the algorithm is O(n<sup>log(3)/log(2)</sup>) as
+ * the operands are split to two and multiplied using three multiplications
+ * (and five additions / subtractions). This splitting is done recursively
+ * until some cut-off point where the basic O(n<sup>2</sup>) algorithm is
+ * applied. The Karatsuba algorithm is faster than the basic O(n<sup>2</sup>)
+ * multiplication algorithm for medium size numbers larger than some certain
+ * size. For very large numbers, the transform-based convolution algorithms
+ * are faster.
+ *
+ * @since 1.4
+ * @version 1.4
+ * @author Mikko Tommila
+ */
+
+public class LongKaratsubaConvolutionStrategy
+    extends LongMediumConvolutionStrategy
+{
+    /**
+     * Cut-off point for Karatsuba / basic convolution.<p>
+     *
+     * Convolutions where the shorter number is at most this long
+     * are calculated using the basic O(n<sup>2</sup>) algorithm
+     * i.e. <code>super.convolute()</code>.
+     */
+
+    public static final int CUTOFF_POINT = 15;
+
+    /**
+     * Creates a convolution strategy using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public LongKaratsubaConvolutionStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public DataStorage convolute(DataStorage x, DataStorage y, long resultSize)
+        throws ApfloatRuntimeException
+    {
+        if (Math.min(x.getSize(), y.getSize()) <= CUTOFF_POINT)
+        {
+            // The numbers are too short for Karatsuba to have any advantage, fall back to O(n^2) algorithm
+            return super.convolute(x, y, resultSize);
+        }
+
+        DataStorage shortStorage, longStorage;
+
+        if (x.getSize() > y.getSize())
+        {
+            shortStorage = y;
+            longStorage = x;
+        }
+        else
+        {
+            shortStorage = x;
+            longStorage = y;
+        }
+
+        long shortSize = shortStorage.getSize(),
+             longSize = longStorage.getSize(),
+             size = shortSize + longSize,
+             halfSize = longSize + 1 >> 1,      // Split point for recursion, round up
+             x1size = longSize - halfSize,
+             x2size = halfSize,
+             y1size = shortSize - halfSize;     // y2size = halfSize
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        DataStorage resultStorage = dataStorageBuilder.createDataStorage(size * 8);
+        resultStorage.setSize(size);
+
+        if (y1size <= 0)
+        {
+            // The shorter number is half of the longer number or less, use simplified algorithm
+            DataStorage.Iterator dst = resultStorage.iterator(DataStorage.WRITE, size, 0),
+                                 src1 = null;
+            long carry = 0;
+            long i = longSize,
+                 xSize;
+
+            // Calculate sub-results in blocks of size shortSize
+            do
+            {
+                xSize = Math.min(i, shortSize);
+                x = longStorage.subsequence(i - xSize, xSize);
+                y = shortStorage;
+
+                // Calculate sub-convolutions recursively
+                DataStorage a = convolute(x, y, xSize + shortSize);
+
+                assert (a.getSize() == xSize + shortSize);
+
+                // Add the sub-results together
+                DataStorage.Iterator src2 = a.iterator(DataStorage.READ, xSize + shortSize, 0);
+
+                carry = baseAdd(src1, src2, carry, dst, shortSize);
+
+                src1 = src2;
+                i -= shortSize;
+            } while (i > 0);
+
+            // Propagate carry through the last sub-result and store to result data
+            carry = baseAdd(src1, null, carry, dst, xSize);
+
+            assert (carry == 0);
+        }
+        else
+        {
+            // The numbers are roughly equal size (shorter is more than half of the longer), use Karatsuba algorithm
+            DataStorage x1 = longStorage.subsequence(0, x1size),
+                        x2 = longStorage.subsequence(x1size, x2size),
+                        y1 = shortStorage.subsequence(0, y1size),
+                        y2 = shortStorage.subsequence(y1size, halfSize);
+
+            // Calculate a = x1 + x2
+            DataStorage a = add(x1, x2);
+
+            // Calculate b = y1 + y2
+            DataStorage b = add(y1, y2);
+
+            // Calculate sub-convolutions recursively
+            DataStorage c = convolute(a, b, a.getSize() + b.getSize());
+            a = convolute(x1, y1, x1size + y1size);
+            b = convolute(x2, y2, 2 * halfSize);
+
+            // Calculate c = c - a - b
+            subtract(c, a);
+            subtract(c, b);
+
+            long cSize = c.getSize(),
+                 c1size = cSize - halfSize;
+
+            if (c1size > x1size + y1size)
+            {
+                // We know that the top one or two words of c are zero
+                // Omit them to avoid later having c1size > x1size + y1size
+                long zeros = c1size - x1size - y1size;
+                assert (isZero(c, 0));
+                assert (zeros == 1 || isZero(c, 1));
+                assert (zeros <= 2);
+                cSize -= zeros;
+                c1size -= zeros;
+                c = c.subsequence(zeros, cSize);
+            }
+
+            assert (a.getSize() == x1size + y1size);
+            assert (b.getSize() == 2 * halfSize);
+            assert (cSize >= 2 * halfSize && cSize <= 2 * halfSize + 2);
+            assert (c1size <= x1size + y1size);
+
+            // Add the sub-results a + b + c together
+            DataStorage.Iterator src1 = a.iterator(DataStorage.READ, x1size + y1size, 0),
+                                 src2 = b.iterator(DataStorage.READ, 2 * halfSize, 0),
+                                 src3 = c.iterator(DataStorage.READ, cSize, 0),
+                                 dst = resultStorage.iterator(DataStorage.WRITE, size, 0);
+
+            long carry = 0;
+            carry = baseAdd(src2, null, carry, dst, halfSize);
+            carry = baseAdd(src2, src3, carry, dst, halfSize);
+            carry = baseAdd(src1, src3, carry, dst, c1size);
+            carry = baseAdd(src1, null, carry, dst, x1size + y1size - c1size);
+
+            assert (carry == 0);
+        }
+
+        return resultStorage;
+    }
+
+    // Return x1 + x2
+    private DataStorage add(DataStorage x1, DataStorage x2)
+    {
+        long x1size = x1.getSize(),
+             x2size = x2.getSize();
+
+        assert (x1size <= x2size);
+
+        long size = x2size + 1;
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        DataStorage resultStorage = dataStorageBuilder.createDataStorage(size * 8);
+        resultStorage.setSize(size);
+
+        // Calculate x1 + x2
+        DataStorage.Iterator src1 = x1.iterator(DataStorage.READ, x1size, 0),
+                             src2 = x2.iterator(DataStorage.READ, x2size, 0),
+                             dst = resultStorage.iterator(DataStorage.WRITE, size, 0);
+
+        long carry = 0;
+        carry = baseAdd(src1, src2, carry, dst, x1size);
+        carry = baseAdd(src2, null, carry, dst, x2size - x1size);
+        baseAdd(null, null, carry, dst, 1);         // Set carry digit to the top word
+        if (carry == 0)
+        {
+            resultStorage = resultStorage.subsequence(1, size - 1);     // Omit zero top word
+        }
+
+        return resultStorage;
+    }
+
+    // x1 -= x2
+    private void subtract(DataStorage x1, DataStorage x2)
+    {
+        long x1size = x1.getSize(),
+             x2size = x2.getSize();
+
+        assert (x1size >= x2size);
+
+        DataStorage.Iterator src1 = x1.iterator(DataStorage.READ_WRITE, x1size, 0),
+                             src2 = x2.iterator(DataStorage.READ, x2size, 0),
+                             dst = src1;
+
+        long carry = 0;
+        carry = baseSubtract(src1, src2, carry, dst, x2size);
+        carry = baseSubtract(src1, null, carry, dst, x1size - x2size);
+
+        assert (carry == 0);
+    }
+
+    private boolean isZero(DataStorage x, long index)
+    {
+        DataStorage.Iterator i = x.iterator(DataStorage.READ, index, index + 1);
+
+        long data = i.getLong();
+        i.next();
+
+        return data == 0;
+    }
+
+    private static final long serialVersionUID = -4812398042499004749L;
+}
Index: src/main/java/org/apfloat/internal/LongMatrixBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/LongMatrixBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongMatrixBuilder.java	(revision 0)
@@ -0,0 +1,32 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.MatrixBuilder;
+import org.apfloat.spi.MatrixStrategy;
+
+/**
+ * Creates matrix operations objects, for the
+ * <code>long</code> type.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class LongMatrixBuilder
+    implements MatrixBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public LongMatrixBuilder()
+    {
+    }
+
+    public MatrixStrategy createMatrix()
+    {
+        return LongMatrixBuilder.matrixStrategy;
+    }
+
+    private static MatrixStrategy matrixStrategy = new LongMatrixStrategy();
+}
Index: src/main/java/org/apfloat/internal/LongMatrixStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/LongMatrixStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongMatrixStrategy.java	(revision 0)
@@ -0,0 +1,442 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.MatrixStrategy;
+import org.apfloat.spi.ArrayAccess;
+import org.apfloat.spi.Util;
+
+/**
+ * Optimized matrix transposition methods for the <code>long</code> type.
+ * The matrix transposition algorithm isn't parallelized.<p>
+ *
+ * While the matrix transposition algorithm could easily be parallelized,
+ * on an SMP machine it does not make any sense. If the matrix doesn't fit
+ * in any processor specific cache then the memory (or higher level
+ * shared cache) bandwidth becomes a bottleneck in the algorithm. Matrix
+ * transposition is in principle a very simple algorithm - it doesn't do
+ * anything else than move data from one place to another. If shared memory
+ * is the bottleneck, then the algorithm isn't any faster if the data is being
+ * moved around by one thread or by multiple threads in parallel.<p>
+ *
+ * If the data fits in a processor specific cache, then the algorithm could
+ * theoretically be made faster with parallelization. To make the parallelization
+ * effective however, the data would have to be set up in some kind of a NUMA
+ * way. For example, each processor core would hold an equal section of
+ * the data in the processor cache. Then the algorithm could be made faster
+ * as each processor core could quickly transpose blocks of data that are in the
+ * processor cache, and then exchange blocks with other processor cores via the
+ * slower higher level shared cache or main memory.<p>
+ *
+ * This approach doesn't work well in practice however, at least not in a Java
+ * program. The reason is that there are no guarantees where the data is when
+ * the algorithm starts (in which processor core caches), and further there are
+ * no guarantees of any processor affinity for the threads that are executing
+ * in parallel. Different processor cores could be executing the transposition
+ * of different sections of the data at any moment, depending on how the
+ * operating system (and the JVM) schedule thread execution. And more often
+ * than not, the operating system isn't smart enough to apply any such processor
+ * affinity for the threads.<p>
+ *
+ * An additional problem for any NUMA based attempt is that the data array would
+ * have to be aligned on a cache line (e.g. 64 or 128 bytes), to prevent
+ * cache contention at the edges of each data section. But a JVM makes no such
+ * guarantees about memory alignment. And since pointers do not exist in Java,
+ * manually aligning memory addresses isn't possible.<p>
+ *
+ * Considering all of the above, the parallel algorithm doesn't in practice work
+ * any faster than the single-thread algorithm, as the algorithm is bound by the
+ * memory bandwidth (or shared cache bandwidth). In some cases parallelization
+ * can even make the execution slower due to increased cache contention.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class LongMatrixStrategy
+    implements MatrixStrategy
+{
+    /**
+     * Default constructor.
+     */
+
+    public LongMatrixStrategy()
+    {
+    }
+
+    /**
+     * Transpose a n<sub>1</sub> x n<sub>2</sub> matrix.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two.
+     * Additionally, one of these must be true:<p>
+     *
+     * n<sub>1</sub> = n<sub>2</sub><br>
+     * n<sub>1</sub> = 2*n<sub>2</sub><br>
+     * n<sub>2</sub> = 2*n<sub>1</sub><br>
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be transposed.
+     * @param n1 Number of rows in the matrix.
+     * @param n2 Number of columns in the matrix.
+     */
+
+    public void transpose(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException
+    {
+        long[] data = arrayAccess.getLongData();
+        int offset = arrayAccess.getOffset();
+
+        if (n1 != (n1 & -n1) ||
+            n2 != (n2 & -n2) ||
+            n1 <= 0 || n2 <= 0)
+        {
+            throw new ApfloatInternalException("Matrix size must be a power of two, not " + n1 + " x " + n2);
+        }
+        if (n1 == n2)
+        {
+            // Simply transpose
+
+            transposeSquare(data, offset, n1, n1);
+        }
+        else if (n2 == 2 * n1)
+        {
+            // First transpose two n1 x n1 blocks
+            transposeSquare(data, offset, n1, n2);
+            transposeSquare(data, offset + n1, n1, n2);
+
+            // Then permute the rows to correct order
+            permuteToHalfWidth(data, offset, n1, n2);
+        }
+        else if (n1 == 2 * n2)
+        {
+            // First permute the rows to correct order
+            permuteToDoubleWidth(data, offset, n1, n2);
+
+            // Then transpose two n2 x n2 blocks
+            transposeSquare(data, offset, n2, n1);
+            transposeSquare(data, offset + n2, n2, n1);
+        }
+        else
+        {
+            throw new ApfloatInternalException("Must be n1 = n2, n1 = 2*n2 or n2 = 2*n1; matrix is " + n1 + " x " + n2);
+        }
+    }
+
+    /**
+     * Transpose a square n<sub>1</sub> x n<sub>1</sub> block of n<sub>1</sub> x n<sub>2</sub> matrix.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two,
+     * and n<sub>1</sub> &lt;= n<sub>2</sub>.
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be transposed.
+     * @param n1 Number of rows and columns in the block to be transposed.
+     * @param n2 Number of columns in the matrix.
+     */
+
+    public void transposeSquare(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException
+    {
+        transposeSquare(arrayAccess.getLongData(), arrayAccess.getOffset(), n1, n2);
+    }
+
+    /**
+     * Permute the rows of the n<sub>1</sub> x n<sub>2</sub> matrix so that it is shaped like a
+     * n<sub>1</sub>/2 x 2*n<sub>2</sub> matrix. Logically, the matrix is split in half, and the
+     * lower half is moved to the right side of the upper half.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two,
+     * and n<sub>1</sub> &gt;= 2.<p>
+     *
+     * E.g. if the matrix layout is originally as follows:
+     * <table style="width:100px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix before">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td>
+     *   </tr>
+     *   <tr>
+     *     <td>4</td><td>5</td><td>6</td><td>7</td>
+     *   </tr>
+     *   <tr>
+     *     <td>8</td><td>9</td><td>10</td><td>11</td>
+     *   </tr>
+     *   <tr>
+     *     <td>12</td><td>13</td><td>14</td><td>15</td>
+     *   </tr>
+     * </table>
+     * <p>
+     *
+     * Then after this method it is as follows:
+     * <table style="width:200px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix after">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td><td>8</td><td>9</td><td>10</td><td>11</td>
+     *   </tr>
+     *   <tr>
+     *     <td>4</td><td>5</td><td>6</td><td>7</td><td>12</td><td>13</td><td>14</td><td>15</td>
+     *   </tr>
+     * </table>
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be permuted.
+     * @param n1 Number of rows in the matrix.
+     * @param n2 Number of columns in the matrix.
+     *
+     * @since 1.7.0
+     */
+
+    public void permuteToDoubleWidth(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException
+    {
+        if (n1 != (n1 & -n1) ||
+            n2 != (n2 & -n2) ||
+            n1 <= 0 || n2 <= 0)
+        {
+            throw new ApfloatInternalException("Matrix size must be a power of two, not " + n1 + " x " + n2);
+        }
+        if (n1 < 2)
+        {
+            throw new ApfloatInternalException("Matrix height must be at least 2.");
+        }
+        permuteToDoubleWidth(arrayAccess.getLongData(), arrayAccess.getOffset(), n1, n2);
+    }
+
+    /**
+     * Permute the rows of the n<sub>1</sub> x n<sub>2</sub> matrix so that it is shaped like a
+     * 2*n<sub>1</sub> x n<sub>2</sub>/2 matrix. Logically, the matrix is split in half, and the
+     * right half is moved below the left half.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two.
+     *
+     * E.g. if the matrix layout is originally as follows:
+     * <table style="width:200px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix before">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td>
+     *   </tr>
+     *   <tr>
+     *     <td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td>
+     *   </tr>
+     * </table>
+     * <p>
+     *
+     * Then after this method it is as follows:
+     * <table style="width:100px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix after">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td>
+     *   </tr>
+     *   <tr>
+     *     <td>8</td><td>9</td><td>10</td><td>11</td>
+     *   </tr>
+     *   <tr>
+     *     <td>4</td><td>5</td><td>6</td><td>7</td>
+     *   </tr>
+     *   <tr>
+     *     <td>12</td><td>13</td><td>14</td><td>15</td>
+     *   </tr>
+     * </table>
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be permuted.
+     * @param n1 Number of rows in the matrix.
+     * @param n2 Number of columns in the matrix.
+     *
+     * @since 1.7.0
+     */
+
+    public void permuteToHalfWidth(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException
+    {
+        if (n1 != (n1 & -n1) ||
+            n2 != (n2 & -n2) ||
+            n1 <= 0 || n2 <= 0)
+        {
+            throw new ApfloatInternalException("Matrix size must be a power of two, not " + n1 + " x " + n2);
+        }
+        permuteToHalfWidth(arrayAccess.getLongData(), arrayAccess.getOffset(), n1, n2);
+    }
+
+    // Move a b x b block from source to dest
+    private static void moveBlock(long[] source, int sourceOffset, int sourceWidth, long[] dest, int destOffset, int destWidth, int b)
+    {
+        for (int i = 0; i < b; i++)
+        {
+            System.arraycopy(source, sourceOffset, dest, destOffset, b);
+
+            destOffset += destWidth;
+            sourceOffset += sourceWidth;
+        }
+    }
+
+    // Transpose two b x b blocks of matrix with specified width
+    // data based on offset1 is accessed in columns, data based on offset2 in rows
+    private static void transpose2blocks(long[] data, int offset1, int offset2, int width, int b)
+    {
+        for (int i = 0, position1 = offset2; i < b; i++, position1 += width)
+        {
+            for (int j = 0, position2 = offset1 + i; j < b; j++, position2 += width)
+            {
+                long tmp = data[position1 + j];
+                data[position1 + j] = data[position2];
+                data[position2] = tmp;
+            }
+        }
+    }
+
+    // Transpose a b x b block of matrix with specified width
+    private static void transposeBlock(long[] data, int offset, int width, int b)
+    {
+        for (int i = 0, position1 = offset; i < b; i++, position1 += width)
+        {
+            for (int j = i + 1, position2 = offset + j * width + i; j < b; j++, position2 += width)
+            {
+                long tmp = data[position1 + j];
+                data[position1 + j] = data[position2];
+                data[position2] = tmp;
+            }
+        }
+    }
+
+    // Transpose a square n1 x n1 block of n1 x n2 matrix in b x b blocks
+    private static void transposeSquare(long[] data, int offset, int n1, int n2)
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        int cacheBurstBlockSize = Util.round2down(ctx.getCacheBurst() / 8),   // Cache burst in longs
+            cacheBlockSize = Util.sqrt4down(ctx.getCacheL1Size() / 8),        // Transpose block size b that fits in processor L1 cache
+            cacheTreshold = Util.round2down(ctx.getCacheL2Size() / 8);        // Size of matrix that fits in L2 cache
+
+        if (n1 <= cacheBurstBlockSize || n1 <= cacheBlockSize)
+        {
+            // Whole matrix fits in L1 cache
+
+            transposeBlock(data, offset, n2, n1);
+        }
+        else if (n1 * n2 <= cacheTreshold)
+        {
+            // Whole matrix fits in L2 cache (but not in L1 cache)
+            // Sometimes the first algorithm (the block above) is faster, if your L2 cache is very fast
+
+            int b = cacheBurstBlockSize;
+
+            for (int i = 0, position1 = offset; i < n1; i += b, position1 += b * n2)
+            {
+                transposeBlock(data, position1 + i, n2, b);
+
+                for (int j = i + b, position2 = offset + j * n2 + i; j < n1; j += b, position2 += b * n2)
+                {
+                    transpose2blocks(data, position1 + j, position2, n2, b);
+                }
+            }
+        }
+        else
+        {
+            // Whole matrix doesn't fit in L2 cache
+            // This algorithm works fastest if L1 cache size is set correctly
+
+            int b = cacheBlockSize;
+
+            long[] tmp1 = new long[b * b],
+                      tmp2 = new long[b * b];
+
+            for (int i = 0, position1 = offset; i < n1; i += b, position1 += b * n2)
+            {
+                moveBlock(data, position1 + i, n2, tmp1, 0, b, b);
+                transposeBlock(tmp1, 0, b, b);
+                moveBlock(tmp1, 0, b, data, position1 + i, n2, b);
+
+                for (int j = i + b, position2 = offset + j * n2 + i; j < n1; j += b, position2 += b * n2)
+                {
+                    moveBlock(data, position1 + j, n2, tmp1, 0, b, b);
+                    transposeBlock(tmp1, 0, b, b);
+
+                    moveBlock(data, position2, n2, tmp2, 0, b, b);
+                    transposeBlock(tmp2, 0, b, b);
+
+                    moveBlock(tmp2, 0, b, data, position1 + j, n2, b);
+                    moveBlock(tmp1, 0, b, data, position2, n2, b);
+                }
+            }
+        }
+    }
+
+    // Permute the rows of matrix to correct order, to make the n1 x n2 matrix half as wide (2*n1 x n2/2)
+    private static void permuteToHalfWidth(long[] data, int offset, int n1, int n2)
+    {
+        if (n1 < 2)
+        {
+            return;
+        }
+
+        int twicen1 = 2 * n1;
+        int halfn2 = n2 / 2;
+        long[] tmp = new long[halfn2];
+        boolean[] isRowDone = new boolean[twicen1];
+
+        int j = 1;
+        do
+        {
+            int o = j,
+                m = j;
+
+            System.arraycopy(data, offset + halfn2 * m, tmp, 0, halfn2);
+
+            isRowDone[m] = true;
+
+            m = (m < n1 ? 2 * m : 2 * (m - n1) + 1);
+
+            while (m != j)
+            {
+                isRowDone[m] = true;
+
+                System.arraycopy(data, offset + halfn2 * m, data, offset + halfn2 * o, halfn2);
+
+                o = m;
+                m = (m < n1 ? 2 * m : 2 * (m - n1) + 1);
+            }
+
+            System.arraycopy(tmp, 0, data, offset + halfn2 * o, halfn2);
+
+            while (isRowDone[j])
+            {
+                j++;
+            }
+        } while (j < twicen1 - 1);
+    }
+
+    // Permute the rows of matrix to correct order, to make the n1 x n2 matrix twice as wide (n1/2 x 2*n2)
+    private static void permuteToDoubleWidth(long[] data, int offset, int n1, int n2)
+    {
+        if (n1 < 4)
+        {
+            return;
+        }
+
+        int halfn1 = n1 / 2;
+        long[] tmp = new long[n2];
+        boolean[] isRowDone = new boolean[n1];
+
+        int j = 1;
+        do
+        {
+            int o = j,
+                m = j;
+
+            System.arraycopy(data, offset + n2 * m, tmp, 0, n2);
+
+            isRowDone[m] = true;
+
+            m = ((m & 1) != 0 ? m / 2 + halfn1 : m / 2);
+
+            while (m != j)
+            {
+                isRowDone[m] = true;
+
+                System.arraycopy(data, offset + n2 * m, data, offset + n2 * o, n2);
+
+                o = m;
+                m = ((m & 1) != 0 ? m / 2 + halfn1 : m / 2);
+            }
+
+            System.arraycopy(tmp, 0, data, offset + n2 * o, n2);
+
+            while (isRowDone[j])
+            {
+                j++;
+            }
+        } while (j < n1 - 1);
+    }
+}
Index: src/main/java/org/apfloat/internal/LongMediumConvolutionStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/LongMediumConvolutionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongMediumConvolutionStrategy.java	(revision 0)
@@ -0,0 +1,125 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ConvolutionStrategy;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.DataStorage;
+
+/**
+ * Medium-length convolution strategy.
+ * Performs a simple O(n<sup>2</sup>) multiplication when the size of one operand is relatively short.
+ *
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class LongMediumConvolutionStrategy
+    extends LongBaseMath
+    implements ConvolutionStrategy
+{
+    // Implementation notes:
+    // - Assumes that the operands have been already truncated to match resultSize (the resultSize argument is ignored)
+    // - This class probably shouldn't be converted to a single class using generics because there is some performance impact
+
+    /**
+     * Creates a convolution strategy using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public LongMediumConvolutionStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public DataStorage convolute(DataStorage x, DataStorage y, long resultSize)
+        throws ApfloatRuntimeException
+    {
+        DataStorage shortStorage, longStorage;
+
+        if (x.getSize() > y.getSize())
+        {
+            shortStorage = y;
+            longStorage = x;
+        }
+        else
+        {
+            shortStorage = x;
+            longStorage = y;
+        }
+
+        long shortSize = shortStorage.getSize(),
+             longSize = longStorage.getSize(),
+             size = shortSize + longSize;
+
+        if (shortSize > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Too long shorter number, size = " + shortSize);
+        }
+
+        final int bufferSize = (int) shortSize;
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        DataStorage resultStorage = dataStorageBuilder.createDataStorage(size * 8);
+        resultStorage.setSize(size);
+
+        DataStorage.Iterator src = longStorage.iterator(DataStorage.READ, longSize, 0),
+                             dst = resultStorage.iterator(DataStorage.WRITE, size, 0),
+                             tmpDst = new DataStorage.Iterator()                        // Cyclic iterator
+                             {
+                                 public void next()
+                                 {
+                                     this.position++;
+                                     this.position = (this.position == bufferSize ? 0 : this.position);
+                                 }
+
+                                 public long getLong()
+                                 {
+                                     return this.buffer[this.position];
+                                 }
+
+                                 public void setLong(long value)
+                                 {
+                                     this.buffer[this.position] = value;
+                                 }
+
+                                 private static final long serialVersionUID = 1L;
+
+                                 private long[] buffer = new long[bufferSize];
+                                 private int position = 0;
+                             };
+
+        for (long i = 0; i < longSize; i++)
+        {
+            DataStorage.Iterator tmpSrc = shortStorage.iterator(DataStorage.READ, shortSize, 0);        // Sub-optimal: this could be cyclic also
+
+            long factor = src.getLong(),          // Get one word of source data
+                    carry = baseMultiplyAdd(tmpSrc, tmpDst, factor, 0, tmpDst, shortSize),
+                    result = tmpDst.getLong();       // Least significant word of the result
+
+            dst.setLong(result);     // Store one word of result
+
+            tmpDst.setLong(carry);   // Set carry from calculation as new last word in cyclic buffer
+
+            tmpDst.next();              // Cycle buffer; current first word becomes last
+            src.next();
+            dst.next();
+        }
+
+        // Exhaust last words from temporary cyclic buffer and store them to result data
+        for (int i = 0; i < bufferSize; i++)
+        {
+            long result = tmpDst.getLong();
+            dst.setLong(result);
+
+            tmpDst.next();
+            dst.next();
+        }
+
+        return resultStorage;
+    }
+
+    private static final long serialVersionUID = 1303060028106603429L;
+}
Index: src/main/java/org/apfloat/internal/LongMemoryArrayAccess.java
===================================================================
--- src/main/java/org/apfloat/internal/LongMemoryArrayAccess.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongMemoryArrayAccess.java	(revision 0)
@@ -0,0 +1,54 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Array access class based on a <code>long[]</code>.
+ *
+ * @version 1.6.3
+ * @author Mikko Tommila
+ */
+
+public class LongMemoryArrayAccess
+    extends ArrayAccess
+{
+    /**
+     * Create an array access.<p>
+     *
+     * @param data The underlying array.
+     * @param offset The offset of the access segment within the array.
+     * @param length The access segment.
+     */
+
+    public LongMemoryArrayAccess(long[] data, int offset, int length)
+    {
+        super(offset, length);
+        this.data = data;
+    }
+
+    public ArrayAccess subsequence(int offset, int length)
+    {
+        return new LongMemoryArrayAccess(this.data, getOffset() + offset, length);
+    }
+
+    public Object getData()
+    {
+        return this.data;
+    }
+
+    public long[] getLongData()
+    {
+        return this.data;
+    }
+
+    public void close()
+        throws ApfloatRuntimeException
+    {
+        this.data = null;       // Might have an impact on garbage collection
+    }
+
+    private static final long serialVersionUID = 844248131988537796L;
+
+    private long[] data;
+}
Index: src/main/java/org/apfloat/internal/LongMemoryDataStorage.java
===================================================================
--- src/main/java/org/apfloat/internal/LongMemoryDataStorage.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongMemoryDataStorage.java	(revision 0)
@@ -0,0 +1,287 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Memory based data storage implementation for the <code>long</code>
+ * element type.
+ *
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class LongMemoryDataStorage
+    extends DataStorage
+{
+    /**
+     * Default constructor.
+     */
+
+    public LongMemoryDataStorage()
+    {
+        this.data = new long[0];
+    }
+
+    /**
+     * Subsequence constructor.
+     *
+     * @param longMemoryDataStorage The originating data storage.
+     * @param offset The subsequence starting position.
+     * @param length The subsequence length.
+     */
+
+    protected LongMemoryDataStorage(LongMemoryDataStorage longMemoryDataStorage, long offset, long length)
+    {
+        super(longMemoryDataStorage, offset, length);
+        this.data = longMemoryDataStorage.data;
+    }
+
+    public boolean isCached()
+    {
+        return true;
+    }
+
+    protected DataStorage implSubsequence(long offset, long length)
+        throws ApfloatRuntimeException
+    {
+        return new LongMemoryDataStorage(this, offset + getOffset(), length);
+    }
+
+    protected void implCopyFrom(DataStorage dataStorage, long size)
+        throws ApfloatRuntimeException
+    {
+        assert (size > 0);
+        assert (!isReadOnly());
+        assert (!isSubsequenced());
+
+        if (size > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Size too big for memory array: " + size);
+        }
+
+        if (dataStorage == this)
+        {
+            setSize(size);
+            return;
+        }
+
+        this.data = new long[(int) size];
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        int readSize = (int) Math.min(size, dataStorage.getSize()),
+            position = 0,
+            bufferSize = ctx.getBlockSize() / 8;
+
+        while (readSize > 0)
+        {
+            int length = (int) Math.min(bufferSize, readSize);
+
+            ArrayAccess arrayAccess = dataStorage.getArray(READ, position, length);
+            System.arraycopy(arrayAccess.getLongData(), arrayAccess.getOffset(), this.data, position, length);
+            arrayAccess.close();
+
+            readSize -= length;
+            position += length;
+       }
+    }
+
+    protected long implGetSize()
+    {
+        return this.data.length;
+    }
+
+    protected void implSetSize(long size)
+        throws ApfloatRuntimeException
+    {
+        assert (size > 0);
+        assert (!isReadOnly());
+        assert (!isSubsequenced());
+
+        if (size == this.data.length)
+        {
+            return;
+        }
+
+        if (size > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Size too big for memory array: " + size);
+        }
+
+        int newSize = (int) size;
+
+        long[] newData = new long[newSize];
+        System.arraycopy(this.data, 0, newData, 0, Math.min(this.data.length, newSize));
+        this.data = newData;
+    }
+
+    protected ArrayAccess implGetArray(int mode, long offset, int length)
+        throws ApfloatRuntimeException
+    {
+        return new LongMemoryArrayAccess(this.data, (int) (offset + getOffset()), length);
+    }
+
+    protected ArrayAccess implGetArray(int mode, int startColumn, int columns, int rows)
+        throws ApfloatRuntimeException
+    {
+        throw new ApfloatInternalException("Method not implemented - would be sub-optimal; change the apfloat configuration settings");
+    }
+
+    protected ArrayAccess implGetTransposedArray(int mode, int startColumn, int columns, int rows)
+        throws ApfloatRuntimeException
+    {
+        throw new ApfloatInternalException("Method not implemented - would be sub-optimal; change the apfloat configuration settings");
+    }
+
+    private class ReadWriteIterator
+        extends AbstractIterator
+    {
+        public ReadWriteIterator(long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            this(READ_WRITE, startPosition, endPosition);
+        }
+
+        protected ReadWriteIterator(int mode, long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            super(mode, startPosition, endPosition);
+
+            this.data = LongMemoryDataStorage.this.data;
+
+            this.position = (int) getPosition() + (int) getOffset();
+            this.length = (int) getLength();
+        }
+
+        public boolean hasNext()
+        {
+            return (this.length > 0);
+        }
+
+        public void next()
+            throws IllegalStateException
+        {
+            checkLength();
+            this.position += getIncrement();
+            this.length--;
+        }
+
+        public long getLong()
+            throws IllegalStateException
+        {
+            checkLength();
+            return this.data[this.position];
+        }
+
+        public void setLong(long value)
+            throws IllegalStateException
+        {
+            checkLength();
+            this.data[this.position] = value;
+        }
+
+        public <T> T get(Class<T> type)
+            throws UnsupportedOperationException, IllegalStateException
+        {
+            if (!(type.equals(Long.TYPE)))
+            {
+                throw new UnsupportedOperationException("Unsupported data type " + type.getCanonicalName() + ", the only supported type is long");
+            }
+            @SuppressWarnings("unchecked")
+            T value = (T) (Long) getLong();
+            return value;
+        }
+
+        public <T> void set(Class<T> type, T value)
+            throws UnsupportedOperationException, IllegalArgumentException, IllegalStateException
+        {
+            if (!(type.equals(Long.TYPE)))
+            {
+                throw new UnsupportedOperationException("Unsupported data type " + type.getCanonicalName() + ", the only supported type is long");
+            }
+            if (!(value instanceof Long))
+            {
+                throw new IllegalArgumentException("Unsupported value type " + value.getClass().getCanonicalName() + ", the only supported type is Long");
+            }
+            setLong((Long) value);
+        }
+
+        protected void checkLength()
+            throws IllegalStateException
+        {
+            if (this.length == 0)
+            {
+                throw new IllegalStateException("At the end of iterator");
+            }
+        }
+
+        private static final long serialVersionUID = 4304749820031861943L;
+
+        private long[] data;
+        private int position,
+                    length;
+    }
+
+    private class ReadOnlyIterator
+        extends ReadWriteIterator
+    {
+        public ReadOnlyIterator(long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            super(READ, startPosition, endPosition);
+        }
+
+        public void setLong(long value)
+            throws IllegalStateException
+        {
+            throw new IllegalStateException("Not a writable iterator");
+        }
+
+        private static final long serialVersionUID = -7988916595169322136L;
+    }
+
+    private class WriteOnlyIterator
+        extends ReadWriteIterator
+    {
+        public WriteOnlyIterator(long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            super(WRITE, startPosition, endPosition);
+        }
+
+        public long getLong()
+            throws IllegalStateException
+        {
+            throw new IllegalStateException("Not a readable iterator");
+        }
+
+        private static final long serialVersionUID = 5072203220986659720L;
+    }
+
+    public Iterator iterator(int mode, long startPosition, long endPosition)
+        throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+    {
+        Iterator iterator;
+        switch (mode & READ_WRITE)
+        {
+            case READ:
+                iterator = new ReadOnlyIterator(startPosition, endPosition);
+                break;
+            case WRITE:
+                iterator = new WriteOnlyIterator(startPosition, endPosition);
+                break;
+            case READ_WRITE:
+                iterator = new ReadWriteIterator(startPosition, endPosition);
+                break;
+            default:
+                throw new IllegalArgumentException("Illegal mode: " + mode);
+        }
+        return iterator;
+    }
+
+    private static final long serialVersionUID = -6031760912313925045L;
+
+    private long[] data;
+}
Index: src/main/java/org/apfloat/internal/LongModConstants.java
===================================================================
--- src/main/java/org/apfloat/internal/LongModConstants.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongModConstants.java	(revision 0)
@@ -0,0 +1,42 @@
+package org.apfloat.internal;
+
+/**
+ * Constants needed for various modular arithmetic operations for the <code>long</code> type.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public interface LongModConstants
+{
+    /**
+     * Moduli to be used in number theoretic transforms.
+     * Allows transform lengths upto 3*2<sup>47</sup>.
+     */
+
+    public static final long MODULUS[] = { 136796838681378817L, 127508164449927169L, 119063915148607489L };
+
+    /**
+     * Primitive roots for the corresponding moduli.
+     */
+
+    public static final long PRIMITIVE_ROOT[] = { 5, 14, 26 };
+
+    /**
+     * Maximum transform length for the moduli.
+     */
+
+    public static final long MAX_TRANSFORM_LENGTH = 422212465065984L;
+
+    /**
+     * Maximum bits in a power-of-two base that fits in a <code>long</code>.
+     */
+
+    public static final int MAX_POWER_OF_TWO_BITS = 57;
+
+    /**
+     * Maximum power-of-two base that fits in a <code>long</code>.
+     */
+
+    public static final long MAX_POWER_OF_TWO_BASE = 1L << MAX_POWER_OF_TWO_BITS;
+}
Index: src/main/java/org/apfloat/internal/LongModMath.java
===================================================================
--- src/main/java/org/apfloat/internal/LongModMath.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongModMath.java	(revision 0)
@@ -0,0 +1,159 @@
+package org.apfloat.internal;
+
+/**
+ * Modulo arithmetic functions for <code>long</code> data.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public class LongModMath
+    extends LongElementaryModMath
+{
+    /**
+     * Default constructor.
+     */
+
+    public LongModMath()
+    {
+    }
+
+    /**
+     * Create a table of powers of n:th root of unity.
+     *
+     * @param w The n:th root of unity modulo the current modulus.
+     * @param n The table length (= transform length).
+     *
+     * @return Table of <code>table[i]=w<sup>i</sup> mod m</code>, i = 0, ..., n-1.
+     */
+
+    public final long[] createWTable(long w, int n)
+    {
+        long[] wTable = new long[n];
+        long wTemp = 1;
+
+        for (int i = 0; i < n; i++)
+        {
+            wTable[i] = wTemp;
+            wTemp = modMultiply(wTemp, w);
+        }
+
+        return wTable;
+    }
+
+    /**
+     * Get forward n:th root of unity. This is <code>w</code>.<p>
+     *
+     * Assumes that the modulus is prime.
+     *
+     * @param primitiveRoot Primitive root of the modulus.
+     * @param n The transform length.
+     *
+     * @return Forward n:th root of unity.
+     */
+
+    public long getForwardNthRoot(long primitiveRoot, long n)
+    {
+        return modPow(primitiveRoot, getModulus() - 1 - (getModulus() - 1) / (long) n);
+    }
+
+    /**
+     * Get inverse n:th root of unity. This is <code>w<sup>-1</sup></code>.<p>
+     *
+     * Assumes that the modulus is prime.
+     *
+     * @param primitiveRoot Primitive root of the modulus.
+     * @param n The transform length.
+     *
+     * @return Inverse n:th root of unity.
+     */
+
+    public long getInverseNthRoot(long primitiveRoot, long n)
+    {
+        return modPow(primitiveRoot, (getModulus() - 1) / (long) n);
+    }
+
+    /**
+     * Modular inverse, that is <code>1 / a</code>. Assumes that the modulus is prime.
+     *
+     * @param a The operand.
+     *
+     * @return <code>a<sup>-1</sup> mod m</code>.
+     */
+
+    public final long modInverse(long a)
+    {
+        return modPow(a, getModulus() - 2);
+    }
+
+    /**
+     * Modular division. Assumes that the modulus is prime.
+     *
+     * @param a The dividend.
+     * @param b The divisor.
+     *
+     * @return <code>a*b<sup>-1</sup> mod m</code>.
+     */
+
+    public final long modDivide(long a, long b)
+    {
+        return modMultiply(a, modInverse(b));
+    }
+
+    /**
+     * Modular negation.
+     *
+     * @param a The argument.
+     *
+     * @return <code>-a mod m</code>.
+     */
+
+    public final long negate(long a)
+    {
+        return (a == 0 ? 0 : getModulus() - a);
+    }
+
+    /**
+     * Modular power. Assumes that the modulus is prime.
+     *
+     * @param a The base.
+     * @param n The exponent.
+     *
+     * @return <code>a<sup>n</sup> mod m</code>.
+     */
+
+    public final long modPow(long a, long n)
+    {
+        assert (a != 0 || n != 0);
+
+        if (n == 0)
+        {
+            return 1;
+        }
+        else if (n < 0)
+        {
+            return modPow(a, getModulus() - 1 + n);
+        }
+
+        long exponent = (long) n;
+
+        while ((exponent & 1) == 0)
+        {
+            a = modMultiply(a, a);
+            exponent >>= 1;
+        }
+
+        long r = a;
+
+        while ((exponent >>= 1) > 0)
+        {
+            a = modMultiply(a, a);
+            if ((exponent & 1) != 0)
+            {
+                r = modMultiply(r, a);
+            }
+        }
+
+        return r;
+    }
+}
Index: src/main/java/org/apfloat/internal/LongNTTBuilder.java
===================================================================
--- src/main/java/org/apfloat/internal/LongNTTBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongNTTBuilder.java	(revision 0)
@@ -0,0 +1,66 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.NTTStrategy;
+import org.apfloat.spi.NTTStepStrategy;
+import org.apfloat.spi.Factor3NTTStepStrategy;
+import org.apfloat.spi.NTTConvolutionStepStrategy;
+
+/**
+ * Creates Number Theoretic Transforms for the
+ * <code>long</code> type.
+ *
+ * @see LongTableFNTStrategy
+ * @see SixStepFNTStrategy
+ * @see TwoPassFNTStrategy
+ * @see Factor3NTTStrategy
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class LongNTTBuilder
+    extends AbstractNTTBuilder
+{
+    /**
+     * Default constructor.
+     */
+
+    public LongNTTBuilder()
+    {
+    }
+
+    public NTTStepStrategy createNTTSteps()
+    {
+        return new LongNTTStepStrategy();
+    }
+
+    public NTTConvolutionStepStrategy createNTTConvolutionSteps()
+    {
+        return new LongNTTConvolutionStepStrategy();
+    }
+
+    public Factor3NTTStepStrategy createFactor3NTTSteps()
+    {
+        return new LongFactor3NTTStepStrategy();
+    }
+
+    protected NTTStrategy createSimpleFNTStrategy()
+    {
+        return new LongTableFNTStrategy();
+    }
+
+    protected NTTStrategy createSixStepFNTStrategy()
+    {
+        return new SixStepFNTStrategy();
+    }
+
+    protected NTTStrategy createTwoPassFNTStrategy()
+    {
+        return new TwoPassFNTStrategy();
+    }
+
+    protected NTTStrategy createFactor3NTTStrategy(NTTStrategy nttStrategy)
+    {
+        return new Factor3NTTStrategy(nttStrategy);
+    }
+}
Index: src/main/java/org/apfloat/internal/LongNTTConvolutionStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/LongNTTConvolutionStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongNTTConvolutionStepStrategy.java	(revision 0)
@@ -0,0 +1,186 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.NTTConvolutionStepStrategy;
+import org.apfloat.spi.DataStorage;
+import static org.apfloat.internal.LongModConstants.*;
+
+/**
+ * Steps of a three-NTT convolution for the <code>long</code> type.
+ * This class implements the details of the element-by-element multiplication
+ * and element-by-element squaring of the transformed elements.<p>
+ *
+ * The in-place multiplication and squaring of the data elements is done
+ * using a parallel algorithm, if the data fits in memory.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class LongNTTConvolutionStepStrategy
+    extends LongModMath
+    implements NTTConvolutionStepStrategy, Parallelizable
+{
+    // Runnable for multiplying elements in place
+    private class MultiplyInPlaceRunnable
+        implements Runnable
+    {
+        public MultiplyInPlaceRunnable(DataStorage sourceAndDestination, DataStorage source, long offset, long length)
+        {
+            this.sourceAndDestination = sourceAndDestination;
+            this.source = source;
+            this.offset = offset;
+            this.length = length;
+        }
+
+        public void run()
+        {
+            DataStorage.Iterator dest = this.sourceAndDestination.iterator(DataStorage.READ_WRITE, this.offset, this.offset + this.length),
+                                 src = this.source.iterator(DataStorage.READ, this.offset, this.offset + this.length);
+
+            while (this.length > 0)
+            {
+                dest.setLong(modMultiply(dest.getLong(), src.getLong()));
+
+                dest.next();
+                src.next();
+                this.length--;
+            }
+        }
+
+        private DataStorage sourceAndDestination,
+                            source;
+        private long offset,
+                     length;
+    }
+
+    // Runnable for squaring elements in place
+    private class SquareInPlaceRunnable
+        implements Runnable
+    {
+        public SquareInPlaceRunnable(DataStorage sourceAndDestination, long offset, long length)
+        {
+            this.sourceAndDestination = sourceAndDestination;
+            this.offset = offset;
+            this.length = length;
+        }
+
+        public void run()
+        {
+            DataStorage.Iterator iterator = this.sourceAndDestination.iterator(DataStorage.READ_WRITE, this.offset, this.offset + this.length);
+
+            while (this.length > 0)
+            {
+                long value = iterator.getLong();
+                iterator.setLong(modMultiply(value, value));
+
+                iterator.next();
+                this.length--;
+            }
+        }
+
+        private DataStorage sourceAndDestination;
+        private long offset,
+                     length;
+    }
+
+    /**
+     * Default constructor.
+     */
+
+    public LongNTTConvolutionStepStrategy()
+    {
+    }
+
+    public void multiplyInPlace(DataStorage sourceAndDestination, DataStorage source, int modulus)
+        throws ApfloatRuntimeException
+    {
+        assert (sourceAndDestination != source);
+
+        long size = sourceAndDestination.getSize();
+
+        ParallelRunnable parallelRunnable = createMultiplyInPlaceParallelRunnable(sourceAndDestination, source, modulus);
+
+        if (size <= Integer.MAX_VALUE &&                                        // Only if the size fits in an integer, but with memory arrays it should
+            sourceAndDestination.isCached() && source.isCached())               // Only if the data storage supports efficient parallel random access
+        {
+            ParallelRunner.runParallel(parallelRunnable);
+        }
+        else
+        {
+            parallelRunnable.run();                                             // Just run in current thread without parallelization
+        }
+    }
+
+    public void squareInPlace(DataStorage sourceAndDestination, int modulus)
+        throws ApfloatRuntimeException
+    {
+        long size = sourceAndDestination.getSize();
+
+        ParallelRunnable parallelRunnable = createSquareInPlaceParallelRunnable(sourceAndDestination, modulus);
+
+        if (size <= Integer.MAX_VALUE &&                                    // Only if the size fits in an integer, but with memory arrays it should
+            sourceAndDestination.isCached())                                // Only if the data storage supports efficient parallel random access
+        {
+            ParallelRunner.runParallel(parallelRunnable);
+        }
+        else
+        {
+            parallelRunnable.run();                                         // Just run in current thread without parallelization
+        }
+    }
+
+    /**
+     * Create a ParallelRunnable for multiplying the elements in-place.
+     *
+     * @param sourceAndDestination The first source data storage, which is also the destination.
+     * @param source The second source data storage.
+     * @param modulus Which modulus to use (0, 1, 2)
+     *
+     * @return An object suitable for multiplying the elements in parallel.
+     */
+
+    protected ParallelRunnable createMultiplyInPlaceParallelRunnable(final DataStorage sourceAndDestination, final DataStorage source, int modulus)
+    {
+        final long size = sourceAndDestination.getSize();
+
+        setModulus(MODULUS[modulus]);
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(size)
+        {
+            public Runnable getRunnable(long offset, long length)
+            {
+                return new MultiplyInPlaceRunnable(sourceAndDestination, source, offset, length);
+            }
+        };
+        return parallelRunnable;
+    }
+
+    /**
+     * Create a ParallelRunnable for squaring the elements in-place.
+     *
+     * @param sourceAndDestination The source data storage, which is also the destination.
+     * @param modulus Which modulus to use (0, 1, 2)
+     *
+     * @return An object suitable for squaring the elements in parallel.
+     */
+
+    protected ParallelRunnable createSquareInPlaceParallelRunnable(final DataStorage sourceAndDestination, int modulus)
+    {
+        final long size = sourceAndDestination.getSize();
+
+        setModulus(MODULUS[modulus]);
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(size)
+        {
+            public Runnable getRunnable(long offset, long length)
+            {
+                return new SquareInPlaceRunnable(sourceAndDestination, offset, length);
+            }
+        };
+        return parallelRunnable;
+    }
+}
Index: src/main/java/org/apfloat/internal/LongNTTStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/LongNTTStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongNTTStepStrategy.java	(revision 0)
@@ -0,0 +1,210 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ArrayAccess;
+import org.apfloat.spi.NTTStepStrategy;
+import static org.apfloat.internal.LongModConstants.*;
+
+/**
+ * Common methods to calculate Fast Number Theoretic Transforms
+ * in parallel using multiple threads.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class LongNTTStepStrategy
+    extends LongTableFNT
+    implements NTTStepStrategy, Parallelizable
+{
+    // Runnable for calculating the row transforms in parallel
+    private class TableFNTRunnable
+        implements Runnable
+    {
+        public TableFNTRunnable(int length, boolean isInverse, ArrayAccess arrayAccess, long[] wTable, int[] permutationTable)
+        {
+            this.length = length;               // Transform length
+            this.isInverse = isInverse;
+            this.arrayAccess = arrayAccess;
+            this.wTable = wTable;
+            this.permutationTable = permutationTable;
+        }
+
+        public void run()
+        {
+            int maxI = this.arrayAccess.getLength();
+
+            for (int i = 0; i < maxI; i += this.length)
+            {
+                ArrayAccess arrayAccess = this.arrayAccess.subsequence(i, this.length);
+
+                if (this.isInverse)
+                {
+                    inverseTableFNT(arrayAccess, this.wTable, this.permutationTable);
+                }
+                else
+                {
+                    tableFNT(arrayAccess, this.wTable, this.permutationTable);
+                }
+            }
+        }
+
+        private int length;
+        private boolean isInverse;
+        private ArrayAccess arrayAccess;
+        private long[] wTable;
+        private int[] permutationTable;
+    }
+
+    // Runnable for multiplying elements in the matrix
+    private class MultiplyRunnable
+        implements Runnable
+    {
+        public MultiplyRunnable(ArrayAccess arrayAccess, int startRow, int startColumn, int rows, int columns, long w, long scaleFactor)
+        {
+            this.arrayAccess = arrayAccess;
+            this.startRow = startRow;
+            this.startColumn = startColumn;
+            this.rows = rows;
+            this.columns = columns;
+            this.w = w;
+            this.scaleFactor = scaleFactor;
+        }
+
+        public void run()
+        {
+            long[] data = this.arrayAccess.getLongData();
+            int position = this.arrayAccess.getOffset();
+            long rowFactor = modPow(this.w, (long) this.startRow);
+            long columnFactor = modPow(this.w, (long) this.startColumn);
+            long rowStartFactor = modMultiply(this.scaleFactor, modPow(rowFactor, (long) this.startColumn));
+
+            for (int i = 0; i < this.rows; i++)
+            {
+                long factor = rowStartFactor;
+
+                for (int j = 0; j < this.columns; j++, position++)
+                {
+                    data[position] = modMultiply(data[position], factor);
+                    factor = modMultiply(factor, rowFactor);
+                }
+
+                rowFactor = modMultiply(rowFactor, this.w);
+                rowStartFactor = modMultiply(rowStartFactor, columnFactor);
+            }
+         }
+
+        private ArrayAccess arrayAccess;
+        private int startRow;
+        private int startColumn;
+        private int rows;
+        private int columns;
+        private long w;
+        private long scaleFactor;
+    }
+
+    /**
+     * Default constructor.
+     */
+
+    public LongNTTStepStrategy()
+    {
+    }
+
+    public void multiplyElements(ArrayAccess arrayAccess, int startRow, int startColumn, int rows, int columns, long length, long totalTransformLength, boolean isInverse, int modulus)
+        throws ApfloatRuntimeException
+    {
+        ParallelRunnable parallelRunnable = createMultiplyElementsParallelRunnable(arrayAccess, startRow, startColumn, rows, columns, length, totalTransformLength, isInverse, modulus);
+
+        ParallelRunner.runParallel(parallelRunnable);
+    }
+
+    public void transformRows(ArrayAccess arrayAccess, int length, int count, boolean isInverse, boolean permute, int modulus)
+        throws ApfloatRuntimeException
+    {
+        ParallelRunnable parallelRunnable = createTransformRowsParallelRunnable(arrayAccess, length, count, isInverse, permute, modulus);
+
+        ParallelRunner.runParallel(parallelRunnable);
+    }
+
+    public long getMaxTransformLength()
+    {
+        return MAX_TRANSFORM_LENGTH;
+    }
+
+    /**
+     * Create a ParallelRunnable object for multiplying the elements of the matrix.
+     *
+     * @param arrayAccess The memory array to multiply.
+     * @param startRow Which row in the whole matrix the starting row in the <code>arrayAccess</code> is.
+     * @param startColumn Which column in the whole matrix the starting column in the <code>arrayAccess</code> is.
+     * @param rows The number of rows in the <code>arrayAccess</code> to multiply.
+     * @param columns The number of columns in the matrix (= n<sub>2</sub>).
+     * @param length The length of data in the matrix being transformed.
+     * @param totalTransformLength The total transform length, for the scaling factor. Used only for the inverse case.
+     * @param isInverse If the multiplication is done for the inverse transform or not.
+     * @param modulus Index of the modulus.
+     *
+     * @return An object suitable for multiplying the elements of the matrix in parallel.
+     */
+
+    protected ParallelRunnable createMultiplyElementsParallelRunnable(final ArrayAccess arrayAccess, final int startRow, final int startColumn, final int rows, final int columns, long length, long totalTransformLength, boolean isInverse, int modulus)
+        throws ApfloatRuntimeException
+    {
+        setModulus(MODULUS[modulus]);
+        final long w = (isInverse ?
+                           getInverseNthRoot(PRIMITIVE_ROOT[modulus], length) :
+                           getForwardNthRoot(PRIMITIVE_ROOT[modulus], length));
+        final long scaleFactor = (isInverse ?
+                                     modDivide((long) 1, (long) totalTransformLength) :
+                                     (long) 1);
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(rows)
+        {
+            public Runnable getRunnable(int strideStartRow, int strideRows)
+            {
+                ArrayAccess subArrayAccess = arrayAccess.subsequence(strideStartRow * columns, strideRows * columns);
+                return new MultiplyRunnable(subArrayAccess, startRow + strideStartRow, startColumn, strideRows, columns, w, scaleFactor);
+            }
+        };
+
+        return parallelRunnable;
+    }
+
+    /**
+     * Create a ParallelRunnable object for transforming the rows of the matrix.
+     *
+     * @param arrayAccess The memory array to split to rows and to transform.
+     * @param length Length of one transform (one row).
+     * @param count Number of rows.
+     * @param isInverse <code>true</code> if an inverse transform is performed, <code>false</code> if a forward transform is performed.
+     * @param permute If permutation should be done.
+     * @param modulus Index of the modulus.
+     *
+     * @return An object suitable for transforming the rows of the matrix in parallel.
+     */
+
+    protected ParallelRunnable createTransformRowsParallelRunnable(final ArrayAccess arrayAccess, final int length, final int count, final boolean isInverse, boolean permute, int modulus)
+        throws ApfloatRuntimeException
+    {
+        setModulus(MODULUS[modulus]);
+        final long[] wTable = (isInverse ?
+                                  LongWTables.getInverseWTable(modulus, length) :
+                                  LongWTables.getWTable(modulus, length));
+        final int[] permutationTable = (permute ? Scramble.createScrambleTable(length) : null);
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(count)
+        {
+            public Runnable getRunnable(int startIndex, int strideCount)
+            {
+                ArrayAccess subArrayAccess = arrayAccess.subsequence(startIndex * length, strideCount * length);
+                return new TableFNTRunnable(length, isInverse, subArrayAccess, wTable, permutationTable);
+            }
+        };
+
+        return parallelRunnable;
+    }
+}
Index: src/main/java/org/apfloat/internal/LongRadixConstants.java
===================================================================
--- src/main/java/org/apfloat/internal/LongRadixConstants.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongRadixConstants.java	(revision 0)
@@ -0,0 +1,36 @@
+package org.apfloat.internal;
+
+/**
+ * Constants related to different radixes for the <code>long</code> data type.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public interface LongRadixConstants
+{
+    /**
+     * Bases for radixes 2, ..., 36. The base is the radix to the maximum power
+     * so that the base is less than all moduli used.
+     */
+
+    public static final long BASE[] = { (long) -1L, (long) -1L, (long) 72057594037927936L, (long) 50031545098999707L, (long) 72057594037927936L, (long) 59604644775390625L, (long) 21936950640377856L, (long) 79792266297612001L, (long) 18014398509481984L, (long) 16677181699666569L, (long) 100000000000000000L, (long) 45949729863572161L, (long) 15407021574586368L, (long) 51185893014090757L, (long) 11112006825558016L, (long) 29192926025390625L, (long) 72057594037927936L, (long) 9904578032905937L, (long) 20822964865671168L, (long) 42052983462257059L, (long) 81920000000000000L, (long) 7355827511386641L, (long) 12855002631049216L, (long) 21914624432020321L, (long) 36520347436056576L, (long) 59604644775390625L, (long) 95428956661682176L, (long) 5559060566555523L, (long) 8293509467471872L, (long) 12200509765705829L, (long) 17714700000000000L, (long) 25408476896404831L, (long) 36028797018963968L, (long) 50542106513726817L, (long) 70188843638032384L, (long) 96549157373046875L, (long) 3656158440062976L };
+
+    /**
+     * The power of the radix in each base.
+     */
+
+    public static final int BASE_DIGITS[] = { -1, -1, 56, 35, 28, 24, 21, 20, 18, 17, 17, 16, 15, 15, 14, 14, 14, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10 };
+
+    /**
+     * The minimum number in each radix to have the specified amount of digits.
+     */
+
+    public static final long MINIMUM_FOR_DIGITS[][] = { null, null, { (long) 1L, (long) 2L, (long) 4L, (long) 8L, (long) 16L, (long) 32L, (long) 64L, (long) 128L, (long) 256L, (long) 512L, (long) 1024L, (long) 2048L, (long) 4096L, (long) 8192L, (long) 16384L, (long) 32768L, (long) 65536L, (long) 131072L, (long) 262144L, (long) 524288L, (long) 1048576L, (long) 2097152L, (long) 4194304L, (long) 8388608L, (long) 16777216L, (long) 33554432L, (long) 67108864L, (long) 134217728L, (long) 268435456L, (long) 536870912L, (long) 1073741824L, (long) 2147483648L, (long) 4294967296L, (long) 8589934592L, (long) 17179869184L, (long) 34359738368L, (long) 68719476736L, (long) 137438953472L, (long) 274877906944L, (long) 549755813888L, (long) 1099511627776L, (long) 2199023255552L, (long) 4398046511104L, (long) 8796093022208L, (long) 17592186044416L, (long) 35184372088832L, (long) 70368744177664L, (long) 140737488355328L, (long) 281474976710656L, (long) 562949953421312L, (long) 1125899906842624L, (long) 2251799813685248L, (long) 4503599627370496L, (long) 9007199254740992L, (long) 18014398509481984L, (long) 36028797018963968L }, { (long) 1L, (long) 3L, (long) 9L, (long) 27L, (long) 81L, (long) 243L, (long) 729L, (long) 2187L, (long) 6561L, (long) 19683L, (long) 59049L, (long) 177147L, (long) 531441L, (long) 1594323L, (long) 4782969L, (long) 14348907L, (long) 43046721L, (long) 129140163L, (long) 387420489L, (long) 1162261467L, (long) 3486784401L, (long) 10460353203L, (long) 31381059609L, (long) 94143178827L, (long) 282429536481L, (long) 847288609443L, (long) 2541865828329L, (long) 7625597484987L, (long) 22876792454961L, (long) 68630377364883L, (long) 205891132094649L, (long) 617673396283947L, (long) 1853020188851841L, (long) 5559060566555523L, (long) 16677181699666569L }, { (long) 1L, (long) 4L, (long) 16L, (long) 64L, (long) 256L, (long) 1024L, (long) 4096L, (long) 16384L, (long) 65536L, (long) 262144L, (long) 1048576L, (long) 4194304L, (long) 16777216L, (long) 67108864L, (long) 268435456L, (long) 1073741824L, (long) 4294967296L, (long) 17179869184L, (long) 68719476736L, (long) 274877906944L, (long) 1099511627776L, (long) 4398046511104L, (long) 17592186044416L, (long) 70368744177664L, (long) 281474976710656L, (long) 1125899906842624L, (long) 4503599627370496L, (long) 18014398509481984L }, { (long) 1L, (long) 5L, (long) 25L, (long) 125L, (long) 625L, (long) 3125L, (long) 15625L, (long) 78125L, (long) 390625L, (long) 1953125L, (long) 9765625L, (long) 48828125L, (long) 244140625L, (long) 1220703125L, (long) 6103515625L, (long) 30517578125L, (long) 152587890625L, (long) 762939453125L, (long) 3814697265625L, (long) 19073486328125L, (long) 95367431640625L, (long) 476837158203125L, (long) 2384185791015625L, (long) 11920928955078125L }, { (long) 1L, (long) 6L, (long) 36L, (long) 216L, (long) 1296L, (long) 7776L, (long) 46656L, (long) 279936L, (long) 1679616L, (long) 10077696L, (long) 60466176L, (long) 362797056L, (long) 2176782336L, (long) 13060694016L, (long) 78364164096L, (long) 470184984576L, (long) 2821109907456L, (long) 16926659444736L, (long) 101559956668416L, (long) 609359740010496L, (long) 3656158440062976L }, { (long) 1L, (long) 7L, (long) 49L, (long) 343L, (long) 2401L, (long) 16807L, (long) 117649L, (long) 823543L, (long) 5764801L, (long) 40353607L, (long) 282475249L, (long) 1977326743L, (long) 13841287201L, (long) 96889010407L, (long) 678223072849L, (long) 4747561509943L, (long) 33232930569601L, (long) 232630513987207L, (long) 1628413597910449L, (long) 11398895185373143L }, { (long) 1L, (long) 8L, (long) 64L, (long) 512L, (long) 4096L, (long) 32768L, (long) 262144L, (long) 2097152L, (long) 16777216L, (long) 134217728L, (long) 1073741824L, (long) 8589934592L, (long) 68719476736L, (long) 549755813888L, (long) 4398046511104L, (long) 35184372088832L, (long) 281474976710656L, (long) 2251799813685248L }, { (long) 1L, (long) 9L, (long) 81L, (long) 729L, (long) 6561L, (long) 59049L, (long) 531441L, (long) 4782969L, (long) 43046721L, (long) 387420489L, (long) 3486784401L, (long) 31381059609L, (long) 282429536481L, (long) 2541865828329L, (long) 22876792454961L, (long) 205891132094649L, (long) 1853020188851841L }, { (long) 1L, (long) 10L, (long) 100L, (long) 1000L, (long) 10000L, (long) 100000L, (long) 1000000L, (long) 10000000L, (long) 100000000L, (long) 1000000000L, (long) 10000000000L, (long) 100000000000L, (long) 1000000000000L, (long) 10000000000000L, (long) 100000000000000L, (long) 1000000000000000L, (long) 10000000000000000L }, { (long) 1L, (long) 11L, (long) 121L, (long) 1331L, (long) 14641L, (long) 161051L, (long) 1771561L, (long) 19487171L, (long) 214358881L, (long) 2357947691L, (long) 25937424601L, (long) 285311670611L, (long) 3138428376721L, (long) 34522712143931L, (long) 379749833583241L, (long) 4177248169415651L }, { (long) 1L, (long) 12L, (long) 144L, (long) 1728L, (long) 20736L, (long) 248832L, (long) 2985984L, (long) 35831808L, (long) 429981696L, (long) 5159780352L, (long) 61917364224L, (long) 743008370688L, (long) 8916100448256L, (long) 106993205379072L, (long) 1283918464548864L }, { (long) 1L, (long) 13L, (long) 169L, (long) 2197L, (long) 28561L, (long) 371293L, (long) 4826809L, (long) 62748517L, (long) 815730721L, (long) 10604499373L, (long) 137858491849L, (long) 1792160394037L, (long) 23298085122481L, (long) 302875106592253L, (long) 3937376385699289L }, { (long) 1L, (long) 14L, (long) 196L, (long) 2744L, (long) 38416L, (long) 537824L, (long) 7529536L, (long) 105413504L, (long) 1475789056L, (long) 20661046784L, (long) 289254654976L, (long) 4049565169664L, (long) 56693912375296L, (long) 793714773254144L }, { (long) 1L, (long) 15L, (long) 225L, (long) 3375L, (long) 50625L, (long) 759375L, (long) 11390625L, (long) 170859375L, (long) 2562890625L, (long) 38443359375L, (long) 576650390625L, (long) 8649755859375L, (long) 129746337890625L, (long) 1946195068359375L }, { (long) 1L, (long) 16L, (long) 256L, (long) 4096L, (long) 65536L, (long) 1048576L, (long) 16777216L, (long) 268435456L, (long) 4294967296L, (long) 68719476736L, (long) 1099511627776L, (long) 17592186044416L, (long) 281474976710656L, (long) 4503599627370496L }, { (long) 1L, (long) 17L, (long) 289L, (long) 4913L, (long) 83521L, (long) 1419857L, (long) 24137569L, (long) 410338673L, (long) 6975757441L, (long) 118587876497L, (long) 2015993900449L, (long) 34271896307633L, (long) 582622237229761L }, { (long) 1L, (long) 18L, (long) 324L, (long) 5832L, (long) 104976L, (long) 1889568L, (long) 34012224L, (long) 612220032L, (long) 11019960576L, (long) 198359290368L, (long) 3570467226624L, (long) 64268410079232L, (long) 1156831381426176L }, { (long) 1L, (long) 19L, (long) 361L, (long) 6859L, (long) 130321L, (long) 2476099L, (long) 47045881L, (long) 893871739L, (long) 16983563041L, (long) 322687697779L, (long) 6131066257801L, (long) 116490258898219L, (long) 2213314919066161L }, { (long) 1L, (long) 20L, (long) 400L, (long) 8000L, (long) 160000L, (long) 3200000L, (long) 64000000L, (long) 1280000000L, (long) 25600000000L, (long) 512000000000L, (long) 10240000000000L, (long) 204800000000000L, (long) 4096000000000000L }, { (long) 1L, (long) 21L, (long) 441L, (long) 9261L, (long) 194481L, (long) 4084101L, (long) 85766121L, (long) 1801088541L, (long) 37822859361L, (long) 794280046581L, (long) 16679880978201L, (long) 350277500542221L }, { (long) 1L, (long) 22L, (long) 484L, (long) 10648L, (long) 234256L, (long) 5153632L, (long) 113379904L, (long) 2494357888L, (long) 54875873536L, (long) 1207269217792L, (long) 26559922791424L, (long) 584318301411328L }, { (long) 1L, (long) 23L, (long) 529L, (long) 12167L, (long) 279841L, (long) 6436343L, (long) 148035889L, (long) 3404825447L, (long) 78310985281L, (long) 1801152661463L, (long) 41426511213649L, (long) 952809757913927L }, { (long) 1L, (long) 24L, (long) 576L, (long) 13824L, (long) 331776L, (long) 7962624L, (long) 191102976L, (long) 4586471424L, (long) 110075314176L, (long) 2641807540224L, (long) 63403380965376L, (long) 1521681143169024L }, { (long) 1L, (long) 25L, (long) 625L, (long) 15625L, (long) 390625L, (long) 9765625L, (long) 244140625L, (long) 6103515625L, (long) 152587890625L, (long) 3814697265625L, (long) 95367431640625L, (long) 2384185791015625L }, { (long) 1L, (long) 26L, (long) 676L, (long) 17576L, (long) 456976L, (long) 11881376L, (long) 308915776L, (long) 8031810176L, (long) 208827064576L, (long) 5429503678976L, (long) 141167095653376L, (long) 3670344486987776L }, { (long) 1L, (long) 27L, (long) 729L, (long) 19683L, (long) 531441L, (long) 14348907L, (long) 387420489L, (long) 10460353203L, (long) 282429536481L, (long) 7625597484987L, (long) 205891132094649L }, { (long) 1L, (long) 28L, (long) 784L, (long) 21952L, (long) 614656L, (long) 17210368L, (long) 481890304L, (long) 13492928512L, (long) 377801998336L, (long) 10578455953408L, (long) 296196766695424L }, { (long) 1L, (long) 29L, (long) 841L, (long) 24389L, (long) 707281L, (long) 20511149L, (long) 594823321L, (long) 17249876309L, (long) 500246412961L, (long) 14507145975869L, (long) 420707233300201L }, { (long) 1L, (long) 30L, (long) 900L, (long) 27000L, (long) 810000L, (long) 24300000L, (long) 729000000L, (long) 21870000000L, (long) 656100000000L, (long) 19683000000000L, (long) 590490000000000L }, { (long) 1L, (long) 31L, (long) 961L, (long) 29791L, (long) 923521L, (long) 28629151L, (long) 887503681L, (long) 27512614111L, (long) 852891037441L, (long) 26439622160671L, (long) 819628286980801L }, { (long) 1L, (long) 32L, (long) 1024L, (long) 32768L, (long) 1048576L, (long) 33554432L, (long) 1073741824L, (long) 34359738368L, (long) 1099511627776L, (long) 35184372088832L, (long) 1125899906842624L }, { (long) 1L, (long) 33L, (long) 1089L, (long) 35937L, (long) 1185921L, (long) 39135393L, (long) 1291467969L, (long) 42618442977L, (long) 1406408618241L, (long) 46411484401953L, (long) 1531578985264449L }, { (long) 1L, (long) 34L, (long) 1156L, (long) 39304L, (long) 1336336L, (long) 45435424L, (long) 1544804416L, (long) 52523350144L, (long) 1785793904896L, (long) 60716992766464L, (long) 2064377754059776L }, { (long) 1L, (long) 35L, (long) 1225L, (long) 42875L, (long) 1500625L, (long) 52521875L, (long) 1838265625L, (long) 64339296875L, (long) 2251875390625L, (long) 78815638671875L, (long) 2758547353515625L }, { (long) 1L, (long) 36L, (long) 1296L, (long) 46656L, (long) 1679616L, (long) 60466176L, (long) 2176782336L, (long) 78364164096L, (long) 2821109907456L, (long) 101559956668416L } };
+
+    /**
+     * Maximum allowed exponent for each radix.
+     */
+
+    public static final long MAX_EXPONENT[] = { -1L, -1L, 164703072086692419L, 263524915338707874L, 329406144173384844L, 384307168202282319L, 439208192231179794L, 461168601842738784L, 512409557603043094L, 542551296285575041L, 542551296285575041L, 576460752303423481L, 614891469123651714L, 614891469123651714L, 658812288346769694L, 658812288346769694L, 658812288346769694L, 709490156681136594L, 709490156681136594L, 709490156681136594L, 709490156681136594L, 768614336404564644L, 768614336404564644L, 768614336404564644L, 768614336404564644L, 768614336404564644L, 768614336404564644L, 838488366986797794L, 838488366986797794L, 838488366986797794L, 838488366986797794L, 838488366986797794L, 838488366986797794L, 838488366986797794L, 838488366986797794L, 838488366986797794L, 922337203685477574L };
+}
Index: src/main/java/org/apfloat/internal/LongScramble.java
===================================================================
--- src/main/java/org/apfloat/internal/LongScramble.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongScramble.java	(revision 0)
@@ -0,0 +1,38 @@
+package org.apfloat.internal;
+
+/**
+ * Functions to perform bit-reverse ordering of <code>long</code> data.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public class LongScramble
+{
+    private LongScramble()
+    {
+    }
+
+    /**
+     * Permute the data in the table to bit-reversed order.<p>
+     *
+     * The permutation table argument should contain pairs of indexes
+     * that indicate array elements whose contents are swapped.
+     *
+     * @param data The array to permute.
+     * @param offset The offset within the array to permute.
+     * @param permutationTable Table of indexes indicating, which elements in the <code>data</code> are to be swapped.
+     */
+
+    public static void scramble(long[] data, int offset, int[] permutationTable)
+    {
+        for (int k = 0; k < permutationTable.length; k += 2)
+        {
+            int i = offset + permutationTable[k],
+                j = offset + permutationTable[k + 1];
+            long tmp = data[i];
+            data[i] = data[j];
+            data[j] = tmp;
+        }
+    }
+}
Index: src/main/java/org/apfloat/internal/LongShortConvolutionStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/LongShortConvolutionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongShortConvolutionStrategy.java	(revision 0)
@@ -0,0 +1,77 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ConvolutionStrategy;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Short convolution strategy.
+ * Performs a simple multiplication when the size of one operand is 1.
+ *
+ * @version 1.1
+ * @author Mikko Tommila
+ */
+
+public class LongShortConvolutionStrategy
+    extends LongBaseMath
+    implements ConvolutionStrategy
+{
+    // Implementation notes:
+    // - Assumes that the operands have been already truncated to match resultSize (the resultSize argument is ignored)
+    // - This class shouldn't be converted to a single class using generics because the performance impact is noticeable
+
+    /**
+     * Creates a convolution strategy using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public LongShortConvolutionStrategy(int radix)
+    {
+        super(radix);
+    }
+
+    public DataStorage convolute(DataStorage x, DataStorage y, long resultSize)
+        throws ApfloatRuntimeException
+    {
+        DataStorage shortStorage, longStorage, resultStorage;
+
+        if (x.getSize() > 1)
+        {
+            shortStorage = y;
+            longStorage = x;
+        }
+        else
+        {
+            shortStorage = x;
+            longStorage = y;
+        }
+
+        assert (shortStorage.getSize() == 1);
+
+        long size = longStorage.getSize() + 1;
+
+        ArrayAccess arrayAccess = shortStorage.getArray(DataStorage.READ, 0, 1);
+        long factor = arrayAccess.getLongData()[arrayAccess.getOffset()];
+        arrayAccess.close();
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        resultStorage = dataStorageBuilder.createDataStorage(size * 8);
+        resultStorage.setSize(size);
+
+        DataStorage.Iterator src = longStorage.iterator(DataStorage.READ, size - 1, 0),
+                             dst = resultStorage.iterator(DataStorage.WRITE, size, 0);
+
+        long carry = baseMultiplyAdd(src, null, factor, 0, dst, size - 1);
+        dst.setLong(carry);
+        dst.close();
+
+        return resultStorage;
+    }
+
+    private static final long serialVersionUID = 1971685561366493327L;
+}
Index: src/main/java/org/apfloat/internal/LongTableFNT.java
===================================================================
--- src/main/java/org/apfloat/internal/LongTableFNT.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongTableFNT.java	(revision 0)
@@ -0,0 +1,159 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.ArrayAccess;
+
+/**
+ * Fast Number Theoretic Transform that uses lookup tables
+ * for powers of n:th root of unity and permutation indexes.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class LongTableFNT
+    extends LongModMath
+{
+    /**
+     * Default constructor.
+     */
+
+    public LongTableFNT()
+    {
+    }
+
+    /**
+     * Forward (Sande-Tukey) fast Number Theoretic Transform.
+     * Data length must be a power of two.
+     *
+     * @param arrayAccess The data array to transform.
+     * @param wTable Table of powers of n:th root of unity <code>w</code> modulo the current modulus.
+     * @param permutationTable Table of permutation indexes, or <code>null</code> if the data should not be permuted.
+     */
+
+    public void tableFNT(ArrayAccess arrayAccess, long[] wTable, int[] permutationTable)
+        throws ApfloatRuntimeException
+    {
+        int nn, offset, istep, mmax, r;
+        long[] data;
+
+        data   = arrayAccess.getLongData();
+        offset = arrayAccess.getOffset();
+        nn     = arrayAccess.getLength();
+
+        assert (nn == (nn & -nn));
+
+        if (nn < 2)
+        {
+            return;
+        }
+
+        r = 1;
+        mmax = nn >> 1;
+        while (mmax > 0)
+        {
+            istep = mmax << 1;
+
+            // Optimize first step when wr = 1
+
+            for (int i = offset; i < offset + nn; i += istep)
+            {
+                int j = i + mmax;
+                long a = data[i];
+                long b = data[j];
+                data[i] = modAdd(a, b);
+                data[j] = modSubtract(a, b);
+            }
+
+            int t = r;
+
+            for (int m = 1; m < mmax; m++)
+            {
+                for (int i = offset + m; i < offset + nn; i += istep)
+                {
+                    int j = i + mmax;
+                    long a = data[i];
+                    long b = data[j];
+                    data[i] = modAdd(a, b);
+                    data[j] = modMultiply(wTable[t], modSubtract(a, b));
+                }
+                t += r;
+            }
+            r <<= 1;
+            mmax >>= 1;
+        }
+
+        if (permutationTable != null)
+        {
+            LongScramble.scramble(data, offset, permutationTable);
+        }
+    }
+
+    /**
+     * Inverse (Cooley-Tukey) fast Number Theoretic Transform.
+     * Data length must be a power of two.
+     *
+     * @param arrayAccess The data array to transform.
+     * @param wTable Table of powers of n:th root of unity <code>w</code> modulo the current modulus.
+     * @param permutationTable Table of permutation indexes, or <code>null</code> if the data should not be permuted.
+     */
+
+    public void inverseTableFNT(ArrayAccess arrayAccess, long[] wTable, int[] permutationTable)
+        throws ApfloatRuntimeException
+    {
+        int nn, offset, istep, mmax, r;
+        long[] data;
+
+        data   = arrayAccess.getLongData();
+        offset = arrayAccess.getOffset();
+        nn     = arrayAccess.getLength();
+
+        assert (nn == (nn & -nn));
+
+        if (nn < 2)
+        {
+            return;
+        }
+
+        if (permutationTable != null)
+        {
+            LongScramble.scramble(data, offset, permutationTable);
+        }
+
+        r = nn;
+        mmax = 1;
+        while (nn > mmax)
+        {
+            istep = mmax << 1;
+            r >>= 1;
+
+            // Optimize first step when w = 1
+
+            for (int i = offset; i < offset + nn; i += istep)
+            {
+                int j = i + mmax;
+                long wTemp = data[j];
+                data[j] = modSubtract(data[i], wTemp);
+                data[i] = modAdd(data[i], wTemp);
+            }
+
+            int t = r;
+
+            for (int m = 1; m < mmax; m++)
+            {
+                for (int i = offset + m; i < offset + nn; i += istep)
+                {
+                    int j = i + mmax;
+                    long wTemp = modMultiply(wTable[t], data[j]);
+                    data[j] = modSubtract(data[i], wTemp);
+                    data[i] = modAdd(data[i], wTemp);
+                }
+                t += r;
+            }
+            mmax = istep;
+        }
+    }
+}
Index: src/main/java/org/apfloat/internal/LongTableFNTStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/LongTableFNTStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongTableFNTStrategy.java	(revision 0)
@@ -0,0 +1,100 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.NTTStrategy;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+import org.apfloat.spi.Util;
+import static org.apfloat.internal.LongModConstants.*;
+
+/**
+ * Fast Number Theoretic Transform strategy that uses lookup tables
+ * for powers of n:th root of unity and permutation indexes.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class LongTableFNTStrategy
+    extends LongTableFNT
+    implements NTTStrategy
+{
+    /**
+     * Default constructor.
+     */
+
+    public LongTableFNTStrategy()
+    {
+    }
+
+    public void transform(DataStorage dataStorage, int modulus)
+        throws ApfloatRuntimeException
+    {
+        long length = dataStorage.getSize();            // Transform length n
+
+        if (length > MAX_TRANSFORM_LENGTH)
+        {
+            throw new TransformLengthExceededException("Maximum transform length exceeded: " + length + " > " + MAX_TRANSFORM_LENGTH);
+        }
+        else if (length > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Maximum array length exceeded: " + length);
+        }
+
+        setModulus(MODULUS[modulus]);                                       // Modulus
+        long[] wTable = LongWTables.getWTable(modulus, (int) length);
+
+        ArrayAccess arrayAccess = dataStorage.getArray(DataStorage.READ_WRITE, 0, (int) length);
+
+        tableFNT(arrayAccess, wTable, null);
+
+        arrayAccess.close();
+    }
+
+    public void inverseTransform(DataStorage dataStorage, int modulus, long totalTransformLength)
+        throws ApfloatRuntimeException
+    {
+        long length = dataStorage.getSize();            // Transform length n
+
+        if (Math.max(length, totalTransformLength) > MAX_TRANSFORM_LENGTH)
+        {
+            throw new TransformLengthExceededException("Maximum transform length exceeded: " + Math.max(length, totalTransformLength) + " > " + MAX_TRANSFORM_LENGTH);
+        }
+        else if (length > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Maximum array length exceeded: " + length);
+        }
+
+        setModulus(MODULUS[modulus]);                                       // Modulus
+        long[] wTable = LongWTables.getInverseWTable(modulus, (int) length);
+
+        ArrayAccess arrayAccess = dataStorage.getArray(DataStorage.READ_WRITE, 0, (int) length);
+
+        inverseTableFNT(arrayAccess, wTable, null);
+
+        divideElements(arrayAccess, (long) totalTransformLength);
+
+        arrayAccess.close();
+    }
+
+    public long getTransformLength(long size)
+    {
+        return Util.round2up(size);
+    }
+
+    private void divideElements(ArrayAccess arrayAccess, long divisor)
+        throws ApfloatRuntimeException
+    {
+        long inverseFactor = modDivide((long) 1, divisor);
+        long[] data = arrayAccess.getLongData();
+        int length = arrayAccess.getLength(),
+            offset = arrayAccess.getOffset();
+
+        for (int i = 0; i < length; i++)
+        {
+            data[i + offset] = modMultiply(data[i + offset], inverseFactor);
+        }
+    }
+}
Index: src/main/java/org/apfloat/internal/LongWTables.java
===================================================================
--- src/main/java/org/apfloat/internal/LongWTables.java	(revision 0)
+++ src/main/java/org/apfloat/internal/LongWTables.java	(revision 0)
@@ -0,0 +1,86 @@
+package org.apfloat.internal;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.ConcurrentMap;
+
+import org.apfloat.internal.LongModMath;
+import static org.apfloat.internal.LongModConstants.*;
+
+/**
+ * Helper class for generating and caching tables of powers of the n:th root of unity.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class LongWTables
+    extends LongModMath
+{
+    private LongWTables()
+    {
+        // Default constructor
+    }
+
+    /**
+     * Get a table of powers of n:th root of unity.
+     *
+     * @param modulus The index of the modulus to be used.
+     * @param length The length of the table to be returned, i.e. n.
+     *
+     * @return The table of powers of the n:th root of unity.
+     */
+
+    public static long[] getWTable(int modulus, int length)
+    {
+        return getWTable(modulus, length, false);
+    }
+
+    /**
+     * Get a table of inverses of powers of n:th root of unity.
+     *
+     * @param modulus The index of the modulus to be used.
+     * @param length The length of the table to be returned, i.e. n.
+     *
+     * @return The table of inverses of powers of the n:th root of unity.
+     */
+
+    public static long[] getInverseWTable(int modulus, int length)
+    {
+        return getWTable(modulus, length, true);
+    }
+
+    private static long[] getWTable(int modulus, int length, boolean isInverse)
+    {
+        List<Integer> key = Arrays.asList(isInverse ? 1 : 0, modulus, length);
+        long[] wTable = LongWTables.cache.get(key);
+        // Do not synchronize, multiple threads may do this at the same time, but only one gets to put the value in the cache
+        if (wTable == null)
+        {
+            LongModMath instance = getInstance(modulus);
+            long w = (isInverse ?
+                         instance.getInverseNthRoot(PRIMITIVE_ROOT[modulus], length) :  // Inverse n:th root
+                         instance.getForwardNthRoot(PRIMITIVE_ROOT[modulus], length));  // Forward n:th root
+            wTable = instance.createWTable(w, length);
+            // Check if another thread already put the wTable in the cache; if so then use it
+            long[] value = LongWTables.cache.putIfAbsent(key, wTable);
+            if (value != null)
+            {
+                // Another thread did put the value in the cache so use it
+                wTable = value;
+            }
+        }
+        return wTable;
+    }
+
+    private static LongModMath getInstance(int modulus)
+    {
+        LongModMath instance = new LongModMath();
+        instance.setModulus(MODULUS[modulus]);
+        return instance;
+    }
+
+    // With inverses, three moduli and lengths being powers of two, the theoretical maximum map size is 2 * 3 * 30 = 180 entries
+    private static ConcurrentMap<List<Integer>, long[]> cache = new ConcurrentSoftHashMap<List<Integer>, long[]>();
+}
Index: src/main/java/org/apfloat/internal/MessagePasser.java
===================================================================
--- src/main/java/org/apfloat/internal/MessagePasser.java	(revision 0)
+++ src/main/java/org/apfloat/internal/MessagePasser.java	(revision 0)
@@ -0,0 +1,92 @@
+package org.apfloat.internal;
+
+import java.util.Map;
+import java.util.HashMap;
+
+import org.apfloat.ApfloatRuntimeException;
+
+/**
+ * Message passing helper class for parallel codes.
+ * The message passer can hold one message for each receiver.
+ * This class is safe for concurrent use from multiple threads.
+ *
+ * @param <K> The receiver type for this message passer.
+ * @param <V> The message type for this message passer.
+ *
+ * @since 1.6
+ * @version 1.6
+ * @author Mikko Tommila
+ */
+
+public class MessagePasser<K, V>
+{
+    private Map<K, V> messages;
+
+    /**
+     * Default constructor.
+     */
+
+    public MessagePasser()
+    {
+        this.messages = new HashMap<K, V>();
+    }
+
+    /**
+     * Send a message.
+     *
+     * @param receiver The receiver.
+     * @param message The message. Must not be <code>null</code>.
+     */
+
+    public synchronized void sendMessage(K receiver, V message)
+    {
+        assert (message != null);
+        assert (!this.messages.containsKey(receiver));
+
+        this.messages.put(receiver, message);
+
+        notifyAll();
+    }
+
+    /**
+     * Get a message if one is available. This method will not block.
+     *
+     * @param receiver The receiver.
+     *
+     * @return The message, or <code>null</code> if none is available.
+     */
+
+    public synchronized V getMessage(K receiver)
+    {
+        V message = this.messages.remove(receiver);
+
+        return message;
+    }
+
+    /**
+     * Receive a message. This method will block until a message is available.
+     *
+     * @param receiver The receiver.
+     *
+     * @return The message.
+     */
+
+    public synchronized V receiveMessage(K receiver)
+        throws ApfloatRuntimeException
+    {
+        V message;
+        while ((message = this.messages.remove(receiver)) == null)
+        {
+            try
+            {
+                wait();
+            }
+            catch (InterruptedException ie)
+            {
+                throw new ApfloatInternalException("Wait for received message interrupted", ie);
+            }
+        }
+
+        return message;
+    }
+}
Index: src/main/java/org/apfloat/internal/ParallelRunnable.java
===================================================================
--- src/main/java/org/apfloat/internal/ParallelRunnable.java	(revision 0)
+++ src/main/java/org/apfloat/internal/ParallelRunnable.java	(revision 0)
@@ -0,0 +1,144 @@
+package org.apfloat.internal;
+
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apfloat.spi.Util;
+
+/**
+ * Abstract class for a <code>Runnable</code> that can be run in parallel by
+ * multiple threads. Internally, the <code>ParallelRunnable</code> splits the
+ * work to many small batches, which are run one at a time, and can be run in
+ * parallel by multiple threads. The <code>ParallelRunnable</code> isn't
+ * completed until all batches are completed, i.e. the {@link #run()} method
+ * only returns when all batches are completed.
+ *
+ * @since 1.1
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public abstract class ParallelRunnable
+    implements Runnable
+{
+    /**
+     * Subclass constructor.
+     *
+     * @param length The length of the work to be run.
+     */
+
+    protected ParallelRunnable(long length)
+    {
+        // Set the batch size to be some balanced value with respect to the batch size and the number of batches
+        this.preferredBatchSize = Util.sqrt4down(length);
+        this.length = length;
+        this.started = new AtomicLong();
+        this.completed = new AtomicLong();
+    }
+
+    /**
+     * Repeatedly get a batch of work and run it, until all batches are
+     * completed. This method can (and should) be called from multiple
+     * threads in parallel.
+     */
+
+    public final void run()
+    {
+        // Run batches as long as there are any available
+        while (runBatch());
+
+        // Wait until all batches are completed (the above only says all batches were started)
+        // Note that accessing this atomic variable also ensures that memory writes in other
+        // threads have happened-before we get here and see that the task is completed
+        while (this.completed.get() < this.length)
+        {
+            Thread.yield();     // Do not waste time
+        }
+    }
+
+    /**
+     * Run one batch if available. Returns <code>true</code> if a batch was
+     * actually acquired and run, <code>false</code> if all batches were
+     * already started and none could be run. This method can be used by any
+     * thread to steal and complete a minimal amount of work.<p>
+     *
+     * Note that if a batch could not be run, it does not mean that all of
+     * the batches are already completed - some could still be running.
+     *
+     * @return If a batch was actually run.
+     */
+
+    public final boolean runBatch()
+    {
+        boolean isRun = false;
+        if (this.started.get() < this.length)
+        {
+            long batchSize = Math.max(MINIMUM_BATCH_SIZE, getPreferredBatchSize());
+            long startValue = this.started.getAndAdd(batchSize);
+            long length = Math.min(batchSize, this.length - startValue);
+            if (length > 0)
+            {
+                Runnable runnable = getRunnable(startValue, length);
+                runnable.run();
+                // This ensures that all memory writes in the Runnable happen-before other threads can see that the batch was completed
+                this.completed.addAndGet(length);
+                isRun = true;
+            }
+        }
+        return isRun;
+    }
+
+    /**
+     * Get the Runnable object for strides which fit in an <code>int</code>.
+     *
+     * @param startValue The starting value for the stride.
+     * @param length The length of the stride.
+     *
+     * @return The Runnable object for the specified stride.
+     */
+
+    protected Runnable getRunnable(int startValue, int length)
+    {
+        throw new UnsupportedOperationException("Not implemented");
+    }
+
+    /**
+     * Get the Runnable object for strides which fit only in a <code>long</code>.
+     *
+     * @param startValue The starting value for the stride.
+     * @param length The length of the stride.
+     *
+     * @return The Runnable object for the specified stride.
+     */
+
+    protected Runnable getRunnable(long startValue, long length)
+    {
+        if (startValue <= Integer.MAX_VALUE - length)   // Avoid overflow
+        {
+            return getRunnable((int) startValue, (int) length);
+        }
+        else
+        {
+            throw new UnsupportedOperationException("Not implemented");
+        }
+    }
+
+    /**
+     * Get the preferred batch size.
+     *
+     * @return The preferred batch size.
+     *
+     * @since 1.7.0
+     */
+
+    protected long getPreferredBatchSize()
+    {
+        return this.preferredBatchSize;
+    }
+
+    private static final int MINIMUM_BATCH_SIZE = 16;
+
+    private long length;
+    private long preferredBatchSize;
+    private AtomicLong started;
+    private AtomicLong completed;
+}
Index: src/main/java/org/apfloat/internal/ParallelRunner.java
===================================================================
--- src/main/java/org/apfloat/internal/ParallelRunner.java	(revision 0)
+++ src/main/java/org/apfloat/internal/ParallelRunner.java	(revision 0)
@@ -0,0 +1,100 @@
+package org.apfloat.internal;
+
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+
+/**
+ * Class for running <code>ParallelRunnable</code> objects in parallel using
+ * multiple threads.<p>
+ *
+ * The ParallelRunner assumes that the current {@link ApfloatContext} returns an
+ * <code>ExecutorService</code> that is limited to a number of threads that is
+ * one less than the number of processors. This way, when also the current thread
+ * runs batches from the <code>ParallelRunnable</code>, CPU utilization should be
+ * maximized but only so that no more threads are actively executing than the
+ * number of processors.
+ *
+ * @since 1.1
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class ParallelRunner
+{
+    private ParallelRunner()
+    {
+    }
+
+    /**
+     * Run a ParallelRunnable object in parallel using multiple threads.
+     * The method assumes that the <code>ExecutorService</code> returned from
+     * {@link ApfloatContext#getExecutorService()} is limited to using one
+     * thread less than the number of processors. This maximizes CPU usage,
+     * When the <code>ParallelRunnable</code> is also run from the current thread.
+     *
+     * @param parallelRunnable The ParallelRunnable to be run.
+     */
+
+    public static void runParallel(ParallelRunnable parallelRunnable)
+        throws ApfloatRuntimeException
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        int numberOfProcessors = ctx.getNumberOfProcessors();
+
+        ParallelRunner.tasks.add(parallelRunnable);
+        try
+        {
+            if (numberOfProcessors > 1)
+            {
+                ExecutorService executorService = ctx.getExecutorService();
+
+                for (int i = 0; i < numberOfProcessors - 1; i++)
+                {
+                    // Process the task also in other threads
+                    executorService.execute(parallelRunnable);
+                }
+            }
+
+            // Also process the task in the current thread, until it is finished
+            parallelRunnable.run();
+        }
+        finally
+        {
+            ParallelRunner.tasks.remove(parallelRunnable);
+        }
+    }
+
+    /**
+     * While waiting for a <code>Future</code> to be completed, steal a minimal
+     * amount of work from any running task and run it.
+     *
+     * @param future The Future to wait for.
+     */
+
+    public static void wait(Future<?> future)
+    {
+        while (!future.isDone())
+        {
+            // Try and get any running task
+            ParallelRunnable parallelRunnable = ParallelRunner.tasks.peek();
+            if (parallelRunnable != null)
+            {
+                // Steal a minimal amount of work while we wait
+                parallelRunnable.runBatch();
+            }
+            else
+            {
+                // Actually idle - give up the rest of the CPU time slice
+                Thread.yield();
+            }
+        }
+    }
+
+    // Implemented as a List because the assumption is that the number of concurrent tasks is very small
+    private static Queue<ParallelRunnable> tasks = new ConcurrentLinkedQueue<ParallelRunnable>();
+}
Index: src/main/java/org/apfloat/internal/ParallelThreeNTTConvolutionStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/ParallelThreeNTTConvolutionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/ParallelThreeNTTConvolutionStrategy.java	(revision 0)
@@ -0,0 +1,119 @@
+package org.apfloat.internal;
+
+import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.Callable;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.spi.NTTStrategy;
+
+/**
+ * Convolution using three Number Theoretic Transforms
+ * and the CRT to get the final result, using multiple threads in parallel.<p>
+ *
+ * This algorithm is parallelized so that all operations are done in parallel
+ * using multiple threads, if the number of processors is greater than one
+ * in {@link ApfloatContext#getNumberOfProcessors()}.<p>
+ *
+ * If the data block to be transformed is larger than the shared memory treshold setting
+ * in the current ApfloatContext, this class will synchronize all data access on
+ * the shared memory lock retrieved from {@link ApfloatContext#getSharedMemoryLock()}.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class ParallelThreeNTTConvolutionStrategy
+    extends ThreeNTTConvolutionStrategy
+{
+    private static class LockFuture
+        extends FutureTask<Void>
+    {
+        public LockFuture(Lock lock)
+        {
+            super(VOID_CALLABLE);
+            this.lock = lock;
+        }
+
+        public boolean isDone()
+        {
+            return this.lock.tryLock();
+        }
+
+        private static final Callable<Void> VOID_CALLABLE = new Callable<Void>()
+        {
+            public Void call()
+            {
+                return null;
+            }
+        };
+
+        private Lock lock;
+    }
+
+    /**
+     * Creates a new convoluter that uses the specified
+     * transform for transforming the data.
+     *
+     * @param radix The radix to be used.
+     * @param nttStrategy The transform to be used.
+     */
+
+    public ParallelThreeNTTConvolutionStrategy(int radix, NTTStrategy nttStrategy)
+    {
+        super(radix, nttStrategy);
+    }
+
+    protected void lock(long length)
+    {
+        assert(this.key == null);
+
+        if (super.nttStrategy instanceof Parallelizable &&
+            super.carryCRTStrategy instanceof Parallelizable &&
+            super.stepStrategy instanceof Parallelizable)
+        {
+            ApfloatContext ctx = ApfloatContext.getContext();
+            if (length > ctx.getSharedMemoryTreshold() / ctx.getBuilderFactory().getElementSize())
+            {
+                // Data size is big: synchronize on shared memory lock
+                this.key = ctx.getSharedMemoryLock();
+
+                if (this.key != null)
+                {
+                    Lock lock;
+                    synchronized (ParallelThreeNTTConvolutionStrategy.locks)
+                    {
+                        lock = ParallelThreeNTTConvolutionStrategy.locks.get(this.key);
+                        if (lock == null)
+                        {
+                            lock = new ReentrantLock();
+                            ParallelThreeNTTConvolutionStrategy.locks.put(this.key, lock);
+                        }
+                    }
+                    ParallelRunner.wait(new LockFuture(lock));
+                }
+            }
+        }
+    }
+
+    protected void unlock()
+    {
+        if (this.key != null)
+        {
+            synchronized (ParallelThreeNTTConvolutionStrategy.locks)
+            {
+                ParallelThreeNTTConvolutionStrategy.locks.get(this.key).unlock();
+            }
+        }
+    }
+
+    private static Map<Object, Lock> locks = new WeakHashMap<Object, Lock>();
+
+    private Object key;
+}
Index: src/main/java/org/apfloat/internal/Parallelizable.java
===================================================================
--- src/main/java/org/apfloat/internal/Parallelizable.java	(revision 0)
+++ src/main/java/org/apfloat/internal/Parallelizable.java	(revision 0)
@@ -0,0 +1,13 @@
+package org.apfloat.internal;
+
+/**
+ * Any task that can use a {@link ParallelRunner} to execute operations in parallel.
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public interface Parallelizable
+{
+}
Index: src/main/java/org/apfloat/internal/RadixMismatchException.java
===================================================================
--- src/main/java/org/apfloat/internal/RadixMismatchException.java	(revision 0)
+++ src/main/java/org/apfloat/internal/RadixMismatchException.java	(revision 0)
@@ -0,0 +1,53 @@
+package org.apfloat.internal;
+
+/**
+ * Exception indicating a different radix being used in two operands
+ * of a calculation.<p>
+ *
+ * While it's possible to convert numbers to different radixes using the
+ * <code>toRadix()</code> methods, this is highly inefficient. If numbers
+ * of different radixes need to be used in a calculation, they should be
+ * explicitly converted to matching radixes before attempting the calculation.
+ * Otherwise this exception should be thrown.
+ *
+ * @since 1.5
+ * @version 1.5
+ * @author Mikko Tommila
+ */
+
+public class RadixMismatchException
+    extends ApfloatInternalException
+{
+    /**
+     * Constructs a new apfloat radix mismatch exception with an empty detail message.
+     */
+
+    public RadixMismatchException()
+    {
+    }
+
+    /**
+     * Constructs a new apfloat radix mismatch exception with the specified detail message.
+     *
+     * @param message The detail message.
+     */
+
+    public RadixMismatchException(String message)
+    {
+        super(message);
+    }
+
+    /**
+     * Constructs a new apfloat radix mismatch exception with the specified detail message and cause.
+     *
+     * @param message The detail message.
+     * @param cause Originating cause of the exception.
+     */
+
+    public RadixMismatchException(String message, Throwable cause)
+    {
+        super(message, cause);
+    }
+
+    private static final long serialVersionUID = -7022924635011038776L;
+}
Index: src/main/java/org/apfloat/internal/Scramble.java
===================================================================
--- src/main/java/org/apfloat/internal/Scramble.java	(revision 0)
+++ src/main/java/org/apfloat/internal/Scramble.java	(revision 0)
@@ -0,0 +1,80 @@
+package org.apfloat.internal;
+
+import org.apfloat.spi.Util;
+
+/**
+ * Functions to perform bit-reverse ordering of data.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public class Scramble
+{
+    private Scramble()
+    {
+    }
+
+    /**
+     * Permute the bits of a number to reverse order.<p>
+     *
+     * For example, if <code>n</code> is 5 and the transform
+     * length is 256, the permutation is (in binary)<p>
+     *
+     * 00000101 &rarr; 10100000
+     *
+     * @param n The number whose bits to reverse.
+     * @param length The FFT transform length for which the bit reversal to perform.
+     *
+     * @return The bits of <code>n</code> reversed.
+     */
+
+    public static int permute(int n, int length)
+    {
+        assert (length == (length & -length));
+
+        int p = 1;
+
+        while (p < length)
+        {
+            p += p + (n & 1);
+            n >>= 1;
+        }
+
+        return p - length;
+    }
+
+    /**
+     * Create a table of indexes for scrambling an array for FFT.<p>
+     *
+     * The returned table contains pairs of indexes that should be swapped
+     * to scramble an array. For example, for transform length 8 the
+     * returned table contains <code>{ 1, 4, 3, 6 }</code> to indicate
+     * that the array elements [1] and [4] should be swapped, and the elements
+     * [3] and [6] should be swapped.
+     *
+     * @param length The FFT transform length for which the scrambling table is created.
+     *
+     * @return An array of pairs of indexes that indicate, which array elements should be swapped to scramble the array.
+     */
+
+    public static int[] createScrambleTable(int length)
+    {
+        assert (length == (length & -length));
+
+        int[] scrambleTable = new int[length - Util.sqrt4up(length)];
+
+        for (int i = 0, k = 0; i < length; i++)
+        {
+            int j = permute(i, length);
+            if (j < i)
+            {
+                scrambleTable[k] = i;
+                scrambleTable[k + 1] = j;
+                k += 2;
+            }
+        }
+
+        return scrambleTable;
+    }
+}
Index: src/main/java/org/apfloat/internal/SixStepFNTStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/SixStepFNTStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/SixStepFNTStrategy.java	(revision 0)
@@ -0,0 +1,232 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+import org.apfloat.spi.MatrixStrategy;
+
+/**
+ * Fast Number Theoretic Transform that uses a "six-step"
+ * algorithm to calculate a long transform more efficiently on
+ * cache-based memory architectures.<p>
+ *
+ * When the data to be transformed is considered to be an
+ * n<sub>1</sub> x n<sub>2</sub> matrix of data, instead of a linear array,
+ * the six steps are as follows:
+ *
+ * <ol>
+ *   <li>Transpose the matrix.</li>
+ *   <li>Transform the rows.</li>
+ *   <li>Transpose the matrix.</li>
+ *   <li>Multiply each matrix element by w<sup>i j</sup> (where w is the n:th root of unity).</li>
+ *   <li>Transform the rows.</li>
+ *   <li>Transpose the matrix.</li>
+ * </ol>
+ * <p>
+ *
+ * In a convolution algorithm the last transposition step can be omitted
+ * to increase performance, as well as the first transposition step in
+ * the inverse transform. The convolution's element-by-element multiplication
+ * is not sensitive to the order in which the elements are.
+ * Also scrambling the data can be omitted.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class SixStepFNTStrategy
+    extends AbstractStepFNTStrategy
+{
+    /**
+     * Default constructor.
+     */
+
+    public SixStepFNTStrategy()
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        this.matrixStrategy = ctx.getBuilderFactory().getMatrixBuilder().createMatrix();
+    }
+
+    protected void transform(DataStorage dataStorage, int n1, int n2, long length, int modulus)
+        throws ApfloatRuntimeException
+    {
+        if (length > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Maximum array length exceeded: " + length);
+        }
+
+        assert (n2 >= n1);
+
+        ArrayAccess arrayAccess = dataStorage.getArray(DataStorage.READ_WRITE, 0, (int) length);
+
+        // Step 1: Transpose the data
+        transposeInitial(arrayAccess, n1, n2, false);
+
+        // Step 2: Do n2 transforms of length n1
+        transformFirst(arrayAccess, n1, n2, false, modulus);
+
+        // Step 3: Transpose the data
+        transposeMiddle(arrayAccess, n2, n1, false);
+
+        // Step 4: Multiply each matrix element by w^(i*j)
+        multiplyElements(arrayAccess, n1, n2, length, 1, false, modulus);
+
+        // Step 5: Do n1 transforms of length n2
+        transformSecond(arrayAccess, n2, n1, false, modulus);
+
+        // Step 6: Transpose the data - omitted as unnecessary
+        transposeFinal(arrayAccess, n1, n2, false);
+
+        arrayAccess.close();
+    }
+
+    protected void inverseTransform(DataStorage dataStorage, int n1, int n2, long length, long totalTransformLength, int modulus)
+        throws ApfloatRuntimeException
+    {
+        if (length > Integer.MAX_VALUE)
+        {
+            throw new ApfloatInternalException("Maximum array length exceeded: " + length);
+        }
+
+        assert (n2 >= n1);
+
+        ArrayAccess arrayAccess = dataStorage.getArray(DataStorage.READ_WRITE, 0, (int) length);
+
+        // Step 1: Transpose the data - omitted as unnecessary
+        transposeFinal(arrayAccess, n2, n1, true);
+
+        // Step 2: Do n1 transforms of length n2
+        transformSecond(arrayAccess, n2, n1, true, modulus);
+
+        // Step 3: Multiply each matrix element by w^(i*j) / totalTransformLength
+        multiplyElements(arrayAccess, n1, n2, length, totalTransformLength, true, modulus);
+
+        // Step 4: Transpose the data
+        transposeMiddle(arrayAccess, n1, n2, true);
+
+        // Step 5: Do n2 transforms of length n1
+        transformFirst(arrayAccess, n1, n2, true, modulus);
+
+        // Step 6: Transpose the data
+        transposeInitial(arrayAccess, n2, n1, true);
+
+        arrayAccess.close();
+    }
+
+    /**
+     * The initial transpose of the forward transform, or the final transpose
+     * of the inverse transform, to transpose the columns of the matrix to be rows.
+     * This step is needed in the six-step algorithm but is omitted in the four-step
+     * algorithm.
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be transposed.
+     * @param n1 Number of rows in the matrix.
+     * @param n2 Number of columns in the matrix.
+     * @param isInverse <code>true</code> if an inverse transform is performed, <code>false</code> if a forward transform is performed.
+     */
+
+    protected void transposeInitial(ArrayAccess arrayAccess, int n1, int n2, boolean isInverse)
+    {
+        this.matrixStrategy.transpose(arrayAccess, n1, n2);
+    }
+
+    /**
+     * The second transpose of either the forward or inverse transform. Normally
+     * this step is always required as the four-step algorithm only transforms
+     * columns of the matrix and the six-step algorithm transforms only rows.
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be transposed.
+     * @param n1 Number of rows in the matrix.
+     * @param n2 Number of columns in the matrix.
+     * @param isInverse <code>true</code> if an inverse transform is performed, <code>false</code> if a forward transform is performed.
+     */
+
+    protected void transposeMiddle(ArrayAccess arrayAccess, int n1, int n2, boolean isInverse)
+    {
+        this.matrixStrategy.transpose(arrayAccess, n1, n2);
+    }
+
+    /**
+     * The final transpose of the forward transform, or the initial transpose
+     * of the inverse transform. By default this method does nothing as the step is
+     * always unnecessary when the data is only needed for convolution.
+     *
+     * @param arrayAccess Accessor to the matrix data.
+     * @param n1 Number of rows in the matrix.
+     * @param n2 Number of columns in the matrix.
+     * @param isInverse <code>true</code> if an inverse transform is performed, <code>false</code> if a forward transform is performed.
+     */
+
+    protected void transposeFinal(ArrayAccess arrayAccess, int n1, int n2, boolean isInverse)
+    {
+        // Omitted as unnecessary
+    }
+
+    /**
+     * The first transform of the rows (or columns) of the data matrix.
+     * In the default implementation the rows are transformed because in the
+     * forward transform the matrix is transposed first. In the inverse transform
+     * the matrix is initially in transposed form as it was left like that by the
+     * forward transform.<p>
+     *
+     * By default the row transforms permute the data, leaving it in the correct
+     * order so the element-by-element multiplication is simpler.
+     *
+     * @param arrayAccess The memory array to split and transform.
+     * @param length Length of one transform (one row physically, by default).
+     * @param count Number of transforms.
+     * @param isInverse <code>true</code> if an inverse transform is performed, <code>false</code> if a forward transform is performed.
+     * @param modulus Index of the modulus.
+     */
+
+    protected void transformFirst(ArrayAccess arrayAccess, int length, int count, boolean isInverse, int modulus)
+    {
+        super.stepStrategy.transformRows(arrayAccess, length, count, isInverse, true, modulus);
+    }
+
+    /**
+     * The second transform of the rows (or columns) of the data matrix.
+     * In the default implementation the rows are transformed because in the
+     * forward transform the matrix is transposed first. In the inverse transform
+     * the matrix is initially in transposed form as it was left like that by the
+     * forward transform.<p>
+     *
+     * By default the row transforms do not permute the data, leaving it in
+     * scrambled order, as this does not matter when the data is only used for
+     * convolution.
+     *
+     * @param arrayAccess The memory array to split to rows and to transform.
+     * @param length Length of one transform (one row).
+     * @param count Number of rows.
+     * @param isInverse <code>true</code> if an inverse transform is performed, <code>false</code> if a forward transform is performed.
+     * @param modulus Index of the modulus.
+     */
+
+    protected void transformSecond(ArrayAccess arrayAccess, int length, int count, boolean isInverse, int modulus)
+    {
+        super.stepStrategy.transformRows(arrayAccess, length, count, isInverse, false, modulus);
+    }
+
+    /**
+     * Multiply each matrix element by a power of the n:th root of unity.
+     *
+     * @param arrayAccess The memory array to multiply.
+     * @param rows The number of rows in the <code>arrayAccess</code> to multiply.
+     * @param columns The number of columns in the matrix (= n<sub>2</sub>).
+     * @param length The length of data in the matrix being transformed.
+     * @param totalTransformLength The total transform length, for the scaling factor. Used only for the inverse case.
+     * @param isInverse If the multiplication is done for the inverse transform or not.
+     * @param modulus Index of the modulus.
+     */
+
+    protected void multiplyElements(ArrayAccess arrayAccess, int rows, int columns, long length, long totalTransformLength, boolean isInverse, int modulus)
+    {
+        super.stepStrategy.multiplyElements(arrayAccess, 0, 0, rows, columns, length, totalTransformLength, isInverse, modulus);
+    }
+
+    private MatrixStrategy matrixStrategy;
+}
Index: src/main/java/org/apfloat/internal/StepCarryCRTStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/StepCarryCRTStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/StepCarryCRTStrategy.java	(revision 0)
@@ -0,0 +1,195 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.BuilderFactory;
+import org.apfloat.spi.CarryCRTStrategy;
+import org.apfloat.spi.CarryCRTStepStrategy;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.DataStorage;
+
+/**
+ * Class for performing the final step of a three-modulus
+ * Number Theoretic Transform based convolution. Works with blocks of data.<p>
+ *
+ * The algorithm is parallelized for multiprocessor computers,
+ * if the data fits in memory.<p>
+ *
+ * The parallelization works so that the carry-CRT is done in
+ * blocks in parallel. As a final step, a second pass is done
+ * through the data set to propagate the carries from one block
+ * to the next.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @see CarryCRTStepStrategy
+ *
+ * @since 1.7.0
+ * @version 1.8.0
+ * @author Mikko Tommila
+ */
+
+public class StepCarryCRTStrategy
+    implements CarryCRTStrategy, Parallelizable
+{
+    // Runnable for calculating the carry-CRT in blocks, then get the carry of the previous block, add it, and provide carry to the next block
+    private class CarryCRTRunnable<T>
+        implements Runnable
+    {
+        public CarryCRTRunnable(DataStorage resultMod0, DataStorage resultMod1, DataStorage resultMod2, DataStorage dataStorage, long size, long resultSize, long offset, long length, MessagePasser<Long, T> messagePasser, CarryCRTStepStrategy<T> stepStrategy)
+        {
+            this.resultMod0 = resultMod0;
+            this.resultMod1 = resultMod1;
+            this.resultMod2 = resultMod2;
+            this.dataStorage = dataStorage;
+            this.size = size;
+            this.resultSize = resultSize;
+            this.offset = offset;
+            this.length = length;
+            this.messagePasser = messagePasser;
+            this.stepStrategy = stepStrategy;
+        }
+
+        public void run()
+        {
+            T results = this.stepStrategy.crt(this.resultMod0, this.resultMod1, this.resultMod2, this.dataStorage, this.size, this.resultSize, this.offset, this.length);
+
+            // Finishing step - get the carry from the previous block and propagate it through the data
+            if (this.offset > 0)
+            {
+                T previousResults = this.messagePasser.receiveMessage(this.offset);
+
+                results = this.stepStrategy.carry(this.dataStorage, this.size, this.resultSize, this.offset, this.length, results, previousResults);
+            }
+
+            // Finally, send the carry to the next block
+            this.messagePasser.sendMessage(this.offset + this.length, results);
+
+            // Last block sanity check
+            if (this.offset + this.length == this.size)
+            {
+                assert (results != null);
+                assert (java.lang.reflect.Array.getLength(results) == 2);
+                assert (((Number) java.lang.reflect.Array.get(results, 0)).longValue() == 0);
+                assert (((Number) java.lang.reflect.Array.get(results, 1)).longValue() == 0);
+            }
+        }
+
+        private DataStorage resultMod0,
+                            resultMod1,
+                            resultMod2,
+                            dataStorage;
+        private long size,
+                     resultSize,
+                     offset,
+                     length;
+        private MessagePasser<Long, T> messagePasser;
+        private CarryCRTStepStrategy<T> stepStrategy;
+    }
+
+    /**
+     * Creates a carry-CRT object using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     */
+
+    public StepCarryCRTStrategy(int radix)
+    {
+        this.radix = radix;
+    }
+
+    /**
+     * Calculate the final result of a three-NTT convolution.<p>
+     *
+     * Performs a Chinese Remainder Theorem (CRT) on each element
+     * of the three result data sets to get the result of each element
+     * modulo the product of the three moduli. Then it calculates the carries
+     * to get the final result.<p>
+     *
+     * Note that the return value's initial word may be zero or non-zero,
+     * depending on how large the result is.<p>
+     *
+     * Assumes that <code>MODULUS[0] &gt; MODULUS[1] &gt; MODULUS[2]</code>.
+     *
+     * @param resultMod0 The result modulo <code>MODULUS[0]</code>.
+     * @param resultMod1 The result modulo <code>MODULUS[1]</code>.
+     * @param resultMod2 The result modulo <code>MODULUS[2]</code>.
+     * @param resultSize The number of elements needed in the final result.
+     *
+     * @return The final result with the CRT performed and the carries calculated.
+     */
+
+    public DataStorage carryCRT(final DataStorage resultMod0, final DataStorage resultMod1, final DataStorage resultMod2, final long resultSize)
+        throws ApfloatRuntimeException
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        BuilderFactory builderFactory = ctx.getBuilderFactory();
+        Class<?> elementArrayType = builderFactory.getElementArrayType();
+
+        return doCarryCRT(elementArrayType, resultMod0, resultMod1, resultMod2, resultSize);
+    }
+
+    private <T> DataStorage doCarryCRT(Class<T> elementArrayType, DataStorage resultMod0, DataStorage resultMod1, DataStorage resultMod2, long resultSize)
+        throws ApfloatRuntimeException
+    {
+        long size = Math.min(resultSize + 2, resultMod0.getSize());         // Some extra precision if not full result is required
+
+        ApfloatContext ctx = ApfloatContext.getContext();
+        BuilderFactory builderFactory = ctx.getBuilderFactory();
+        DataStorageBuilder dataStorageBuilder = builderFactory.getDataStorageBuilder();
+        final DataStorage dataStorage = dataStorageBuilder.createDataStorage(resultSize * builderFactory.getElementSize());
+        dataStorage.setSize(resultSize);
+
+        ParallelRunnable parallelRunnable = createCarryCRTParallelRunnable(elementArrayType, resultMod0, resultMod1, resultMod2, dataStorage, size, resultSize);
+
+        if (size <= Integer.MAX_VALUE &&                                    // Only if the size fits in an integer, but with memory arrays it should
+            resultMod0.isCached() &&                                        // Only if the data storage supports efficient parallel random access
+            resultMod1.isCached() &&
+            resultMod2.isCached() &&
+            dataStorage.isCached())
+        {
+            ParallelRunner.runParallel(parallelRunnable);
+        }
+        else
+        {
+            parallelRunnable.getRunnable(0, size).run();                    // Just run in current thread without parallelization
+        }
+
+        return dataStorage;
+    }
+
+    /**
+     * Create a ParallelRunnable object for doing the carry-CRT in parallel.
+     *
+     * @param <T> The element array type used.
+     * @param elementArrayType The element array type used.
+     * @param resultMod0 The result modulo <code>MODULUS[0]</code>.
+     * @param resultMod1 The result modulo <code>MODULUS[1]</code>.
+     * @param resultMod2 The result modulo <code>MODULUS[2]</code>.
+     * @param dataStorage The destination data storage of the computation.
+     * @param size The number of elements in the whole data set.
+     * @param resultSize The number of elements needed in the final result.
+     *
+     * @return An suitable object for performing the carry-CRT in parallel.
+     */
+
+    protected <T> ParallelRunnable createCarryCRTParallelRunnable(Class<T> elementArrayType, final DataStorage resultMod0, final DataStorage resultMod1, final DataStorage resultMod2, final DataStorage dataStorage, final long size, final long resultSize)
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        BuilderFactory builderFactory = ctx.getBuilderFactory();
+
+        final MessagePasser<Long, T> messagePasser = new MessagePasser<Long, T>();
+        final CarryCRTStepStrategy<T> stepStrategy = builderFactory.getCarryCRTBuilder(elementArrayType).createCarryCRTSteps(this.radix);
+
+        ParallelRunnable parallelRunnable = new ParallelRunnable(size)
+        {
+            public Runnable getRunnable(long offset, long length)
+            {
+                return new CarryCRTRunnable<T>(resultMod0, resultMod1, resultMod2, dataStorage, size, resultSize, offset, length, messagePasser, stepStrategy);
+            }
+        };
+        return parallelRunnable;
+    }
+
+    private int radix;
+}
Index: src/main/java/org/apfloat/internal/ThreeNTTConvolutionStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/ThreeNTTConvolutionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/ThreeNTTConvolutionStrategy.java	(revision 0)
@@ -0,0 +1,230 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.BuilderFactory;
+import org.apfloat.spi.CarryCRTStrategy;
+import org.apfloat.spi.ConvolutionStrategy;
+import org.apfloat.spi.NTTStrategy;
+import org.apfloat.spi.NTTConvolutionStepStrategy;
+import org.apfloat.spi.DataStorageBuilder;
+import org.apfloat.spi.DataStorage;
+
+/**
+ * Convolution using three Number Theoretic Transforms
+ * and the Chinese Remainder Theorem to get the final result.<p>
+ *
+ * Multiplication can be done in linear time in the transform domain, where
+ * the multiplication is simply an element-by-element multiplication.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public class ThreeNTTConvolutionStrategy
+    implements ConvolutionStrategy
+{
+    /**
+     * Creates a new convoluter that uses the specified
+     * transform for transforming the data.
+     *
+     * @param radix The radix to be used.
+     * @param nttStrategy The transform to be used.
+     */
+
+    public ThreeNTTConvolutionStrategy(int radix, NTTStrategy nttStrategy)
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        BuilderFactory builderFactory = ctx.getBuilderFactory();
+        this.nttStrategy = nttStrategy;
+        this.carryCRTStrategy = builderFactory.getCarryCRTBuilder(builderFactory.getElementArrayType()).createCarryCRT(radix);
+        this.stepStrategy = builderFactory.getNTTBuilder().createNTTConvolutionSteps();
+    }
+
+    public DataStorage convolute(DataStorage x, DataStorage y, long resultSize)
+        throws ApfloatRuntimeException
+    {
+        if (x == y)
+        {
+            return autoConvolute(x, resultSize);
+        }
+
+        long length = this.nttStrategy.getTransformLength(x.getSize() + y.getSize());
+
+        DataStorage result;
+        lock(length);
+        try
+        {
+            DataStorage resultMod0 = convoluteOne(x, y, length, 0, false),
+                        resultMod1 = convoluteOne(x, y, length, 1, false),
+                        resultMod2 = convoluteOne(x, y, length, 2, true);
+
+            result = this.carryCRTStrategy.carryCRT(resultMod0, resultMod1, resultMod2, resultSize);
+        }
+        finally
+        {
+            unlock();
+        }
+        return result;
+    }
+
+    /**
+     * Performs a convolution modulo one modulus, of the specified transform length.
+     *
+     * @param x First data set.
+     * @param y Second data set.
+     * @param length Length of the transformation.
+     * @param modulus Which modulus to use.
+     * @param cached If the result data should be kept cached in memory when possible.
+     *
+     * @return The result of the convolution for one modulus.
+     */
+
+    protected DataStorage convoluteOne(DataStorage x, DataStorage y, long length, int modulus, boolean cached)
+        throws ApfloatRuntimeException
+    {
+        DataStorage tmpY = createCachedDataStorage(length);
+        tmpY.copyFrom(y, length);                               // Using a cached data storage here can avoid an extra write
+        this.nttStrategy.transform(tmpY, modulus);
+        tmpY = createDataStorage(tmpY);
+
+        DataStorage tmpX = createCachedDataStorage(length);
+        tmpX.copyFrom(x, length);
+        this.nttStrategy.transform(tmpX, modulus);
+
+        this.stepStrategy.multiplyInPlace(tmpX, tmpY, modulus);
+
+        this.nttStrategy.inverseTransform(tmpX, modulus, length);
+        tmpX = (cached ? tmpX : createDataStorage(tmpX));
+
+        return tmpX;
+    }
+
+    /**
+     * Convolutes a data set with itself.
+     *
+     * @param x The data set.
+     * @param resultSize Number of elements needed in the result data.
+     *
+     * @return The convolved data.
+     */
+
+    protected DataStorage autoConvolute(DataStorage x, long resultSize)
+        throws ApfloatRuntimeException
+    {
+        long length = this.nttStrategy.getTransformLength(x.getSize() * 2);
+
+        DataStorage result;
+        lock(length);
+        try
+        {
+            DataStorage resultMod0 = autoConvoluteOne(x, length, 0, false),
+                        resultMod1 = autoConvoluteOne(x, length, 1, false),
+                        resultMod2 = autoConvoluteOne(x, length, 2, true);
+
+            result = this.carryCRTStrategy.carryCRT(resultMod0, resultMod1, resultMod2, resultSize);
+        }
+        finally
+        {
+            unlock();
+        }
+        return result;
+    }
+
+    /**
+     * Performs an autoconvolution modulo one modulus, of the specified transform length.
+     *
+     * @param x The data set.
+     * @param length Length of the transformation.
+     * @param modulus Which modulus to use.
+     * @param cached If the result data should be kept cached in memory when possible.
+     *
+     * @return The result of the convolution for one modulus.
+     */
+
+    protected DataStorage autoConvoluteOne(DataStorage x, long length, int modulus, boolean cached)
+        throws ApfloatRuntimeException
+    {
+        DataStorage tmp = createCachedDataStorage(length);
+        tmp.copyFrom(x, length);
+        this.nttStrategy.transform(tmp, modulus);
+
+        this.stepStrategy.squareInPlace(tmp, modulus);
+
+        this.nttStrategy.inverseTransform(tmp, modulus, length);
+        tmp = (cached ? tmp : createDataStorage(tmp));
+
+        return tmp;
+    }
+
+    /**
+     * Lock the execution against a synchronization lock.
+     *
+     * @param length The length of the data being processed for determining the type of lock to use.
+     */
+
+    protected void lock(long length)
+    {
+    }
+
+    /**
+     * Remove the synchronization lock.
+     */
+
+    protected void unlock()
+    {
+    }
+
+    /**
+     * Create a cached (if possible) data storage for the specified number of elements.
+     * 
+     * @param size The number of elements.
+     *
+     * @return The data storage.
+     */
+
+    protected DataStorage createCachedDataStorage(long size)
+        throws ApfloatRuntimeException
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        return dataStorageBuilder.createCachedDataStorage(size * ctx.getBuilderFactory().getElementSize());
+    }
+
+    /**
+     * Create a cached data storage from the (possibly) cached data storage.
+     *
+     * @param dataStorage The data storage, which may be cached.
+     *
+     * @return The data storage, which isn't cached.
+     */
+
+    protected DataStorage createDataStorage(DataStorage dataStorage)
+        throws ApfloatRuntimeException
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        DataStorageBuilder dataStorageBuilder = ctx.getBuilderFactory().getDataStorageBuilder();
+        return dataStorageBuilder.createDataStorage(dataStorage);
+    }
+
+    /**
+     * The transform to use.
+     */
+
+    protected NTTStrategy nttStrategy;
+
+    /**
+     * The carry-CRT to use.
+     */
+
+    protected CarryCRTStrategy carryCRTStrategy;
+
+    /**
+     * The convolution steps to use.
+     */
+
+    protected NTTConvolutionStepStrategy stepStrategy;
+}
Index: src/main/java/org/apfloat/internal/TransformLengthExceededException.java
===================================================================
--- src/main/java/org/apfloat/internal/TransformLengthExceededException.java	(revision 0)
+++ src/main/java/org/apfloat/internal/TransformLengthExceededException.java	(revision 0)
@@ -0,0 +1,52 @@
+package org.apfloat.internal;
+
+/**
+ * Exception indicating that the "size" of the numbers used in a
+ * multiplication is too large. The "size" is equivalent to the number
+ * of significant digits in the mantissa of the number, excluding any
+ * leading or trailing zeros.<p>
+ *
+ * This exception indicates a mathematical limitation. The exact
+ * maximum transform length depends on the apfloat implementation.
+ *
+ * @since 1.5
+ * @version 1.5
+ * @author Mikko Tommila
+ */
+
+public class TransformLengthExceededException
+    extends ApfloatInternalException
+{
+    /**
+     * Constructs a new apfloat transform length exceeded exception with an empty detail message.
+     */
+
+    public TransformLengthExceededException()
+    {
+    }
+
+    /**
+     * Constructs a new apfloat transform length exceeded exception with the specified detail message.
+     *
+     * @param message The detail message.
+     */
+
+    public TransformLengthExceededException(String message)
+    {
+        super(message);
+    }
+
+    /**
+     * Constructs a new apfloat transform length exceeded exception with the specified detail message and cause.
+     *
+     * @param message The detail message.
+     * @param cause Originating cause of the exception.
+     */
+
+    public TransformLengthExceededException(String message, Throwable cause)
+    {
+        super(message, cause);
+    }
+
+    private static final long serialVersionUID = -7022924635011038776L;
+}
Index: src/main/java/org/apfloat/internal/TwoPassFNTStrategy.java
===================================================================
--- src/main/java/org/apfloat/internal/TwoPassFNTStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/internal/TwoPassFNTStrategy.java	(revision 0)
@@ -0,0 +1,257 @@
+package org.apfloat.internal;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+import org.apfloat.spi.ArrayAccess;
+import org.apfloat.spi.Util;
+
+/**
+ * Fast Number Theoretic Transform that uses a "two-pass"
+ * algorithm to calculate a very long transform on data that
+ * resides on a mass storage device. The storage medium should
+ * preferably be a solid state disk for good performance;
+ * on normal hard disks performance is usually inadequate.<p>
+ *
+ * The "two-pass" algorithm only needs to do two passes through
+ * the data set. In comparison, a basic FFT algorithm of length 2<sup>n</sup>
+ * needs to do n passes through the data set. Although the
+ * algorithm is fairly optimal in terms of amount of data transferred
+ * between the mass storage and main memory, the mass storage access is
+ * not linear but done in small incontinuous pieces, so due to disk
+ * seek times the performance can be quite lousy.<p>
+ *
+ * When the data to be transformed is considered to be an
+ * n<sub>1</sub> x n<sub>2</sub> matrix of data, instead of a linear array,
+ * the two passes go as follows:
+ *
+ * <ol>
+ *   <li>Do n<sub>2</sub> transforms of length n<sub>1</sub> by transforming the matrix columns.
+ *       Do this by fetching n<sub>1</sub> x b blocks in memory so that the
+ *       blocks are as large as possible but fit in main memory.</li>
+ *   <li>Then do n<sub>1</sub> transforms of length n<sub>2</sub> by transforming the matrix rows.
+ *       Do this also by fetching b x n<sub>2</sub> blocks in memory so that the blocks just
+ *       fit in the available memory.</li>
+ * </ol>
+ * <p>
+ *
+ * The algorithm requires reading blocks of b elements from the mass storage device.
+ * The smaller the amount of memory compared to the transform length is, the smaller
+ * is b also. Reading very short blocks of data from hard disks can be prohibitively
+ * slow.<p>
+ *
+ * When reading the column data to be transformed, the data can be transposed to
+ * rows by reading the b-length blocks to proper locations in memory and then
+ * transposing the b x b blocks.<p>
+ *
+ * In a convolution algorithm the data elements can remain in any order after
+ * the transform, as long as the inverse transform can transform it back.
+ * The convolution's element-by-element multiplication is not sensitive
+ * to the order in which the elements are.<p>
+ *
+ * All access to this class must be externally synchronized.
+ *
+ * @see DataStorage#getTransposedArray(int,int,int,int)
+ *
+ * @since 1.7.0
+ * @version 1.8.1
+ * @author Mikko Tommila
+ */
+
+public class TwoPassFNTStrategy
+    extends AbstractStepFNTStrategy
+{
+    /**
+     * Default constructor.
+     */
+
+    public TwoPassFNTStrategy()
+    {
+    }
+
+    protected void transform(DataStorage dataStorage, int n1, int n2, long length, int modulus)
+        throws ApfloatRuntimeException
+    {
+        assert (n2 >= n1);
+
+        int maxBlockSize = getMaxMemoryBlockSize(length),   // Maximum memory array size that can be allocated
+            b;
+
+        if (n1 > maxBlockSize || n2 > maxBlockSize)
+        {
+            throw new ApfloatInternalException("Not enough memory available to fit one row or column of matrix to memory; n1=" + n1 + ", n2=" + n2 + ", available=" + maxBlockSize);
+        }
+
+        b = maxBlockSize / n1;
+
+        for (int i = 0; i < n2; i += b)
+        {
+            // Read the data in n1 x b blocks, transposed
+            ArrayAccess arrayAccess = getColumns(dataStorage, i, b, n1);
+
+            // Do b transforms of size n1
+            transformColumns(arrayAccess, n1, b, false, modulus);
+
+            arrayAccess.close();
+        }
+
+        b = maxBlockSize / n2;
+
+        for (int i = 0; i < n1; i += b)
+        {
+            // Read the data in b x n2 blocks
+            ArrayAccess arrayAccess = getRows(dataStorage, i, b, n2);
+
+            // Multiply each matrix element by w^(i*j)
+            multiplyElements(arrayAccess, i, 0, b, n2, length, 1, false, modulus);
+
+            // Do b transforms of size n2
+            transformRows(arrayAccess, n2, b, false, modulus);
+
+            arrayAccess.close();
+        }
+    }
+
+    protected void inverseTransform(DataStorage dataStorage, int n1, int n2, long length, long totalTransformLength, int modulus)
+        throws ApfloatRuntimeException
+    {
+        assert (n2 >= n1);
+
+        int maxBlockSize = getMaxMemoryBlockSize(length),   // Maximum memory array size that can be allocated
+            b;
+
+        if (n1 > maxBlockSize || n2 > maxBlockSize)
+        {
+            throw new ApfloatInternalException("Not enough memory available to fit one row or column of matrix to memory; n1=" + n1 + ", n2=" + n2 + ", available=" + maxBlockSize);
+        }
+
+        b = maxBlockSize / n2;
+
+        for (int i = 0; i < n1; i += b)
+        {
+            // Read the data in b x n2 blocks
+            ArrayAccess arrayAccess = getRows(dataStorage, i, b, n2);
+
+            // Do b transforms of size n2
+            transformRows(arrayAccess, n2, b, true, modulus);
+
+            // Multiply each matrix element by w^(i*j) / n
+            multiplyElements(arrayAccess, i, 0, b, n2, length, totalTransformLength, true, modulus);
+
+            arrayAccess.close();
+        }
+
+        b = maxBlockSize / n1;
+
+        for (int i = 0; i < n2; i += b)
+        {
+            // Read the data in n1 x b blocks, transposed
+            ArrayAccess arrayAccess = getColumns(dataStorage, i, b, n1);
+
+            // Do b transforms of size n1
+            transformColumns(arrayAccess, n1, b, true, modulus);
+
+            arrayAccess.close();
+        }
+    }
+
+    /**
+     * Get a block of column data. The data may be transposed, depending on the implementation.
+     *
+     * @param dataStorage The data storage.
+     * @param startColumn The starting column where data is read.
+     * @param columns The number of columns of data to read.
+     * @param rows The number of rows of data to read. This should be equivalent to n<sub>1</sub>, number of rows in the matrix.
+     *
+     * @return Access to an array of size <code>columns</code> x <code>rows</code> containing the data.
+     */
+
+    protected ArrayAccess getColumns(DataStorage dataStorage, int startColumn, int columns, int rows)
+    {
+        return dataStorage.getTransposedArray(DataStorage.READ_WRITE, startColumn, columns, rows);
+    }
+
+    /**
+     * Get a block of row data. The data may be transposed, depending on the implementation.
+     *
+     * @param dataStorage The data storage.
+     * @param startRow The starting row where data is read.
+     * @param rows The number of rows of data to read.
+     * @param columns The number of columns of data to read. This should be equivalent to n<sub>2</sub>, number of columns in the matrix.
+     *
+     * @return Access to an array of size <code>columns</code> x <code>rows</code> containing the data.
+     */
+
+    protected ArrayAccess getRows(DataStorage dataStorage, int startRow, int rows, int columns)
+    {
+        return dataStorage.getArray(DataStorage.READ_WRITE, startRow * columns, rows * columns);
+    }
+
+    /**
+     * Multiply each matrix element <code>(i, j)</code> by <code>w<sup>i * j</sup> / totalTransformLength</code>.
+     * The matrix size is n<sub>1</sub> x n<sub>2</sub>.
+     *
+     * @param arrayAccess The memory array to multiply.
+     * @param startRow Which row in the whole matrix the starting row in the <code>arrayAccess</code> is.
+     * @param startColumn Which column in the whole matrix the starting column in the <code>arrayAccess</code> is.
+     * @param rows The number of rows in the <code>arrayAccess</code> to multiply.
+     * @param columns The number of columns in the matrix (= n<sub>2</sub>).
+     * @param length The length of data in the matrix being transformed.
+     * @param totalTransformLength The total transform length, for the scaling factor. Used only for the inverse case.
+     * @param isInverse If the multiplication is done for the inverse transform or not.
+     * @param modulus Index of the modulus.
+     */
+
+    protected void multiplyElements(ArrayAccess arrayAccess, int startRow, int startColumn, int rows, int columns, long length, long totalTransformLength, boolean isInverse, int modulus)
+    {
+        super.stepStrategy.multiplyElements(arrayAccess, startRow, startColumn, rows, columns, length, totalTransformLength, isInverse, modulus);
+    }
+
+    /**
+     * Transform the columns of the data matrix.
+     * The data may be in transposed format, depending on the implementation.<p>
+     *
+     * By default the column transforms permute the data, leaving it in the correct
+     * order so the element-by-element multiplication is simpler.
+     *
+     * @param arrayAccess The memory array to split to columns and to transform.
+     * @param length Length of one transform (one columns).
+     * @param count Number of columns.
+     * @param isInverse <code>true</code> if an inverse transform is performed, <code>false</code> if a forward transform is performed.
+     * @param modulus Index of the modulus.
+     */
+
+    protected void transformColumns(ArrayAccess arrayAccess, int length, int count, boolean isInverse, int modulus)
+    {
+        super.stepStrategy.transformRows(arrayAccess, length, count, isInverse, true, modulus);
+    }
+
+    /**
+     * Transform the rows of the data matrix.
+     * The data may be in transposed format, depending on the implementation.<p>
+     *
+     * By default the row transforms do not permute the data, leaving it in
+     * scrambled order, as this does not matter when the data is only used for
+     * convolution.
+     *
+     * @param arrayAccess The memory array to split to rows and to transform.
+     * @param length Length of one transform (one row).
+     * @param count Number of rows.
+     * @param isInverse <code>true</code> if an inverse transform is performed, <code>false</code> if a forward transform is performed.
+     * @param modulus Index of the modulus.
+     */
+
+    protected void transformRows(ArrayAccess arrayAccess, int length, int count, boolean isInverse, int modulus)
+    {
+        super.stepStrategy.transformRows(arrayAccess, length, count, isInverse, false, modulus);
+    }
+
+    private int getMaxMemoryBlockSize(long length)
+    {
+        ApfloatContext ctx = ApfloatContext.getContext();
+        long maxMemoryBlockSize = Util.round2down(Math.min(ctx.getMaxMemoryBlockSize(), Integer.MAX_VALUE)) / ctx.getBuilderFactory().getElementSize();
+        int maxBlockSize = (int) Math.min(length, maxMemoryBlockSize);
+
+        return maxBlockSize;
+    }
+}
Index: src/main/java/org/apfloat/internal/package-info.java
===================================================================
--- src/main/java/org/apfloat/internal/package-info.java	(revision 0)
+++ src/main/java/org/apfloat/internal/package-info.java	(revision 0)
@@ -0,0 +1,212 @@
+/**
+Default implementations of the apfloat Service Provider Interface (SPI).<p>
+
+The <code>org.apfloat.internal</code> package contains four different
+implementations of the apfloat SPI, each based on a different primitive
+element type:
+
+<ul>
+  <li>{@link org.apfloat.internal.IntBuilderFactory}, based on element type
+      <code>int</code>: This is the default implementation used by apfloat.
+      It works well for 32-bit platforms that perform integer operations fast
+      (including integer multiplication), and can multiply <code>double</code>s
+      and convert between <code>double</code> and <code>int</code> with adequate
+      performance. This applies to most workstations today (Intel x86 processors
+      and compatibles, in particular processors with SSE2 support, and most RISC
+      architectures). You can do calculations up to roughly 226 million digits
+      (in radix 10) with this implementation, which should be enough for most
+      purposes.</li>
+  <li>{@link org.apfloat.internal.LongBuilderFactory}, based on element type
+      <code>long</code>: This implementation uses the 64-bit <code>long</code>
+      integer as the elementary type for all data storage and manipulation. It
+      usually is faster than the <code>int</code> version on 64-bit architectures
+      if you have a JVM that actually uses the 64-bit features of the processor.
+      In some places it uses also <code>double</code> arithmetic, so the processor
+      should be able to perform double-precision floating point operations as well
+      as convert between <code>double</code> and <code>long</code>, for decent
+      performance. For example, on x86-64 and SPARC the 64-bit <code>long</code>
+      version is faster than the 32-bit <code>int</code> version. You can use the
+      <code>long</code> implementation on 32-bit platforms too, however the
+      performance per element is less than half of the <code>int</code> version,
+      even if roughly twice as much data is processed per element. The upside
+      is that this implementation can do much bigger calculations: up to about
+      3.5&nbsp;*&nbsp;10<sup>15</sup> digits in radix 10.</li>
+  <li>{@link org.apfloat.internal.DoubleBuilderFactory}, based on element type
+      <code>double</code>: This implementation exists generally only as a
+      curiosity. It will typically perform worse than the <code>long</code>
+      version, and it's only able to do calculations with about 1/20 of its
+      maximum digit length. The only situation where using the <code>double</code>
+      version might make sense is on a platform that performs floating-point
+      arithmetic well, but performs integer arithmetic extremely badly. Finding
+      such a platform today might be difficult, so generally it's advisable to
+      use the <code>long</code> version instead, if you have a 64-bit platform
+      or need the most extreme precision.</li>
+  <li>{@link org.apfloat.internal.FloatBuilderFactory}, based on element type
+      <code>float</code>: This version is also only a curiosity. The main
+      downside is that it can only perform calculations up to about 1.3
+      million radix-10 digits. The per-digit performance is also typically
+      less than that of the <code>int</code> version. Unless you have a
+      computer that performs floating-point arithmetic extraordinarily well
+      compared to integer arithmetic, it's always advisable to use the
+      <code>int</code> version instead.</li>
+</ul>
+
+For example, the relative performance of the above implementations on some
+CPUs is as follows (bigger percentage means better performance):
+
+<table border="1" summary="Implementations">
+<tr><th>Type</th><th>Pentium 4</th><th>Athlon XP</th><th>Athlon 64 (32-bit)</th><th>Athlon 64 (64-bit)</th><th>UltraSPARC II</th></tr>
+<tr><td>Int</td><td>100%</td><td>100%</td><td>100%</td><td>100%</td><td>100%</td></tr>
+<tr><td>Long</td><td>40%</td><td>76%</td><td>59%</td><td>95%</td><td>132%</td></tr>
+<tr><td>Double</td><td>45%</td><td>63%</td><td>59%</td><td>94%</td><td>120%</td></tr>
+<tr><td>Float</td><td>40%</td><td>43%</td><td>46%</td><td>42%</td><td>82%</td></tr>
+</table><br>
+(Test was done with apfloat 1.1 using Sun's Java 5.0 server VM calculating &pi; to
+one million digits with no disk storage.)<p>
+
+Compared to the <code>java.math.BigInteger</code> class with different digit
+sizes, the apfloat relative performance with the same CPUs is as follows:<p>
+
+<img src="doc-files/biginteger-comparison.gif" alt="Apfloat and BigInteger comparison"><p>
+
+(Test was done with apfloat 1.1 using Sun's Java 5.0 server VM calculating
+3<sup>n</sup> and converting the result to decimal.)<p>
+
+This benchmark suggests that for small numbers &#150; less than roughly 200 decimal
+digits in size &#150; the <code>BigInteger</code> / <code>BigDecimal</code> classes
+are probably faster, even by an order of magnitude. Using apfloats is only beneficial
+for numbers that have at least a couple hundred digits, or of course if some
+mathematical functions are needed that are not available for <code>BigInteger</code>s
+or <code>BigDecimal</code>s. The results can be easily explained by the smaller overhead
+that <code>BigInteger</code>s have due to their simpler implementation. When the size
+of the mantissa grows, the O(n log n) complexity of apfloat's FFT-based multiplication
+makes apfloat considerably faster than the steady O(n<sup>2</sup>) implementation
+of the <code>BigInteger</code> class. For numbers with millions of digits,
+multiplication using <code>BigInteger</code>s would be simply unfeasible, whereas for
+apfloat it would not be a problem at all.<p>
+
+All of the above apfloat implementations have the following features (some of the links
+point to the <code>int</code> version, but all four versions have similar classes):
+
+<ul>
+  <li>Depending on the size, numbers can be stored in memory
+      ({@link org.apfloat.internal.IntMemoryDataStorage}) or on disk
+      ({@link org.apfloat.internal.IntDiskDataStorage}).</li>
+  <li>Multiplication can be done in an optimized way if one multiplicand
+      has size 1 ({@link org.apfloat.internal.IntShortConvolutionStrategy}),
+      using a simple O(n<sup>2</sup>) long multiplication algorithm for small numbers,
+      with low overhead ({@link org.apfloat.internal.IntMediumConvolutionStrategy}),
+      using the Karatsuba multiplication algorithm for slightly larger numbers,
+      with some more overhead ({@link org.apfloat.internal.IntKaratsubaConvolutionStrategy}),
+      or using a Number Theoretic Transform (NTT) done using three different moduli,
+      and the final result calculated using the Chinese Remainder Theorem
+      ({@link org.apfloat.internal.ThreeNTTConvolutionStrategy}), for big numbers.</li>
+  <li>Different NTT algorithms for different transform lengths: basic fast NTT
+      ({@link org.apfloat.internal.IntTableFNTStrategy}) when the entire transform
+      fits in the processor cache, "six-step" NTT when the transform fits in the
+      main memory ({@link org.apfloat.internal.SixStepFNTStrategy}),
+      and a disk-based "two-pass" NTT strategy when the whole transform doesn't
+      fit in the available memory ({@link org.apfloat.internal.TwoPassFNTStrategy}).</li>
+</ul>
+
+The apfloat implementation-specific exceptions being thrown by the apfloat library
+all extend the base class {@link org.apfloat.internal.ApfloatInternalException}.
+This exception, or various subclasses can be thrown in different situations, for
+example:
+
+<ul>
+  <li>Backing storage failure. For example, if a number is stored on disk,
+      an <code>IOException</code> can be thrown in any of the disk operations,
+      if e.g. a file can't be created, or written to if the disk is full.</li>
+  <li>Operands have different radixes. This is a limitation allowed by the
+      specification.</li>
+  <li>Other internal limitation, e.g. the maximum transform length
+      mathematically possible for the implementation, is exceeded.</li>
+</ul>
+
+Note in particular that numbers, which take a lot of space are stored on disk
+in temporary files. These files have by default the extension <code>*.ap</code>
+and they are by default created in the current working directory. When the objects
+are garbage collected, the temporary files are deleted. However, garbage collection
+may not work perfectly at all times, and in general there are no guarantees that
+it will happen at all. So, depending on the program being executed, it may be
+beneficial to explicitly call <code>System.gc()</code> at some point to ensure
+that unused temporary files are deleted. However, VM vendors generally warn
+against doing this too often, since it may seriously degrade performance. So,
+figuring out how to optimally call it may be difficult. If the file deletion fails
+for some reason, some temporary files may be left on disk after the program
+exits. These files can be safely removed after the program has terminated.<p>
+
+Many parts of the program are parallelized i.e. are processed with multiple threads
+in parallel. Parallelization is done where it has been easy to implement and where
+it is efficient. E.g. the "six-step" NTT is parallelized, because the data is in
+matrix form in memory and it's easy and highly efficient to process the rows of the
+matrix in parallel. Other places where parallelization is implemented are the
+in-place multiplication of transform results and the carry-CRT operation. However
+in both of these algorithms the process is parallelized only if the data is in
+memory - if the data was stored on disk then the irregular disk seeking could make
+the parallel algorithm highly inefficient.<p>
+
+Many sections of the code are not parallelized, where it's obvious that
+parallelization would not bring any benefits. Examples of such cases are
+addition, subtraction and matrix transposition. While parallel algorithms for
+these operations could certainly be implemented, they would not bring any
+performance improvement. The bottleneck in these operations is memory or I/O
+bandwidth and not CPU processing time. The CPU processing in addition and
+subtraction is highly trivial; in matrix transposition it's outright
+nonexistent - the algorithm only moves data from one place to another. Even
+if all the data was stored in memory, the memory bandwidth would be the
+bottleneck. E.g. in addition, the algorithm only needs a few CPU cycles per
+element to be processed. However moving the data from main memory to CPU
+registers and back to main memory needs likely significantly more CPU cycles
+than the addition operation itself. Parallelization would therefore not
+improve efficiency at all - the total CPU load might appear to increase but
+when measured in wall-clock time the execution would not be any faster.<p>
+
+Since the core functionality of the apfloat implementation is based on the
+original C++ version of apfloat, no significant new algorithms have been
+added (although the architecture has been otherwise greatly beautified e.g. by
+separating the different implementations behind a SPI, and applying all kinds
+of patterns everywhere). Thus, there are no different implementations for e.g.
+using a floating-point FFT instead of a NTT, as the SPI ({@link org.apfloat.spi})
+might suggest. However the default implementation does implement all the
+patterns suggested by the SPI &#150; in fact the SPI was designed for the
+default implementation.<p>
+
+The class diagram for an example apfloat that is stored on disk is shown below.
+Note that all the aggregate classes can be shared by multiple objects that point
+to the same instance. For example, multiple Apfloats can point to the same
+ApfloatImpl, multiple ApfloatImpls can point to the same DataStorage etc. This
+sharing happens in various situations, e.g. by calling <code>floor()</code>,
+multiplying by one etc:<p>
+
+<img src="doc-files/implementation-classes.gif" alt="Implementation class diagram"><p>
+
+The sequence diagram for creating a new apfloat that is stored on disk is as
+follows. Note that the FileStorage class is a private inner class of the
+DiskDataStorage class:<p>
+
+<img src="doc-files/new-sequence.gif" alt="New Apfloat sequence diagram"><p>
+
+The sequence diagram for multiplying two apfloats is as follows. In this case a
+NTT based convolution is used, and the resulting apfloat is stored in memory:<p>
+
+<img src="doc-files/multiply-sequence.gif" alt="Multiplication sequence diagram"><p>
+
+Most of the files in the apfloat implementations are generated from templates
+where a template tag is replaced by <code>int/long/float/double</code> or
+<code>Int/Long/Float/Double</code>. Also the byte size of the element type is
+templatized and replaced by 4/8/4/8. The only files that are individually
+implemented for each element type are:
+
+<pre>
+*BaseMath.java
+*CRTMath.java
+*ElementaryModMath.java
+*ModConstants.java
+</pre>
+
+@see org.apfloat.spi
+*/
+
+package org.apfloat.internal;
Index: src/main/java/org/apfloat/spi/AdditionBuilder.java
===================================================================
--- src/main/java/org/apfloat/spi/AdditionBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/spi/AdditionBuilder.java	(revision 0)
@@ -0,0 +1,27 @@
+package org.apfloat.spi;
+
+/**
+ * Interface of a factory for creating addition strategies.
+ * The factory method pattern is used.
+ *
+ * @param <T> The element type of the addition strategies.
+ *
+ * @see AdditionStrategy
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public interface AdditionBuilder<T>
+{
+    /**
+     * Returns an addition strategy of suitable type for the specified radix.
+     *
+     * @param radix The radix that will be used.
+     *
+     * @return A suitable object for performing the addition.
+     */
+
+    public AdditionStrategy<T> createAddition(int radix);
+}
Index: src/main/java/org/apfloat/spi/AdditionStrategy.java
===================================================================
--- src/main/java/org/apfloat/spi/AdditionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/spi/AdditionStrategy.java	(revision 0)
@@ -0,0 +1,113 @@
+package org.apfloat.spi;
+
+import org.apfloat.ApfloatRuntimeException;
+import org.apfloat.spi.DataStorage;
+
+/**
+ * Generic addition strategy. Also subtraction, "short" multiplication and
+ * "short" division can be done.
+ *
+ * @param <T> The element type of the addition strategy.
+ * 
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+public interface AdditionStrategy<T>
+{
+    /**
+     * Addition in some base. Adds the data words
+     * of <code>src1</code> and <code>src2</code> and stores the result to
+     * <code>dst</code>. <code>src2</code> may be <code>null</code>, in
+     * which case it is ignored (only the carry is propagated).<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] + src2[i]</code>.
+     *
+     * @param src1 First source data sequence. Can be <code>null</code>, in which case it's ignored.
+     * @param src2 Second source data sequence. Can be <code>null</code>, in which case it's ignored.
+     * @param carry Input carry bit. This is added to the first (rightmost) word in the accessed sequence.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Overflow carry bit. Propagated carry bit from the addition of the last (leftmost) word in the accessed sequence.
+     */
+
+    public T add(DataStorage.Iterator src1, DataStorage.Iterator src2, T carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Subtraction in some base. Subtracts the data words
+     * of <code>src1</code> and <code>src2</code> and stores the result to
+     * <code>dst</code>. <code>src1</code> and <code>src2</code> may be
+     * <code>null</code>, in which case they are ignored (the values are assumed
+     * to be zero and only the carry is propagated).<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] - src2[i]</code>.
+     *
+     * @param src1 First source data sequence. Can be <code>null</code>, in which case the input values are assumed to be zero.
+     * @param src2 Second source data sequence. Can be <code>null</code>, in which case it's ignored, or can be the same as <code>dst</code>.
+     * @param carry Input carry bit. This is subtracted from the first (rightmost) word in the accessed sequence.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Overflow carry bit. Propagated carry bit from the subtraction of the last (leftmost) word in the accessed sequence. The value is <code>1</code> if the carry is set, and <code>0</code> otherwise.
+     */
+
+    public T subtract(DataStorage.Iterator src1, DataStorage.Iterator src2, T carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Multiplication and addition in some base. Multiplies the data words
+     * of <code>src1</code> by <code>src3</code> and adds the result to the
+     * words in <code>src2</code>, and stores the result to <code>dst</code>.
+     * <code>src2</code> may be <code>null</code>, in which case it is ignored
+     * (the values are assumed to be zero).<p>
+     *
+     * Assumes that the result from the addition doesn't overflow the upper
+     * result word (to larger than the base). This is the case e.g. when using
+     * this method to perform an arbitrary precision multiplication.<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] * src3 + src2[i]</code>.
+     *
+     * @param src1 First source data sequence.
+     * @param src2 Second source data sequence. Can be <code>null</code>, in which case it's ignored, or can be the same as <code>dst</code>.
+     * @param src3 Multiplicand. All elements of <code>src1</code> are multiplied by this value.
+     * @param carry Input carry word. This is added to the first (rightmost) word in the accessed sequence.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Overflow carry word. Propagated carry word from the multiplication and addition of the last (leftmost) word in the accessed sequence.
+     */
+
+    public T multiplyAdd(DataStorage.Iterator src1, DataStorage.Iterator src2, T src3, T carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Division in some base. Divides the data words
+     * of <code>src1</code> by <code>src2</code> and stores the result to
+     * <code>dst</code>. <code>src1</code> may be <code>null</code>,
+     * in which case it is ignored (the values are assumed to be
+     * zero and only the carry division is propagated).<p>
+     *
+     * Essentially calculates <code>dst[i] = src1[i] / src2</code>.
+     *
+     * @param src1 First source data sequence. Can be <code>null</code>, in which case the input values are assumed to be zero.
+     * @param src2 Divisor. All elements of <code>src1</code> are divided by this value.
+     * @param carry Input carry word. Used as the upper word for the division of the first input element. This should be the remainder word returned from the previous block processed.
+     * @param dst Destination data sequence.
+     * @param size Number of elements to process.
+     *
+     * @return Remainder word of the propagated division of the last (rightmost) word in the accessed sequence.
+     */
+
+    public T divide(DataStorage.Iterator src1, T src2, T carry, DataStorage.Iterator dst, long size)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Returns the zero element.
+     *
+     * @return Zero of the correct element type.
+     */
+
+    public T zero();
+}
Index: src/main/java/org/apfloat/spi/ApfloatBuilder.java
===================================================================
--- src/main/java/org/apfloat/spi/ApfloatBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/spi/ApfloatBuilder.java	(revision 0)
@@ -0,0 +1,80 @@
+package org.apfloat.spi;
+
+import java.io.PushbackReader;
+import java.io.IOException;
+
+import org.apfloat.ApfloatRuntimeException;
+
+/**
+ * An ApfloatBuilder contains factory methods to create
+ * new instances of {@link ApfloatImpl} implementations.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public interface ApfloatBuilder
+{
+    /**
+     * Create a new <code>ApfloatImpl</code> instance from a <code>String</code>.
+     *
+     * @param value The string to be parsed to a number.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     * @param isInteger Specifies if the number to be parsed from the string is to be treated as an integer or not.
+     *
+     * @return A new <code>ApfloatImpl</code>.
+     *
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public ApfloatImpl createApfloat(String value, long precision, int radix, boolean isInteger)
+        throws NumberFormatException, ApfloatRuntimeException;
+
+    /**
+     * Create a new <code>ApfloatImpl</code> instance from a <code>long</code>.
+     *
+     * @param value The value of the number.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     *
+     * @return A new <code>ApfloatImpl</code>.
+     *
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public ApfloatImpl createApfloat(long value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException;
+
+    /**
+     * Create a new <code>ApfloatImpl</code> instance from a <code>double</code>.
+     *
+     * @param value The value of the number.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     *
+     * @return A new <code>ApfloatImpl</code>.
+     *
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public ApfloatImpl createApfloat(double value, long precision, int radix)
+        throws NumberFormatException, ApfloatRuntimeException;
+
+    /**
+     * Create a new <code>ApfloatImpl</code> instance reading from a stream.
+     *
+     * @param in The stream to read from.
+     * @param precision The precision of the number (in digits of the radix).
+     * @param radix The radix in which the number is created.
+     * @param isInteger Specifies if the number to be parsed from the stream is to be treated as an integer or not.
+     *
+     * @return A new <code>ApfloatImpl</code>.
+     *
+     * @exception java.io.IOException If an I/O error occurs accessing the stream.
+     * @exception java.lang.NumberFormatException If the number is not valid.
+     */
+
+    public ApfloatImpl createApfloat(PushbackReader in, long precision, int radix, boolean isInteger)
+        throws IOException, NumberFormatException, ApfloatRuntimeException;
+}
Index: src/main/java/org/apfloat/spi/ApfloatImpl.java
===================================================================
--- src/main/java/org/apfloat/spi/ApfloatImpl.java	(revision 0)
+++ src/main/java/org/apfloat/spi/ApfloatImpl.java	(revision 0)
@@ -0,0 +1,270 @@
+package org.apfloat.spi;
+
+import java.io.Serializable;
+import java.io.Writer;
+import java.io.IOException;
+
+import org.apfloat.ApfloatRuntimeException;
+
+/**
+ * Interface for apfloat implementations. An <code>ApfloatImpl</code> implements all of the
+ * low-level functionality that is needed behind the high-level apfloat API.<p>
+ *
+ * A class implementing <code>ApfloatImpl</code> is not required to accept any other <code>ApfloatImpl</code>
+ * class as the argument than the same implementing class.
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public interface ApfloatImpl
+    extends Serializable
+{
+    /**
+     * Add or subtract an <code>ApfloatImpl</code> to this object.
+     *
+     * @param x The number to be added or subtracted to this <code>ApfloatImpl</code>.
+     * @param subtract <code>true</code> if the numbers are to be subtracted, <code>false</code> if added.
+     *
+     * @return <code>this + x</code> or <code>this - x</code> depending on the <code>subtract</code> argument.
+     */
+
+    public ApfloatImpl addOrSubtract(ApfloatImpl x, boolean subtract)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Multiply this object by an <code>ApfloatImpl</code>.
+     *
+     * @param x The number to be multiplied by this <code>ApfloatImpl</code>.
+     *
+     * @return <code>this * x</code>.
+     */
+
+    public ApfloatImpl multiply(ApfloatImpl x)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Returns if this <code>ApfloatImpl</code> is "short". Typically <code>ApfloatImpl</code>
+     * is "short" if its mantissa fits in one machine word. If the apfloat is "short",
+     * some algorithms can be performed faster.<p>
+     *
+     * The return value of this method is highly implementation dependent.
+     *
+     * @return <code>true</code> if the <code>ApfloatImpl</code> is "short", <code>false</code> if not.
+     *
+     * @see org.apfloat.Apfloat#isShort()
+     */
+
+    public boolean isShort()
+        throws ApfloatRuntimeException;
+
+    /**
+     * Divide this <code>ApfloatImpl</code> by an <code>ApfloatImpl</code> that is "short".
+     *
+     * @param x The number by which this <code>ApfloatImpl</code> is to be divided.
+     *
+     * @return <code>this / x</code>.
+     */
+
+    public ApfloatImpl divideShort(ApfloatImpl x)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Returns this <code>ApfloatImpl</code> rounded towards zero.
+     *
+     * @return This <code>ApfloatImpl</code> rounded towards zero.
+     */
+
+    public ApfloatImpl absFloor()
+        throws ApfloatRuntimeException;
+
+    /**
+     * Returns this <code>ApfloatImpl</code> rounded away from zero.
+     *
+     * @return This <code>ApfloatImpl</code> rounded away from zero.
+     */
+
+    public ApfloatImpl absCeil()
+        throws ApfloatRuntimeException;
+
+    /**
+     * Returns the fractional part of this <code>ApfloatImpl</code>.
+     *
+     * @return The fractional part of this <code>ApfloatImpl</code>.
+     *
+     * @since 1.7.0
+     */
+
+    public ApfloatImpl frac()
+        throws ApfloatRuntimeException;
+
+    /**
+     * Returns the radix of this <code>ApfloatImpl</code>.
+     *
+     * @return The radix of this <code>ApfloatImpl</code>.
+     */
+
+    public int radix();
+
+    /**
+     * Returns the precision of this <code>ApfloatImpl</code>.
+     *
+     * @return The precision of this <code>ApfloatImpl</code>.
+     */
+
+    public long precision();
+
+    /**
+     * Returns the size of the mantissa of this <code>ApfloatImpl</code>.
+     *
+     * @return The size of the mantissa of this <code>ApfloatImpl</code>.
+     *
+     * @since 1.2
+     */
+
+    public long size()
+        throws ApfloatRuntimeException;
+
+    /**
+     * Returns this <code>ApfloatImpl</code> with the specified precision.
+     *
+     * @param precision The precision.
+     *
+     * @return This <code>ApfloatImpl</code> with the specified precision.
+     */
+
+    public ApfloatImpl precision(long precision)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Returns the scale of this <code>ApfloatImpl</code>.
+     *
+     * @return The scale of this <code>ApfloatImpl</code>.
+     *
+     * @see org.apfloat.Apfloat#scale()
+     */
+
+    public long scale()
+        throws ApfloatRuntimeException;
+
+    /**
+     * Returns the signum of this <code>ApfloatImpl</code>.
+     *
+     * @return The signum of this <code>ApfloatImpl</code>.
+     *
+     * @see org.apfloat.Apfloat#signum()
+     */
+
+    public int signum();
+
+    /**
+     * Returns this <code>ApfloatImpl</code> negated.
+     *
+     * @return <code>-this</code>.
+     */
+
+    public ApfloatImpl negate()
+        throws ApfloatRuntimeException;
+
+    /**
+     * Returns the value of the this number as a <code>double</code>.
+     *
+     * If the number is greater than <code>Double.MAX_VALUE</code>,
+     * then <code>Double.POSITIVE_INFINITY</code> is returned.<p>
+     *
+     * If the number is less than <code>Double.MIN_VALUE</code>,
+     * then <code>Double.NEGATIVE_INFINITY</code> is returned.<p>
+     *
+     * If the number is very small in magnitude, underflow may
+     * happen and zero is returned.
+     *
+     * @return The numeric value represented by this object after conversion to type <code>double</code>.
+     */
+
+    public double doubleValue();
+
+    /**
+     * Returns the value of the this number as a <code>long</code>.
+     * The fractional part is truncated towards zero.<p>
+     *
+     * If the number is greater than <code>Long.MAX_VALUE</code>,
+     * then <code>Long.MAX_VALUE</code> is returned.<p>
+     *
+     * If the number is less than <code>Long.MIN_VALUE</code>,
+     * then <code>Long.MIN_VALUE</code> is returned.
+     *
+     * @return The numeric value represented by this object after conversion to type <code>long</code>.
+     */
+
+    public long longValue();
+
+    /**
+     * Tests if this number is equal to 1.
+     *
+     * @return <code>true</code> if this number is equal to one, otherwise <code>false</code>.
+     */
+
+    public boolean isOne()
+        throws ApfloatRuntimeException;
+
+    /**
+     * The number of equal digits in this <code>ApfloatImpl</code> and another number.
+     *
+     * @param x The number to compare with.
+     *
+     * @return The number of equal digits in this <code>ApfloatImpl</code> and <code>x</code>.
+     *
+     * @see org.apfloat.Apfloat#equalDigits(org.apfloat.Apfloat)
+     */
+
+    public long equalDigits(ApfloatImpl x)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Compare this <code>ApfloatImpl</code> and another number.
+     *
+     * @param x The number to compare with.
+     *
+     * @return Zero, less than zero or greater than zero depending on the result of the comparison.
+     *
+     * @see org.apfloat.Apfloat#compareTo(org.apfloat.Apfloat)
+     */
+
+    public int compareTo(ApfloatImpl x)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Returns the hash code for this <code>ApfloatImpl</code>.
+     *
+     * @return The hash code for this <code>ApfloatImpl</code>.
+     */
+
+    public int hashCode();
+
+    /**
+     * Convert this <code>ApfloatImpl</code> to <code>String</code>.
+     *
+     * @param pretty Flag for formatting.
+     *
+     * @return String representation of this <code>ApfloatImpl</code>.
+     *
+     * @see org.apfloat.Apfloat#toString(boolean)
+     */
+
+    public String toString(boolean pretty)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Print this <code>ApfloatImpl</code> to a stream.
+     *
+     * @param out The stream to write to.
+     * @param pretty Flag for formatting.
+     *
+     * @exception java.io.IOException In case of I/O error writing to the stream.
+     *
+     * @see org.apfloat.Apfloat#writeTo(Writer,boolean)
+     */
+
+    public void writeTo(Writer out, boolean pretty)
+        throws IOException, ApfloatRuntimeException;
+}
Index: src/main/java/org/apfloat/spi/ArrayAccess.java
===================================================================
--- src/main/java/org/apfloat/spi/ArrayAccess.java	(revision 0)
+++ src/main/java/org/apfloat/spi/ArrayAccess.java	(revision 0)
@@ -0,0 +1,170 @@
+package org.apfloat.spi;
+
+import java.io.Serializable;
+
+import org.apfloat.ApfloatRuntimeException;
+
+/**
+ * The <code>ArrayAccess</code> class simulates a <code>C</code> language pointer.
+ * With one <code>ArrayAccess</code> object you can point to a location within an
+ * array. You can easily add or subtract a value to this "pointer", thus
+ * essentially emulating <code>C</code> pointer arithmetic. An <code>ArrayAccess</code>
+ * provides an array, the starting index within that array and the length of
+ * accessible data within the array, all in one convenient package.<p>
+ *
+ * Just like pointers in the <code>C</code> language, <code>ArrayAccess</code>
+ * objects are inherently unsafe and must be used cautiously. It is the
+ * responsibility of the user of an <code>ArrayAccess</code> object to make sure
+ * that he doesn't access the provided array outside the allowed range. The
+ * <code>ArrayAccess</code> object itself does nothing to enforce this, except
+ * of course the mandatory bounds check of Java, which can throw an
+ * <code>ArrayIndexOutOfBoundsException</code>.
+ *
+ * @version 1.6.3
+ * @author Mikko Tommila
+ */
+
+public abstract class ArrayAccess
+    implements Serializable
+{
+    /**
+     * Create an array access.<p>
+     *
+     * @param offset The offset of the access segment within the array.
+     * @param length The access segment.
+     */
+
+    protected ArrayAccess(int offset, int length)
+    {
+        this.offset = offset;
+        this.length = length;
+    }
+
+    /**
+     * Create a sub-sequence view of this array access.<p>
+     *
+     * Note that the changes done to the sub-sequence array
+     * are not necessarily committed to the underlying data
+     * storage when the sub-sequence is closed (with {@link #close()}),
+     * but only when the "base" <code>ArrayAccess</code> is closed.
+     *
+     * @param offset The sub-sequence starting offset within this ArrayAccess.
+     * @param length The sub-sequence length.
+     *
+     * @return The sub-sequence array access.
+     */
+
+    public abstract ArrayAccess subsequence(int offset, int length);
+
+    /**
+     * Returns the array of this array access. This is an array of a
+     * primitive type, depending on the implementation class.
+     *
+     * @return The backing array of this array access.
+     */
+
+    public abstract Object getData()
+        throws ApfloatRuntimeException;
+
+    /**
+     * Returns the array of this array access as an <code>int[]</code>.
+     *
+     * @return The backing array of this array access.
+     *
+     * @exception UnsupportedOperationException In case the backing array can't be presented as <code>int[]</code>.
+     */
+
+    public int[] getIntData()
+        throws UnsupportedOperationException, ApfloatRuntimeException
+    {
+        throw new UnsupportedOperationException("Not implemented");
+    }
+
+    /**
+     * Returns the array of this array access as a <code>long[]</code>.
+     *
+     * @return The backing array of this array access.
+     *
+     * @exception UnsupportedOperationException In case the backing array can't be presented as <code>long[]</code>.
+     */
+
+    public long[] getLongData()
+        throws UnsupportedOperationException, ApfloatRuntimeException
+    {
+        throw new UnsupportedOperationException("Not implemented");
+    }
+
+    /**
+     * Returns the array of this array access as a <code>float[]</code>.
+     *
+     * @return The backing array of this array access.
+     *
+     * @exception UnsupportedOperationException In case the backing array can't be presented as <code>float[]</code>.
+     */
+
+    public float[] getFloatData()
+        throws UnsupportedOperationException, ApfloatRuntimeException
+    {
+        throw new UnsupportedOperationException("Not implemented");
+    }
+
+    /**
+     * Returns the array of this array access as a <code>double[]</code>.
+     *
+     * @return The backing array of this array access.
+     *
+     * @exception UnsupportedOperationException In case the backing array can't be presented as <code>double[]</code>.
+     */
+
+    public double[] getDoubleData()
+        throws UnsupportedOperationException, ApfloatRuntimeException
+    {
+        throw new UnsupportedOperationException("Not implemented");
+    }
+
+    /**
+     * Returns the offset of the access segment within the backing array.
+     *
+     * @return The starting index within the backing array that is allowed to be accessed.
+     */
+
+    public int getOffset()
+    {
+        return this.offset;
+    }
+
+    /**
+     * Returns the length of the access segment within the backing array.
+     *
+     * @return The number of elements within the backing array that is allowed to be accessed.
+     */
+
+    public int getLength()
+    {
+        return this.length;
+    }
+
+    /**
+     * Close this array access and commit any changes to the
+     * underlying data storage if applicable.<p>
+     *
+     * If the <code>ArrayAccess</code> was obtained in write
+     * mode, the changes are saved to the data storage. Note
+     * that even if the <code>ArrayAccess</code> was obtained
+     * for reading only, any changes made to the array data
+     * may still be committed to the data storage.<p>
+     *
+     * Note that changes done to a sub-sequence array
+     * are not necessarily committed to the underlying data
+     * storage when the sub-sequence is closed,
+     * but only when the "base" <code>ArrayAccess</code> is closed.
+     */
+
+    public abstract void close()
+        throws ApfloatRuntimeException;
+
+    private static final long serialVersionUID = -7899494275459577958L;
+
+    private int offset;
+    private int length;
+}
Index: src/main/java/org/apfloat/spi/BuilderFactory.java
===================================================================
--- src/main/java/org/apfloat/spi/BuilderFactory.java	(revision 0)
+++ src/main/java/org/apfloat/spi/BuilderFactory.java	(revision 0)
@@ -0,0 +1,141 @@
+package org.apfloat.spi;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+
+/**
+ * A <code>BuilderFactory</code> object contains factory methods for building
+ * the various parts of an apfloat using the Builder pattern. There
+ * is no separate "director" object in the apfloat SPI; it is suggested
+ * that the <code>ApfloatImpl</code> implementation itself acts as the director,
+ * calling the different builders directly.
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public interface BuilderFactory
+{
+    /**
+     * Returns an <code>ApfloatBuilder</code> object.
+     *
+     * @return An <code>ApfloatBuilder</code> object.
+     */
+
+    public ApfloatBuilder getApfloatBuilder();
+
+    /**
+     * Returns a <code>DataStorageBuilder</code> object.
+     *
+     * @return A <code>DataStorageBuilder</code> object.
+     */
+
+    public DataStorageBuilder getDataStorageBuilder();
+
+    /**
+     * Returns an <code>AdditionBuilder</code> object.
+     *
+     * @param <T> The element type of the additions.
+     * @param elementType The element type of the additions.
+     *
+     * @return An <code>AdditionBuilder</code> object.
+     *
+     * @throws IllegalArgumentException In case of unsupported element type.
+     *
+     * @since 1.7.0
+     */
+
+    public <T> AdditionBuilder<T> getAdditionBuilder(Class<T> elementType)
+        throws IllegalArgumentException;
+
+    /**
+     * Returns a <code>ConvolutionBuilder</code> object.
+     *
+     * @return A <code>ConvolutionBuilder</code> object.
+     */
+
+    public ConvolutionBuilder getConvolutionBuilder();
+
+    /**
+     * Returns an <code>NTTBuilder</code> object.
+     *
+     * @return An <code>NTTBuilder</code> object.
+     */
+
+    public NTTBuilder getNTTBuilder();
+
+    /**
+     * Returns a <code>MatrixBuilder</code> object.
+     *
+     * @return A <code>MatrixBuilder</code> object.
+     *
+     * @since 1.7.0
+     */
+
+    public MatrixBuilder getMatrixBuilder();
+
+    /**
+     * Returns a <code>CarryCRTBuilder</code> object.
+     *
+     * @param <T> The element array type of the carry-CRT.
+     * @param elementArrayType The element array type of the carry-CRT.
+     *
+     * @return A <code>CarryCRTBuilder</code> object.
+     *
+     * @throws IllegalArgumentException In case of unsupported element array type.
+     *
+     * @since 1.7.0
+     */
+
+    public <T> CarryCRTBuilder<T> getCarryCRTBuilder(Class<T> elementArrayType)
+        throws IllegalArgumentException;
+
+    /**
+     * Returns the element type of the data objects created.
+     *
+     * @return The element type of the data objects created.
+     *
+     * @since 1.7.0
+     */
+
+    public Class<?> getElementType();
+
+    /**
+     * Returns the element array type of the data objects created.
+     *
+     * @return The element array type of the data objects created.
+     *
+     * @since 1.7.0
+     */
+
+    public Class<?> getElementArrayType();
+
+    /**
+     * Returns the element size of the data objects created, in bytes.
+     *
+     * @return The element size of the data objects created, in bytes.
+     *
+     * @since 1.7.0
+     */
+
+    public int getElementSize();
+
+    /**
+     * Shuts down the builder factory. Clean-up tasks can be executed by this method.
+     * This method is invoked by the {@link ApfloatContext} when cleanupAtExit is enabled.
+     *
+     * @since 1.6.2
+     */
+
+    public void shutdown()
+        throws ApfloatRuntimeException;
+
+    /**
+     * Do garbage collection and related things such as empty any reference queues.
+     *
+     * @since 1.6.2
+     */
+
+    public void gc()
+        throws ApfloatRuntimeException;
+}
Index: src/main/java/org/apfloat/spi/CarryCRTBuilder.java
===================================================================
--- src/main/java/org/apfloat/spi/CarryCRTBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/spi/CarryCRTBuilder.java	(revision 0)
@@ -0,0 +1,40 @@
+package org.apfloat.spi;
+
+/**
+ * Interface of a factory for creating carry-CRT related objects.
+ * The factory method pattern is used.
+ *
+ * @param <T> The element array type of the CRT.
+ *
+ * @see CarryCRTStrategy
+ * @see CarryCRTStepStrategy
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public interface CarryCRTBuilder<T>
+{
+    /**
+     * Creates an object for implementing the carry-CRT of a three-NTT
+     * based convolution using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     *
+     * @return A suitable object for performing the carry-CRT.
+     */
+
+    public CarryCRTStrategy createCarryCRT(int radix);
+
+    /**
+     * Creates an object for implementing the steps of the carry-CRT
+     * of a three-NTT based convolution using the specified radix.
+     *
+     * @param radix The radix that will be used.
+     *
+     * @return A suitable object for performing the carry-CRT steps.
+     */
+
+    public CarryCRTStepStrategy<T> createCarryCRTSteps(int radix);
+}
Index: src/main/java/org/apfloat/spi/CarryCRTStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/spi/CarryCRTStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/spi/CarryCRTStepStrategy.java	(revision 0)
@@ -0,0 +1,60 @@
+package org.apfloat.spi;
+
+import org.apfloat.ApfloatRuntimeException;
+
+/**
+ * Interface for performing the steps of a carry-CRT operation in a convolution.
+ *
+ * @param <T> The element array type of the carry-CRT steps.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public interface CarryCRTStepStrategy<T>
+{
+    /**
+     * Perform the Chinese Remainder Theorem (CRT) on each element
+     * of the three result data sets to get the result of each element
+     * modulo the product of the three moduli. Then it calculates the carries
+     * for the block of data to get the final result.<p>
+     *
+     * Note that the return value's initial word may be zero or non-zero,
+     * depending on how large the result is.<p>
+     *
+     * Assumes that <code>MODULUS[0] &gt; MODULUS[1] &gt; MODULUS[2]</code>.
+     *
+     * @param resultMod0 The result modulo <code>MODULUS[0]</code>.
+     * @param resultMod1 The result modulo <code>MODULUS[1]</code>.
+     * @param resultMod2 The result modulo <code>MODULUS[2]</code>.
+     * @param dataStorage The destination data storage of the computation.
+     * @param size The number of elements in the whole data set.
+     * @param resultSize The number of elements needed in the final result.
+     * @param offset The offset within the data for the block to be computed.
+     * @param length Length of the block to be computed.
+     *
+     * @return The carries overflowing from this block (two elements).
+     */
+
+    public T crt(DataStorage resultMod0, DataStorage resultMod1, DataStorage resultMod2, DataStorage dataStorage, long size, long resultSize, long offset, long length)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Propagate carries from the previous block computed with the CRT
+     * method.
+     *
+     * @param dataStorage The destination data storage of the computation.
+     * @param size The number of elements in the whole data set.
+     * @param resultSize The number of elements needed in the final result.
+     * @param offset The offset within the data for the block to be computed.
+     * @param length Length of the block to be computed.
+     * @param results The carry overflow from this block (two elements).
+     * @param previousResults The carry overflow from the previous block (two elements).
+     *
+     * @return The carries overflowing from this block (two elements).
+     */
+
+    public T carry(DataStorage dataStorage, long size, long resultSize, long offset, long length, T results, T previousResults)
+        throws ApfloatRuntimeException;
+}
Index: src/main/java/org/apfloat/spi/CarryCRTStrategy.java
===================================================================
--- src/main/java/org/apfloat/spi/CarryCRTStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/spi/CarryCRTStrategy.java	(revision 0)
@@ -0,0 +1,39 @@
+package org.apfloat.spi;
+
+import org.apfloat.ApfloatRuntimeException;
+
+/**
+ * Interface for performing the final step of a three-modulus
+ * Number Theoretic Transform based convolution.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public interface CarryCRTStrategy
+{
+    /**
+     * Calculate the final result of a three-NTT convolution.<p>
+     *
+     * Performs a Chinese Remainder Theorem (CRT) on each element
+     * of the three result data sets to get the result of each element
+     * modulo the product of the three moduli. Then it calculates the carries
+     * to get the final result.<p>
+     *
+     * Note that the return value's initial word may be zero or non-zero,
+     * depending on how large the result is.<p>
+     *
+     * Assumes that <code>MODULUS[0] &gt; MODULUS[1] &gt; MODULUS[2]</code>.
+     *
+     * @param resultMod0 The result modulo <code>MODULUS[0]</code>.
+     * @param resultMod1 The result modulo <code>MODULUS[1]</code>.
+     * @param resultMod2 The result modulo <code>MODULUS[2]</code>.
+     * @param resultSize The number of elements needed in the final result.
+     *
+     * @return The final result with the CRT performed and the carries calculated.
+     */
+
+    public DataStorage carryCRT(DataStorage resultMod0, DataStorage resultMod1, DataStorage resultMod2, long resultSize)
+        throws ApfloatRuntimeException;
+}
Index: src/main/java/org/apfloat/spi/ConvolutionBuilder.java
===================================================================
--- src/main/java/org/apfloat/spi/ConvolutionBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/spi/ConvolutionBuilder.java	(revision 0)
@@ -0,0 +1,28 @@
+package org.apfloat.spi;
+
+/**
+ * Interface of a factory for creating convolutors.
+ * The factory method pattern is used.
+ *
+ * @see ConvolutionStrategy
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public interface ConvolutionBuilder
+{
+    /**
+     * Returns a convolution strategy of suitable
+     * type for the specified length.
+     *
+     * @param radix The radix that will be used.
+     * @param size1 Length of first data set.
+     * @param size2 Length of second data set.
+     * @param resultSize Minimum number of elements needed in the result data.
+     *
+     * @return A suitable object for performing the convolution.
+     */
+
+    public ConvolutionStrategy createConvolution(int radix, long size1, long size2, long resultSize);
+}
Index: src/main/java/org/apfloat/spi/ConvolutionStrategy.java
===================================================================
--- src/main/java/org/apfloat/spi/ConvolutionStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/spi/ConvolutionStrategy.java	(revision 0)
@@ -0,0 +1,34 @@
+package org.apfloat.spi;
+
+import org.apfloat.ApfloatRuntimeException;
+
+/**
+ * Generic convolution strategy. To perform the convolution,
+ * an implementing class could use e.g.
+ *
+ * <ul>
+ *   <li>A simple long multiplication convolution with O(n<sup>2</sup>) complexity</li>
+ *   <li>An O(n<sup>log2(3)</sup>) Karatsuba type algorithm, e.g. <a href="http://www.apfloat.org/log23.html" target="_blank">as desribed in Knuth's Seminumerical Algorithms</a></li>
+ *   <li>Floating-point Fast Fourier Transform (FFT) based convolution</li>
+ *   <li><a href="http://www.apfloat.org/ntt.html" target="_blank">Number-Theoretic Transform (NTT)</a> based convolution, with the <a href="http://www.apfloat.org/crt.html" target="_blank">Chinese Remainder Theorem</a> used</li>
+ * </ul>
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public interface ConvolutionStrategy
+{
+    /**
+     * Convolutes the two sets of data.
+     *
+     * @param x First data set.
+     * @param y Second data set.
+     * @param resultSize Number of elements needed in the result data.
+     *
+     * @return The convolved data.
+     */
+
+    public DataStorage convolute(DataStorage x, DataStorage y, long resultSize)
+        throws ApfloatRuntimeException;
+}
Index: src/main/java/org/apfloat/spi/DataStorage.java
===================================================================
--- src/main/java/org/apfloat/spi/DataStorage.java	(revision 0)
+++ src/main/java/org/apfloat/spi/DataStorage.java	(revision 0)
@@ -0,0 +1,1154 @@
+package org.apfloat.spi;
+
+import java.io.Serializable;
+
+import org.apfloat.ApfloatRuntimeException;
+
+/**
+ * Generic data storage class.<p>
+ *
+ * Initially when a data storage is created, it is mutable
+ * (it can be modified). After the contents have been properly
+ * set, the user should call {@link #setReadOnly()} to set the
+ * storage to be immutable. After this the data storage can be
+ * safely shared between different users.<p>
+ *
+ * Access to <code>DataStorage</code> objects is generally not internally synchronized.
+ * Accessing multiple non-overlapping parts of the storage concurrently with the
+ * {@link #getArray(int,long,int)}, {@link #getArray(int,int,int,int)}
+ * or {@link #getTransposedArray(int,int,int,int)} method and with
+ * iterators over non-overlapping parts is permitted. Invoking
+ * other methods must generally be externally synchronized.
+ *
+ * @version 1.8.1
+ * @author Mikko Tommila
+ */
+
+public abstract class DataStorage
+    implements Serializable
+{
+    /**
+     * Read access mode specifier.
+     */
+
+    public static final int READ = 1;
+
+    /**
+     * Write access mode specifier.
+     */
+
+    public static final int WRITE = 2;
+
+    /**
+     * Read-write access mode specifier. For convenience, equivalent to <code>READ | WRITE</code>.
+     */
+
+    public static final int READ_WRITE = READ | WRITE;
+
+    /**
+     * Iterator for iterating through elements of the data storage.
+     */
+
+    public static abstract class Iterator
+        implements Serializable
+    {
+        /**
+         * Default constructor. Can be used e.g. for simple anonymous subclasses.
+         */
+
+        protected Iterator()
+        {
+        }
+
+        /**
+         * Check if <code>next()</code> can be called without going past the end of the sequence.<p>
+         * That is, if <code>next()</code> can be called without deliberately causing an exception.
+         *
+         * <b>Note:</b> It is important that the iterator is iterated
+         * past the last element; that is <code>next()</code> is called
+         * <code>startPosition - endPosition</code> times. The
+         * <code>get()</code> or <code>set()</code> methods should not
+         * be called for the last element.<p>
+         *
+         * The default implementation always returns <code>false</code>.
+         *
+         * @return <code>true</code> if {@link #next()} can be called, otherwise <code>false</code>.
+         */
+
+        public boolean hasNext()
+        {
+            return false;
+        }
+
+        /**
+         * Advances the position in the stream by one element.<p>
+         *
+         * <b>Note:</b> It is important that the iterator is iterated
+         * past the last element; that is <code>next()</code> is called
+         * <code>startPosition - endPosition</code> times. The
+         * <code>get()</code> or <code>set()</code> methods should not
+         * be called for the last element.<p>
+         *
+         * The default implementation always throws <code>IllegalStateException</code>.
+         *
+         * @exception IllegalStateException If the iterator has been iterated to the end already.
+         */
+
+        public void next()
+            throws IllegalStateException, ApfloatRuntimeException
+        {
+            throw new IllegalStateException("Not implemented");
+        }
+
+        /**
+         * Gets the current element as an <code>int</code>.<p>
+         *
+         * The default implementation calls {@link #get(Class)} with argument {@link Integer#TYPE}.
+         *
+         * @return The current element as an <code>int</code>.
+         *
+         * @exception UnsupportedOperationException If the element type of the data storage can't be converted to an <code>int</code>.
+         * @exception IllegalStateException If the iterator is at the end.
+         */
+
+        public int getInt()
+            throws UnsupportedOperationException, IllegalStateException, ApfloatRuntimeException
+        {
+            return get(Integer.TYPE);
+        }
+
+        /**
+         * Gets the current element as a <code>long</code>.<p>
+         *
+         * The default implementation calls {@link #get(Class)} with argument {@link Long#TYPE}.
+         *
+         * @return The current element as a <code>long</code>.
+         *
+         * @exception UnsupportedOperationException If the element type of the data storage can't be converted to a <code>long</code>.
+         * @exception IllegalStateException If the iterator is at the end.
+         */
+
+        public long getLong()
+            throws UnsupportedOperationException, IllegalStateException, ApfloatRuntimeException
+        {
+            return get(Long.TYPE);
+        }
+
+        /**
+         * Gets the current element as a <code>float</code>.<p>
+         *
+         * The default implementation calls {@link #get(Class)} with argument {@link Float#TYPE}.
+         *
+         * @return The current element as a <code>float</code>.
+         *
+         * @exception UnsupportedOperationException If the element type of the data storage can't be converted to a <code>float</code>.
+         * @exception IllegalStateException If the iterator is at the end.
+         */
+
+        public float getFloat()
+            throws UnsupportedOperationException, IllegalStateException, ApfloatRuntimeException
+        {
+            return get(Float.TYPE);
+        }
+
+        /**
+         * Gets the current element as a <code>double</code>.<p>
+         *
+         * The default implementation calls {@link #get(Class)} with argument {@link Double#TYPE}.
+         *
+         * @return The current element as a <code>double</code>.
+         *
+         * @exception UnsupportedOperationException If the element type of the data storage can't be converted to a <code>double</code>.
+         * @exception IllegalStateException If the iterator is at the end.
+         */
+
+        public double getDouble()
+            throws UnsupportedOperationException, IllegalStateException, ApfloatRuntimeException
+        {
+            return get(Double.TYPE);
+        }
+
+        /**
+         * Sets the current element as an <code>int</code>.<p>
+         *
+         * The default implementation calls {@link #set(Class,Object)} with first argument {@link Integer#TYPE}.
+         *
+         * @param value The value to be set to the current element as an <code>int</code>.
+         *
+         * @exception UnsupportedOperationException If the element type of the data storage can't be converted to an <code>int</code>.
+         * @exception IllegalStateException If the iterator is at the end.
+         */
+
+        public void setInt(int value)
+            throws UnsupportedOperationException, IllegalStateException, ApfloatRuntimeException
+        {
+            set(Integer.TYPE, value);
+        }
+
+        /**
+         * Sets the current element as a <code>long</code>.<p>
+         *
+         * The default implementation calls {@link #set(Class,Object)} with first argument {@link Long#TYPE}.
+         *
+         * @param value The value to be set to the current element as a <code>long</code>.
+         *
+         * @exception UnsupportedOperationException If the element type of the data storage can't be converted to a <code>long</code>.
+         * @exception IllegalStateException If the iterator is at the end.
+         */
+
+        public void setLong(long value)
+            throws UnsupportedOperationException, IllegalStateException, ApfloatRuntimeException
+        {
+            set(Long.TYPE, value);
+        }
+
+        /**
+         * Sets the current element as a <code>float</code>.<p>
+         *
+         * The default implementation calls {@link #set(Class,Object)} with first argument {@link Float#TYPE}.
+         *
+         * @param value The value to be set to the current element as a <code>float</code>.
+         *
+         * @exception UnsupportedOperationException If the element type of the data storage can't be converted to a <code>float</code>.
+         * @exception IllegalStateException If the iterator is at the end.
+         */
+
+        public void setFloat(float value)
+            throws UnsupportedOperationException, IllegalStateException, ApfloatRuntimeException
+        {
+            set(Float.TYPE, value);
+        }
+
+        /**
+         * Sets the current element as a <code>double</code>.<p>
+         *
+         * The default implementation calls {@link #set(Class,Object)} with first argument {@link Double#TYPE}.
+         *
+         * @param value The value to be set to the current element as a <code>double</code>.
+         *
+         * @exception UnsupportedOperationException If the element type of the data storage can't be converted to a <code>double</code>.
+         * @exception IllegalStateException If the iterator is at the end.
+         */
+
+        public void setDouble(double value)
+            throws UnsupportedOperationException, IllegalStateException, ApfloatRuntimeException
+        {
+            set(Double.TYPE, value);
+        }
+
+        /**
+         * Gets the current element as a the specified element type.<p>
+         *
+         * The default implementation always throws <code>UnsupportedOperationException</code>.
+         *
+         * @param <T> The type of the element.
+         * @param type The type of the element.
+         *
+         * @return The current element as the specified type.
+         *
+         * @exception UnsupportedOperationException If the element type of the data storage can't be converted to the specified type.
+         * @exception IllegalStateException If the iterator is at the end.
+         *
+         * @since 1.7.0
+         */
+
+        public <T> T get(Class<T> type)
+            throws UnsupportedOperationException, IllegalStateException, ApfloatRuntimeException
+        {
+            throw new UnsupportedOperationException("Not implemented");
+        }
+
+        /**
+         * Sets the current element as the specified element type.<p>
+         *
+         * The default implementation always throws <code>UnsupportedOperationException</code>.
+         *
+         * @param <T> The type of the element.
+         * @param type The type of the element.
+         * @param value The value to be set to the current element as the specified type.
+         *
+         * @exception UnsupportedOperationException If the element type of the data storage can't be converted to the specified type.
+         * @exception IllegalArgumentException If the value is not of the specified type.
+         * @exception IllegalStateException If the iterator is at the end.
+         *
+         * @since 1.7.0
+         */
+
+        public <T> void set(Class<T> type, T value)
+            throws UnsupportedOperationException, IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            throw new UnsupportedOperationException("Not implemented");
+        }
+
+        /**
+         * Closes the iterator. This needs to be called only if the
+         * iterator is not iterated to the end.
+         */
+
+        public void close()
+            throws ApfloatRuntimeException
+        {
+        }
+
+        private static final long serialVersionUID = 7155668655967297483L;
+    }
+
+    /**
+     * Abstract base class for iterators iterating through this <code>DataStorage</code>.
+     * This class provides most of the common functionality needed.
+     */
+
+    protected abstract class AbstractIterator
+        extends Iterator
+    {
+        /**
+         * Construct a new iterator. Elements can be iterated either
+         * in forward or in reverse order, depending on if <code>startPosition</code>
+         * is less than or greater than <code>endPosition</code>, correspondingly.
+         *
+         * @param mode Access mode for iterator: {@link #READ}, {@link #WRITE} or both.
+         * @param startPosition Starting position of iterator in the data set. For reverse access, the first element in the iterator is <code>startPosition - 1</code>.
+         * @param endPosition End position of iterator in the data set. For forward access, the last accessible element in the iterator is <code>endPosition - 1</code>.
+         *
+         * @exception IllegalArgumentException If the requested block is out of bounds of the data storage.
+         * @exception IllegalStateException If write access is requested for a read-only data storage.
+         */
+
+        protected AbstractIterator(int mode, long startPosition, long endPosition)
+            throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+        {
+            if (startPosition < 0 || endPosition < 0 ||
+                startPosition > getSize() || endPosition > getSize())
+            {
+                throw new IllegalArgumentException("Requested block out of range: startPosition=" + startPosition + ", endPosition=" + endPosition + ", available=" + getSize());
+            }
+
+            if (isReadOnly() && (mode & WRITE) != 0)
+            {
+                throw new IllegalStateException("Write access requested for read-only data storage");
+            }
+
+            this.mode = mode;
+
+            if (endPosition >= startPosition)
+            {
+                this.position = startPosition;
+                this.length = endPosition - startPosition;
+                this.increment = 1;
+            }
+            else
+            {
+                this.position = startPosition - 1;
+                this.length = startPosition - endPosition;
+                this.increment = -1;
+            }
+        }
+
+        /**
+         * Check if <code>next()</code> can be called without going past the end of the sequence.
+         * That is, if <code>next()</code> can be called without deliberately causing an exception.<p>
+         *
+         * <b>Note:</b> It is important that the iterator is iterated
+         * past the last element; that is <code>next()</code> is called
+         * <code>startPosition - endPosition</code> times. The
+         * <code>get()</code> or <code>set()</code> methods should not
+         * be called for the last element.
+         *
+         * @return <code>true</code> if {@link #next()} can be called, otherwise <code>false</code>.
+         */
+
+        public boolean hasNext()
+        {
+            return (this.length > 0);
+        }
+
+        /**
+         * Advances the position in the stream by one element.<p>
+         *
+         * <b>Note:</b> It is important that the iterator is iterated
+         * past the last element; that is <code>next()</code> is called
+         * <code>startPosition - endPosition</code> times. The
+         * <code>get()</code> or <code>set()</code> methods should not
+         * be called for the last element.
+         */
+
+        public void next()
+            throws IllegalStateException, ApfloatRuntimeException
+        {
+            checkLength();
+            this.position += this.increment;
+            this.length--;
+        }
+
+        public int getInt()
+            throws UnsupportedOperationException, IllegalStateException, ApfloatRuntimeException
+        {
+            checkGet();
+            return super.getInt();
+        }
+
+        public long getLong()
+            throws UnsupportedOperationException, IllegalStateException, ApfloatRuntimeException
+        {
+            checkGet();
+            return super.getLong();
+        }
+
+        public float getFloat()
+            throws UnsupportedOperationException, IllegalStateException, ApfloatRuntimeException
+        {
+            checkGet();
+            return super.getFloat();
+        }
+
+        public double getDouble()
+            throws UnsupportedOperationException, IllegalStateException, ApfloatRuntimeException
+        {
+            checkGet();
+            return super.getDouble();
+        }
+
+        public void setInt(int value)
+            throws UnsupportedOperationException, IllegalStateException, ApfloatRuntimeException
+        {
+            checkSet();
+            super.setInt(value);
+        }
+
+        public void setLong(long value)
+            throws UnsupportedOperationException, IllegalStateException, ApfloatRuntimeException
+        {
+            checkSet();
+            super.setLong(value);
+        }
+
+        public void setFloat(float value)
+            throws UnsupportedOperationException, IllegalStateException, ApfloatRuntimeException
+        {
+            checkSet();
+            super.setFloat(value);
+        }
+
+        public void setDouble(double value)
+            throws UnsupportedOperationException, IllegalStateException, ApfloatRuntimeException
+        {
+            checkSet();
+            super.setDouble(value);
+        }
+
+        /**
+         * Checks if any of the <code>get()</code> methods can be called.
+         * This checks both that the iterator is not at the end yet, and
+         * that the iterator was opened in a readable mode.
+         *
+         * @exception IllegalStateException If the iterator is at end or is not readable.
+         */
+
+        protected void checkGet()
+            throws IllegalStateException
+        {
+            checkLength();
+            if ((this.mode & READ) == 0)
+            {
+                throw new IllegalStateException("Not a readable iterator");
+            }
+        }
+
+        /**
+         * Checks if any of the <code>set()</code> methods can be called.
+         * This checks both that the iterator is not at the end yet, and
+         * that the iterator was opened in a writable mode.
+         *
+         * @exception IllegalStateException If the iterator is at end or is not writable.
+         */
+
+        protected void checkSet()
+            throws IllegalStateException
+        {
+            checkLength();
+            if ((this.mode & WRITE) == 0)
+            {
+                throw new IllegalStateException("Not a writable iterator");
+            }
+        }
+
+        /**
+         * Checks if the iterator is at the end yet.
+         *
+         * @exception IllegalStateException If the iterator is at end.
+         */
+
+        protected void checkLength()
+            throws IllegalStateException
+        {
+            if (this.length == 0)
+            {
+                throw new IllegalStateException("At the end of iterator");
+            }
+        }
+
+        /**
+         * Returns the mode in which the iterator was created.
+         *
+         * @return The mode in which the iterator was created.
+         */
+
+        protected int getMode()
+        {
+            return this.mode;
+        }
+
+        /**
+         * Returns the current position of the iterator.
+         *
+         * @return The current position of the iterator.
+         */
+
+        protected long getPosition()
+        {
+            return this.position;
+        }
+
+        /**
+         * Returns the remaining length in the iterator.
+         *
+         * @return The remaining length in the iterator.
+         */
+
+        protected long getLength()
+        {
+            return this.length;
+        }
+
+        /**
+         * Returns the increment of the iterator.
+         * This is 1 if the iterator runs forward, or -1
+         * if the iterator runs backwards in the data.
+         *
+         * @return The increment of the iterator.
+         */
+
+        protected int getIncrement()
+        {
+            return this.increment;
+        }
+
+        private static final long serialVersionUID = 1668346231773868058L;
+
+        private int mode,
+                    increment;
+        private long position,
+                     length;
+    }
+
+    /**
+     * Default constructor. To be called by subclasses when creating a new empty
+     * <code>DataStorage</code>.
+     */
+
+    protected DataStorage()
+    {
+        this.offset = 0;
+        this.length = 0;
+        this.originalDataStorage = null;    // No dataStorage that this is a subsequence of
+        this.isReadOnly = false;            // Initially writable
+        this.isSubsequenced = false;        // Initially is not a subsequence nor any subsequences of this object exist
+    }
+
+    /**
+     * Subsequence constructor. To be called by subclasses when creating a subsequence of an
+     * existing DataStorage.
+     *
+     * @param dataStorage The originating data storage.
+     * @param offset The subsequence starting position.
+     * @param length The subsequence length.
+     */
+
+    protected DataStorage(DataStorage dataStorage, long offset, long length)
+    {
+        this.offset = offset;
+        this.length = length;
+        this.originalDataStorage = dataStorage;
+    }
+
+    /**
+     * Get a subsequence of this data storage.
+     *
+     * @param offset The subsequence starting position.
+     * @param length The subsequence length.
+     *
+     * @return Data storage that represents the specified part of this data storage.
+     *
+     * @exception IllegalArgumentException If the requested subsequence is out of range.
+     */
+
+    public final DataStorage subsequence(long offset, long length)
+        throws IllegalArgumentException, ApfloatRuntimeException
+    {
+        if (offset < 0 || length <= 0 || offset + length < 0 ||
+            offset + length > getSize())
+        {
+            throw new IllegalArgumentException("Requested subsequence out of range: offset=" + offset + ", length=" + length + ", available=" + getSize());
+        }
+
+        setSubsequenced();
+
+        if (offset == 0 && length == getSize())
+        {
+            // Full contents of the data set; not actually a subsequence
+            return this;
+        }
+
+        return implSubsequence(offset, length);
+    }
+
+    /**
+     * Implementation of getting a subsequence of this data storage.
+     * The validity of the arguments of this method do not need to be
+     * checked.
+     *
+     * @param offset The subsequence starting position.
+     * @param length The subsequence length.
+     *
+     * @return Data storage that represents the specified part of this data storage.
+     */
+
+    protected abstract DataStorage implSubsequence(long offset, long length)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Copies all data from another data storage to this data storage.
+     *
+     * @param dataStorage The data storage where the data should be copied from.
+     *
+     * @exception IllegalArgumentException If the origin data source has a size of zero.
+     * @exception IllegalStateException If this data storage is read-only or has subsequences.
+     */
+
+    public final void copyFrom(DataStorage dataStorage)
+        throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+    {
+        copyFrom(dataStorage, dataStorage.getSize());
+    }
+
+    /**
+     * Copies the specified number of elements from another data storage to this data storage.
+     *
+     * @param dataStorage The data storage where the data should be copied from.
+     * @param size The number of elements to be copied.
+     *
+     * @exception IllegalArgumentException If the size is invalid or zero.
+     * @exception IllegalStateException If this data storage is read-only or has subsequences.
+     */
+
+    public final void copyFrom(DataStorage dataStorage, long size)
+        throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+    {
+        if (size <= 0)
+        {
+            throw new IllegalArgumentException("Illegal size: " + size);
+        }
+        else if (isReadOnly())
+        {
+            throw new IllegalStateException("Cannot copy to read-only object");
+        }
+        else if (isSubsequenced())
+        {
+            throw new IllegalStateException("Cannot copy to when subsequences exist");
+        }
+
+        implCopyFrom(dataStorage, size);
+    }
+
+    /**
+     * Copies the specified number of elements from another data storage to this data storage.
+     * The validity of the arguments of this method do not need to be
+     * checked.
+     *
+     * @param dataStorage The data storage where the data should be copied from.
+     * @param size The number of elements to be copied.
+     */
+
+    protected abstract void implCopyFrom(DataStorage dataStorage, long size)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Return the size of the data storage, or the length of this sub-sequence
+     * if this data storage is a sub-sequence.
+     *
+     * @return The size of the data storage.
+     */
+
+    public final long getSize()
+        throws ApfloatRuntimeException
+    {
+        if (isReadOnly() || isSubsequenced())
+        {
+            return this.length;
+        }
+        else
+        {
+            return implGetSize();
+        }
+    }
+
+    /**
+     * Return the size of the whole data storage, not including sub-sequence settings.
+     *
+     * @return The size of the whole data storage, not including sub-sequence settings.
+     */
+
+    protected abstract long implGetSize()
+        throws ApfloatRuntimeException;
+
+    /**
+     * Sets the size of the data storage.
+     *
+     * @param size The size of the data storage.
+     *
+     * @exception IllegalArgumentException If the size is invalid or zero.
+     * @exception IllegalStateException If this data storage is read-only or has subsequences.
+     */
+
+    public final void setSize(long size)
+        throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+    {
+        if (size <= 0)
+        {
+            throw new IllegalArgumentException("Illegal size: " + size);
+        }
+        else if (isReadOnly())
+        {
+            throw new IllegalStateException("Cannot set size of read-only object");
+        }
+        else if (isSubsequenced())
+        {
+            throw new IllegalStateException("Cannot set size when subsequences exist");
+        }
+
+        implSetSize(size);
+    }
+
+    /**
+     * Sets the size of the data storage.
+     * The validity of the arguments of this method do not need to be
+     * checked.
+     *
+     * @param size The size of the data storage.
+     */
+
+    protected abstract void implSetSize(long size)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Returns the read-only state of this data storage.
+     *
+     * @return <code>true</code> if this data storage is read-only, otherwise <code>false</code>.
+     */
+
+    public final boolean isReadOnly()
+    {
+        if (this.originalDataStorage == null)
+        {
+            return this.isReadOnly;
+        }
+        else
+        {
+            return this.originalDataStorage.isReadOnly();
+        }
+    }
+
+    /**
+     * Sets this data storage as read-only.
+     * All existing sub-sequences (recursively) of this data storage
+     * are set to read-only as well.
+     */
+
+    public final void setReadOnly()
+        throws ApfloatRuntimeException
+    {
+        if (isReadOnly())
+        {
+            return;
+        }
+
+        if (!isSubsequenced())
+        {
+            this.length = implGetSize();
+        }
+
+        if (this.originalDataStorage == null)
+        {
+            this.isReadOnly = true;
+        }
+        else
+        {
+            this.originalDataStorage.setReadOnly();
+        }
+    }
+
+    /**
+     * Gets an array access to the data of this data storage when
+     * the data is treated as a linear block.
+     *
+     * @param mode Access mode for the array access: {@link #READ}, {@link #WRITE} or both.
+     * @param offset Starting position of the array access in the data storage.
+     * @param length Number of accessible elements in the array access.
+     *
+     * @return The array access.
+     *
+     * @exception IllegalArgumentException If the offset or length are out of bounds of the data storage.
+     * @exception IllegalStateException If write access is requested for a read-only data storage.
+     */
+
+    public final ArrayAccess getArray(int mode, long offset, int length)
+        throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+    {
+        if (isReadOnly() && (mode & WRITE) != 0)
+        {
+            throw new IllegalStateException("Write access requested for read-only data storage");
+        }
+
+        if (offset < 0 || length < 0 || offset + length < 0 ||
+            offset + length > getSize())
+        {
+            throw new IllegalArgumentException("Requested block out of range: offset=" + offset + ", length=" + length + ", available=" + getSize());
+        }
+
+        return implGetArray(mode, offset, length);
+    }
+
+    /**
+     * Gets an array access to the data of this data storage when it is treated as a linear block.
+     * The validity of the arguments of this method do not need to be checked.
+     *
+     * @param mode Access mode for the array access: {@link #READ}, {@link #WRITE} or both.
+     * @param offset Starting position of the array access in the data storage.
+     * @param length Number of accessible elements in the array access.
+     *
+     * @return The array access.
+     */
+
+    protected abstract ArrayAccess implGetArray(int mode, long offset, int length)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Maps a block of data to a memory array when the data is treated as a matrix.
+     * The matrix size is n<sub>1</sub> x n<sub>2</sub>.
+     * The following picture illustrates the block being accessed (in gray):
+     *
+     * <table style="border-collapse:collapse; text-align:center" summary="Matrix">
+     *   <tr style="height:300px">
+     *     <td style="width:200px; border:1px solid black">
+     *       <code>&larr; startColumn &rarr;</code>
+     *     </td>
+     *     <td style="width:150px; border:1px solid black; background:lightgray">
+     *       <code>&larr; columns &rarr;</code>
+     *     </td>
+     *     <td style="width:50px; border:1px solid black">
+     *       <code>&uarr;<br>
+     *       n<sub>1</sub><br>
+     *       &darr;<br></code>
+     *     </td>
+     *   </tr>
+     *   <tr>
+     *     <td colspan="3">
+     *       <code>&larr; n<sub>2</sub> &rarr;</code>
+     *     </td>
+     *   </tr>
+     * </table>
+     *
+     * @param mode Whether the array is prepared for reading, writing or both. The value should be {@link #READ}, {@link #WRITE} or a combination of these.
+     * @param startColumn The starting column where data is read.
+     * @param columns The number of columns of data to read.
+     * @param rows The number of rows of data to read. This should be equivalent to n<sub>1</sub>, number of rows in the matrix.
+     *
+     * @return Access to an array of size <code>columns</code> x <code>rows</code> containing the data.
+     *
+     * @exception IllegalArgumentException If the requested area is out of bounds of the data storage.
+     * @exception IllegalStateException If write access is requested for a read-only data storage.
+     *
+     * @since 1.7.0
+     */
+
+    public final ArrayAccess getArray(int mode, int startColumn, int columns, int rows)
+        throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+    {
+        if (isReadOnly() && (mode & WRITE) != 0)
+        {
+            throw new IllegalStateException("Write access requested for read-only data storage");
+        }
+
+        long size = (long) columns * rows;
+        if (startColumn < 0 || columns < 0 || rows < 0 || startColumn + columns < 0 ||
+            (long) (startColumn + columns) * rows > getSize())
+        {
+            throw new IllegalArgumentException("Requested block out of range: startColumn=" + startColumn + ", columns=" + columns + ", rows=" + rows + ", available=" + getSize());
+        }
+        else if (size > Integer.MAX_VALUE)
+        {
+            throw new ApfloatRuntimeException("Block too large to fit in an array: " + size);
+        }
+
+        return implGetArray(mode, startColumn, columns, rows);
+    }
+
+    /**
+     * Maps a block of data to a memory array when the data is treated as a matrix.
+     * The validity of the arguments of this method do not need to be
+     * checked.
+     *
+     * @param mode Whether the array is prepared for reading, writing or both. The value should be {@link #READ}, {@link #WRITE} or a combination of these.
+     * @param startColumn The starting column where data is read.
+     * @param columns The number of columns of data to read.
+     * @param rows The number of rows of data to read. This should be equivalent to n<sub>1</sub>, number of rows in the matrix.
+     *
+     * @return Access to an array of size <code>columns</code> x <code>rows</code> containing the data.
+     *
+     * @since 1.7.0
+     */
+
+    protected abstract ArrayAccess implGetArray(int mode, int startColumn, int columns, int rows)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Maps a transposed block of data to a memory array when the data is treated as a matrix.
+     * The matrix size is n<sub>1</sub> x n<sub>2</sub>. The accessed block is illustrated in gray
+     * in the following picture. The argument <code>columns</code> is the value <code>b</code>:
+     *
+     * <table style="border-collapse:collapse; text-align:center" summary="Matrix">
+     *   <tr>
+     *     <td style="width:200px; height:300px; border:1px solid black" rowspan="5">
+     *       <code>&larr; startColumn &rarr;</code>
+     *     </td>
+     *     <td style="width:150px; height:25px; background:lightgray; border:1px solid black">
+     *       <code>A</code>
+     *     </td>
+     *     <td style="width:50px; border:1px solid black" rowspan="5">
+     *       <code>&uarr;<br>
+     *       n<sub>1</sub><br>
+     *       &darr;<br></code>
+     *     </td>
+     *   </tr>
+     *   <tr>
+     *     <td style="width:100px; height:25px; background:lightgray; border:1px solid black">
+     *       <code>B</code>
+     *     </td>
+     *   </tr>
+     *   <tr>
+     *     <td style="width:100px; height:25px; background:lightgray; border:1px solid black">
+     *       <code>C</code>
+     *     </td>
+     *   </tr>
+     *   <tr>
+     *     <td style="width:100px; height:25px; background:lightgray; border:1px solid black">
+     *       <code>D</code>
+     *     </td>
+     *   </tr>
+     *   <tr>
+     *     <td style="width:100px; height:200px; background:lightgray; border:1px solid black">
+     *       <code>&larr; b &rarr;</code>
+     *     </td>
+     *   </tr>
+     *   <tr>
+     *     <td colspan="3">
+     *       <code>&larr; n<sub>2</sub> &rarr; </code>
+     *     </td>
+     *   </tr>
+     * </table>
+     *
+     * The data is read from an n<sub>1</sub> x b area of the matrix, in blocks
+     * of b elements, to a b x n<sub>1</sub> memory array as follows:
+     *
+     * <table style="border-collapse:collapse; text-align:center" summary="Read matrix section">
+     *   <tr style="background:lightgray">
+     *     <td style="width:100px; height:25px; border:1px solid black">
+     *       <code>A</code>
+     *     </td>
+     *     <td style="width:200px; border:1px solid black" rowspan="4">
+     *       <code>&uarr;<br>
+     *       b<br>
+     *       &darr;<br></code>
+     *     </td>
+     *   </tr>
+     *   <tr style="background:lightgray">
+     *     <td style="width:100px; height:25px; border:1px solid black">
+     *       <code>B</code>
+     *     </td>
+     *   </tr>
+     *   <tr style="background:lightgray">
+     *     <td style="width:100px; height:25px; border:1px solid black">
+     *       <code>C</code>
+     *     </td>
+     *   </tr>
+     *   <tr style="background:lightgray">
+     *     <td style="width:100px; height:25px; border:1px solid black">
+     *       <code>D</code>
+     *     </td>
+     *   </tr>
+     *   <tr>
+     *     <td colspan="2">
+     *       <code>&larr; n<sub>1</sub> &rarr;</code>
+     *     </td>
+     *   </tr>
+     * </table>
+     *
+     * Each b x b block is transposed, to form the final b x n<sub>1</sub> array
+     * in memory, where the columns are located linearly:
+     *
+     * <table style="border-collapse:collapse; text-align:center" summary="Transposed matrix section">
+     *   <tr style="height:100px; background:lightgray">
+     *     <td style="width:25px; border:1px solid black">
+     *       <code>A</code>
+     *     </td>
+     *     <td style="width:25px; border:1px solid black">
+     *       <code>B</code>
+     *     </td>
+     *     <td style="width:25px; border:1px solid black">
+     *       <code>C</code>
+     *     </td>
+     *     <td style="width:25px; border:1px solid black">
+     *       <code>D</code>
+     *     </td>
+     *     <td style="width:200px; border:1px solid black">
+     *       <code>&uarr;<br>
+     *       b<br>
+     *       &darr;<br></code>
+     *     </td>
+     *   </tr>
+     *   <tr>
+     *     <td colspan="5">
+     *       <code>&larr; n<sub>1</sub> &rarr;</code>
+     *     </td>
+     *   </tr>
+     * </table>
+     *
+     * @param mode Whether the array is prepared for reading, writing or both. The value should be {@link #READ}, {@link #WRITE} or a combination of these.
+     * @param startColumn The starting column where data is read.
+     * @param columns The number of columns of data to read.
+     * @param rows The number of rows of data to read. This should be equivalent to n<sub>1</sub>, number of rows in the matrix.
+     *
+     * @return Access to an array of size <code>columns</code> x <code>rows</code> containing the transposed data.
+     *
+     * @exception IllegalArgumentException If the requested area is out of bounds of the data storage.
+     * @exception IllegalStateException If write access is requested for a read-only data storage.
+     */
+
+    public final ArrayAccess getTransposedArray(int mode, int startColumn, int columns, int rows)
+        throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException
+    {
+        if (isReadOnly() && (mode & WRITE) != 0)
+        {
+            throw new IllegalStateException("Write access requested for read-only data storage");
+        }
+
+        long size = (long) columns * rows;
+        if (startColumn < 0 || columns < 0 || rows < 0 || startColumn + columns < 0 ||
+            (long) (startColumn + columns) * rows > getSize())
+        {
+            throw new IllegalArgumentException("Requested block out of range: startColumn=" + startColumn + ", columns=" + columns + ", rows=" + rows + ", available=" + getSize());
+        }
+        else if (size > Integer.MAX_VALUE)
+        {
+            throw new ApfloatRuntimeException("Block too large to fit in an array: " + size);
+        }
+
+        return implGetTransposedArray(mode, startColumn, columns, rows);
+    }
+
+    /**
+     * Maps a transposed block of data to a memory array when the data is treated as a matrix.
+     * The validity of the arguments of this method do not need to be
+     * checked.
+     *
+     * @param mode Whether the array is prepared for reading, writing or both. The value should be {@link #READ}, {@link #WRITE} or a combination of these.
+     * @param startColumn The starting column where data is read.
+     * @param columns The number of columns of data to read.
+     * @param rows The number of rows of data to read. This should be equivalent to n<sub>1</sub>, number of rows in the matrix.
+     *
+     * @return Access to an array of size <code>columns</code> x <code>rows</code> containing the transposed data.
+     */
+
+    protected abstract ArrayAccess implGetTransposedArray(int mode, int startColumn, int columns, int rows)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Constructs a new iterator. Elements can be iterated either
+     * in forward or in reverse order, depending on if <code>startPosition</code>
+     * is less than or greater than <code>endPosition</code>, correspondingly.
+     *
+     * @param mode Access mode for iterator: {@link #READ}, {@link #WRITE} or both.
+     * @param startPosition Starting position of iterator in the data set. For reverse access, the first element in the iterator is <code>startPosition - 1</code>.
+     * @param endPosition End position of iterator in the data set. For forward access, the last accessible element in the iterator is <code>endPosition - 1</code>.
+     *
+     * @return An iterator.
+     *
+     * @exception IllegalArgumentException If the requested area is out of bounds of the data storage.
+     * @exception IllegalStateException If write access is requested for a read-only data storage.
+     */
+
+    public abstract Iterator iterator(int mode, long startPosition, long endPosition)
+        throws IllegalArgumentException, IllegalStateException, ApfloatRuntimeException;
+
+    /**
+     * Is this object a subsequence of some other object, or do subsequences of this object exist.
+     *
+     * @return <code>true</code> if this object is a subsequence of some other object, or if subsequences of this object exist, <code>false</code> otherwise.
+     */
+
+    public final boolean isSubsequenced()
+    {
+        if (this.originalDataStorage == null)
+        {
+            return this.isSubsequenced;
+        }
+        else
+        {
+            return true;
+        }
+    }
+
+    /**
+     * Is this object cached in memory.
+     *
+     * @return <code>true</code> if this object is cached in memory, <code>false</code> if not.
+     *
+     * @since 1.7.0
+     */
+
+    public abstract boolean isCached();
+
+    /**
+     * Return the sub-sequence offset.
+     *
+     * @return Absolute offset of the sub-sequence within the (top-level) base data storage.
+     */
+
+    protected final long getOffset()
+    {
+        return this.offset;
+    }
+
+    private void setSubsequenced()
+        throws ApfloatRuntimeException
+    {
+        if (!isSubsequenced())
+        {
+            if (!isReadOnly())
+            {
+                this.length = implGetSize();        // Size can't be changed after this
+            }
+            // This may be called even after the DataStorage has been set to be read-only, but the mutation behaves
+            // consistently even if done from multiple threads at the same time
+            this.isSubsequenced = true;             // Subsequences exist for this object
+        }
+    }
+
+    private static final long serialVersionUID = 1862028601696578467L;
+
+    private long offset;
+    private long length;
+    private DataStorage originalDataStorage;
+    private boolean isReadOnly;
+    private boolean isSubsequenced;
+}
Index: src/main/java/org/apfloat/spi/DataStorageBuilder.java
===================================================================
--- src/main/java/org/apfloat/spi/DataStorageBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/spi/DataStorageBuilder.java	(revision 0)
@@ -0,0 +1,81 @@
+package org.apfloat.spi;
+
+import org.apfloat.ApfloatRuntimeException;
+
+/**
+ * Interface for determining a suitable storage
+ * type for data of some expected size. The factory method
+ * pattern is used for creating the data storages.<p>
+ *
+ * The storage type can be different based on the size of the
+ * data. For example, it may be beneficial to store small amounts
+ * of data always in memory, for small overhead in access times,
+ * and to store larger objects on disk files, to avoid running
+ * out of memory.<p>
+ *
+ * Further, an implementing class may provide data storage objects
+ * that store data in disk files, for Java client applications, or
+ * e.g. in a relational database, for an EJB server environment
+ * where files are not allowed to be used.
+ *
+ * @see DataStorage
+ *
+ * @version 1.5.1
+ * @author Mikko Tommila
+ */
+
+public interface DataStorageBuilder
+{
+    /**
+     * Get an appropriate type of data storage for the requested size of data.<p>
+     *
+     * Note that the returned data storage object is not set to have the
+     * requested size, so the client should call the object's {@link DataStorage#setSize(long)}
+     * method before storing data to it.
+     *
+     * @param size The size of data to be stored in the storage, in bytes.
+     *
+     * @return An empty <code>DataStorage</code> object of an appropriate type for storing <code>size</code> bytes of data.
+     */
+
+    public DataStorage createDataStorage(long size)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Get a data storage that is cached in memory, if possible, for the requested size of data.<p>
+     *
+     * Note that the returned data storage object is not set to have the
+     * requested size, so the client should call the object's {@link DataStorage#setSize(long)}
+     * method before storing data to it.
+     *
+     * @param size The size of data to be stored in the storage, in bytes.
+     *
+     * @return An empty <code>DataStorage</code> object of an appropriate type for storing <code>size</code> bytes of data, cached if possible.
+     *
+     * @since 1.5.1
+     */
+
+    public DataStorage createCachedDataStorage(long size)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Convert cached data storage to the appropriate normal data storage type.<p>
+     *
+     * If the data storage already has the appropriate type for its size, the data
+     * storage may be returned unchanged. The argument data storage does not necessarily
+     * have to be created with the {@link #createCachedDataStorage(long)} method, it can
+     * be created as well with the {@link #createDataStorage(long)} method.<p>
+     *
+     * If the given data storage does not have the appropriate type for its size, then
+     * a new data storage of the appropriate type is created and the data is copied to it.<p>
+     *
+     * @param dataStorage The data storage to be converted, if necessary.
+     *
+     * @return A <code>DataStorage</code> that can be the original data storage or a copy of it, with the appropriate type.
+     *
+     * @since 1.5.1
+     */
+
+    public DataStorage createDataStorage(DataStorage dataStorage)
+        throws ApfloatRuntimeException;
+}
Index: src/main/java/org/apfloat/spi/Factor3NTTStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/spi/Factor3NTTStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/spi/Factor3NTTStepStrategy.java	(revision 0)
@@ -0,0 +1,39 @@
+package org.apfloat.spi;
+
+import org.apfloat.ApfloatRuntimeException;
+
+/**
+ * Steps for the factor-3 NTT.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public interface Factor3NTTStepStrategy
+{
+    /**
+     * Transform the columns of a matrix using a 3-point transform.
+     *
+     * @param dataStorage0 The data of the first column.
+     * @param dataStorage1 The data of the second column.
+     * @param dataStorage2 The data of the third column.
+     * @param startColumn The starting element index in the data storages to transform.
+     * @param columns How many columns to transform.
+     * @param power2length Length of the column transform.
+     * @param length Length of total transform (three times the length of one column).
+     * @param isInverse <code>true</code> if an inverse transform is performed, <code>false</code> if a forward transform is performed.
+     * @param modulus Index of the modulus.
+     */
+
+    public void transformColumns(DataStorage dataStorage0, DataStorage dataStorage1, DataStorage dataStorage2, long startColumn, long columns, long power2length, long length, boolean isInverse, int modulus)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Get the maximum transform length.
+     *
+     * @return The maximum transform length.
+     */
+
+    public long getMaxTransformLength();
+}
Index: src/main/java/org/apfloat/spi/FilenameGenerator.java
===================================================================
--- src/main/java/org/apfloat/spi/FilenameGenerator.java	(revision 0)
+++ src/main/java/org/apfloat/spi/FilenameGenerator.java	(revision 0)
@@ -0,0 +1,101 @@
+package org.apfloat.spi;
+
+import org.apfloat.ApfloatContext;
+
+/**
+ * Class for generating filenames for temporary files.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public class FilenameGenerator
+{
+    /**
+     * Create a new filename generator. The generated filenames will
+     * point to the specified directory path. The base file name is a
+     * sequential number. The specified suffix is appended to the
+     * final file name.
+     *
+     * @param path The path where the file are created. If <code>null</code>, the default file path from the {@link ApfloatContext} is used.
+     * @param initialValue The initial value for the numbers. If <code>null</code>, the default file initial value from the {@link ApfloatContext} is used.
+     * @param suffix The suffix for file names. If <code>null</code>, the default file suffix from the {@link ApfloatContext} is used.
+     *
+     * @exception NumberFormatException If initialValue is not a valid integer number.
+     */
+
+    public FilenameGenerator(String path, String initialValue, String suffix)
+        throws NumberFormatException
+    {
+        if (path == null)
+        {
+            ApfloatContext ctx = ApfloatContext.getContext();
+            path = ctx.getProperty(ApfloatContext.FILE_PATH);
+        }
+
+        if (initialValue == null)
+        {
+            ApfloatContext ctx = ApfloatContext.getContext();
+            initialValue = ctx.getProperty(ApfloatContext.FILE_INITIAL_VALUE);
+        }
+
+        if (suffix == null)
+        {
+            ApfloatContext ctx = ApfloatContext.getContext();
+            suffix = ctx.getProperty(ApfloatContext.FILE_SUFFIX);
+        }
+
+        this.path = path;
+        this.value = Long.parseLong(initialValue);
+        this.suffix = suffix;
+    }
+
+    /**
+     * Generate a filename. The returned filename is unique among
+     * those generated by this filename generator.
+     *
+     * @return A generated file name.
+     */
+
+    public synchronized String generateFilename()
+    {
+        return this.path + (this.value++) + this.suffix;
+    }
+
+    /**
+     * Returns the path setting of this filename generator.
+     *
+     * @return The path setting of this filename generator.
+     */
+
+    public String getPath()
+    {
+        return this.path;
+    }
+
+    /**
+     * Returns the current initial value of the base file names generated.
+     *
+     * @return The current initial value of the base file names generated.
+     */
+
+    public synchronized String getInitialValue()
+    {
+        return String.valueOf(this.value);
+    }
+
+    /**
+     * Returns the suffix setting of this filename generator.
+     *
+     * @return The suffix setting of this filename generator.
+     */
+
+    public String getSuffix()
+    {
+        return this.suffix;
+    }
+
+    private String path;
+    private long value;
+    private String suffix;
+}
Index: src/main/java/org/apfloat/spi/MatrixBuilder.java
===================================================================
--- src/main/java/org/apfloat/spi/MatrixBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/spi/MatrixBuilder.java	(revision 0)
@@ -0,0 +1,23 @@
+package org.apfloat.spi;
+
+/**
+ * Interface of a factory for creating matrix related objects.
+ * The factory method pattern is used.
+ *
+ * @see MatrixStrategy
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public interface MatrixBuilder
+{
+    /**
+     * Creates an object for matrix operations.
+     *
+     * @return A suitable object for performing the matrix operations.
+     */
+
+    public MatrixStrategy createMatrix();
+}
Index: src/main/java/org/apfloat/spi/MatrixStrategy.java
===================================================================
--- src/main/java/org/apfloat/spi/MatrixStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/spi/MatrixStrategy.java	(revision 0)
@@ -0,0 +1,133 @@
+package org.apfloat.spi;
+
+import org.apfloat.ApfloatRuntimeException;
+
+/**
+ * Matrix operations.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public interface MatrixStrategy
+{
+    /**
+     * Transpose a n<sub>1</sub> x n<sub>2</sub> matrix.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two.
+     * Additionally, one of these must be true:<p>
+     *
+     * n<sub>1</sub> = n<sub>2</sub><br>
+     * n<sub>1</sub> = 2*n<sub>2</sub><br>
+     * n<sub>2</sub> = 2*n<sub>1</sub><br>
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be transposed.
+     * @param n1 Number of rows in the matrix.
+     * @param n2 Number of columns in the matrix.
+     */
+
+    public void transpose(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Transpose a square n<sub>1</sub> x n<sub>1</sub> block of n<sub>1</sub> x n<sub>2</sub> matrix.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two,
+     * and n<sub>1</sub> &lt;= n<sub>2</sub>.
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be transposed.
+     * @param n1 Number of rows and columns in the block to be transposed.
+     * @param n2 Number of columns in the matrix.
+     */
+
+    public void transposeSquare(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Permute the rows of the n<sub>1</sub> x n<sub>2</sub> matrix so that it is shaped like a
+     * n<sub>1</sub>/2 x 2*n<sub>2</sub> matrix. Logically, the matrix is split in half, and the
+     * lower half is moved to the right side of the upper half.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two,
+     * and n<sub>1</sub> &gt;= 2.<p>
+     *
+     * E.g. if the matrix layout is originally as follows:
+     * <table style="width:100px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix before">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td>
+     *   </tr>
+     *   <tr>
+     *     <td>4</td><td>5</td><td>6</td><td>7</td>
+     *   </tr>
+     *   <tr style="background:lightgray">
+     *     <td>8</td><td>9</td><td>10</td><td>11</td>
+     *   </tr>
+     *   <tr style="background:lightgray">
+     *     <td>12</td><td>13</td><td>14</td><td>15</td>
+     *   </tr>
+     * </table>
+     * <p>
+     *
+     * Then after this method it is as follows:
+     * <table style="width:200px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix after">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td><td style="background:lightgray">8</td><td style="background:lightgray">9</td><td style="background:lightgray">10</td><td style="background:lightgray">11</td>
+     *   </tr>
+     *   <tr>
+     *     <td>4</td><td>5</td><td>6</td><td>7</td><td style="background:lightgray">12</td><td style="background:lightgray">13</td><td style="background:lightgray">14</td><td style="background:lightgray">15</td>
+     *   </tr>
+     * </table>
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be permuted.
+     * @param n1 Number of rows in the matrix.
+     * @param n2 Number of columns in the matrix.
+     *
+     * @since 1.7.0
+     */
+
+    public void permuteToDoubleWidth(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Permute the rows of the n<sub>1</sub> x n<sub>2</sub> matrix so that it is shaped like a
+     * 2*n<sub>1</sub> x n<sub>2</sub>/2 matrix. Logically, the matrix is split in half, and the
+     * right half is moved below the left half.<p>
+     *
+     * Both n<sub>1</sub> and n<sub>2</sub> must be powers of two.
+     *
+     * E.g. if the matrix layout is originally as follows:
+     * <table style="width:200px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix before">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td><td style="background:lightgray">4</td><td style="background:lightgray">5</td><td style="background:lightgray">6</td><td style="background:lightgray">7</td>
+     *   </tr>
+     *   <tr>
+     *     <td>8</td><td>9</td><td>10</td><td>11</td><td style="background:lightgray">12</td><td style="background:lightgray">13</td><td style="background:lightgray">14</td><td style="background:lightgray">15</td>
+     *   </tr>
+     * </table>
+     * <p>
+     *
+     * Then after this method it is as follows:
+     * <table style="width:100px; border-collapse:collapse; border:1px solid black" border="1" summary="Matrix after">
+     *   <tr>
+     *     <td>0</td><td>1</td><td>2</td><td>3</td>
+     *   </tr>
+     *   <tr>
+     *     <td>8</td><td>9</td><td>10</td><td>11</td>
+     *   </tr>
+     *   <tr style="background:lightgray">
+     *     <td>4</td><td>5</td><td>6</td><td>7</td>
+     *   </tr>
+     *   <tr style="background:lightgray">
+     *     <td>12</td><td>13</td><td>14</td><td>15</td>
+     *   </tr>
+     * </table>
+     *
+     * @param arrayAccess Accessor to the matrix data. This data will be permuted.
+     * @param n1 Number of rows in the matrix.
+     * @param n2 Number of columns in the matrix.
+     */
+
+    public void permuteToHalfWidth(ArrayAccess arrayAccess, int n1, int n2)
+        throws ApfloatRuntimeException;
+}
Index: src/main/java/org/apfloat/spi/NTTBuilder.java
===================================================================
--- src/main/java/org/apfloat/spi/NTTBuilder.java	(revision 0)
+++ src/main/java/org/apfloat/spi/NTTBuilder.java	(revision 0)
@@ -0,0 +1,58 @@
+package org.apfloat.spi;
+
+/**
+ * Interface of a factory for creating Number Theoretic Transforms.
+ * The factory method pattern is used.
+ *
+ * @see NTTStrategy
+ * @see NTTStepStrategy
+ *
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public interface NTTBuilder
+{
+    /**
+     * Creates a Number Theoretic Transform of suitable
+     * type for the specified length.
+     *
+     * @param size The transform length that will be used.
+     *
+     * @return A suitable NTT object for performing the transform.
+     */
+
+    public NTTStrategy createNTT(long size);
+
+    /**
+     * Creates an object for implementing the steps of a step-based
+     * Number Theoretic Transform.
+     *
+     * @return A suitable object for performing the transform steps.
+     *
+     * @since 1.7.0
+     */
+
+    public NTTStepStrategy createNTTSteps();
+
+    /**
+     * Creates an object for implementing the steps of a three-NTT
+     * based convolution.
+     *
+     * @return A suitable object for performing the convolution steps.
+     *
+     * @since 1.7.0
+     */
+
+    public NTTConvolutionStepStrategy createNTTConvolutionSteps();
+
+    /**
+     * Creates an object for implementing the steps of factor-3 NTT.
+     *
+     * @return A suitable object for performing the factor-3 NTT steps.
+     *
+     * @since 1.7.0
+     */
+
+    public Factor3NTTStepStrategy createFactor3NTTSteps();
+}
Index: src/main/java/org/apfloat/spi/NTTConvolutionStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/spi/NTTConvolutionStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/spi/NTTConvolutionStepStrategy.java	(revision 0)
@@ -0,0 +1,44 @@
+package org.apfloat.spi;
+
+import org.apfloat.ApfloatRuntimeException;
+
+/**
+ * Steps for a three-NTT convolution. This includes element-by-element
+ * multiplication and squaring of the transformed data.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public interface NTTConvolutionStepStrategy
+{
+    /**
+     * Linear multiplication in the number theoretic domain.
+     * The operation is <code>sourceAndDestination[i] *= source[i] (mod m)</code>.<p>
+     *
+     * For maximum performance, <code>sourceAndDestination</code>
+     * should be in memory if possible.
+     *
+     * @param sourceAndDestination The first source data storage, which is also the destination.
+     * @param source The second source data storage.
+     * @param modulus Which modulus to use (0, 1, 2)
+     */
+
+    public void multiplyInPlace(DataStorage sourceAndDestination, DataStorage source, int modulus)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Linear squaring in the number theoretic domain.
+     * The operation is <code>sourceAndDestination[i] *= sourceAndDestination[i] (mod m)</code>.<p>
+     *
+     * For maximum performance, <code>sourceAndDestination</code>
+     * should be in memory if possible.
+     *
+     * @param sourceAndDestination The source data storage, which is also the destination.
+     * @param modulus Which modulus to use (0, 1, 2)
+     */
+
+    public void squareInPlace(DataStorage sourceAndDestination, int modulus)
+        throws ApfloatRuntimeException;
+}
Index: src/main/java/org/apfloat/spi/NTTStepStrategy.java
===================================================================
--- src/main/java/org/apfloat/spi/NTTStepStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/spi/NTTStepStrategy.java	(revision 0)
@@ -0,0 +1,59 @@
+package org.apfloat.spi;
+
+import org.apfloat.ApfloatContext;
+import org.apfloat.ApfloatRuntimeException;
+
+/**
+ * Steps for the six-step or two-pass NTT.
+ *
+ * @since 1.7.0
+ * @version 1.7.0
+ * @author Mikko Tommila
+ */
+
+public interface NTTStepStrategy
+{
+    /**
+     * Multiply each matrix element <code>(i, j)</code> by <code>w<sup>i * j</sup> / totalTransformLength</code>.
+     * The matrix size is n<sub>1</sub> x n<sub>2</sub>.
+     *
+     * @param arrayAccess The memory array to multiply.
+     * @param startRow Which row in the whole matrix the starting row in the <code>arrayAccess</code> is.
+     * @param startColumn Which column in the whole matrix the starting column in the <code>arrayAccess</code> is.
+     * @param rows The number of rows in the <code>arrayAccess</code> to multiply.
+     * @param columns The number of columns in the matrix (= n<sub>2</sub>).
+     * @param length The length of data in the matrix being transformed.
+     * @param totalTransformLength The total transform length, for the scaling factor. Used only for the inverse case.
+     * @param isInverse If the multiplication is done for the inverse transform or not.
+     * @param modulus Index of the modulus.
+     */
+
+    public void multiplyElements(ArrayAccess arrayAccess, int startRow, int startColumn, int rows, int columns, long length, long totalTransformLength, boolean isInverse, int modulus)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Transform the rows of the data matrix.
+     * If only one processor is available, it runs all transforms in the current
+     * thread. If more than one processor are available, it dispatches the calculations
+     * to multiple threads to parallelize the calculation. The number of processors is
+     * determined using {@link ApfloatContext#getNumberOfProcessors()}.
+     *
+     * @param arrayAccess The memory array to split to rows and to transform.
+     * @param length Length of one transform (one row).
+     * @param count Number of rows.
+     * @param isInverse <code>true</code> if an inverse transform is performed, <code>false</code> if a forward transform is performed.
+     * @param permute If permutation should be done.
+     * @param modulus Index of the modulus.
+     */
+
+    public void transformRows(ArrayAccess arrayAccess, int length, int count, boolean isInverse, boolean permute, int modulus)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Get the maximum transform length.
+     *
+     * @return The maximum transform length.
+     */
+
+    public long getMaxTransformLength();
+}
Index: src/main/java/org/apfloat/spi/NTTStrategy.java
===================================================================
--- src/main/java/org/apfloat/spi/NTTStrategy.java	(revision 0)
+++ src/main/java/org/apfloat/spi/NTTStrategy.java	(revision 0)
@@ -0,0 +1,65 @@
+package org.apfloat.spi;
+
+import org.apfloat.ApfloatRuntimeException;
+
+/**
+ * Number Theoretic Transform (NTT) strategy.
+ * An implementing class could be e.g.
+ *
+ * <ul>
+ *   <li>Fast Number Theoretic Transform (FNT)</li>
+ *   <li>"Four-step" FNT</li>
+ *   <li>"Two-pass" mass storage FNT</li>
+ *   <li>Winograd Fourier Transform Algorithm (WFTA)</li>
+ * </ul>
+ * <p>
+ *
+ * Note: an implementing transformation class is required only to be able
+ * to perform an inverse transform on data transformed by the same class,
+ * not by any other class.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public interface NTTStrategy
+{
+    /**
+     * Perform a forward transform on the data.<p>
+     *
+     * Multiple moduli can be used, if the convolution algorithm
+     * uses the Chinese Remainder Theorem to calculate the final
+     * result.
+     *
+     * @param dataStorage The data to be transformed.
+     * @param modulus Number of modulus to use (in case the transform supports multiple moduli).
+     */
+
+    public void transform(DataStorage dataStorage, int modulus)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Perform an inverse transform on the data.<p>
+     *
+     * Multiple moduli can be used, if the convolution algorithm
+     * uses the Chinese Remainder Theorem to calculate the final
+     * result.
+     *
+     * @param dataStorage The data to be transformed.
+     * @param modulus Number of modulus to use (in case the transform supports multiple moduli).
+     * @param totalTransformLength Total transform length; the final result elements are divided by this value.
+     */
+
+    public void inverseTransform(DataStorage dataStorage, int modulus, long totalTransformLength)
+        throws ApfloatRuntimeException;
+
+    /**
+     * Return the supported transform length for the specified data size.
+     *
+     * @param size Length of the data to be transformed.
+     *
+     * @return Length of the transform needed by this transform.
+     */
+
+    public long getTransformLength(long size);
+}
Index: src/main/java/org/apfloat/spi/RadixConstants.java
===================================================================
--- src/main/java/org/apfloat/spi/RadixConstants.java	(revision 0)
+++ src/main/java/org/apfloat/spi/RadixConstants.java	(revision 0)
@@ -0,0 +1,43 @@
+package org.apfloat.spi;
+
+/**
+ * Constants related to different radixes.
+ *
+ * @version 1.0
+ * @author Mikko Tommila
+ */
+
+public interface RadixConstants
+{
+    /**
+     * Factors of numbers 2, ..., 36. For 2 &lt;= radix &lt;= 36,
+     * <code>RADIX_FACTORS[radix]</code> contains an array of
+     * integers containing the different factors of the radix.
+     */
+
+    public static final int RADIX_FACTORS[][] = { null, null, { 2 }, { 3 }, { 2 }, { 5 }, { 2, 3 }, { 7 }, { 2 }, { 3 }, { 2, 5 }, { 11 }, { 2, 3 }, { 13 }, { 2, 7 }, { 3, 5 }, { 2 }, { 17 }, { 2, 3 }, { 19 }, { 2, 5 }, { 3, 7 }, { 2, 11 }, { 23 }, { 2, 3 }, { 5 }, { 2, 13 }, { 3 }, { 2, 7 }, { 29 }, { 2, 3, 5 }, { 31 }, { 2 }, { 3, 11 }, { 2, 17 }, { 5, 7 }, { 2, 3 } };
+
+    /**
+     * Precision of a <code>float</code> in the digits of each radix.
+     */
+
+    public static final int FLOAT_PRECISION[] = { -1, -1, 24, 16, 12, 11, 10, 9, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5 };
+
+    /**
+     * Precision of a <code>double</code> in the digits of each radix.
+     */
+
+    public static final int DOUBLE_PRECISION[] = { -1, -1, 53, 34, 27, 23, 21, 19, 18, 17, 16, 16, 15, 15, 14, 14, 14, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 11, 11 };
+
+    /**
+     * Precision of a <code>long</code> in the digits of each radix.
+     */
+
+    public static final int LONG_PRECISION[] = { -1, -1, 63, 40, 32, 28, 25, 23, 21, 20, 19, 19, 18, 18, 17, 17, 16, 16, 16, 15, 15, 15, 15, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13 };
+
+    /**
+     * How many digits maximally fit in a <code>long</code> in each radix.
+     */
+
+    public static final int LONG_DIGITS[] = { -1, -1, 63, 39, 31, 27, 24, 22, 21, 19, 18, 18, 17, 17, 16, 16, 15, 15, 15, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 12 };
+}
Index: src/main/java/org/apfloat/spi/Util.java
===================================================================
--- src/main/java/org/apfloat/spi/Util.java	(revision 0)
+++ src/main/java/org/apfloat/spi/Util.java	(revision 0)
@@ -0,0 +1,447 @@
+package org.apfloat.spi;
+
+import org.apfloat.Apfloat;
+
+/**
+ * Miscellaneous utility methods.
+ *
+ * @version 1.6
+ * @author Mikko Tommila
+ */
+
+public class Util
+{
+    private Util()
+    {
+    }
+
+    /**
+     * Round down to nearest power of two.
+     *
+     * @param x The input value, which must be non-negative.
+     *
+     * @return <code>x</code> rounded down to the nearest power of two.
+     */
+
+    public static int round2down(int x)
+    {
+        assert (x >= 0);
+
+        return Integer.highestOneBit(x);
+    }
+
+    /**
+     * Round down to nearest power of two.
+     *
+     * @param x The input value, which must be non-negative.
+     *
+     * @return <code>x</code> rounded down to the nearest power of two.
+     */
+
+    public static long round2down(long x)
+    {
+        assert (x >= 0);
+
+        return Long.highestOneBit(x);
+    }
+
+    /**
+     * Round up to nearest power of two.
+     *
+     * @param x The input value, which must be non-negative and not greater than 2<sup>30</sup>.
+     *
+     * @return <code>x</code> rounded up to the nearest power of two.
+     */
+
+    public static int round2up(int x)
+    {
+        assert (x >= 0);
+        assert (x <= 0x40000000);
+
+        if (x == 0)
+        {
+            return 0;
+        }
+
+        int r = 1;
+
+        while (r < x)
+        {
+            r += r;
+        }
+
+        return r;
+    }
+
+    /**
+     * Round up to nearest power of two.
+     *
+     * @param x The input value, which must be non-negative and not greater than 2<sup>62</sup>.
+     *
+     * @return <code>x</code> rounded up to the nearest power of two.
+     */
+
+    public static long round2up(long x)
+    {
+        assert (x >= 0);
+        assert (x <= 0x4000000000000000L);
+
+        if (x == 0)
+        {
+            return 0;
+        }
+
+        long r = 1;
+
+        while (r < x)
+        {
+            r += r;
+        }
+
+        return r;
+    }
+
+    /**
+     * Round down to nearest power of two or three times a power of two.
+     *
+     * @param x The input value, which must be non-negative.
+     *
+     * @return <code>x</code> rounded down to nearest power of two or three times a power of two.
+     */
+
+    public static int round23down(int x)
+    {
+        assert (x >= 0);
+
+        if (x == 0)
+        {
+            return 0;
+        }
+
+        int r = 1, p = 0;
+
+        while (r <= x && r > 0)     // Detect overflow
+        {
+            p = r;
+            if (r == 1)
+            {
+                r = 2;
+            }
+            else if (r == (r & -r))
+            {
+                r = r / 2 * 3;
+            }
+            else
+            {
+                r = r / 3 * 4;
+            }
+        }
+
+        return p;
+    }
+
+    /**
+     * Round down to nearest power of two or three times a power of two.
+     *
+     * @param x The input value, which must be non-negative.
+     *
+     * @return <code>x</code> rounded down to nearest power of two or three times a power of two.
+     */
+
+    public static long round23down(long x)
+    {
+        assert (x >= 0);
+
+        if (x == 0)
+        {
+            return 0;
+        }
+
+        long r = 1, p = 0;
+
+        while (r <= x && r > 0)     // Detect overflow
+        {
+            p = r;
+            if (r == 1)
+            {
+                r = 2;
+            }
+            else if (r == (r & -r))
+            {
+                r = r / 2 * 3;
+            }
+            else
+            {
+                r = r / 3 * 4;
+            }
+        }
+
+        return p;
+    }
+
+    /**
+     * Round up to nearest power of two or three times a power of two.
+     *
+     * @param x The input value, which must be non-negative and not greater than 3 * 2<sup>29</sup>.
+     *
+     * @return <code>x</code> rounded up to the nearest power of two or three times a power of two.
+     */
+
+    public static int round23up(int x)
+    {
+        assert (x >= 0);
+        assert (x <= 0x60000000);
+
+        if (x == 0)
+        {
+            return 0;
+        }
+
+        int r = 1;
+
+        while (r < x)
+        {
+            if (r == 1)
+            {
+                r = 2;
+            }
+            else if (r == (r & -r))
+            {
+                r = r / 2 * 3;
+            }
+            else
+            {
+                r = r / 3 * 4;
+            }
+        }
+
+        return r;
+    }
+
+    /**
+     * Round up to nearest power of two or three times a power of two.
+     *
+     * @param x The input value, which must be non-negative and not greater than 3 * 2<sup>61</sup>.
+     *
+     * @return <code>x</code> rounded up to the nearest power of two or three times a power of two.
+     */
+
+    public static long round23up(long x)
+    {
+        assert (x >= 0);
+        assert (x <= 0x6000000000000000L);
+
+        if (x == 0)
+        {
+            return 0;
+        }
+
+        long r = 1;
+
+        while (r < x)
+        {
+            if (r == 1)
+            {
+                r = 2;
+            }
+            else if (r == (r & -r))
+            {
+                r = r / 2 * 3;
+            }
+            else
+            {
+                r = r / 3 * 4;
+            }
+        }
+
+        return r;
+    }
+
+    /**
+     * Square root rounded down to nearest power of two.
+     *
+     * @param x The input value, which must be non-negative.
+     *
+     * @return Square root of <code>x</code> rounded down to nearest power of two.
+     */
+
+    public static int sqrt4down(int x)
+    {
+        assert (x >= 0);
+
+        if (x == 0)
+        {
+            return 0;
+        }
+
+        int r = 1;
+
+        while ((x >>= 2) > 0)
+        {
+            r <<= 1;
+        }
+
+        return r;
+    }
+
+    /**
+     * Square root rounded down to nearest power of two.
+     *
+     * @param x The input value, which must be non-negative.
+     *
+     * @return Square root of <code>x</code> rounded down to nearest power of two.
+     */
+
+    public static long sqrt4down(long x)
+    {
+        assert (x >= 0);
+
+        if (x == 0)
+        {
+            return 0;
+        }
+
+        long r = 1;
+
+        while ((x >>= 2) > 0)
+        {
+            r <<= 1;
+        }
+
+        return r;
+    }
+
+    /**
+     * Square root rounded up to nearest power of two.
+     *
+     * @param x The input value, which must be non-negative.
+     *
+     * @return Square root of <code>x</code> rounded up to nearest power of two.
+     */
+
+    public static int sqrt4up(int x)
+    {
+        assert (x >= 0);
+
+        if (x == 0)
+        {
+            return 0;
+        }
+
+        int r = 1, p = 1;
+
+        while (p < x && p > 0)      // Detect overflow
+        {
+            p <<= 2;
+            r <<= 1;
+        }
+
+        return r;
+    }
+
+    /**
+     * Square root rounded up to nearest power of two.
+     *
+     * @param x The input value, which must be non-negative.
+     *
+     * @return Square root of <code>x</code> rounded up to nearest power of two.
+     */
+
+    public static long sqrt4up(long x)
+    {
+        assert (x >= 0);
+
+        if (x == 0)
+        {
+            return 0;
+        }
+
+        long r = 1, p = 1;
+
+        while (p < x && p > 0)      // Detect overflow
+        {
+            p <<= 2;
+            r <<= 1;
+        }
+
+        return r;
+    }
+
+    /**
+     * Base-2 logarithm rounded down to nearest power of two.
+     *
+     * @param x The input value, which must be positive.
+     *
+     * @return <code>log<sub>2</sub>(x)</code> rounded down to nearest integer.
+     */
+
+    public static int log2down(int x)
+    {
+        assert (x > 0);
+
+        return 31 - Integer.numberOfLeadingZeros(x);
+    }
+
+    /**
+     * Base-2 logarithm rounded down to nearest power of two.
+     *
+     * @param x The input value, which must be positive.
+     *
+     * @return <code>log<sub>2</sub>(x)</code> rounded down to nearest integer.
+     */
+
+    public static int log2down(long x)
+    {
+        assert (x > 0);
+
+        return 63 - Long.numberOfLeadingZeros(x);
+    }
+
+    /**
+     * Base-2 logarithm rounded up to nearest power of two.
+     *
+     * @param x The input value, which must be positive.
+     *
+     * @return <code>log<sub>2</sub>(x)</code> rounded up to nearest integer.
+     */
+
+    public static int log2up(int x)
+    {
+        assert (x > 0);
+
+        return log2down(x) + (x == (x & -x) ? 0 : 1);
+    }
+
+    /**
+     * Base-2 logarithm rounded up to nearest power of two.
+     *
+     * @param x The input value, which must be positive.
+     *
+     * @return <code>log<sub>2</sub>(x)</code> rounded up to nearest integer.
+     */
+
+    public static int log2up(long x)
+    {
+        assert (x > 0);
+
+        return log2down(x) + (x == (x & -x) ? 0 : 1);
+    }
+
+    /**
+     * Returns the argument <code>y</code> limited to <code>Apfloat.INFINITE</code>.
+     * In case <code>x</code> is <code>Apfloat.INFINITE</code>, then <code>Apfloat.INFINITE</code>
+     * is returned, otherwise <code>y</code>. Also if <code>y</code> is negative or zero, this is
+     * treated as a case of overflow, and <code>Apfloat.INFINITE</code> is returned. The
+     * return value is thus always positive.
+     *
+     * @param x The argument that is tested to be <code>Apfloat.INFINITE</code>.
+     * @param y The argument that is returned if <code>x</code> is not <code>Apfloat.INFINITE</code>.
+     *
+     * @return <code>(x == Apfloat.INFINITE || y &lt;= 0 ? Apfloat.INFINITE : y)</code>
+     */
+
+    public static long ifFinite(long x, long y)
+    {
+        return (x == Apfloat.INFINITE || y <= 0 ? Apfloat.INFINITE : y);
+    }
+}
Index: src/main/java/org/apfloat/spi/package-info.java
===================================================================
--- src/main/java/org/apfloat/spi/package-info.java	(revision 0)
+++ src/main/java/org/apfloat/spi/package-info.java	(revision 0)
@@ -0,0 +1,115 @@
+/**
+The apfloat Service Provider Interface (SPI).<p>
+
+The apfloat API is a high-level API that defines algorithms on the level of
+e.g. the Newton iteration for the inverse of a number. Behind this high-level
+API there is a lot of low-level functionality that makes all the arbitrary
+precision arithmetic happen. The digits of a large number are stored in an
+array of <code>int</code>s, for example. In fact, an {@link org.apfloat.Apfloat}
+is structurally just a pointer to an {@link org.apfloat.spi.ApfloatImpl}, and
+most of the functionality of the Apfloat class is simply delegated to the
+underlying ApfloatImpl.<p>
+
+The apfloat SPI defines the general interface for the low-level things that
+must happen behind the scenes of the high-level API. An actual implementation
+of the SPI can be optimized for different things, for example:
+<ul>
+  <li>Size of numbers: different algorithms are efficient for numbers with
+      with 1000 or 1000000 digits. This applies both to the actual storage
+      method of the data, and the mathematical algorithms used for e.g.
+      multiplying numbers.</li>
+  <li>Memory consumption vs. performance: different types of Fast Fourier
+      Transform (FFT) based algorithms can be used to find a suitable trade-off
+      between memory consumption and performance.</li>
+  <li>Hardware architecture: 32-bit and 64-bit systems handle <code>int</code>
+      and <code>long</code> type elements correspondingly most efficiently, for
+      example. Some systems perform floating-point operations (with
+      <code>float</code> or <code>double</code> type elements) faster than
+      integer operations (<code>int</code> or <code>long</code>).</li>
+  <li>Complexity: a more complex implementation may be optimized for different
+      cases, however more code will take more space and use more memory. This
+      may be a concern on some systems (e.g. mobile devices).</li>
+</ul>
+
+A Service Provider is only required to implement the {@link org.apfloat.spi.BuilderFactory}
+interface, and actually only the {@link org.apfloat.spi.BuilderFactory#getApfloatBuilder()}
+method in this interface. All apfloat implementations ({@link org.apfloat.spi.ApfloatImpl})
+are created through the {@link org.apfloat.spi.ApfloatBuilder} interface's
+methods. The rest of the interfaces in the SPI exist only for the convenience
+of the default apfloat SPI implementations ({@link org.apfloat.internal}).<p>
+
+The apfloat SPI suggests the usage of various patterns, as encouraged by the
+specification of all the interfaces in the SPI. These patterns include:
+
+<ul>
+  <li>Abstract factory pattern, for getting instances of the various builders,
+      as well as other types of components built by the different builders
+      ({@link org.apfloat.spi.ApfloatBuilder}, {@link org.apfloat.spi.DataStorageBuilder},
+      {@link org.apfloat.spi.ConvolutionBuilder}, {@link org.apfloat.spi.NTTBuilder}).</li>
+  <li>Factory method pattern; obviously the abstract factories use factory
+      methods to create instances of objects.</li>
+  <li>Builder pattern: an {@link org.apfloat.spi.ApfloatImpl} needs various
+      "parts" for its structural construction ({@link org.apfloat.spi.DataStorage})
+      as well as its behavior ({@link org.apfloat.spi.ConvolutionStrategy}). Builders
+      are used to build the different sub-parts needed, and the ApfloatImpl
+      itself only knows the high-level algorithm for how the parts are used and
+      related. The construction of the sub-part details is left for the
+      builders, and the ApfloatImpl accesses the parts only via an interface.</li>
+  <li>Strategy pattern: for multiplying numbers, completely different algorithms
+      are optimal, depending on the size of the numbers. The
+      {@link org.apfloat.spi.ConvolutionStrategy} defines different convolution
+      algorithms to be used in the multiplication. For very large numbers, a
+      transform-based convolution can be used, and even a different transform
+      strategy can be specified via the {@link org.apfloat.spi.NTTStrategy}
+      interface.</li>
+  <li>Iterators are used for iterating through {@link org.apfloat.spi.DataStorage}
+      elements in a highly flexible manner. The base class is
+      {@link org.apfloat.spi.DataStorage.Iterator}. For example, a data storage that
+      uses a simple array to store the entire data set in memory can return
+      a simple iterator that goes through the array element by element. In
+      comparison, a data storage that stores the data in a disk file, can have
+      an iterator that reads blocks of data from the file to a memory array,
+      and then iterates through the array, one block at a time.</li>
+  <li>Singleton pattern, assumed to be used in the {@link org.apfloat.spi.BuilderFactory}
+      class, as there should be no need to have more than one instance of each
+      builder class. Also the BuilderFactory instance itself is a singleton,
+      within an {@link org.apfloat.ApfloatContext}.</li>
+  <li>Bridge pattern: the SPI itself is the bridge pattern. An {@link org.apfloat.Apfloat}
+      provides a simple high-level programming interface and the complex technical
+      implementation details are delegated to an {@link org.apfloat.spi.ApfloatImpl}.
+      The Apfloat class can be subclassed for additional functionality, and independent
+      of that, different subclasses of an ApfloatImpl can be used to optimize the
+      implementation.</li>
+</ul>
+
+Associations of the SPI classes are shown in a class diagram format below:<p>
+
+<img src="doc-files/spi-classes.gif" alt="Class diagram"><p>
+
+The class implementing {@link org.apfloat.spi.BuilderFactory} that is used in
+creating apfloat implementations is defined in the {@link org.apfloat.ApfloatContext}.
+You can set the BuilderFactory instance programmatically by calling
+{@link org.apfloat.ApfloatContext#setBuilderFactory(BuilderFactory)},
+for example:
+
+<pre>
+BuilderFactory builderFactory = new MyBuilderFactory();
+ApfloatContext.getContext().setBuilderFactory(builderFactory);
+</pre>
+
+It's a lot easier to specify this to happen automatically whenever your program
+starts. To do this just specify the BuilderFactory class name in the
+<code>apfloat.properties</code> file (or the apfloat ResourceBundle if you use one).
+For example, the <code>apfloat.properties</code> file might contain the line:
+
+<pre>
+builderFactory=org.mycompany.MyBuilderFactory
+</pre>
+
+For more details about configuring the apfloat BuilderFactory, see the
+documentation for {@link org.apfloat.ApfloatContext}.
+
+@see org.apfloat.internal
+*/
+
+package org.apfloat.spi;
Index: src/main/java/org/overturetool/vdmj/Settings.java
===================================================================
--- src/main/java/org/overturetool/vdmj/Settings.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/Settings.java	(working copy)
@@ -23,6 +23,9 @@
 
 package org.overturetool.vdmj;
 
+import java.math.MathContext;
+import java.math.RoundingMode;
+
 import org.overturetool.vdmj.lex.Dialect;
 
 /**
@@ -39,6 +42,7 @@
 	public static boolean dynamictypechecks = true;
 	public static boolean measureChecks = true;
 	public static boolean exceptions = false;
+	public static MathContext precision = new MathContext(100, RoundingMode.HALF_UP);
 
 	public static boolean usingDBGP = false;
 	public static boolean usingCmdLine = false;
Index: src/main/java/org/overturetool/vdmj/VDMJ.java
===================================================================
--- src/main/java/org/overturetool/vdmj/VDMJ.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/VDMJ.java	(working copy)
@@ -24,6 +24,8 @@
 package org.overturetool.vdmj;
 
 import java.io.File;
+import java.math.MathContext;
+import java.math.RoundingMode;
 import java.net.JarURLConnection;
 import java.net.URL;
 import java.nio.charset.Charset;
@@ -280,6 +282,26 @@
     				usage("-path option requires a directory");
     			}
     		}
+    		else if (arg.equals("-precision"))
+    		{
+    			if (i.hasNext())
+    			{
+       				int precision = Integer.parseInt(i.next());
+       				
+       				if (precision < 10)
+       				{
+       					usage("Precision argument must be >= 10");
+       				}
+       				else
+       				{
+       					Settings.precision = new MathContext(precision, RoundingMode.HALF_UP);
+       				}
+    			}
+    			else
+    			{
+    				usage("-precision option requires a value");
+    			}
+    		}
     		else if (arg.startsWith("-"))
     		{
     			usage("Unknown option " + arg);
@@ -476,6 +498,7 @@
 		System.err.println("-measures: disable recursive measure checking");
 		System.err.println("-log <filename>: enable real-time event logging");
 		System.err.println("-remote <class>: enable remote control");
+		System.err.println("-precision <n>: set real number precision to n places");
 
 		System.exit(1);
 	}
Index: src/main/java/org/overturetool/vdmj/commands/CommandReader.java
===================================================================
--- src/main/java/org/overturetool/vdmj/commands/CommandReader.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/commands/CommandReader.java	(working copy)
@@ -31,6 +31,8 @@
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.io.UnsupportedEncodingException;
+import java.math.MathContext;
+import java.math.RoundingMode;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -324,6 +326,10 @@
 				{
 					carryOn = doFilter(line);
 				}
+				else if (line.startsWith("precision"))
+				{
+					carryOn = doPrecision(line);
+				}
 				else
 				{
 					println("Bad command. Try 'help'");
@@ -539,7 +545,36 @@
 
 		return true;
 	}
+	
+	protected boolean doPrecision(String line)
+	{
+		String parts[] = line.split("\\s+");
 
+		switch (parts.length)
+		{
+		case 2:
+			int scale = Integer.parseInt(parts[1]);
+			
+			if (scale < 10)
+			{
+				println("Precision must be >10");
+				return true;
+			}
+			
+			Settings.precision = new MathContext(scale, RoundingMode.HALF_UP);
+			println("Decimal precision = " + Settings.precision.getPrecision());
+			return true;
+			
+		case 1:
+			println("Decimal precision = " + Settings.precision.getPrecision());
+			return true;
+			
+		default:
+			println("Usage: precision <#decimal places>");
+			return true;
+		}
+	}
+
 	private void isEnabled(String name, boolean flag)
 	{
 		print(name);
@@ -1333,6 +1368,7 @@
 		println("word [<files>] - generate Word HTML line coverage files");
 		println("files - list files in the current specification");
 		println("set [<pre|post|inv|dtc|measures> <on|off>] - set runtime checks");
+		println("precision [<#decimal places>] - set real number precision");
 		println("reload - reload the current specification files");
 		println("load <files or dirs> - replace current loaded specification files");
 		println("save [<files>] - generate Word/ODF source extract files");
Index: src/main/java/org/overturetool/vdmj/definitions/CPUClassDefinition.java
===================================================================
--- src/main/java/org/overturetool/vdmj/definitions/CPUClassDefinition.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/definitions/CPUClassDefinition.java	(working copy)
@@ -30,7 +30,6 @@
 import org.overturetool.vdmj.lex.LexNameToken;
 import org.overturetool.vdmj.lex.LexTokenReader;
 import org.overturetool.vdmj.runtime.Context;
-import org.overturetool.vdmj.runtime.ContextException;
 import org.overturetool.vdmj.runtime.ObjectContext;
 import org.overturetool.vdmj.runtime.ValueException;
 import org.overturetool.vdmj.syntax.DefinitionReader;
@@ -117,7 +116,7 @@
     		SeqValue opname = (SeqValue)octxt.lookup(varName("opname"));
     		NaturalValue priority = (NaturalValue)octxt.check(varName("priority"));
 
-    		cpu.setPriority(opname.stringValue(ctxt), priority.intValue(ctxt));
+    		cpu.setPriority(opname.stringValue(ctxt), priority.intValue(ctxt).longValue());
    			return new VoidValue();
 		}
 		catch (Exception e)
Index: src/main/java/org/overturetool/vdmj/definitions/MutexSyncDefinition.java
===================================================================
--- src/main/java/org/overturetool/vdmj/definitions/MutexSyncDefinition.java	(revision 500)
+++ src/main/java/org/overturetool/vdmj/definitions/MutexSyncDefinition.java	(working copy)
@@ -23,6 +23,8 @@
 
 package org.overturetool.vdmj.definitions;
 
+import java.math.BigInteger;
+
 import org.overturetool.vdmj.expressions.EqualsExpression;
 import org.overturetool.vdmj.expressions.Expression;
 import org.overturetool.vdmj.expressions.HistoryExpression;
@@ -190,6 +192,6 @@
 		return new EqualsExpression(
 			new HistoryExpression(location, Token.ACTIVE, list),
     		new LexKeywordToken(Token.EQUALS, location),
-    		new IntegerLiteralExpression(new LexIntegerToken(0, location)));
+    		new IntegerLiteralExpression(new LexIntegerToken(BigInteger.ZERO, location)));
 	}
 }
Index: src/main/java/org/overturetool/vdmj/expressions/AbsoluteExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/AbsoluteExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/AbsoluteExpression.java	(working copy)
@@ -89,7 +89,16 @@
 
 		try
 		{
-			return NumericValue.valueOf(Math.abs(exp.eval(ctxt).realValue(ctxt)), ctxt);
+			Value arg = exp.eval(ctxt);
+			
+			if (NumericValue.isInteger(arg))
+			{
+				return NumericValue.valueOf(arg.intValue(ctxt).abs(), ctxt);
+			}
+			else
+			{
+				return NumericValue.valueOf(arg.realValue(ctxt).abs(), ctxt);
+			}
 		}
 		catch (ValueException e)
 		{
Index: src/main/java/org/overturetool/vdmj/expressions/DivExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/DivExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/DivExpression.java	(working copy)
@@ -23,6 +23,11 @@
 
 package org.overturetool.vdmj.expressions;
 
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.math.RoundingMode;
+
+import org.overturetool.vdmj.Settings;
 import org.overturetool.vdmj.lex.LexToken;
 import org.overturetool.vdmj.pog.NonZeroObligation;
 import org.overturetool.vdmj.pog.POContextStack;
@@ -61,50 +66,24 @@
 
 		try
 		{
-    		double lv = left.eval(ctxt).intValue(ctxt);
-    		double rv = right.eval(ctxt).intValue(ctxt);
+    		BigInteger lv = left.eval(ctxt).intValue(ctxt);
+    		BigInteger rv = right.eval(ctxt).intValue(ctxt);
 
-    		if (rv == 0)
+    		if (rv.equals(BigInteger.ZERO))
     		{
     			throw new ValueException(4134, "Infinite or NaN trouble", ctxt);
     		}
 
-    		return NumericValue.valueOf(div(lv, rv), ctxt);
+    		return NumericValue.valueOf(lv.divide(rv), ctxt);
         }
         catch (ValueException e)
         {
         	return abort(e);
         }
-	}
-
-	static public long div(double lv, double rv)
-	{
-		/*
-		 * There is often confusion on how integer division, remainder and modulus
-		 * work on negative numbers. In fact, there are two valid answers to -14 div
-		 * 3: either (the intuitive) -4 as in the Toolbox, or -5 as in e.g. Standard
-		 * ML [Paulson91]. It is therefore appropriate to explain these operations in
-		 * some detail.
-		 *
-		 * Integer division is defined using floor and real number division:
-		 *
-		 *		x/y < 0:	x div y = -floor(abs(-x/y))
-		 *		x/y >= 0:	x div y = floor(abs(x/y))
-		 *
-		 * Note that the order of floor and abs on the right-hand side makes a difference,
-		 * the above example would yield -5 if we changed the order. This is
-		 * because floor always yields a smaller (or equal) integer, e.g. floor (14/3) is
-		 * 4 while floor (-14/3) is -5.
-		 */
-
-		if (lv/rv < 0)
+		catch (Exception e)
 		{
-			return (long)-Math.floor(Math.abs(lv/rv));
+			return abort(new ValueException(4064, e.getMessage(), ctxt));
 		}
-		else
-		{
-			return (long)Math.floor(Math.abs(-lv/rv));
-		}
 	}
 
 	@Override
Index: src/main/java/org/overturetool/vdmj/expressions/DivideExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/DivideExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/DivideExpression.java	(working copy)
@@ -23,6 +23,10 @@
 
 package org.overturetool.vdmj.expressions;
 
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
+import org.overturetool.vdmj.Settings;
 import org.overturetool.vdmj.lex.LexToken;
 import org.overturetool.vdmj.pog.NonZeroObligation;
 import org.overturetool.vdmj.pog.POContextStack;
@@ -61,15 +65,34 @@
 
 		try
 		{
-    		double lv = left.eval(ctxt).realValue(ctxt);
-    		double rv = right.eval(ctxt).realValue(ctxt);
+    		Value l = left.eval(ctxt);
+    		Value r = right.eval(ctxt);
 
-    		return NumericValue.valueOf(lv / rv, ctxt);
+			if (NumericValue.areIntegers(l, r))
+			{
+				BigInteger lv = l.intValue(ctxt);
+				BigInteger rv = r.intValue(ctxt);
+				BigInteger[] result = lv.divideAndRemainder(rv);
+				
+				if (result[1].equals(BigInteger.ZERO))	// Else do BigDecimal
+				{
+					return NumericValue.valueOf(result[0], ctxt);
+				}
+			}
+
+			BigDecimal lv = l.realValue(ctxt);
+    		BigDecimal rv = r.realValue(ctxt);
+
+    		return NumericValue.valueOf(lv.divide(rv, Settings.precision), ctxt);
         }
         catch (ValueException e)
         {
         	return abort(e);
         }
+		catch (Exception e)
+		{
+			return abort(new ValueException(4134, e.getMessage(), ctxt));
+		}
 	}
 
 	@Override
Index: src/main/java/org/overturetool/vdmj/expressions/FieldNumberExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/FieldNumberExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/FieldNumberExpression.java	(working copy)
@@ -73,7 +73,7 @@
 		}
 
 		ProductType product = type.getProduct();
-		long fn = field.value;
+		long fn = field.value.longValue();
 
 		if (fn > product.types.size() || fn < 1)
 		{
@@ -93,7 +93,7 @@
 		try
 		{
     		ValueList fields = tuple.eval(ctxt).tupleValue(ctxt);
-    		Value r = fields.get((int)field.value - 1);
+    		Value r = fields.get(field.value.intValue() - 1);
 
     		if (r == null)
     		{
@@ -132,7 +132,7 @@
 				{
 					ProductType pt = t.getProduct();
 
-					if (pt.types.size() < field.value)
+					if (pt.types.size() < field.value.intValue())
 					{
 						list.add(new TupleSelectObligation(this, pt, ctxt));
 					}
Index: src/main/java/org/overturetool/vdmj/expressions/FloorExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/FloorExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/FloorExpression.java	(working copy)
@@ -23,6 +23,8 @@
 
 package org.overturetool.vdmj.expressions;
 
+import java.math.RoundingMode;
+
 import org.overturetool.vdmj.lex.LexLocation;
 import org.overturetool.vdmj.runtime.Context;
 import org.overturetool.vdmj.runtime.ValueException;
@@ -67,7 +69,16 @@
 
 		try
 		{
-			return NumericValue.valueOf(Math.floor(exp.eval(ctxt).realValue(ctxt)), ctxt);
+			Value v = exp.eval(ctxt);
+			
+			if (NumericValue.isInteger(v))
+			{
+				return v;
+			}
+			else
+			{
+				return NumericValue.valueOf(v.realValue(ctxt).setScale(0, RoundingMode.FLOOR), ctxt);
+			}
         }
         catch (ValueException e)
         {
Index: src/main/java/org/overturetool/vdmj/expressions/GreaterEqualExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/GreaterEqualExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/GreaterEqualExpression.java	(working copy)
@@ -61,7 +61,7 @@
 
 		try
 		{
-			return new BooleanValue(lv.realValue(ctxt) >= rv.realValue(ctxt));
+			return new BooleanValue(lv.realValue(ctxt).compareTo(rv.realValue(ctxt)) >= 0);
         }
         catch (ValueException e)
         {
Index: src/main/java/org/overturetool/vdmj/expressions/GreaterExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/GreaterExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/GreaterExpression.java	(working copy)
@@ -61,7 +61,7 @@
 
 		try
 		{
-			return new BooleanValue(lv.realValue(ctxt) > rv.realValue(ctxt));
+			return new BooleanValue(lv.realValue(ctxt).compareTo(rv.realValue(ctxt)) > 0);
         }
         catch (ValueException e)
         {
Index: src/main/java/org/overturetool/vdmj/expressions/IntegerLiteralExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/IntegerLiteralExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/IntegerLiteralExpression.java	(working copy)
@@ -23,6 +23,8 @@
 
 package org.overturetool.vdmj.expressions;
 
+import java.math.BigInteger;
+
 import org.overturetool.vdmj.lex.LexIntegerToken;
 import org.overturetool.vdmj.runtime.Context;
 import org.overturetool.vdmj.runtime.ValueException;
@@ -58,11 +60,11 @@
 	{
 		Type result = null;
 		
-		if (value.value < 0)
+		if (value.value.compareTo(BigInteger.ZERO) < 0)
 		{
 			result = new IntegerType(location);
 		}
-		else if (value.value == 0)
+		else if (value.value.equals(BigInteger.ZERO))
 		{
 			result = new NaturalType(location);
 		}
Index: src/main/java/org/overturetool/vdmj/expressions/LessEqualExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/LessEqualExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/LessEqualExpression.java	(working copy)
@@ -61,7 +61,7 @@
 
 		try
 		{
-			return new BooleanValue(lv.realValue(ctxt) <= rv.realValue(ctxt));
+			return new BooleanValue(lv.realValue(ctxt).compareTo(rv.realValue(ctxt)) <= 0);
 		}
         catch (ValueException e)
         {
Index: src/main/java/org/overturetool/vdmj/expressions/LessExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/LessExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/LessExpression.java	(working copy)
@@ -61,7 +61,7 @@
 
 		try
 		{
-			return new BooleanValue(lv.realValue(ctxt) < rv.realValue(ctxt));
+			return new BooleanValue(lv.realValue(ctxt).compareTo(rv.realValue(ctxt)) < 0);
 		}
         catch (ValueException e)
         {
Index: src/main/java/org/overturetool/vdmj/expressions/ModExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/ModExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/ModExpression.java	(working copy)
@@ -23,6 +23,8 @@
 
 package org.overturetool.vdmj.expressions;
 
+import java.math.BigInteger;
+
 import org.overturetool.vdmj.lex.LexToken;
 import org.overturetool.vdmj.runtime.Context;
 import org.overturetool.vdmj.runtime.ValueException;
@@ -74,20 +76,31 @@
 			 * is positive.
 			 */
 
-    		double lv = left.eval(ctxt).intValue(ctxt);
-    		double rv = right.eval(ctxt).intValue(ctxt);
+    		BigInteger lv = left.eval(ctxt).intValue(ctxt);
+    		BigInteger rv = right.eval(ctxt).intValue(ctxt);
 
-    		if (rv == 0)
+    		if (rv.equals(BigInteger.ZERO))
     		{
     			throw new ValueException(4134, "Infinite or NaN trouble", ctxt);
     		}
-
-    		return NumericValue.valueOf(lv - rv * (long)Math.floor(lv/rv), ctxt);
+    		
+    		if (rv.signum() < 0)
+    		{
+    			return NumericValue.valueOf(lv.mod(rv.abs()).subtract(rv.abs()), ctxt);
+    		}
+    		else
+    		{
+    			return NumericValue.valueOf(lv.mod(rv), ctxt);
+    		}
 		}
 		catch (ValueException e)
 		{
 			return abort(e);
 		}
+		catch (Exception e)
+		{
+			return abort(new ValueException(4064, e.getMessage(), ctxt));
+		}
 	}
 
 	@Override
Index: src/main/java/org/overturetool/vdmj/expressions/PlusExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/PlusExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/PlusExpression.java	(working copy)
@@ -23,6 +23,10 @@
 
 package org.overturetool.vdmj.expressions;
 
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
+import org.overturetool.vdmj.Settings;
 import org.overturetool.vdmj.lex.LexToken;
 import org.overturetool.vdmj.runtime.Context;
 import org.overturetool.vdmj.runtime.ValueException;
@@ -98,10 +102,21 @@
 
 		try
 		{
-    		double lv = left.eval(ctxt).realValue(ctxt);
-    		double rv = right.eval(ctxt).realValue(ctxt);
+    		Value l = left.eval(ctxt);
+    		Value r = right.eval(ctxt);
 
-    		return NumericValue.valueOf(lv + rv, ctxt);
+			if (NumericValue.areIntegers(l, r))
+			{
+				BigInteger lv = l.intValue(ctxt);
+				BigInteger rv = r.intValue(ctxt);
+				return NumericValue.valueOf(lv.add(rv), ctxt);
+			}
+			else
+			{
+				BigDecimal lv = l.realValue(ctxt);
+				BigDecimal rv = r.realValue(ctxt);
+	    		return NumericValue.valueOf(lv.add(rv, Settings.precision), ctxt);
+			}
     	}
     	catch (ValueException e)
     	{
Index: src/main/java/org/overturetool/vdmj/expressions/PlusPlusExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/PlusPlusExpression.java	(revision 483)
+++ src/main/java/org/overturetool/vdmj/expressions/PlusPlusExpression.java	(working copy)
@@ -163,7 +163,7 @@
 
     			for (Value k: map.keySet())
     			{
-					int iv = (int)k.intValue(ctxt);
+					int iv = k.intValue(ctxt).intValue();
 
 					if (iv < 1 || iv > seq.size())
 					{
Index: src/main/java/org/overturetool/vdmj/expressions/RealLiteralExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/RealLiteralExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/RealLiteralExpression.java	(working copy)
@@ -23,6 +23,9 @@
 
 package org.overturetool.vdmj.expressions;
 
+import java.math.BigDecimal;
+import java.math.RoundingMode;
+
 import org.overturetool.vdmj.lex.LexRealToken;
 import org.overturetool.vdmj.runtime.Context;
 import org.overturetool.vdmj.runtime.ValueException;
@@ -59,13 +62,13 @@
 	{
 		Type result;
 		
-		if (Math.round(value.value) == value.value)
+		if (value.value.setScale(0, RoundingMode.HALF_UP).compareTo(value.value) == 0)
 		{
-    		if (value.value < 0)
+    		if (value.value.compareTo(BigDecimal.ZERO) < 0)
     		{
     			result = new IntegerType(location);
     		}
-    		else if (value.value == 0)
+    		else if (value.value.equals(BigDecimal.ZERO))
     		{
     			result = new NaturalType(location);
     		}
Index: src/main/java/org/overturetool/vdmj/expressions/RemExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/RemExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/RemExpression.java	(working copy)
@@ -23,6 +23,8 @@
 
 package org.overturetool.vdmj.expressions;
 
+import java.math.BigInteger;
+
 import org.overturetool.vdmj.lex.LexToken;
 import org.overturetool.vdmj.runtime.Context;
 import org.overturetool.vdmj.runtime.ValueException;
@@ -74,15 +76,15 @@
 			 * is positive.
 			 */
 
-    		double lv = left.eval(ctxt).intValue(ctxt);
-    		double rv = right.eval(ctxt).intValue(ctxt);
+    		BigInteger lv = left.eval(ctxt).intValue(ctxt);
+    		BigInteger rv = right.eval(ctxt).intValue(ctxt);
 
-    		if (rv == 0)
+    		if (rv.equals(BigInteger.ZERO))
     		{
     			throw new ValueException(4134, "Infinite or NaN trouble", ctxt);
     		}
-
-    		return NumericValue.valueOf(lv - rv * DivExpression.div(lv, rv), ctxt);
+    		
+    		return NumericValue.valueOf(lv.remainder(rv), ctxt);
 		}
 		catch (ValueException e)
 		{
Index: src/main/java/org/overturetool/vdmj/expressions/SetRangeExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/SetRangeExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/SetRangeExpression.java	(working copy)
@@ -23,6 +23,9 @@
 
 package org.overturetool.vdmj.expressions;
 
+import java.math.BigInteger;
+import java.math.RoundingMode;
+
 import org.overturetool.vdmj.lex.LexLocation;
 import org.overturetool.vdmj.pog.POContextStack;
 import org.overturetool.vdmj.pog.ProofObligationList;
@@ -31,7 +34,6 @@
 import org.overturetool.vdmj.typechecker.Environment;
 import org.overturetool.vdmj.typechecker.NameScope;
 import org.overturetool.vdmj.types.IntegerType;
-import org.overturetool.vdmj.types.NaturalType;
 import org.overturetool.vdmj.types.SetType;
 import org.overturetool.vdmj.types.Type;
 import org.overturetool.vdmj.types.TypeList;
@@ -94,13 +96,14 @@
 
 		try
 		{
-    		long from = (long)Math.ceil(first.eval(ctxt).realValue(ctxt));
-    		long to = (long)Math.floor(last.eval(ctxt).realValue(ctxt));
+    		BigInteger from = first.eval(ctxt).realValue(ctxt).setScale(0, RoundingMode.CEILING).toBigInteger();
+    		BigInteger to = last.eval(ctxt).realValue(ctxt).setScale(0, RoundingMode.FLOOR).toBigInteger();
     		ValueSet set = new ValueSet();
 
-    		for (long i=from; i<= to; i++)
+    		while (from.compareTo(to) <= 0)
     		{
-    			set.add(new IntegerValue(i));
+    			set.add(new IntegerValue(from));
+    			from = from.add(BigInteger.ONE);
     		}
 
     		return new SetValue(set);
Index: src/main/java/org/overturetool/vdmj/expressions/StarStarExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/StarStarExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/StarStarExpression.java	(working copy)
@@ -23,6 +23,12 @@
 
 package org.overturetool.vdmj.expressions;
 
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
+import org.apfloat.Apfloat;
+import org.apfloat.ApfloatMath;
+import org.overturetool.vdmj.Settings;
 import org.overturetool.vdmj.lex.LexToken;
 import org.overturetool.vdmj.pog.FuncIterationObligation;
 import org.overturetool.vdmj.pog.MapIterationObligation;
@@ -46,6 +52,8 @@
 {
 	private static final long serialVersionUID = 1L;
 
+	private static final BigInteger BIG_MAX_INT = new BigInteger(Integer.toString(Integer.MAX_VALUE));
+	
 	public StarStarExpression(Expression left, LexToken op, Expression right)
 	{
 		super(left, op, right);
@@ -101,7 +109,7 @@
     		if (lv instanceof MapValue)
     		{
     			ValueMap map = lv.mapValue(ctxt);
-    			long n = rv.intValue(ctxt);
+    			long n = rv.intValue(ctxt).longValue();
     			ValueMap result = new ValueMap();
 
     			for (Value k: map.keySet())
@@ -131,14 +139,23 @@
     		else if (lv instanceof FunctionValue)
     		{
     			return new IterFunctionValue(
-    				lv.functionValue(ctxt), rv.intValue(ctxt));
+    				lv.functionValue(ctxt), rv.intValue(ctxt).longValue());
     		}
     		else if (lv instanceof NumericValue)
     		{
-    			double ld = lv.realValue(ctxt);
-    			double rd = rv.realValue(ctxt);
+    			if (NumericValue.areIntegers(lv, rv))
+    			{
+    				if (rv.intValue(ctxt).compareTo(BIG_MAX_INT) < 0)
+    				{
+    					return NumericValue.valueOf(lv.intValue(ctxt).pow(rv.intValue(ctxt).intValue()), ctxt);
+    				}
+    			}
 
-    			return NumericValue.valueOf(Math.pow(ld, rd), ctxt);
+    			Apfloat ld = new Apfloat(lv.realValue(ctxt));
+    			Apfloat rd = new Apfloat(rv.realValue(ctxt));
+    			Apfloat result = ApfloatMath.pow(ld, rd);
+
+    			return NumericValue.valueOf(new BigDecimal(result.toString(), Settings.precision), ctxt);
     		}
 
     		return abort(4031,
Index: src/main/java/org/overturetool/vdmj/expressions/SubseqExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/SubseqExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/SubseqExpression.java	(working copy)
@@ -23,6 +23,8 @@
 
 package org.overturetool.vdmj.expressions;
 
+import java.math.RoundingMode;
+
 import org.overturetool.vdmj.lex.LexNameList;
 import org.overturetool.vdmj.pog.POContextStack;
 import org.overturetool.vdmj.pog.ProofObligationList;
@@ -93,10 +95,8 @@
 		try
 		{
     		ValueList list = seq.eval(ctxt).seqValue(ctxt);
-    		double fr = from.eval(ctxt).realValue(ctxt);
-    		double tr = to.eval(ctxt).realValue(ctxt);
-    		int fi = (int)Math.ceil(fr);
-    		int ti = (int)Math.floor(tr);
+    		int fi = from.eval(ctxt).realValue(ctxt).setScale(0, RoundingMode.CEILING).intValue();
+    		int ti = to.eval(ctxt).realValue(ctxt).setScale(0, RoundingMode.FLOOR).intValue();
 
     		if (fi < 1)
     		{
Index: src/main/java/org/overturetool/vdmj/expressions/SubtractExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/SubtractExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/SubtractExpression.java	(working copy)
@@ -23,6 +23,10 @@
 
 package org.overturetool.vdmj.expressions;
 
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
+import org.overturetool.vdmj.Settings;
 import org.overturetool.vdmj.lex.LexToken;
 import org.overturetool.vdmj.runtime.Context;
 import org.overturetool.vdmj.runtime.ValueException;
@@ -67,10 +71,21 @@
 
 		try
 		{
-    		double lv = left.eval(ctxt).realValue(ctxt);
-    		double rv = right.eval(ctxt).realValue(ctxt);
+    		Value l = left.eval(ctxt);
+    		Value r = right.eval(ctxt);
 
-    		return NumericValue.valueOf(lv - rv, ctxt);
+			if (NumericValue.areIntegers(l, r))
+			{
+				BigInteger lv = l.intValue(ctxt);
+				BigInteger rv = r.intValue(ctxt);
+				return NumericValue.valueOf(lv.subtract(rv), ctxt);
+			}
+			else
+			{
+        		BigDecimal lv = l.realValue(ctxt);
+        		BigDecimal rv = r.realValue(ctxt);
+        		return NumericValue.valueOf(lv.subtract(rv, Settings.precision), ctxt);
+			}
 		}
 		catch (ValueException e)
 		{
Index: src/main/java/org/overturetool/vdmj/expressions/TimesExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/TimesExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/TimesExpression.java	(working copy)
@@ -23,6 +23,10 @@
 
 package org.overturetool.vdmj.expressions;
 
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
+import org.overturetool.vdmj.Settings;
 import org.overturetool.vdmj.lex.LexToken;
 import org.overturetool.vdmj.runtime.Context;
 import org.overturetool.vdmj.runtime.ValueException;
@@ -93,10 +97,21 @@
 
 		try
 		{
-    		double lv = left.eval(ctxt).realValue(ctxt);
-    		double rv = right.eval(ctxt).realValue(ctxt);
+    		Value l = left.eval(ctxt);
+    		Value r = right.eval(ctxt);
 
-    		return NumericValue.valueOf(lv * rv, ctxt);
+			if (NumericValue.areIntegers(l, r))
+			{
+				BigInteger lv = l.intValue(ctxt);
+				BigInteger rv = r.intValue(ctxt);
+				return NumericValue.valueOf(lv.multiply(rv), ctxt);
+			}
+			else
+			{
+				BigDecimal lv = l.realValue(ctxt);
+				BigDecimal rv = r.realValue(ctxt);
+				return NumericValue.valueOf(lv.multiply(rv, Settings.precision), ctxt);
+			}
 		}
 		catch (ValueException e)
 		{
Index: src/main/java/org/overturetool/vdmj/expressions/UnaryMinusExpression.java
===================================================================
--- src/main/java/org/overturetool/vdmj/expressions/UnaryMinusExpression.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/expressions/UnaryMinusExpression.java	(working copy)
@@ -74,8 +74,16 @@
 
 		try
 		{
-			double v = exp.eval(ctxt).realValue(ctxt);
-			return NumericValue.valueOf(-v, ctxt);
+			Value v = exp.eval(ctxt);
+			
+			if (NumericValue.isInteger(v))
+			{
+				return NumericValue.valueOf(v.intValue(ctxt).negate(), ctxt);
+			}
+			else
+			{
+    			return NumericValue.valueOf(v.realValue(ctxt).negate(), ctxt);
+			}
 		}
 		catch (ValueException e)
 		{
Index: src/main/java/org/overturetool/vdmj/lex/LexIntegerToken.java
===================================================================
--- src/main/java/org/overturetool/vdmj/lex/LexIntegerToken.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/lex/LexIntegerToken.java	(working copy)
@@ -23,12 +23,14 @@
 
 package org.overturetool.vdmj.lex;
 
+import java.math.BigInteger;
+
 public class LexIntegerToken extends LexToken
 {
 	private static final long serialVersionUID = 1L;
-	public final long value;
+	public final BigInteger value;
 
-	public LexIntegerToken(long value, LexLocation location)
+	public LexIntegerToken(BigInteger value, LexLocation location)
 	{
 		super(location, Token.NUMBER);
 		this.value = value;
@@ -37,12 +39,12 @@
 	public LexIntegerToken(String value, LexLocation location)
 	{
 		super(location, Token.NUMBER);
-		this.value = Long.parseLong(value);
+		this.value = new BigInteger(value);
 	}
 
 	@Override
 	public String toString()
 	{
-		return Long.toString(value);
+		return value.toString();
 	}
 }
Index: src/main/java/org/overturetool/vdmj/lex/LexRealToken.java
===================================================================
--- src/main/java/org/overturetool/vdmj/lex/LexRealToken.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/lex/LexRealToken.java	(working copy)
@@ -23,18 +23,23 @@
 
 package org.overturetool.vdmj.lex;
 
+import java.math.BigDecimal;
+
+import org.overturetool.vdmj.Settings;
+
 public class LexRealToken extends LexToken
 {
 	private static final long serialVersionUID = 1L;
-	public final double value;
+	public final BigDecimal value;
 
 	public LexRealToken(String real, LexLocation location)
 	{
 		super(location, Token.REALNUMBER);
-		value = Double.parseDouble(real);
+		value = new BigDecimal(real).setScale(
+			Settings.precision.getPrecision(), Settings.precision.getRoundingMode());
 	}
 
-	public LexRealToken(double value, LexLocation location)
+	public LexRealToken(BigDecimal value, LexLocation location)
 	{
 		super(location, Token.REALNUMBER);
 		this.value = value;
@@ -43,6 +48,6 @@
 	@Override
 	public String toString()
 	{
-		return Double.toString(value);
+		return value.stripTrailingZeros().toString();
 	}
 }
Index: src/main/java/org/overturetool/vdmj/lex/LexTokenReader.java
===================================================================
--- src/main/java/org/overturetool/vdmj/lex/LexTokenReader.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/lex/LexTokenReader.java	(working copy)
@@ -25,6 +25,7 @@
 
 import java.io.File;
 import java.io.UnsupportedEncodingException;
+import java.math.BigInteger;
 import java.util.List;
 import java.util.Stack;
 import java.util.Vector;
@@ -873,7 +874,7 @@
 				{
 					unpush();
 					rdCh();
-					String decimal = String.valueOf(Long.parseLong(rdNumber(16), 16));
+					BigInteger decimal = new BigInteger(rdNumber(16), 16);
 					last = new LexIntegerToken(decimal, location(tokline, tokpos));
 				}
 				else
Index: src/main/java/org/overturetool/vdmj/patterns/IntegerPattern.java
===================================================================
--- src/main/java/org/overturetool/vdmj/patterns/IntegerPattern.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/patterns/IntegerPattern.java	(working copy)
@@ -70,7 +70,7 @@
 
 		try
 		{
-			if (expval.intValue(ctxt) != value.value)
+			if (!expval.intValue(ctxt).equals(value.value))
 			{
 				patternFail(4111, "Integer pattern match failed");
 			}
Index: src/main/java/org/overturetool/vdmj/runtime/Breakpoint.java
===================================================================
--- src/main/java/org/overturetool/vdmj/runtime/Breakpoint.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/runtime/Breakpoint.java	(working copy)
@@ -137,7 +137,7 @@
 		}
 
 		LexIntegerToken num = (LexIntegerToken)arg;
-		return new BreakpointExpression(this, cond, num.value);
+		return new BreakpointExpression(this, cond, num.value.longValue());
 	}
 
 	@Override
Index: src/main/java/org/overturetool/vdmj/statements/CyclesStatement.java
===================================================================
--- src/main/java/org/overturetool/vdmj/statements/CyclesStatement.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/statements/CyclesStatement.java	(working copy)
@@ -98,7 +98,7 @@
 				try
 				{
 					ctxt.threadState.setAtomic(true);
-					value = cycles.eval(ctxt).intValue(ctxt);
+					value = cycles.eval(ctxt).intValue(ctxt).longValue();
 				}
 				finally
 				{
Index: src/main/java/org/overturetool/vdmj/statements/DurationStatement.java
===================================================================
--- src/main/java/org/overturetool/vdmj/statements/DurationStatement.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/statements/DurationStatement.java	(working copy)
@@ -98,7 +98,7 @@
 				try
 				{
 					ctxt.threadState.setAtomic(true);
-					step = duration.eval(ctxt).intValue(ctxt);
+					step = duration.eval(ctxt).intValue(ctxt).longValue();
 				}
 				finally
 				{
Index: src/main/java/org/overturetool/vdmj/statements/ForIndexStatement.java
===================================================================
--- src/main/java/org/overturetool/vdmj/statements/ForIndexStatement.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/statements/ForIndexStatement.java	(working copy)
@@ -23,6 +23,8 @@
 
 package org.overturetool.vdmj.statements;
 
+import java.math.BigInteger;
+
 import org.overturetool.vdmj.definitions.Definition;
 import org.overturetool.vdmj.definitions.LocalDefinition;
 import org.overturetool.vdmj.expressions.Expression;
@@ -146,19 +148,20 @@
 
 		try
 		{
-			long fval = from.eval(ctxt).intValue(ctxt);
-			long tval = to.eval(ctxt).intValue(ctxt);
-			long bval = (by == null) ? 1 : by.eval(ctxt).intValue(ctxt);
+			BigInteger fval = from.eval(ctxt).intValue(ctxt);
+			BigInteger tval = to.eval(ctxt).intValue(ctxt);
+			BigInteger bval = (by == null) ? BigInteger.ONE : by.eval(ctxt).intValue(ctxt);
 
-			if (bval == 0)
+			if (bval.equals(BigInteger.ZERO))
 			{
 				abort(4038, "Loop, from " + fval + " to " + tval + " by " + bval +
 						" will never terminate", ctxt);
 			}
 
-			for (long value = fval;
-				 (bval > 0 && value <= tval) || (bval < 0 && value >= tval);
-				 value += bval)
+			for (BigInteger value = fval;
+				 (bval.compareTo(BigInteger.ZERO) > 0 && value.compareTo(tval) <= 0) ||
+				 (bval.compareTo(BigInteger.ZERO) < 0 && value.compareTo(tval) >= 0);
+				 value = value.add(bval))
 			{
 				Context evalContext = new Context(location, "for index", ctxt);
 				evalContext.put(var, new IntegerValue(value));
Index: src/main/java/org/overturetool/vdmj/statements/MapSeqDesignator.java
===================================================================
--- src/main/java/org/overturetool/vdmj/statements/MapSeqDesignator.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/statements/MapSeqDesignator.java	(working copy)
@@ -157,7 +157,7 @@
 			else if (root.isType(SeqValue.class))
 			{
 				ValueList seq = root.seqValue(ctxt);
-				int i = (int)index.intValue(ctxt)-1;
+				int i = index.intValue(ctxt).intValue()-1;
 
 				if (!seq.inbounds(i))
 				{
Index: src/main/java/org/overturetool/vdmj/statements/ObjectApplyDesignator.java
===================================================================
--- src/main/java/org/overturetool/vdmj/statements/ObjectApplyDesignator.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/statements/ObjectApplyDesignator.java	(working copy)
@@ -145,7 +145,7 @@
 			{
 				ValueList seq = v.seqValue(ctxt);
 				Value a = args.get(0).eval(ctxt);
-				int i = (int)a.intValue(ctxt)-1;
+				int i = a.intValue(ctxt).intValue()-1;
 
 				if (!seq.inbounds(i))
 				{
Index: src/main/java/org/overturetool/vdmj/statements/PeriodicStatement.java
===================================================================
--- src/main/java/org/overturetool/vdmj/statements/PeriodicStatement.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/statements/PeriodicStatement.java	(working copy)
@@ -139,7 +139,7 @@
 			{
 				arg.location.hit();
 				argval = arg.eval(ctxt);
-				values[i] = argval.intValue(ctxt);
+				values[i] = argval.intValue(ctxt).longValue();
 
 				if (values[i] < 0)
 				{
Index: src/main/java/org/overturetool/vdmj/statements/SporadicStatement.java
===================================================================
--- src/main/java/org/overturetool/vdmj/statements/SporadicStatement.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/statements/SporadicStatement.java	(working copy)
@@ -139,7 +139,7 @@
 			{
 				arg.location.hit();
 				argval = arg.eval(ctxt);
-				values[i] = argval.intValue(ctxt);
+				values[i] = argval.intValue(ctxt).longValue();
 
 				if (values[i] < 0)
 				{
Index: src/main/java/org/overturetool/vdmj/syntax/DefinitionReader.java
===================================================================
--- src/main/java/org/overturetool/vdmj/syntax/DefinitionReader.java	(revision 500)
+++ src/main/java/org/overturetool/vdmj/syntax/DefinitionReader.java	(working copy)
@@ -1518,8 +1518,8 @@
 				}
 
 				LexIntegerToken lit = (LexIntegerToken)lastToken();
-				from = lit.value;
-				to = lit.value;
+				from = lit.value.longValue();
+				to = lit.value.longValue();
 
 				switch (nextToken().type)
 				{
@@ -1530,7 +1530,7 @@
 						}
 
 						lit = (LexIntegerToken)readToken();
-						to = lit.value;
+						to = lit.value.longValue();
 						checkFor(Token.SET_CLOSE, 2265, "Expecting '{n1, n2}' after trace definition");
 						break;
 
Index: src/main/java/org/overturetool/vdmj/types/NumericType.java
===================================================================
--- src/main/java/org/overturetool/vdmj/types/NumericType.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/types/NumericType.java	(working copy)
@@ -23,6 +23,8 @@
 
 package org.overturetool.vdmj.types;
 
+import java.math.BigInteger;
+
 import org.overturetool.vdmj.lex.LexLocation;
 
 public abstract class NumericType extends BasicType
@@ -48,13 +50,13 @@
 		return this;
 	}
 	
-	public static NumericType typeOf(long iv, LexLocation location)
+	public static NumericType typeOf(BigInteger iv, LexLocation location)
 	{
-		if (iv > 0)
+		if (iv.compareTo(BigInteger.ZERO) > 0)
 		{
 			return new NaturalOneType(location);
 		}
-		else if (iv >= 0)
+		else if (iv.compareTo(BigInteger.ZERO) >= 0)
 		{
 			return new NaturalType(location);
 		}
Index: src/main/java/org/overturetool/vdmj/util/Delegate.java
===================================================================
--- src/main/java/org/overturetool/vdmj/util/Delegate.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/util/Delegate.java	(working copy)
@@ -249,7 +249,7 @@
 		catch (InvocationTargetException e)
 		{
 			throw new InternalException(59,
-				"Failed in native method: " + e.getTargetException().getMessage());
+				"Failed in native method: " + e.getTargetException());
 		}
 	}
 
Index: src/main/java/org/overturetool/vdmj/values/BUSValue.java
===================================================================
--- src/main/java/org/overturetool/vdmj/values/BUSValue.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/values/BUSValue.java	(working copy)
@@ -28,7 +28,6 @@
 import java.util.Vector;
 
 import org.overturetool.vdmj.runtime.Context;
-import org.overturetool.vdmj.runtime.ContextException;
 import org.overturetool.vdmj.runtime.ValueException;
 import org.overturetool.vdmj.scheduler.BusThread;
 import org.overturetool.vdmj.scheduler.CPUResource;
@@ -57,7 +56,7 @@
 		SchedulingPolicy policy = SchedulingPolicy.factory(parg.value.toUpperCase());
 
 		RealValue sarg = (RealValue)argvals.get(1);
-		double speed = sarg.value;
+		double speed = sarg.value.doubleValue();
 
 		SetValue set = (SetValue)argvals.get(2);
 		List<CPUResource> cpulist = new Vector<CPUResource>();
Index: src/main/java/org/overturetool/vdmj/values/CPUValue.java
===================================================================
--- src/main/java/org/overturetool/vdmj/values/CPUValue.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/values/CPUValue.java	(working copy)
@@ -49,7 +49,7 @@
 		SchedulingPolicy cpup = SchedulingPolicy.factory(parg.value.toUpperCase());
 		RealValue sarg = (RealValue)argvals.get(1);
 
-		resource = new CPUResource(cpup, sarg.value);
+		resource = new CPUResource(cpup, sarg.value.doubleValue());
 		deployed = new Vector<ObjectValue>();
 	}
 
Index: src/main/java/org/overturetool/vdmj/values/IntegerValue.java
===================================================================
--- src/main/java/org/overturetool/vdmj/values/IntegerValue.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/values/IntegerValue.java	(working copy)
@@ -23,6 +23,10 @@
 
 package org.overturetool.vdmj.values;
 
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
+import org.overturetool.vdmj.Settings;
 import org.overturetool.vdmj.messages.InternalException;
 import org.overturetool.vdmj.runtime.Context;
 import org.overturetool.vdmj.runtime.ValueException;
@@ -33,21 +37,26 @@
 public class IntegerValue extends RationalValue
 {
 	private static final long serialVersionUID = 1L;
-	protected final long longVal;
+	protected final BigInteger longVal;
 
-	public IntegerValue(long value)
+	public IntegerValue(BigInteger value)
 	{
 		super(value);
 		longVal = value;
 	}
 
+	public IntegerValue(long value)
+	{
+		this(new BigInteger(Long.toString(value)));
+	}
+
 	@Override
 	public int compareTo(Value other)
 	{
 		if (other instanceof IntegerValue)
 		{
 			IntegerValue io = (IntegerValue)other;
-			return (int)(longVal - io.longVal);
+			return longVal.compareTo(io.longVal);
 		}
 
 		return super.compareTo(other);
@@ -56,19 +65,19 @@
 	@Override
 	public String toString()
 	{
-		return Long.toString(longVal);
+		return longVal.toString();
 	}
 
 	@Override
-	public long intValue(Context ctxt)
+	public BigInteger intValue(Context ctxt)
 	{
 		return longVal;
 	}
 
 	@Override
-	public long nat1Value(Context ctxt) throws ValueException
+	public BigInteger nat1Value(Context ctxt) throws ValueException
 	{
-		if (longVal < 1)
+		if (longVal.compareTo(BigInteger.ONE) < 0)
 		{
 			abort(4058, "Value " + longVal + " is not a nat1", ctxt);
 		}
@@ -77,9 +86,9 @@
 	}
 
 	@Override
-	public long natValue(Context ctxt) throws ValueException
+	public BigInteger natValue(Context ctxt) throws ValueException
 	{
-		if (longVal < 0)
+		if (longVal.compareTo(BigInteger.ZERO) < 0)
 		{
 			abort(4059, "Value " + longVal + " is not a nat", ctxt);
 		}
@@ -88,15 +97,16 @@
 	}
 
 	@Override
-	public double realValue(Context ctxt)
+	public BigDecimal realValue(Context ctxt)
 	{
-		return longVal;
+		return new BigDecimal(longVal).setScale(
+			Settings.precision.getPrecision(), Settings.precision.getRoundingMode());
 	}
 
 	@Override
 	public int hashCode()
 	{
-		return (int)longVal;
+		return longVal.hashCode();
 	}
 
 	@Override
Index: src/main/java/org/overturetool/vdmj/values/NaturalOneValue.java
===================================================================
--- src/main/java/org/overturetool/vdmj/values/NaturalOneValue.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/values/NaturalOneValue.java	(working copy)
@@ -23,6 +23,8 @@
 
 package org.overturetool.vdmj.values;
 
+import java.math.BigInteger;
+
 import org.overturetool.vdmj.messages.InternalException;
 import org.overturetool.vdmj.runtime.Context;
 import org.overturetool.vdmj.runtime.ValueException;
@@ -34,16 +36,21 @@
 {
 	private static final long serialVersionUID = 1L;
 
-	public NaturalOneValue(long value) throws Exception
+	public NaturalOneValue(BigInteger iv) throws Exception
 	{
-		super(value);
+		super(iv);
 
-		if (value < 1)
+		if (iv.compareTo(BigInteger.ONE) < 0)
 		{
-			throw new Exception("Value " + value + " is not a nat1");
+			throw new Exception("Value " + iv + " is not a nat1");
 		}
 	}
 
+	public NaturalOneValue(long i) throws Exception
+	{
+		this(new BigInteger("" + i));
+	}
+
 	@Override
 	public String kind()
 	{
Index: src/main/java/org/overturetool/vdmj/values/NaturalValue.java
===================================================================
--- src/main/java/org/overturetool/vdmj/values/NaturalValue.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/values/NaturalValue.java	(working copy)
@@ -23,6 +23,8 @@
 
 package org.overturetool.vdmj.values;
 
+import java.math.BigInteger;
+
 import org.overturetool.vdmj.messages.InternalException;
 import org.overturetool.vdmj.runtime.Context;
 import org.overturetool.vdmj.runtime.ValueException;
@@ -34,16 +36,21 @@
 {
 	private static final long serialVersionUID = 1L;
 
-	public NaturalValue(long value) throws Exception
+	public NaturalValue(BigInteger iv) throws Exception
 	{
-		super(value);
+		super(iv);
 
-		if (value < 0)
+		if (iv.compareTo(BigInteger.ZERO) < 0)
 		{
-			throw new Exception("Value " + value + " is not a nat");
+			throw new Exception("Value " + iv + " is not a nat");
 		}
 	}
 
+	public NaturalValue(long size) throws Exception
+	{
+		this(new BigInteger(Long.toString(size)));
+	}
+
 	@Override
 	public String kind()
 	{
Index: src/main/java/org/overturetool/vdmj/values/NumericValue.java
===================================================================
--- src/main/java/org/overturetool/vdmj/values/NumericValue.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/values/NumericValue.java	(working copy)
@@ -23,6 +23,10 @@
 
 package org.overturetool.vdmj.values;
 
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.math.RoundingMode;
+
 import org.overturetool.vdmj.runtime.Context;
 import org.overturetool.vdmj.runtime.ValueException;
 import org.overturetool.vdmj.types.IntegerType;
@@ -36,24 +40,24 @@
 public abstract class NumericValue extends Value
 {
 	private static final long serialVersionUID = 1L;
-	public final double value;
+	public final BigDecimal value;
 
-	public NumericValue(double value)
+	public NumericValue(BigDecimal value)
 	{
 		super();
 		this.value = value;
 	}
 
-	public static NumericValue valueOf(double d, Context ctxt) throws ValueException
+	public static NumericValue valueOf(BigDecimal d, Context ctxt) throws ValueException
 	{
-		if (Double.isInfinite(d) || Double.isNaN(d))
-		{
-			throw new ValueException(4134, "Infinite or NaN trouble", ctxt);
-		}
+//		if (Double.isInfinite(d) || Double.isNaN(d))
+//		{
+//			throw new ValueException(4134, "Infinite or NaN trouble", ctxt);
+//		}
 
-		long rounded = Math.round(d);
+		BigInteger rounded = d.setScale(0, RoundingMode.HALF_UP).toBigInteger();
 
-		if (rounded != d)
+		if (new BigDecimal(rounded).compareTo(d) != 0)
 		{
 			try
 			{
@@ -68,9 +72,9 @@
 		return valueOf(rounded, ctxt);
 	}
 
-	public static NumericValue valueOf(long iv, Context ctxt) throws ValueException
+	public static NumericValue valueOf(BigInteger iv, Context ctxt) throws ValueException
 	{
-		if (iv > 0)
+		if (iv.compareTo(BigInteger.ZERO) > 0)
 		{
 			try
 			{
@@ -82,7 +86,7 @@
 			}
 		}
 
-		if (iv >= 0)
+		if (iv.compareTo(BigInteger.ZERO) >= 0)
 		{
 			try
 			{
@@ -96,7 +100,17 @@
 
 		return new IntegerValue(iv);
 	}
+	
+	public static boolean isInteger(Value value)
+	{
+		return value instanceof IntegerValue;
+	}
 
+	public static boolean areIntegers(Value left, Value right)
+	{
+		return isInteger(left) && isInteger(right);
+	}
+
 	@Override
 	protected Value convertValueTo(Type to, Context ctxt, TypeSet done) throws ValueException
 	{
@@ -164,7 +178,7 @@
 			if (val instanceof NumericValue)
 			{
 				NumericValue nov = (NumericValue)val;
-				return nov.value == value;
+				return nov.value.compareTo(value) == 0;		// NB. NOT equals()
 			}
 		}
 
@@ -172,15 +186,15 @@
 	}
 
 	@Override
-	abstract public double realValue(Context ctxt) throws ValueException;
+	abstract public BigDecimal realValue(Context ctxt) throws ValueException;
 	@Override
-	abstract public double ratValue(Context ctxt) throws ValueException;
+	abstract public BigDecimal ratValue(Context ctxt) throws ValueException;
 	@Override
-	abstract public long intValue(Context ctxt) throws ValueException;
+	abstract public BigInteger intValue(Context ctxt) throws ValueException;
 	@Override
-	abstract public long natValue(Context ctxt) throws ValueException;
+	abstract public BigInteger natValue(Context ctxt) throws ValueException;
 	@Override
-	abstract public long nat1Value(Context ctxt) throws ValueException;
+	abstract public BigInteger nat1Value(Context ctxt) throws ValueException;
 	@Override
 	abstract public int hashCode();
 	@Override
Index: src/main/java/org/overturetool/vdmj/values/RationalValue.java
===================================================================
--- src/main/java/org/overturetool/vdmj/values/RationalValue.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/values/RationalValue.java	(working copy)
@@ -23,6 +23,9 @@
 
 package org.overturetool.vdmj.values;
 
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
 import org.overturetool.vdmj.runtime.Context;
 import org.overturetool.vdmj.runtime.ValueException;
 import org.overturetool.vdmj.types.RationalType;
@@ -33,12 +36,12 @@
 {
 	private static final long serialVersionUID = 1L;
 
-	public RationalValue(double value) throws Exception
+	public RationalValue(BigDecimal value) throws Exception
 	{
 		super(value);
 	}
 
-	public RationalValue(long value)
+	public RationalValue(BigInteger value)
 	{
 		super(value);
 	}
Index: src/main/java/org/overturetool/vdmj/values/RealValue.java
===================================================================
--- src/main/java/org/overturetool/vdmj/values/RealValue.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/values/RealValue.java	(working copy)
@@ -23,6 +23,11 @@
 
 package org.overturetool.vdmj.values;
 
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.math.RoundingMode;
+
+import org.overturetool.vdmj.Settings;
 import org.overturetool.vdmj.runtime.Context;
 import org.overturetool.vdmj.runtime.ValueException;
 import org.overturetool.vdmj.types.RealType;
@@ -33,98 +38,104 @@
 {
 	private static final long serialVersionUID = 1L;
 
-	public RealValue(double value) throws Exception
+	public RealValue(BigDecimal value) throws Exception
 	{
 		super(value);
 
-		if (Double.isInfinite(value))
-		{
-			throw new Exception("Real is infinite");
-		}
-		else if (Double.isNaN(value))
-		{
-			throw new Exception("Real is NaN");
-		}
+//		if (Double.isInfinite(value))
+//		{
+//			throw new Exception("Real is infinite");
+//		}
+//		else if (Double.isNaN(value))
+//		{
+//			throw new Exception("Real is NaN");
+//		}
 	}
 
-	public RealValue(long value)
+	public RealValue(BigInteger value)
 	{
-		super(value);
+		super(new BigDecimal(value).setScale(
+			Settings.precision.getPrecision(), Settings.precision.getRoundingMode()));
 	}
 
+	public RealValue(double value)
+	{
+		super(new BigDecimal(value));
+	}
+
 	@Override
 	public int compareTo(Value other)
 	{
 		if (other instanceof RealValue)
 		{
 			RealValue ro = (RealValue)other;
-			return (int)Math.round(Math.signum(value - ro.value));
+			return value.compareTo(ro.value);
 		}
 
 		return super.compareTo(other);
 	}
 
 	@Override
-	public double realValue(Context ctxt)
+	public BigDecimal realValue(Context ctxt)
 	{
 		return value;
 	}
 
 	@Override
-	public double ratValue(Context ctxt)
+	public BigDecimal ratValue(Context ctxt)
 	{
 		return value;
 	}
 
 	@Override
-	public long intValue(Context ctxt) throws ValueException
+	public BigInteger intValue(Context ctxt) throws ValueException
 	{
-		long rounded = Math.round(value);
+		BigDecimal rounded = value.setScale(0, RoundingMode.HALF_UP);
 
-		if (rounded != value)
+		if (rounded.compareTo(value) != 0)
 		{
-			abort(4075, "Value " + value + " is not an integer", ctxt);
+			abort(4075, "Value " + value.stripTrailingZeros() + " is not an integer", ctxt);
 		}
 
-		return rounded;
+		return rounded.toBigInteger();
 	}
 
 	@Override
-	public long nat1Value(Context ctxt) throws ValueException
+	public BigInteger nat1Value(Context ctxt) throws ValueException
 	{
-		long rounded = Math.round(value);
+		BigDecimal rounded = value.setScale(0, RoundingMode.HALF_UP);
 
-		if (rounded != value || rounded < 1)
+		if (rounded.compareTo(value) != 0 || rounded.compareTo(BigDecimal.ONE) < 0)
 		{
-			abort(4076, "Value " + value + " is not a nat1", ctxt);
+			abort(4076, "Value " + value.stripTrailingZeros() + " is not a nat1", ctxt);
 		}
 
-		return rounded;
+		return rounded.toBigInteger();
 	}
 
 	@Override
-	public long natValue(Context ctxt) throws ValueException
+	public BigInteger natValue(Context ctxt) throws ValueException
 	{
-		long rounded = Math.round(value);
+		BigDecimal rounded = value.setScale(0, RoundingMode.HALF_UP);
 
-		if (rounded != value || rounded < 0)
+		if (rounded.compareTo(value) != 0 || rounded.compareTo(BigDecimal.ONE) < 0)
 		{
-			abort(4077, "Value " + value + " is not a nat", ctxt);
+			abort(4077, "Value " + value.stripTrailingZeros() + " is not a nat", ctxt);
 		}
 
-		return rounded;
+		return rounded.toBigInteger();
 	}
 
 	@Override
 	public String toString()
 	{
-		return Double.toString(value);
+		return value.stripTrailingZeros().toString();
 	}
 
 	@Override
 	public int hashCode()
 	{
-		return new Double(value).hashCode();
+		return value.hashCode();
 	}
 
 	@Override
Index: src/main/java/org/overturetool/vdmj/values/ReferenceValue.java
===================================================================
--- src/main/java/org/overturetool/vdmj/values/ReferenceValue.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/values/ReferenceValue.java	(working copy)
@@ -23,6 +23,9 @@
 
 package org.overturetool.vdmj.values;
 
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
 import org.overturetool.vdmj.runtime.Context;
 import org.overturetool.vdmj.runtime.ValueException;
 import org.overturetool.vdmj.types.Type;
@@ -75,25 +78,25 @@
 	}
 
 	@Override
-	public double realValue(Context ctxt) throws ValueException
+	public BigDecimal realValue(Context ctxt) throws ValueException
 	{
 		return value.realValue(ctxt);
 	}
 
 	@Override
-	public long intValue(Context ctxt) throws ValueException
+	public BigInteger intValue(Context ctxt) throws ValueException
 	{
 		return value.intValue(ctxt);
 	}
 
 	@Override
-	public long natValue(Context ctxt) throws ValueException
+	public BigInteger natValue(Context ctxt) throws ValueException
 	{
 		return value.nat1Value(ctxt);
 	}
 
 	@Override
-	public long nat1Value(Context ctxt) throws ValueException
+	public BigInteger nat1Value(Context ctxt) throws ValueException
 	{
 		return value.nat1Value(ctxt);
 	}
Index: src/main/java/org/overturetool/vdmj/values/SeqValue.java
===================================================================
--- src/main/java/org/overturetool/vdmj/values/SeqValue.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/values/SeqValue.java	(working copy)
@@ -119,7 +119,7 @@
 
 	public Value get(Value arg, Context ctxt) throws ValueException
 	{
-		int i = (int)arg.nat1Value(ctxt);
+		int i = arg.nat1Value(ctxt).intValue();
 
 		if (i < 1 || i > values.size())
 		{
Index: src/main/java/org/overturetool/vdmj/values/TransactionValue.java
===================================================================
--- src/main/java/org/overturetool/vdmj/values/TransactionValue.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/values/TransactionValue.java	(working copy)
@@ -23,6 +23,8 @@
 
 package org.overturetool.vdmj.values;
 
+import java.math.BigDecimal;
+import java.math.BigInteger;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Vector;
@@ -202,25 +204,25 @@
 	}
 
 	@Override
-	public synchronized double realValue(Context ctxt) throws ValueException
+	public synchronized BigDecimal realValue(Context ctxt) throws ValueException
 	{
 		return select().realValue(ctxt);
 	}
 
 	@Override
-	public synchronized long intValue(Context ctxt) throws ValueException
+	public synchronized BigInteger intValue(Context ctxt) throws ValueException
 	{
 		return select().intValue(ctxt);
 	}
 
 	@Override
-	public synchronized long natValue(Context ctxt) throws ValueException
+	public synchronized BigInteger natValue(Context ctxt) throws ValueException
 	{
 		return select().nat1Value(ctxt);
 	}
 
 	@Override
-	public synchronized long nat1Value(Context ctxt) throws ValueException
+	public synchronized BigInteger nat1Value(Context ctxt) throws ValueException
 	{
 		return select().nat1Value(ctxt);
 	}
Index: src/main/java/org/overturetool/vdmj/values/UpdatableValue.java
===================================================================
--- src/main/java/org/overturetool/vdmj/values/UpdatableValue.java	(revision 499)
+++ src/main/java/org/overturetool/vdmj/values/UpdatableValue.java	(working copy)
@@ -23,6 +23,9 @@
 
 package org.overturetool.vdmj.values;
 
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
 import org.overturetool.vdmj.Settings;
 import org.overturetool.vdmj.config.Properties;
 import org.overturetool.vdmj.lex.Dialect;
@@ -219,25 +222,25 @@
 	}
 
 	@Override
-	public synchronized double realValue(Context ctxt) throws ValueException
+	public synchronized BigDecimal realValue(Context ctxt) throws ValueException
 	{
 		return value.realValue(ctxt);
 	}
 
 	@Override
-	public synchronized long intValue(Context ctxt) throws ValueException
+	public synchronized BigInteger intValue(Context ctxt) throws ValueException
 	{
 		return value.intValue(ctxt);
 	}
 
 	@Override
-	public synchronized long natValue(Context ctxt) throws ValueException
+	public synchronized BigInteger natValue(Context ctxt) throws ValueException
 	{
 		return value.nat1Value(ctxt);
 	}
 
 	@Override
-	public synchronized long nat1Value(Context ctxt) throws ValueException
+	public synchronized BigInteger nat1Value(Context ctxt) throws ValueException
 	{
 		return value.nat1Value(ctxt);
 	}
Index: src/main/java/org/overturetool/vdmj/values/Value.java
===================================================================
--- src/main/java/org/overturetool/vdmj/values/Value.java	(revision 466)
+++ src/main/java/org/overturetool/vdmj/values/Value.java	(working copy)
@@ -24,6 +24,8 @@
 package org.overturetool.vdmj.values;
 
 import java.io.Serializable;
+import java.math.BigDecimal;
+import java.math.BigInteger;
 import java.util.Formattable;
 import java.util.FormattableFlags;
 import java.util.Formatter;
@@ -349,34 +351,34 @@
 		return this;
 	}
 
-	public double realValue(Context ctxt) throws ValueException
+	public BigDecimal realValue(Context ctxt) throws ValueException
 	{
 		abort(4089, "Can't get real value of " + kind(), ctxt);
-		return 0;
+		return BigDecimal.ZERO;
 	}
 
-	public double ratValue(Context ctxt) throws ValueException
+	public BigDecimal ratValue(Context ctxt) throws ValueException
 	{
 		abort(4090, "Can't get rat value of " + kind(), ctxt);
-		return 0;
+		return BigDecimal.ZERO;
 	}
 
-	public long intValue(Context ctxt) throws ValueException
+	public BigInteger intValue(Context ctxt) throws ValueException
 	{
 		abort(4091, "Can't get int value of " + kind(), ctxt);
-		return 0;
+		return BigInteger.ZERO;
 	}
 
-	public long natValue(Context ctxt) throws ValueException
+	public BigInteger natValue(Context ctxt) throws ValueException
 	{
 		abort(4092, "Can't get nat value of " + kind(), ctxt);
-		return 0;
+		return BigInteger.ZERO;
 	}
 
-	public long nat1Value(Context ctxt) throws ValueException
+	public BigInteger nat1Value(Context ctxt) throws ValueException
 	{
 		abort(4093, "Can't get nat1 value of " + kind(), ctxt);
-		return 0;
+		return BigInteger.ZERO;
 	}
 
 	public boolean boolValue(Context ctxt) throws ValueException
Index: src/test/java/junit/overture/OvertureTest.java
===================================================================
--- src/test/java/junit/overture/OvertureTest.java	(revision 466)
+++ src/test/java/junit/overture/OvertureTest.java	(working copy)
@@ -363,7 +363,7 @@
 
 			for (Value ex: assertions.seqValue(null))
 			{
-				long n = ex.intValue(null);
+				long n = ex.intValue(null).longValue();
 				expected.add(n);
 			}
 
